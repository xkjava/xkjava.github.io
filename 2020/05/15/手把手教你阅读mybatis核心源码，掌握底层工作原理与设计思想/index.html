<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>手把手教你阅读mybatis核心源码，掌握底层工作原理与设计思想 | 来一杯咖啡</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="title: 手把手教你阅读mybatis核心源码，掌握底层工作原理与设计思想date: 2020-05-15 11:27:43tags:–Mybatis目前作为互联网公司Java体系开源ORM框架的首选，它有着天然的优势，很多同学只关注其公司业务CRUD程序的编写，忽略了其源码阅读的重要性。下面来看一段使用Mybatis API写的代码示例： 123456789101112String res">
<meta property="og:type" content="article">
<meta property="og:title" content="手把手教你阅读mybatis核心源码，掌握底层工作原理与设计思想">
<meta property="og:url" content="https://xkjava.github.io/2020/05/15/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%98%85%E8%AF%BBmybatis%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%EF%BC%8C%E6%8E%8C%E6%8F%A1%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/index.html">
<meta property="og:site_name" content="来一杯咖啡">
<meta property="og:description" content="title: 手把手教你阅读mybatis核心源码，掌握底层工作原理与设计思想date: 2020-05-15 11:27:43tags:–Mybatis目前作为互联网公司Java体系开源ORM框架的首选，它有着天然的优势，很多同学只关注其公司业务CRUD程序的编写，忽略了其源码阅读的重要性。下面来看一段使用Mybatis API写的代码示例： 123456789101112String res">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/5/14/17211ef5a2c1f056?w=621&h=330&f=png&s=34774">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/5/14/17212043919beb10?w=1719&h=201&f=png&s=17962">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/5/14/172122a8ead77411?w=720&h=590&f=jpeg&s=66823">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/5/14/1721245f64e5e6e9?w=1239&h=378&f=png&s=26496">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/5/14/172125b1eace1d19?w=981&h=234&f=png&s=32839">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/5/14/1721265937c7c78b?w=720&h=539&f=jpeg&s=65450">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/5/14/17213567060a5a09?w=935&h=487&f=png&s=224353">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/5/14/172135b12a5dd6af?w=933&h=527&f=png&s=227459">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/5/14/172135df8fd7a684?w=720&h=511&f=jpeg&s=55503">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/5/15/1721652a86370b3e?w=720&h=466&f=jpeg&s=51595">
<meta property="article:published_time" content="2020-05-15T03:29:27.878Z">
<meta property="article:modified_time" content="2020-05-15T03:29:27.845Z">
<meta property="article:author" content="Kevin Shaw">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="Netty">
<meta property="article:tag" content="Kafka...">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2020/5/14/17211ef5a2c1f056?w=621&h=330&f=png&s=34774">
  
    <link rel="alternate" href="/atom.xml" title="来一杯咖啡" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">来一杯咖啡</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">互联网技术无边界，学习与交流</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://xkjava.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-手把手教你阅读mybatis核心源码，掌握底层工作原理与设计思想" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/15/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%98%85%E8%AF%BBmybatis%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%EF%BC%8C%E6%8E%8C%E6%8F%A1%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/" class="article-date">
  <time datetime="2020-05-15T03:29:27.878Z" itemprop="datePublished">2020-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      手把手教你阅读mybatis核心源码，掌握底层工作原理与设计思想
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: 手把手教你阅读mybatis核心源码，掌握底层工作原理与设计思想<br>date: 2020-05-15 11:27:43<br>tags:<br>–<br>Mybatis目前作为互联网公司Java体系开源ORM框架的首选，它有着天然的优势，很多同学只关注其公司业务CRUD程序的编写，忽略了其源码阅读的重要性。下面来看一段使用Mybatis API写的代码示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String resource &#x3D; &quot;mybatis-config.xml&quot;;</span><br><span class="line">InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">SqlSession session &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">try &#123;</span><br><span class="line">    BusinessMapper mapper &#x3D; session.getMapper(BusinessMapper.class);</span><br><span class="line">    Business business &#x3D; mapper.selectBusinessById(1);</span><br><span class="line">    System.out.println(business);</span><br><span class="line">    </span><br><span class="line">&#125;finally &#123;</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来按照示例代码的步骤一步一步地来分析代码的运行背后的秘密，揭开mybatis源码的真实面目。给出的源码片段均有中文注释，方便同学们加深理解。</p>
<h1 id="一、全局配置解析过程"><a href="#一、全局配置解析过程" class="headerlink" title="一、全局配置解析过程"></a>一、全局配置解析过程</h1><h2 id="1-1-SqlSessionFactoryBuilder（构建工厂类）"><a href="#1-1-SqlSessionFactoryBuilder（构建工厂类）" class="headerlink" title="1.1 SqlSessionFactoryBuilder（构建工厂类）"></a>1.1 SqlSessionFactoryBuilder（构建工厂类）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure>

<p>创建一个新的<strong>SqlSessionFactoryBuilder</strong>对象，这里使用了建造者模式。调用了build()方法创建了<strong>SqlSessionFactory</strong>对象，在<strong>SqlSessionFactoryBuilder</strong>中有9个重载的build()方法，可以使用不同的方式来创建<strong>SqlSessionFactory</strong>对象，其默认是单例模式的。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/14/17211ef5a2c1f056?w=621&h=330&f=png&s=34774" alt=""></p>
<h2 id="1-2-XmlConfigBuilder（解析全局配置文件）"><a href="#1-2-XmlConfigBuilder（解析全局配置文件）" class="headerlink" title="1.2 XmlConfigBuilder（解析全局配置文件）"></a>1.2 XmlConfigBuilder（解析全局配置文件）</h2><p>创建<strong>XmlConfigBuilder</strong>对象用来解析全局配置文件，解析完成之后会返回一个<strong>Configuration</strong>对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public SqlSessionFactory build(Reader reader, String environment, Properties properties) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F;1、创建XMLConfigBuilder对象</span><br><span class="line">      XMLConfigBuilder parser &#x3D; new XMLConfigBuilder(reader, environment, properties);</span><br><span class="line">      &#x2F;&#x2F;2、调用解析方法返回Configuration对象</span><br><span class="line">      return build(parser.parse());</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">      try &#123;</span><br><span class="line">        reader.close();</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">        &#x2F;&#x2F; Intentionally ignore. Prefer previous error.</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>XMLConfigBuilder</strong>继承自抽象类<strong>BaseBuilder</strong>，解析全局的配置文件，<strong>BaseBuilder</strong>还有一些子类，用来创建不同的目标的。例如：</p>
<ul>
<li>XMLMapperBuilder：解析Mapper映射器</li>
<li>XMLStatementBuilder：解析增删改查标签</li>
<li>XMLScriptBuilder：解析动态SQL</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/14/17212043919beb10?w=1719&h=201&f=png&s=17962" alt=""></p>
<p>接着来看下<strong>XMLConfigBuilder</strong>对象调用的<strong>parse</strong>()方法的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Configuration parse() &#123;</span><br><span class="line">   if (parsed) &#123;</span><br><span class="line">     throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   parsed &#x3D; true;</span><br><span class="line">   &#x2F;&#x2F; XPathParser，dom 和 SAX 都有用到 &gt;&gt;</span><br><span class="line">   parseConfiguration(parser.evalNode(&quot;&#x2F;configuration&quot;));</span><br><span class="line">   return configuration;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>java中解析xml配置文件的方式有很多种，mybatis对DOM和SAX两种方式做了不同的封装。接着看<strong>parseConfiguration</strong>()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private void parseConfiguration(XNode root) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F;issue #117 read properties first</span><br><span class="line">      &#x2F;&#x2F; 对于全局配置文件各种标签的解析</span><br><span class="line">      1、解析&lt;properties&gt;标签，可以读取外部引入的属性文件，比如database.properties</span><br><span class="line">      propertiesElement(root.evalNode(&quot;properties&quot;));</span><br><span class="line">      &#x2F;&#x2F; 2、解析 settings 标签</span><br><span class="line">      Properties settings &#x3D; settingsAsProperties(root.evalNode(&quot;settings&quot;));</span><br><span class="line">      &#x2F;&#x2F;3、获取Virtual File System自定义实现类，比如读取本地文件</span><br><span class="line">      loadCustomVfs(settings);</span><br><span class="line">      &#x2F;&#x2F;4、根据&lt;longImpl&gt;标签获取日志实现类</span><br><span class="line">      loadCustomLogImpl(settings);</span><br><span class="line">      &#x2F;&#x2F;5、解析类型别名</span><br><span class="line">      typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));</span><br><span class="line">      &#x2F;&#x2F;6、解析plugins标签，比如翻页插件PageHelper</span><br><span class="line">      pluginElement(root.evalNode(&quot;plugins&quot;));</span><br><span class="line">      &#x2F;&#x2F; 用于创建对象</span><br><span class="line">      objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));</span><br><span class="line">      &#x2F;&#x2F; 用于对对象进行加工</span><br><span class="line">      objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));</span><br><span class="line">      &#x2F;&#x2F; 反射工具箱</span><br><span class="line">      reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));</span><br><span class="line">      &#x2F;&#x2F; settings 子标签赋值，默认值就是在这里提供的 &gt;&gt;</span><br><span class="line">      settingsElement(settings);</span><br><span class="line">      &#x2F;&#x2F; read it after objectFactory and objectWrapperFactory issue #631</span><br><span class="line">      &#x2F;&#x2F; 创建了数据源 &gt;&gt;</span><br><span class="line">      environmentsElement(root.evalNode(&quot;environments&quot;));</span><br><span class="line">      &#x2F;&#x2F; 解析databaseIdProvider标签，生成DatabaseIdProvider对象</span><br><span class="line">      databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));</span><br><span class="line">      &#x2F;&#x2F; 用来做映射的，得到JavaType和JdbcType，存放在TypeHandlerRegistry对象中</span><br><span class="line">      typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));</span><br><span class="line">      &#x2F;&#x2F; 解析引用的Mapper映射器</span><br><span class="line">      mapperElement(root.evalNode(&quot;mappers&quot;));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法中所有的值都会封装到<strong>Configuration</strong>对象中。下面是创建过程的时序图。<br><img src="https://user-gold-cdn.xitu.io/2020/5/14/172122a8ead77411?w=720&h=590&f=jpeg&s=66823" alt=""></p>
<h1 id="二、会话创建过程"><a href="#二、会话创建过程" class="headerlink" title="二、会话创建过程"></a>二、会话创建过程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session &#x3D; sqlSessionFactory.openSession();</span><br></pre></td></tr></table></figure>
<p>这里实际上调用了<strong>DefaultSqlSessionFactory</strong>类的<strong>openSessionFromDataSource</strong>()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123;</span><br><span class="line">    Transaction tx &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      final Environment environment &#x3D; configuration.getEnvironment();</span><br><span class="line">      &#x2F;&#x2F; 获取事务工厂</span><br><span class="line">      final TransactionFactory transactionFactory &#x3D; getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">      &#x2F;&#x2F; 创建事务</span><br><span class="line">      tx &#x3D; transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">      &#x2F;&#x2F; 根据事务工厂和默认的执行器类型，创建执行器 &gt;&gt;</span><br><span class="line">      final Executor executor &#x3D; configuration.newExecutor(tx, execType);</span><br><span class="line">      return new DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      closeTransaction(tx); &#x2F;&#x2F; may have fetched a connection so lets call close()</span><br><span class="line">      throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-1-获取Environment对象"><a href="#2-1-获取Environment对象" class="headerlink" title="2.1 获取Environment对象"></a>2.1 获取Environment对象</h2><p>从<strong>Configuration</strong>对象中获取<strong>Environment</strong>对象，环境对象中有事务工厂类；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final class Environment &#123;</span><br><span class="line">  private final String id;</span><br><span class="line">  private final TransactionFactory transactionFactory;</span><br><span class="line">  private final DataSource dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-创建事务"><a href="#2-2-创建事务" class="headerlink" title="2.2 创建事务"></a>2.2 创建事务</h2><p>从<strong>Environment</strong>对象中获取一个<strong>TranscationFactory</strong>对象，事务工厂类型可以配置成<strong>JDBC</strong>或者<strong>MANAGED</strong>。</p>
<ul>
<li>JDBC；使用jdbc的Connection对象来管理事务；</li>
<li>MANAGED：事务将有容器进行管理。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private TransactionFactory getTransactionFactoryFromEnvironment(Environment environment) &#123;</span><br><span class="line">   if (environment &#x3D;&#x3D; null || environment.getTransactionFactory() &#x3D;&#x3D; null) &#123;</span><br><span class="line">     return new ManagedTransactionFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   return environment.getTransactionFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-创建执行器"><a href="#2-3-创建执行器" class="headerlink" title="2.3 创建执行器"></a>2.3 创建执行器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final Executor executor &#x3D; configuration.newExecutor(tx, execType);</span><br></pre></td></tr></table></figure>
<p>执行器<strong>Executor</strong>的基本类型有三种：</p>
<ul>
<li>SIMPLE（默认）</li>
<li>BATCH</li>
<li>REUSE</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (ExecutorType.BATCH &#x3D;&#x3D; executorType) &#123;</span><br><span class="line">      executor &#x3D; new BatchExecutor(this, transaction);</span><br><span class="line">    &#125; else if (ExecutorType.REUSE &#x3D;&#x3D; executorType) &#123;</span><br><span class="line">      executor &#x3D; new ReuseExecutor(this, transaction);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 默认 SimpleExecutor</span><br><span class="line">      executor &#x3D; new SimpleExecutor(this, transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/5/14/1721245f64e5e6e9?w=1239&h=378&f=png&s=26496" alt=""></p>
<p>抽象类BaseExecutor实现Executor接口，这是模板设计模式的体现。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/14/172125b1eace1d19?w=981&h=234&f=png&s=32839" alt=""></p>
<p><strong>缓存装饰</strong></p>
<p>在newExecutor()方法中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 二级缓存开关，settings 中的 cacheEnabled 默认是 true</span><br><span class="line">if (cacheEnabled) &#123;</span><br><span class="line">  executor &#x3D; new CachingExecutor(executor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代理插件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 植入插件的逻辑，至此，四大对象已经全部拦截完毕</span><br><span class="line">executor &#x3D; (Executor) interceptorChain.pluginAll(executor);</span><br></pre></td></tr></table></figure>

<h2 id="2-4-返回SqlSession"><a href="#2-4-返回SqlSession" class="headerlink" title="2.4 返回SqlSession"></a>2.4 返回SqlSession</h2><p><strong>SqlSession</strong>类中包括<strong>Configuration</strong>和<strong>Executor</strong>两大对象。下面是创建过程的时序图。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/14/1721265937c7c78b?w=720&h=539&f=jpeg&s=65450" alt=""></p>
<h1 id="三、获取代理对象"><a href="#三、获取代理对象" class="headerlink" title="三、获取代理对象"></a>三、获取代理对象</h1><p>接口中的名称和Mapper.xml文件中的namespace是一一对应的，方法名称也是StatementId也是对应的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BusinessMapper mapper &#x3D; session.getMapper(BusinessMapper.class);</span><br><span class="line">Business business &#x3D; mapper.selectBusinessById(1);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace&#x3D;&quot;com.sy.mapper.BusinessMapper&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id&#x3D;&quot;selectBusinessById&quot; resultMap&#x3D;&quot;BaseResultMap&quot; statementType&#x3D;&quot;PREPARED&quot; &gt;</span><br><span class="line">        select * from bsuiness where bid &#x3D; #&#123;bid&#125;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-1-getMapper-方法"><a href="#3-1-getMapper-方法" class="headerlink" title="3.1 getMapper()方法"></a>3.1 getMapper()方法</h2><p>1、<strong>DefaultSqlSession</strong>中的<strong>getMapper()</strong>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type) &#123;</span><br><span class="line">    return configuration.getMapper(type, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、<strong>Configuration</strong>类中的<strong>getMapper</strong>()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</span><br><span class="line">    return mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>3、<strong>MapperRegistry</strong>中的<strong>getMapper</strong>()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</span><br><span class="line">    final MapperProxyFactory&lt;T&gt; mapperProxyFactory &#x3D; (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    if (mapperProxyFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      return mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在解析mapper标签和Mapper.xml的时候已经把接口类型和类型对应的<strong>MapperProxyFactory</strong>放到一个map中，获取<strong>Mapper</strong>的代理对象，实际上是从map中获取对应的工厂类后，最终通过<strong>JDK动态代理</strong>创建的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123;</span><br><span class="line">    &#x2F;&#x2F; 1：类加载器;</span><br><span class="line">    &#x2F;&#x2F; 2：被代理类实现的接口;</span><br><span class="line">    &#x2F;&#x2F; 3：实现了 InvocationHandler 的触发管理类</span><br><span class="line">    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public T newInstance(SqlSession sqlSession) &#123;</span><br><span class="line">    final MapperProxy&lt;T&gt; mapperProxy &#x3D; new MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    return newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>MapperProxy</strong>实现了<strong>InvocationHandler</strong>接口，参数有<strong>sqlSession, mapperInterface, methodCache</strong>，最终是通过JDK的动态代理创建返回代理对象（类型是$<strong>Proxy数字</strong>）。这个对象继承<strong>Proxy类</strong>，实例被代理的接口，里面持有了一个<strong>MapperProxy</strong>类型的触发管理类。</p>
<h2 id="3-2-MapperProxy-实现对接口的代理"><a href="#3-2-MapperProxy-实现对接口的代理" class="headerlink" title="3.2 MapperProxy 实现对接口的代理"></a>3.2 MapperProxy 实现对接口的代理</h2><p>JDK的动态代理有三个核心角色：</p>
<ul>
<li>被代理类（实现类）</li>
<li>接口</li>
<li>实现了InvocationHandler的触发管理类</li>
</ul>
<p>用来生成代理对象。被代理的类必须实现接口，因为要通过接口获取方法，而且代理类也要实现这个接口。<br><img src="https://user-gold-cdn.xitu.io/2020/5/14/17213567060a5a09?w=935&h=487&f=png&s=224353" alt=""><br>而MyBatis里面的Mapper没有实现类，它直接忽略了实现类，直接对接口进行代理。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/14/172135b12a5dd6af?w=933&h=527&f=png&s=227459" alt=""><br>获取Mapper对象的过程，实际上是获取了一个JDK动态代理对象。这个代理类继承Proxy类，实现被代理的接口，里面持有一个MapperProxy类型的触发管理类。来看下代理类过程的时序图吧。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/14/172135df8fd7a684?w=720&h=511&f=jpeg&s=55503" alt=""></p>
<h1 id="四、执行SQL"><a href="#四、执行SQL" class="headerlink" title="四、执行SQL"></a>四、执行SQL</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Business business &#x3D; mapper.selectBusinessById(1);</span><br></pre></td></tr></table></figure>
<h2 id="4-1-MapperProxy-invoke-方法"><a href="#4-1-MapperProxy-invoke-方法" class="headerlink" title="4.1 MapperProxy.invoke()方法"></a>4.1 MapperProxy.invoke()方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; toString hashCode equals getClass等方法，无需走到执行SQL的流程</span><br><span class="line">      if (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        return method.invoke(this, args);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 提升获取 mapperMethod 的效率，到 MapperMethodInvoker（内部接口） 的 invoke</span><br><span class="line">        &#x2F;&#x2F; 普通方法会走到 PlainMethodInvoker（内部类） 的 invoke</span><br><span class="line">        return cachedInvoker(method).invoke(proxy, method, args, sqlSession);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">      throw ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-1-1、首先判断是否要执行SQL还是直接执行方法"><a href="#4-1-1、首先判断是否要执行SQL还是直接执行方法" class="headerlink" title="4.1.1、首先判断是否要执行SQL还是直接执行方法"></a>4.1.1、首先判断是否要执行SQL还是直接执行方法</h2><p>Object本身的方法和Java 8中的默认方法不需要取执行SQL</p>
<h2 id="4-1-2、获取缓存"><a href="#4-1-2、获取缓存" class="headerlink" title="4.1.2、获取缓存"></a>4.1.2、获取缓存</h2><p>这里加入缓存时为了提升MapperMethod的获取速度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private MapperMethodInvoker cachedInvoker(Method method) throws Throwable &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; Java8 中 Map 的方法，根据 key 获取值，如果值是 null，则把后面Object 的值赋给 key</span><br><span class="line">     &#x2F;&#x2F; 如果获取不到，就创建</span><br><span class="line">     &#x2F;&#x2F; 获取的是 MapperMethodInvoker（接口） 对象，只有一个invoke方法</span><br><span class="line">     return methodCache.computeIfAbsent(method, m -&gt; &#123;</span><br><span class="line">       if (m.isDefault()) &#123;</span><br><span class="line">         &#x2F;&#x2F; 接口的默认方法(Java8)，只要实现接口都会继承接口的默认方法，例如 List.sort()</span><br><span class="line">         try &#123;</span><br><span class="line">           if (privateLookupInMethod &#x3D;&#x3D; null) &#123;</span><br><span class="line">             return new DefaultMethodInvoker(getMethodHandleJava8(method));</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">             return new DefaultMethodInvoker(getMethodHandleJava9(method));</span><br><span class="line">           &#125;</span><br><span class="line">         &#125; catch (IllegalAccessException | InstantiationException | InvocationTargetException</span><br><span class="line">             | NoSuchMethodException e) &#123;</span><br><span class="line">           throw new RuntimeException(e);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         &#x2F;&#x2F; 创建了一个 MapperMethod</span><br><span class="line">         return new PlainMethodInvoker(new MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125; catch (RuntimeException re) &#123;</span><br><span class="line">     Throwable cause &#x3D; re.getCause();</span><br><span class="line">     throw cause &#x3D;&#x3D; null ? re : cause;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>Map 的 <strong>computeIfAbsent</strong>()方法：只有key不存在或者value为null，则把后面的Object的值赋给key。<strong>Java8</strong>和<strong>Java9</strong>中的接口默认方法由特殊处理，返回<strong>DefaultMethodInvoker</strong>对象。普通的方法返回的是<strong>PlainMethodInvoker</strong>，<strong>MapperMethod</strong>。</p>
<p>在MapperMethod对象中有两个比较重要的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; statement id （例如：com.sy.mapper.BusinessMapper.selectBusinessById） 和 SQL 类型</span><br><span class="line"> private final SqlCommand command;</span><br><span class="line"> &#x2F;&#x2F; 方法签名，主要是返回值的类型</span><br><span class="line"> private final MethodSignature method;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-MappperMethod-execute-方法"><a href="#4-2-MappperMethod-execute-方法" class="headerlink" title="4.2 MappperMethod.execute()方法"></a>4.2 MappperMethod.execute()方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public Object execute(SqlSession sqlSession, Object[] args) &#123;</span><br><span class="line">    Object result;</span><br><span class="line">    switch (command.getType()) &#123;</span><br><span class="line">      case INSERT: &#123;</span><br><span class="line">        Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result &#x3D; rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      case UPDATE: &#123;</span><br><span class="line">        Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result &#x3D; rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      case DELETE: &#123;</span><br><span class="line">        Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result &#x3D; rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      case SELECT:</span><br><span class="line">        if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">          executeWithResultHandler(sqlSession, args);</span><br><span class="line">          result &#x3D; null;</span><br><span class="line">        &#125; else if (method.returnsMany()) &#123;</span><br><span class="line">          result &#x3D; executeForMany(sqlSession, args);</span><br><span class="line">        &#125; else if (method.returnsMap()) &#123;</span><br><span class="line">          result &#x3D; executeForMap(sqlSession, args);</span><br><span class="line">        &#125; else if (method.returnsCursor()) &#123;</span><br><span class="line">          result &#x3D; executeForCursor(sqlSession, args);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">          &#x2F;&#x2F; 普通 select 语句的执行入口 &gt;&gt;</span><br><span class="line">          result &#x3D; sqlSession.selectOne(command.getName(), param);</span><br><span class="line">          if (method.returnsOptional()</span><br><span class="line">              &amp;&amp; (result &#x3D;&#x3D; null || !method.getReturnType().equals(result.getClass()))) &#123;</span><br><span class="line">            result &#x3D; Optional.ofNullable(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">      case FLUSH:</span><br><span class="line">        result &#x3D; sqlSession.flushStatements();</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    if (result &#x3D;&#x3D; null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">      throw new BindingException(&quot;Mapper method &#39;&quot; + command.getName()</span><br><span class="line">          + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>根据不同的类型（<strong>INSERT、UPDATE、DELETE、SELECT</strong>）和返回类型：</p>
<ul>
<li>调用<strong>convertArgsToSqlCommandParam</strong>()将方法的参数转换为SQL的参数。</li>
<li>调用sqlSession的insert()、update()、delete()、selectOne()方法。</li>
</ul>
<p>下面重点来讲下查询的selectOne()方法。调用了<strong>DefaultSqlSession</strong>的selectOne()方法。</p>
<h2 id="4-3-DefaultSqlSession-selectOne-方法"><a href="#4-3-DefaultSqlSession-selectOne-方法" class="headerlink" title="4.3 DefaultSqlSession.selectOne()方法"></a>4.3 DefaultSqlSession.selectOne()方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T selectOne(String statement, Object parameter) &#123;</span><br><span class="line">    &#x2F;&#x2F; 来到了 DefaultSqlSession</span><br><span class="line">    &#x2F;&#x2F; Popular vote was to return null on 0 results and throw exception on too many.</span><br><span class="line">    List&lt;T&gt; list &#x3D; this.selectList(statement, parameter);</span><br><span class="line">    if (list.size() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">      return list.get(0);</span><br><span class="line">    &#125; else if (list.size() &gt; 1) &#123;</span><br><span class="line">      throw new TooManyResultsException(&quot;Expected one result (or null) to be returned by selectOne(), but found: &quot; + list.size());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在SelectList()中，我们先根据commandname（StatementID）从Configuration中拿到MappedStatement，这个ms上面有我们在xml中配置的所有属性，包括id、statementType、sqlSource、useCache、入参、出参等等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      MappedStatement ms &#x3D; configuration.getMappedStatement(statement);</span><br><span class="line">      &#x2F;&#x2F; 如果 cacheEnabled &#x3D; true（默认），Executor会被 CachingExecutor装饰</span><br><span class="line">      return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>然后执行executor.query()，前面我们说到了Executor有三种基本类型，SIMPLE/REUSE/BATCH，还有一种包装类型，CachingExecutor。那么在这里到底会选择哪一种执行器呢？我们要回过头去看看DefaultSqlSession在初始化的时候是怎么赋值的，这个就是我们的会话创建过程。如果启用了二级缓存，就会先调用CachingExecutor 的query()方法，里面有缓存相关的操作，然后才是再调用基本类型的执行器，比如默认的SimpleExecutor。在没有开启二级缓存的情况下，先会走到BaseExecutor的query()方法（否则会先走到CachingExecutor）。</p>
<h2 id="4-4-CachingExector-query-方法"><a href="#4-4-CachingExector-query-方法" class="headerlink" title="4.4 CachingExector.query()方法"></a>4.4 CachingExector.query()方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取SQL</span><br><span class="line">    BoundSql boundSql &#x3D; ms.getBoundSql(parameterObject);</span><br><span class="line">    &#x2F;&#x2F; 创建CacheKey：什么样的SQL是同一条SQL？ &gt;&gt;</span><br><span class="line">    CacheKey key &#x3D; createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-4-1、创建CacheKey"><a href="#4-4-1、创建CacheKey" class="headerlink" title="4.4.1、创建CacheKey"></a>4.4.1、创建CacheKey</h2><p>二级缓存的CacheKey是如何构成的呢？换句话说，什么样的查询才能确定是同一个查询呢？在BaseExector中createCacheKey()方法，用到了六要素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) &#123;</span><br><span class="line">    if (closed) &#123;</span><br><span class="line">      throw new ExecutorException(&quot;Executor was closed.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    CacheKey cacheKey &#x3D; new CacheKey();</span><br><span class="line">    cacheKey.update(ms.getId()); </span><br><span class="line">    cacheKey.update(rowBounds.getOffset()); &#x2F;&#x2F; 0</span><br><span class="line">    cacheKey.update(rowBounds.getLimit()); &#x2F;&#x2F; 2147483647 &#x3D; 2^31-1</span><br><span class="line">    cacheKey.update(boundSql.getSql());</span><br><span class="line">    List&lt;ParameterMapping&gt; parameterMappings &#x3D; boundSql.getParameterMappings();</span><br><span class="line">    TypeHandlerRegistry typeHandlerRegistry &#x3D; ms.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">    &#x2F;&#x2F; mimic DefaultParameterHandler logic</span><br><span class="line">    for (ParameterMapping parameterMapping : parameterMappings) &#123;</span><br><span class="line">      if (parameterMapping.getMode() !&#x3D; ParameterMode.OUT) &#123;</span><br><span class="line">        Object value;</span><br><span class="line">        String propertyName &#x3D; parameterMapping.getProperty();</span><br><span class="line">        if (boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">          value &#x3D; boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">        &#125; else if (parameterObject &#x3D;&#x3D; null) &#123;</span><br><span class="line">          value &#x3D; null;</span><br><span class="line">        &#125; else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">          value &#x3D; parameterObject;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          MetaObject metaObject &#x3D; configuration.newMetaObject(parameterObject);</span><br><span class="line">          value &#x3D; metaObject.getValue(propertyName);</span><br><span class="line">        &#125;</span><br><span class="line">        cacheKey.update(value); &#x2F;&#x2F; development</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (configuration.getEnvironment() !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; issue #176</span><br><span class="line">      cacheKey.update(configuration.getEnvironment().getId());</span><br><span class="line">    &#125;</span><br><span class="line">    return cacheKey;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>即为方法相同、翻页偏移相同、SQL相同、参数值相同、数据源环境相同才会被认定为同一个查询。</p>
<p>注意看下CacheKey类的属性，里面有一个List按照顺序存放了上面的六要素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static final int DEFAULT_MULTIPLIER &#x3D; 37;</span><br><span class="line"> private static final int DEFAULT_HASHCODE &#x3D; 17;</span><br><span class="line"></span><br><span class="line"> private final int multiplier;</span><br><span class="line"> private int hashcode;</span><br><span class="line"> private long checksum;</span><br><span class="line"> private int count;</span><br><span class="line"> &#x2F;&#x2F; 8&#x2F;21&#x2F;2017 - Sonarlint flags this as needing to be marked transient.  While true if content is not serializable, this is not always true and thus should not be marked transient.</span><br><span class="line"> private List&lt;Object&gt; updateList;</span><br></pre></td></tr></table></figure>

<p>怎么比较两个CacheKey是否相等呢？如果一上来就依次比较六个要素是否相等，这样要比6次，这样效率不高。每一个类都继承自Object，都有一个hashCode()方法，用来生成哈希码。它是用来在集合中快速判重的。</p>
<p>在生成cacheKey的时候也就是调用update()方法，也更新了cacheKey的hashCode，它是用乘法哈希生成的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void update(Object object) &#123;</span><br><span class="line">    &#x2F;&#x2F; 加法哈希</span><br><span class="line">    int baseHashCode &#x3D; object &#x3D;&#x3D; null ? 1 : ArrayUtil.hashCode(object);</span><br><span class="line"></span><br><span class="line">    count++;</span><br><span class="line">    checksum +&#x3D; baseHashCode;</span><br><span class="line">    baseHashCode *&#x3D; count;</span><br><span class="line">    &#x2F;&#x2F; 37 * 17 + </span><br><span class="line">    hashcode &#x3D; multiplier * hashcode + baseHashCode;</span><br><span class="line"></span><br><span class="line">    updateList.add(object);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Object中的hashCode()方法是一个本地方法，通过<strong>随机数算法生成</strong>（OpenJDK8 默认，可以通过-XX:hashCode修改）。CacheKey中的hashCode()方法进行了重写，返回生成新的hashCode。</p>
<p>为什么需要用37作为乘法因子呢？这是一个经验值，跟String类中的31类似。看下String类中的hashCode()方法源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int hashCode() &#123;</span><br><span class="line">    int h &#x3D; hash;</span><br><span class="line">    if (h &#x3D;&#x3D; 0 &amp;&amp; value.length &gt; 0) &#123;</span><br><span class="line">        char val[] &#x3D; value;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; value.length; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;31作为乘法因子</span><br><span class="line">            h &#x3D; 31 * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash &#x3D; h;</span><br><span class="line">    &#125;</span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CacheKey中的equals()方法也进行了重写，比较cacheKey是否相等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object object) &#123;</span><br><span class="line">    &#x2F;&#x2F; 同一个对象</span><br><span class="line">    if (this &#x3D;&#x3D; object) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 被比较的对象不是 CacheKey</span><br><span class="line">    if (!(object instanceof CacheKey)) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    final CacheKey cacheKey &#x3D; (CacheKey) object;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; hashcode 不相等</span><br><span class="line">    if (hashcode !&#x3D; cacheKey.hashcode) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; checksum 不相等</span><br><span class="line">    if (checksum !&#x3D; cacheKey.checksum) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; count 不相等</span><br><span class="line">    if (count !&#x3D; cacheKey.count) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i &lt; updateList.size(); i++) &#123;</span><br><span class="line">      Object thisObject &#x3D; updateList.get(i);</span><br><span class="line">      Object thatObject &#x3D; cacheKey.updateList.get(i);</span><br><span class="line">      if (!ArrayUtil.equals(thisObject, thatObject)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果哈希值（乘法哈希），校验值（加法哈希），要素个数任何一个不相等，都不是同一个查询，最后再循环比较要素，防止hash碰撞。</p>
<p>CacheKey生成之后，调用CachingExecutor类的query()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取SQL</span><br><span class="line">    BoundSql boundSql &#x3D; ms.getBoundSql(parameterObject);</span><br><span class="line">    &#x2F;&#x2F; 创建CacheKey：什么样的SQL是同一条SQL？ &gt;&gt;</span><br><span class="line">    CacheKey key &#x3D; createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4-2、处理二级缓存"><a href="#4-4-2、处理二级缓存" class="headerlink" title="4.4.2、处理二级缓存"></a>4.4.2、处理二级缓存</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span><br><span class="line">      throws SQLException &#123;</span><br><span class="line">    Cache cache &#x3D; ms.getCache();</span><br><span class="line">    &#x2F;&#x2F; cache 对象是在哪里创建的？  XMLMapperBuilder类 xmlconfigurationElement()</span><br><span class="line">    &#x2F;&#x2F; 由 &lt;cache&gt; 标签决定</span><br><span class="line">    if (cache !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; flushCache&#x3D;&quot;true&quot; 清空一级二级缓存 &gt;&gt;</span><br><span class="line">      flushCacheIfRequired(ms);</span><br><span class="line">      if (ms.isUseCache() &amp;&amp; resultHandler &#x3D;&#x3D; null) &#123;</span><br><span class="line">        ensureNoOutParams(ms, boundSql);</span><br><span class="line">        &#x2F;&#x2F; 获取二级缓存</span><br><span class="line">        &#x2F;&#x2F; 缓存通过 TransactionalCacheManager、TransactionalCache 管理</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        List&lt;E&gt; list &#x3D; (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">        if (list &#x3D;&#x3D; null) &#123;</span><br><span class="line">          list &#x3D; delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">          &#x2F;&#x2F; 写入二级缓存</span><br><span class="line">          tcm.putObject(cache, key, list); &#x2F;&#x2F; issue #578 and #116</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 走到 SimpleExecutor | ReuseExecutor | BatchExecutor</span><br><span class="line">    return delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>首先从<strong>MappedStatement</strong>对象中调用<strong>getCache</strong>()方法，判断对象是否为空，如果为空，则没有查询二级缓存、写入二级缓存的流程。</p>
<p>那么Cache对象是什么时候被创建出来的呢？用来解析Mapper.xml的<strong>XMLMapperBuilder</strong>类，<strong>configurationElement</strong>()方法中调用<strong>cacheElement</strong>()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cacheElement(context.evalNode(&quot;cache&quot;));</span><br></pre></td></tr></table></figure>
<p>只有Mapper.xml中的cache标签不为空才会被解析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void cacheElement(XNode context) &#123;</span><br><span class="line">   &#x2F;&#x2F; 只有 cache 标签不为空才解析</span><br><span class="line">   if (context !&#x3D; null) &#123;</span><br><span class="line">     String type &#x3D; context.getStringAttribute(&quot;type&quot;, &quot;PERPETUAL&quot;);</span><br><span class="line">     Class&lt;? extends Cache&gt; typeClass &#x3D; typeAliasRegistry.resolveAlias(type);</span><br><span class="line">     String eviction &#x3D; context.getStringAttribute(&quot;eviction&quot;, &quot;LRU&quot;);</span><br><span class="line">     Class&lt;? extends Cache&gt; evictionClass &#x3D; typeAliasRegistry.resolveAlias(eviction);</span><br><span class="line">     Long flushInterval &#x3D; context.getLongAttribute(&quot;flushInterval&quot;);</span><br><span class="line">     Integer size &#x3D; context.getIntAttribute(&quot;size&quot;);</span><br><span class="line">     boolean readWrite &#x3D; !context.getBooleanAttribute(&quot;readOnly&quot;, false);</span><br><span class="line">     boolean blocking &#x3D; context.getBooleanAttribute(&quot;blocking&quot;, false);</span><br><span class="line">     Properties props &#x3D; context.getChildrenAsProperties();</span><br><span class="line">     builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>builderAssistant.useNewCache</strong>()方法创建了一个Cache对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public Cache useNewCache(Class&lt;? extends Cache&gt; typeClass,</span><br><span class="line">      Class&lt;? extends Cache&gt; evictionClass,</span><br><span class="line">      Long flushInterval,</span><br><span class="line">      Integer size,</span><br><span class="line">      boolean readWrite,</span><br><span class="line">      boolean blocking,</span><br><span class="line">      Properties props) &#123;</span><br><span class="line">    Cache cache &#x3D; new CacheBuilder(currentNamespace)</span><br><span class="line">        .implementation(valueOrDefault(typeClass, PerpetualCache.class))</span><br><span class="line">        .addDecorator(valueOrDefault(evictionClass, LruCache.class))</span><br><span class="line">        .clearInterval(flushInterval)</span><br><span class="line">        .size(size)</span><br><span class="line">        .readWrite(readWrite)</span><br><span class="line">        .blocking(blocking)</span><br><span class="line">        .properties(props)</span><br><span class="line">        .build();</span><br><span class="line">    configuration.addCache(cache);</span><br><span class="line">    currentCache &#x3D; cache;</span><br><span class="line">    return cache;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>二级缓存为什么要用TCM来进行管理呢？</strong></p>
<p>我们来思考一个问题，在一个事务中：</p>
<ul>
<li>1、首先插入一条数据（没有提交），此时二级缓存会被清空。</li>
<li>2、在这个事务中查询数据，写入二级缓存。</li>
<li>3、提交事务，出现异常，数据回滚。</li>
</ul>
<p>此时出现了数据库没有这条数据，但是二级缓存有这条数据的情况。所以MyBatis<br>的二级缓存需要跟事务关联起来。</p>
<p><strong>那么为什么一级缓存不这么做？</strong></p>
<p>因为一个session就是一个事务，事务回滚，会话就结束了，缓存也清空了，不存<br>在读到一级缓存中脏数据的情况。二级缓存是跨session的，也就是跨事务的，才有可能出现对同一个方法的不同事务访问。</p>
<h2 id="4-4-2-1-写入二级缓存"><a href="#4-4-2-1-写入二级缓存" class="headerlink" title="4.4.2.1 写入二级缓存"></a>4.4.2.1 写入二级缓存</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcm.putObject(cache, key, list); &#x2F;&#x2F; issue #578 and #116</span><br></pre></td></tr></table></figure>

<p>调用<strong>TranscationalCacheManager</strong>的<strong>putObject</strong>()方法，从map中拿出TransactionalCache对象，把value添加到待提交的map中。此时缓存还没有真正的写入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void putObject(Cache cache, CacheKey key, Object value) &#123;</span><br><span class="line">    getTransactionalCache(cache).putObject(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private TransactionalCache getTransactionalCache(Cache cache) &#123;</span><br><span class="line">    return transactionalCaches.computeIfAbsent(cache, TransactionalCache::new);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<strong>TranscationalCache</strong>的<strong>putObject</strong>()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void putObject(Object key, Object object) &#123;</span><br><span class="line">    entriesToAddOnCommit.put(key, object);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>只有真正的提交事务的时候才真正的写入缓存。</strong></p>
<h2 id="4-4-2-2-获取二级缓存"><a href="#4-4-2-2-获取二级缓存" class="headerlink" title="4.4.2.2 获取二级缓存"></a>4.4.2.2 获取二级缓存</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;E&gt; list &#x3D; (List&lt;E&gt;) tcm.getObject(cache, key);</span><br></pre></td></tr></table></figure>
<p>从map中拿出<strong>Transcational</strong>对象，这个对象也是对<strong>PerpetualCache</strong>经过层层装饰的缓存对象。<strong>getObject</strong>()方法层层递归，直到到达<strong>PerpetualCache</strong>，拿到value。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public Object getObject(Object key) &#123;</span><br><span class="line">    &#x2F;&#x2F; issue #116</span><br><span class="line">    Object object &#x3D; delegate.getObject(key);</span><br><span class="line">    if (object &#x3D;&#x3D; null) &#123;</span><br><span class="line">      entriesMissedInCache.add(key);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; issue #146</span><br><span class="line">    if (clearOnCommit) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return object;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>PerpetualCache</strong>中的<strong>getObject</strong>()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object getObject(Object key) &#123;</span><br><span class="line">    return cache.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-BaseExecutor-query-方法"><a href="#4-5-BaseExecutor-query-方法" class="headerlink" title="4.5 BaseExecutor.query()方法"></a>4.5 BaseExecutor.query()方法</h2><h2 id="4-5-1-清空本地缓存"><a href="#4-5-1-清空本地缓存" class="headerlink" title="4.5.1 清空本地缓存"></a>4.5.1 清空本地缓存</h2><p><strong>queryStack</strong>用于记录查询栈，防止递归时候查询重复处理缓存。<strong>flushCache=true</strong>的时候，会先清除本地缓存LocalCache（一级缓存）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (queryStack &#x3D;&#x3D; 0 &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">      &#x2F;&#x2F; flushCache&#x3D;&quot;true&quot;时，即使是查询，也清空一级缓存</span><br><span class="line">      clearLocalCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有缓存，会从数据库查询。调用<strong>queryFromDatabase()</strong>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list &#x3D; queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br></pre></td></tr></table></figure>

<p><strong>LocalCacheScope == STATEMENT</strong>，就会清空本地缓存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (configuration.getLocalCacheScope() &#x3D;&#x3D; LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">    &#x2F;&#x2F; issue #482</span><br><span class="line">    clearLocalCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-2-数据库查询"><a href="#4-5-2-数据库查询" class="headerlink" title="4.5.2 数据库查询"></a>4.5.2 数据库查询</h2><p>1、先在缓存用占位符进行占位。执行查询后，移除占位符，放入数据。</p>
<p>2、执行Exector的doQuery()方法，默认是SimpleExector。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">   List&lt;E&gt; list;</span><br><span class="line">   &#x2F;&#x2F; 先占位</span><br><span class="line">   localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; 三种 Executor 的区别，看doUpdate</span><br><span class="line">     &#x2F;&#x2F; 默认Simple</span><br><span class="line">     list &#x3D; doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">     &#x2F;&#x2F; 移除占位符</span><br><span class="line">     localCache.removeObject(key);</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 写入一级缓存</span><br><span class="line">   localCache.putObject(key, list);</span><br><span class="line">   if (ms.getStatementType() &#x3D;&#x3D; StatementType.CALLABLE) &#123;</span><br><span class="line">     localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">   &#125;</span><br><span class="line">   return list;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-6-SimpleExecutor-query-方法"><a href="#4-6-SimpleExecutor-query-方法" class="headerlink" title="4.6 SimpleExecutor.query()方法"></a>4.6 SimpleExecutor.query()方法</h2><h2 id="4-6-1-创建StatementHandler"><a href="#4-6-1-创建StatementHandler" class="headerlink" title="4.6.1 创建StatementHandler"></a>4.6.1 创建StatementHandler</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">    Statement stmt &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      Configuration configuration &#x3D; ms.getConfiguration();</span><br><span class="line">      &#x2F;&#x2F; 注意，已经来到SQL处理的关键对象 StatementHandler &gt;&gt;</span><br><span class="line">      StatementHandler handler &#x3D; configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      &#x2F;&#x2F; 获取一个 Statement对象</span><br><span class="line">      stmt &#x3D; prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">      &#x2F;&#x2F; 执行查询</span><br><span class="line">      return handler.query(stmt, resultHandler);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      &#x2F;&#x2F; 用完就关闭</span><br><span class="line">      closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>configuration.newStatementHandler</strong>()先得到<strong>RoutingStatementHandler</strong>。RoutingStatementHandler没有任何实现，用来创建基本的<strong>StatementHandler</strong>，这里会根据<strong>MappedStatement</strong>里面的<strong>statementType</strong>决定<strong>StatementHandler</strong>的类型。默认是<strong>PREPARED（STATEMENT、PREPARED、CALLABLE）</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public RoutingStatementHandler(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">    &#x2F;&#x2F; StatementType 是怎么来的？ 增删改查标签中的 statementType&#x3D;&quot;PREPARED&quot;，默认值 PREPARED</span><br><span class="line">    switch (ms.getStatementType()) &#123;</span><br><span class="line">      case STATEMENT:</span><br><span class="line">        delegate &#x3D; new SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        break;</span><br><span class="line">      case PREPARED:</span><br><span class="line">        &#x2F;&#x2F; 创建 StatementHandler 的时候做了什么？ &gt;&gt;</span><br><span class="line">        delegate &#x3D; new PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        break;</span><br><span class="line">      case CALLABLE:</span><br><span class="line">        delegate &#x3D; new CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        throw new ExecutorException(&quot;Unknown statement type: &quot; + ms.getStatementType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>StatementHandler</strong>里面包含了处理参数的<strong>ParamterHandler</strong>和处理结果集的<strong>ResultHandler</strong>。这两个对象都是在上面new的时候创建的。</p>
<p><strong>StatementHandler</strong>父类<strong>BaseStatementHandler</strong>类中的构造函数中创建以上两个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected BaseStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">   this.configuration &#x3D; mappedStatement.getConfiguration();</span><br><span class="line">   this.executor &#x3D; executor;</span><br><span class="line">   this.mappedStatement &#x3D; mappedStatement;</span><br><span class="line">   this.rowBounds &#x3D; rowBounds;</span><br><span class="line"></span><br><span class="line">   this.typeHandlerRegistry &#x3D; configuration.getTypeHandlerRegistry();</span><br><span class="line">   this.objectFactory &#x3D; configuration.getObjectFactory();</span><br><span class="line"></span><br><span class="line">   if (boundSql &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; issue #435, get the key before calculating the statement</span><br><span class="line">     generateKeys(parameterObject);</span><br><span class="line">     boundSql &#x3D; mappedStatement.getBoundSql(parameterObject);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   this.boundSql &#x3D; boundSql;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 创建了四大对象的其它两大对象 &gt;&gt;</span><br><span class="line">   &#x2F;&#x2F; 创建这两大对象的时候分别做了什么？</span><br><span class="line">   this.parameterHandler &#x3D; configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">   this.resultSetHandler &#x3D; configuration.newResultSetHandler(executor, mappedStatement, rowBounds, parameterHandler, resultHandler, boundSql);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这些对象都是可以被插件拦截的四大对象，所以在创建之后都要用拦截器进行包装的方法。在<strong>Configuration</strong>中进行拦截调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) &#123;</span><br><span class="line">    ParameterHandler parameterHandler &#x3D; mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    &#x2F;&#x2F; 植入插件逻辑（返回代理对象）</span><br><span class="line">    parameterHandler &#x3D; (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">    return parameterHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span><br><span class="line">      ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">    ResultSetHandler resultSetHandler &#x3D; new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">    &#x2F;&#x2F; 植入插件逻辑（返回代理对象）</span><br><span class="line">    resultSetHandler &#x3D; (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">    return resultSetHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">    StatementHandler statementHandler &#x3D; new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">    &#x2F;&#x2F; 植入插件逻辑（返回代理对象）</span><br><span class="line">    statementHandler &#x3D; (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">    return statementHandler;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里只有对其中的三个对象，还有一个对象呢？它什么时候创建呢？</p>
<h2 id="4-6-2-创建Statement"><a href="#4-6-2-创建Statement" class="headerlink" title="4.6.2 创建Statement"></a>4.6.2 创建Statement</h2><p>用new出来的<strong>StatementHandler</strong>创建<strong>Statement</strong>对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException &#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    Connection connection &#x3D; getConnection(statementLog);</span><br><span class="line">    &#x2F;&#x2F; 获取 Statement 对象，如果有插件包装，会先走到被拦截的业务逻辑</span><br><span class="line">    stmt &#x3D; handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">    &#x2F;&#x2F; 为 Statement 设置参数，对sql语句进行预编译，处理参数</span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    return stmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void parameterize(Statement statement) throws SQLException &#123;</span><br><span class="line">    delegate.parameterize(statement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-6-3-执行StatementHandler的query-方法"><a href="#4-6-3-执行StatementHandler的query-方法" class="headerlink" title="4.6.3 执行StatementHandler的query()方法"></a>4.6.3 执行StatementHandler的query()方法</h1><p>RoutingStatementHandler的query()方法，delegate委派，最终执行PreparedStatementHandler的query()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">   return delegate.query(statement, resultHandler);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-6-4-执行PreparedStatementHandler的query-方法"><a href="#4-6-4-执行PreparedStatementHandler的query-方法" class="headerlink" title="4.6.4 执行PreparedStatementHandler的query()方法"></a>4.6.4 执行PreparedStatementHandler的query()方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">    PreparedStatement ps &#x3D; (PreparedStatement) statement;</span><br><span class="line">    &#x2F;&#x2F; 到了JDBC的流程</span><br><span class="line">    ps.execute();</span><br><span class="line">    &#x2F;&#x2F; 处理结果集</span><br><span class="line">    return resultSetHandler.handleResultSets(ps);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-6-5-ResultHandler处理结果集"><a href="#4-6-5-ResultHandler处理结果集" class="headerlink" title="4.6.5 ResultHandler处理结果集"></a>4.6.5 ResultHandler处理结果集</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resultSetHandler.handleResultSets(ps);</span><br></pre></td></tr></table></figure>

<p>怎么把ResultSet转换成List<ObJect>?</p>
<p><strong>ResultSetHandIer</strong>只有一个实现类：<strong>DefaultResultSetHandler</strong>也就是执行<br>DefaultResultSetHandler的<strong>handleResultSets</strong>()方法。首先我们会先拿到第一个结果集，如果没有配置一个查询返回多个结果集的情况，一般只有一个结果集。如果下面的这个while循环我们也不用，就执行一次。然后会调用<strong>handleResuItSet</strong>()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public List&lt;Object&gt; handleResultSets(Statement stmt) throws SQLException &#123;</span><br><span class="line">    ErrorContext.instance().activity(&quot;handling results&quot;).object(mappedStatement.getId());</span><br><span class="line"></span><br><span class="line">    final List&lt;Object&gt; multipleResults &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    int resultSetCount &#x3D; 0;</span><br><span class="line">    ResultSetWrapper rsw &#x3D; getFirstResultSet(stmt);</span><br><span class="line"></span><br><span class="line">    List&lt;ResultMap&gt; resultMaps &#x3D; mappedStatement.getResultMaps();</span><br><span class="line">    int resultMapCount &#x3D; resultMaps.size();</span><br><span class="line">    validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line">    while (rsw !&#x3D; null &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</span><br><span class="line">      ResultMap resultMap &#x3D; resultMaps.get(resultSetCount);</span><br><span class="line">      handleResultSet(rsw, resultMap, multipleResults, null);</span><br><span class="line">      rsw &#x3D; getNextResultSet(stmt);</span><br><span class="line">      cleanUpAfterHandlingResultSet();</span><br><span class="line">      resultSetCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] resultSets &#x3D; mappedStatement.getResultSets();</span><br><span class="line">    if (resultSets !&#x3D; null) &#123;</span><br><span class="line">      while (rsw !&#x3D; null &amp;&amp; resultSetCount &lt; resultSets.length) &#123;</span><br><span class="line">        ResultMapping parentMapping &#x3D; nextResultMaps.get(resultSets[resultSetCount]);</span><br><span class="line">        if (parentMapping !&#x3D; null) &#123;</span><br><span class="line">          String nestedResultMapId &#x3D; parentMapping.getNestedResultMapId();</span><br><span class="line">          ResultMap resultMap &#x3D; configuration.getResultMap(nestedResultMapId);</span><br><span class="line">          handleResultSet(rsw, resultMap, null, parentMapping);</span><br><span class="line">        &#125;</span><br><span class="line">        rsw &#x3D; getNextResultSet(stmt);</span><br><span class="line">        cleanUpAfterHandlingResultSet();</span><br><span class="line">        resultSetCount++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return collapseSingleResultList(multipleResults);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void handleResultSet(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Object&gt; multipleResults, ResultMapping parentMapping) throws SQLException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      if (parentMapping !&#x3D; null) &#123;</span><br><span class="line">        handleRowValues(rsw, resultMap, null, RowBounds.DEFAULT, parentMapping);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (resultHandler &#x3D;&#x3D; null) &#123;</span><br><span class="line">          DefaultResultHandler defaultResultHandler &#x3D; new DefaultResultHandler(objectFactory);</span><br><span class="line">          handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, null);</span><br><span class="line">          multipleResults.add(defaultResultHandler.getResultList());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          handleRowValues(rsw, resultMap, resultHandler, rowBounds, null);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      &#x2F;&#x2F; issue #228 (close resultsets)</span><br><span class="line">      closeResultSet(rsw.getResultSet());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://user-gold-cdn.xitu.io/2020/5/15/1721652a86370b3e?w=720&h=466&f=jpeg&s=51595" alt=""></h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/05/15/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%98%85%E8%AF%BBmybatis%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%EF%BC%8C%E6%8E%8C%E6%8F%A1%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/" data-id="ckiohtc9m0014ryra6wm50ygo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/05/18/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%8F%AD%E5%BC%80%E7%AF%87%E7%AB%A0%EF%BC%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86%EF%BC%8C%E4%BA%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%84%8F%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          JAVA并发编程揭开篇章，并发编程基本认识，了解多线程意义和使用
        
      </div>
    </a>
  
  
    <a href="/2020/05/14/%E9%9D%A2%E8%AF%95%E5%AE%98%E5%8F%A3%E4%B8%AD%E7%9A%84Mybatis%EF%BC%8C%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E3%80%81%E6%9E%B6%E6%9E%84%E5%88%86%E5%B1%82%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86%E4%BB%A5%E5%8F%8A%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">面试官口中的Mybatis，工作流程、架构分层与模块划分以及缓存机制</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/12/14/%E8%BF%88%E5%87%BAspring5%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81%E5%B9%B6%E4%BD%BF%E7%94%A8IDEA%E6%89%93%E5%BC%80/">迈出spring5源码阅读第一步，如何编译源码并使用IDEA打开</a>
          </li>
        
          <li>
            <a href="/2020/09/16/Ambari%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0%E9%9B%86%E7%BE%A4%E5%88%A9%E5%99%A8%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E8%B7%B5/">Ambari大数据平台集群利器的探索与实践</a>
          </li>
        
          <li>
            <a href="/2020/09/03/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E5%BA%93InfluxDB%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88%E9%AB%98%E7%BA%A7%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C%EF%BC%8C%E8%AF%B7%E5%85%B3%E6%B3%A8/">时间序列数据库InfluxDB集群方案高级实践经验，请关注</a>
          </li>
        
          <li>
            <a href="/2020/08/25/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E7%9A%84%E7%8E%8B%E8%80%85Apache-Atlas%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84API/">数据治理的王者Apache-Atlas如何构建自己的API</a>
          </li>
        
          <li>
            <a href="/2020/07/26/CountDownLatch%E3%80%81Semaphore%E3%80%81CyclicBarrier%E3%80%81Condition%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">CountDownLatch、Semaphore、CyclicBarrier、Condition源码分析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Kevin Shaw<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>