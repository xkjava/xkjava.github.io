<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>JAVA并发编程关于锁的那些事，ReentantLock的底层设计深入浅出 | 来一杯咖啡</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一、介绍JUCjava.util.concurrent是在并发编程中比较常用的工具类，里面包含很多用来在并发场景中使用的组件。比如线程池、阻塞队列、计时器、同步器、并发集合等等。 二、介绍LockLock最为重要的特性就是解决并发程序的安全性问题。 在JUC大部分组件都使用了Lock，所以了解和使用Lock显得尤为重要。Lock在JUC中本质上是以一个接口的形势表现的。  我们可以从上面的图中可以">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA并发编程关于锁的那些事，ReentantLock的底层设计深入浅出">
<meta property="og:url" content="https://xkjava.github.io/2020/06/26/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B3%E4%BA%8E%E9%94%81%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%8CReentantLock%E7%9A%84%E5%BA%95%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/index.html">
<meta property="og:site_name" content="来一杯咖啡">
<meta property="og:description" content="一、介绍JUCjava.util.concurrent是在并发编程中比较常用的工具类，里面包含很多用来在并发场景中使用的组件。比如线程池、阻塞队列、计时器、同步器、并发集合等等。 二、介绍LockLock最为重要的特性就是解决并发程序的安全性问题。 在JUC大部分组件都使用了Lock，所以了解和使用Lock显得尤为重要。Lock在JUC中本质上是以一个接口的形势表现的。  我们可以从上面的图中可以">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/21/172d4c105e6dc681?w=1498&h=529&f=png&s=50933">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/21/172d5dcc08f66488?w=1080&h=383&f=png&s=295579">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/21/172d5dac220c07ab?w=1252&h=280&f=png&s=138903">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/21/172d6465503eb58f?w=1600&h=680&f=png&s=77986">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/21/172d64a181e4952f?w=1231&h=226&f=png&s=30412">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/25/172e9942c6022b84?w=1342&h=265&f=png&s=29677">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/26/172eea9bb11f862b?w=996&h=529&f=png&s=66511">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/26/172eed6b9d9d8b11?w=790&h=157&f=png&s=15582">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/26/172ef8298e418507?w=757&h=172&f=png&s=11808">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/26/172ef99ae113acc9?w=776&h=146&f=png&s=11943">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/26/172efa6404e1343a?w=893&h=214&f=png&s=21823">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/26/172efb16874cc2df?w=1156&h=230&f=png&s=24416">
<meta property="article:published_time" content="2020-06-26T08:34:17.000Z">
<meta property="article:modified_time" content="2020-06-26T08:39:11.849Z">
<meta property="article:author" content="Kevin Shaw">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="Netty">
<meta property="article:tag" content="Kafka...">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2020/6/21/172d4c105e6dc681?w=1498&h=529&f=png&s=50933">
  
    <link rel="alternate" href="/atom.xml" title="来一杯咖啡" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">来一杯咖啡</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">互联网技术无边界，学习与交流</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://xkjava.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-JAVA并发编程关于锁的那些事，ReentantLock的底层设计深入浅出" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/26/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B3%E4%BA%8E%E9%94%81%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%8CReentantLock%E7%9A%84%E5%BA%95%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/" class="article-date">
  <time datetime="2020-06-26T08:34:17.000Z" itemprop="datePublished">2020-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JAVA并发编程关于锁的那些事，ReentantLock的底层设计深入浅出
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、介绍JUC"><a href="#一、介绍JUC" class="headerlink" title="一、介绍JUC"></a>一、介绍JUC</h1><p>java.util.concurrent是在并发编程中比较常用的工具类，里面包含很多用来在并发场景中使用的组件。比如<strong>线程池、阻塞队列、计时器、同步器、并发集合</strong>等等。</p>
<h1 id="二、介绍Lock"><a href="#二、介绍Lock" class="headerlink" title="二、介绍Lock"></a>二、介绍Lock</h1><p><strong>Lock最为重要的特性就是解决并发程序的安全性问题。</strong> 在JUC大部分组件都使用了Lock，所以了解和使用Lock显得尤为重要。Lock在JUC中本质上是以一个接口的形势表现的。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d4c105e6dc681?w=1498&h=529&f=png&s=50933" alt=""></p>
<p>我们可以从上面的图中可以看出关于锁有很多不同的实现类。下面来简单介绍一翻吧。</p>
<h2 id="2-1-ReentrantLock（重入锁）"><a href="#2-1-ReentrantLock（重入锁）" class="headerlink" title="2.1 ReentrantLock（重入锁）"></a>2.1 ReentrantLock（重入锁）</h2><p>ReentrantLock实现了Lock接口，表示重入锁。是线程在获得锁之后，再次获取锁不需要阻塞，而是直接关联一次计数器增加重入次数。<strong>后面我们重点分析ReentrantLock的原理。</strong></p>
<h2 id="2-2-ReentrantReadWriteLock（重入读写锁）"><a href="#2-2-ReentrantReadWriteLock（重入读写锁）" class="headerlink" title="2.2 ReentrantReadWriteLock（重入读写锁）"></a>2.2 ReentrantReadWriteLock（重入读写锁）</h2><p>ReentrantReadWriteLock实现了ReadWriteLock接口，其中有两把锁，一个<strong>ReadLock</strong>,一个<strong>WriteLock</strong>,它们分别实现了<strong>Lock</strong>接口。<strong>适合读多写少的场景。</strong><br>基本原则：</p>
<ul>
<li>读和读不互斥；</li>
<li>读和写互斥；</li>
<li>写和写互斥。<h2 id="2-3-StampedLock（改进版读写锁）"><a href="#2-3-StampedLock（改进版读写锁）" class="headerlink" title="2.3 StampedLock（改进版读写锁）"></a>2.3 StampedLock（改进版读写锁）</h2>StampedLock是JDK1.8引进的新的锁机制，它是读写锁的一个改进版。一种乐观的读策略，使得乐观锁完全不阻塞写线程。</li>
</ul>
<h1 id="三、ReentrantLock设计"><a href="#三、ReentrantLock设计" class="headerlink" title="三、ReentrantLock设计"></a>三、ReentrantLock设计</h1><p>说到重入锁ReentrantLock，就是再次获取锁的同时，只是对重入次数进行计数，而不需要阻塞来获取锁。先来看一个案例代码，这样容易理解重入锁的概念。</p>
<p>我们在测试代码中调用test()方法获得了当前对象的锁，然后在这个方法中去调用test1()方法，test2()中也存在一个实例锁，这个时候当前线程无法获取test1()中的对象锁而阻塞， 这样就会产生死锁。R<strong>eentrantLock重入锁的目的就是为了避免线程产生死锁。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantLockDemo &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void test() &#123;</span><br><span class="line">        System.out.println(&quot;Begin test...&quot;);</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test1() &#123;</span><br><span class="line">        System.out.println(&quot;Begin test1...&quot;);</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ReentrantLockDemo reentrantLockDemo &#x3D; new ReentrantLockDemo();</span><br><span class="line">        new Thread(reentrantLockDemo::test).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-1-ReentrantLock重入锁使用案例"><a href="#3-1-ReentrantLock重入锁使用案例" class="headerlink" title="3.1 ReentrantLock重入锁使用案例"></a>3.1 ReentrantLock重入锁使用案例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantLockDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    static Lock lock &#x3D; new ReentrantLock(true);</span><br><span class="line"></span><br><span class="line">    public static void incr() &#123;</span><br><span class="line">        &#x2F;&#x2F;线程A获取锁，计数state &#x3D; 1</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;退出线程 中断的过程往下传递.  true</span><br><span class="line">            &#x2F;&#x2F; sleep&#x2F; join&#x2F; wait</span><br><span class="line">            &#x2F;&#x2F;while()</span><br><span class="line">            &#x2F;&#x2F; ...</span><br><span class="line">            Thread.sleep(1);</span><br><span class="line">            count++;</span><br><span class="line">&#x2F;&#x2F;            decr();</span><br><span class="line">        &#125;catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            &#x2F;&#x2F;线程A释放锁，state&#x3D;1-1&#x3D;0</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void decr() &#123;</span><br><span class="line">        &#x2F;&#x2F;线程A再次获取锁，计数加1，state &#x3D; 2</span><br><span class="line">        lock.lock();</span><br><span class="line">        try&#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 &#x3D; new Thread(()-&gt;&#123;</span><br><span class="line">           ReentrantLockDemo.incr();</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t1.interrupt();&#x2F;&#x2F;线程中断</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; 0 ; i &lt; 1000; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                ReentrantLockDemo.incr();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        System.out.println(&quot;result &#x3D; &quot; + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-ReentrantReadWriteLock重入读写锁案例"><a href="#3-2-ReentrantReadWriteLock重入读写锁案例" class="headerlink" title="3.2 ReentrantReadWriteLock重入读写锁案例"></a>3.2 ReentrantReadWriteLock重入读写锁案例</h2><p>读写锁维护了一个读锁，一个写锁。一般情况下读写锁比排它锁的性能要好一些，因为大多数的场景是读多写少的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantReadWriteLockDemo &#123;</span><br><span class="line"></span><br><span class="line">    static Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    static ReentrantReadWriteLock rrwl &#x3D; new ReentrantReadWriteLock();</span><br><span class="line">    static Lock read &#x3D; rrwl.readLock();</span><br><span class="line">    static Lock write &#x3D; rrwl.writeLock();</span><br><span class="line"></span><br><span class="line">    public static Object get(String key) &#123;</span><br><span class="line">        System.out.println(&quot;Begin reading data...&quot;);</span><br><span class="line">        read.lock();</span><br><span class="line">        try&#123;</span><br><span class="line">            return map.get(key);</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            read.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object put(String key, Object obj) &#123;</span><br><span class="line">        System.out.println(&quot;Begin writing data...&quot;);</span><br><span class="line">        write.lock();</span><br><span class="line">        try&#123;</span><br><span class="line">            return map.put(key, obj);</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            write.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>读锁与读锁可以共享；</li>
<li>读锁与写锁不可以共享（排他）；</li>
<li>写锁与写锁不可以共享（排他。</li>
</ul>
<h2 id="3-3-ReentrantLock的实现原理"><a href="#3-3-ReentrantLock的实现原理" class="headerlink" title="3.3 ReentrantLock的实现原理"></a>3.3 ReentrantLock的实现原理</h2><p>我们在Synchronized中分析了<strong>偏向锁、轻量级锁、重量级锁</strong>。它们是基于<strong>乐观锁</strong>以及<strong>自旋锁</strong>来优化synchronized加锁的开销，在<strong>重量级锁阶段</strong>是通过线程的阻塞以及唤醒来达到线程竞争和同步的目的。</p>
<p>那么在ReentrantLock也一定存在这样的问题，那么它是怎么去解决的呢？这里我们需要引入AQS(AbstractQueueSynchronizer)。</p>
<h2 id="3-3-1-什么是AQS"><a href="#3-3-1-什么是AQS" class="headerlink" title="3.3.1 什么是AQS"></a>3.3.1 什么是AQS</h2><p>在Lock中，AQS是一个同步队列，它是一个同步工具，也是Lock用来实现线程同步的核心组件。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d5dcc08f66488?w=1080&h=383&f=png&s=295579" alt=""></p>
<h2 id="3-3-2-AQS的独占锁和共享锁"><a href="#3-3-2-AQS的独占锁和共享锁" class="headerlink" title="3.3.2 AQS的独占锁和共享锁"></a>3.3.2 AQS的独占锁和共享锁</h2><ul>
<li>独占锁：每次只有一个线程持有锁，<strong>ReentrantLock</strong>的独占锁方式；</li>
<li>共享锁：允许多个线程同时获得锁，并访问共享资源，<strong>ReentrantReadWriteLock</strong>的共享锁方式。</li>
</ul>
<h2 id="3-3-3-AQS的内部实现"><a href="#3-3-3-AQS的内部实现" class="headerlink" title="3.3.3 AQS的内部实现"></a>3.3.3 AQS的内部实现</h2><p>AQS内部维护的是一个FIFO的双向链表，这种数据结构的特点就是有<strong>两个指针</strong>，分别指向直接的后继节点next和直接的前驱节点prev。当线程抢占锁失败后，会封装成一个<strong>Node</strong>直接放入到AQS阻塞队列中。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d5dac220c07ab?w=1252&h=280&f=png&s=138903" alt=""></p>
<h2 id="3-3-4-AQS中的Node"><a href="#3-3-4-AQS中的Node" class="headerlink" title="3.3.4 AQS中的Node"></a>3.3.4 AQS中的Node</h2><p>先上AQS中的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line">        &#x2F;** Marker to indicate a node is waiting in shared mode *&#x2F;</span><br><span class="line">        static final Node SHARED &#x3D; new Node();</span><br><span class="line">        &#x2F;** Marker to indicate a node is waiting in exclusive mode *&#x2F;</span><br><span class="line">        static final Node EXCLUSIVE &#x3D; null;</span><br><span class="line"></span><br><span class="line">        &#x2F;** waitStatus value to indicate thread has cancelled *&#x2F;</span><br><span class="line">        static final int CANCELLED &#x3D;  1;</span><br><span class="line">        &#x2F;** waitStatus value to indicate successor&#39;s thread needs unparking *&#x2F;</span><br><span class="line">        static final int SIGNAL    &#x3D; -1;</span><br><span class="line">        &#x2F;** waitStatus value to indicate thread is waiting on condition *&#x2F;</span><br><span class="line">        static final int CONDITION &#x3D; -2;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * waitStatus value to indicate the next acquireShared should</span><br><span class="line">         * unconditionally propagate</span><br><span class="line">         *&#x2F;</span><br><span class="line">        static final int PROPAGATE &#x3D; -3;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Status field, taking on only the values:</span><br><span class="line">         *   SIGNAL:     The successor of this node is (or will soon be)</span><br><span class="line">         *               blocked (via park), so the current node must</span><br><span class="line">         *               unpark its successor when it releases or</span><br><span class="line">         *               cancels. To avoid races, acquire methods must</span><br><span class="line">         *               first indicate they need a signal,</span><br><span class="line">         *               then retry the atomic acquire, and then,</span><br><span class="line">         *               on failure, block.</span><br><span class="line">         *   CANCELLED:  This node is cancelled due to timeout or interrupt.</span><br><span class="line">         *               Nodes never leave this state. In particular,</span><br><span class="line">         *               a thread with cancelled node never again blocks.</span><br><span class="line">         *   CONDITION:  This node is currently on a condition queue.</span><br><span class="line">         *               It will not be used as a sync queue node</span><br><span class="line">         *               until transferred, at which time the status</span><br><span class="line">         *               will be set to 0. (Use of this value here has</span><br><span class="line">         *               nothing to do with the other uses of the</span><br><span class="line">         *               field, but simplifies mechanics.)</span><br><span class="line">         *   PROPAGATE:  A releaseShared should be propagated to other</span><br><span class="line">         *               nodes. This is set (for head node only) in</span><br><span class="line">         *               doReleaseShared to ensure propagation</span><br><span class="line">         *               continues, even if other operations have</span><br><span class="line">         *               since intervened.</span><br><span class="line">         *   0:          None of the above</span><br><span class="line">         *</span><br><span class="line">         * The values are arranged numerically to simplify use.</span><br><span class="line">         * Non-negative values mean that a node doesn&#39;t need to</span><br><span class="line">         * signal. So, most code doesn&#39;t need to check for particular</span><br><span class="line">         * values, just for sign.</span><br><span class="line">         *</span><br><span class="line">         * The field is initialized to 0 for normal sync nodes, and</span><br><span class="line">         * CONDITION for condition nodes.  It is modified using CAS</span><br><span class="line">         * (or when possible, unconditional volatile writes).</span><br><span class="line">         *&#x2F;</span><br><span class="line">        volatile int waitStatus;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Link to predecessor node that current node&#x2F;thread relies on</span><br><span class="line">         * for checking waitStatus. Assigned during enqueuing, and nulled</span><br><span class="line">         * out (for sake of GC) only upon dequeuing.  Also, upon</span><br><span class="line">         * cancellation of a predecessor, we short-circuit while</span><br><span class="line">         * finding a non-cancelled one, which will always exist</span><br><span class="line">         * because the head node is never cancelled: A node becomes</span><br><span class="line">         * head only as a result of successful acquire. A</span><br><span class="line">         * cancelled thread never succeeds in acquiring, and a thread only</span><br><span class="line">         * cancels itself, not any other node.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        volatile Node prev;&#x2F;&#x2F;前驱节点</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Link to the successor node that the current node&#x2F;thread</span><br><span class="line">         * unparks upon release. Assigned during enqueuing, adjusted</span><br><span class="line">         * when bypassing cancelled predecessors, and nulled out (for</span><br><span class="line">         * sake of GC) when dequeued.  The enq operation does not</span><br><span class="line">         * assign next field of a predecessor until after attachment,</span><br><span class="line">         * so seeing a null next field does not necessarily mean that</span><br><span class="line">         * node is at end of queue. However, if a next field appears</span><br><span class="line">         * to be null, we can scan prev&#39;s from the tail to</span><br><span class="line">         * double-check.  The next field of cancelled nodes is set to</span><br><span class="line">         * point to the node itself instead of null, to make life</span><br><span class="line">         * easier for isOnSyncQueue.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        volatile Node next;&#x2F;&#x2F;后继节点</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * The thread that enqueued this node.  Initialized on</span><br><span class="line">         * construction and nulled out after use.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        volatile Thread thread;&#x2F;&#x2F;当前线程</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Link to next node waiting on condition, or the special</span><br><span class="line">         * value SHARED.  Because condition queues are accessed only</span><br><span class="line">         * when holding in exclusive mode, we just need a simple</span><br><span class="line">         * linked queue to hold nodes while they are waiting on</span><br><span class="line">         * conditions. They are then transferred to the queue to</span><br><span class="line">         * re-acquire. And because conditions can only be exclusive,</span><br><span class="line">         * we save a field by using special value to indicate shared</span><br><span class="line">         * mode.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        Node nextWaiter;&#x2F;&#x2F;存储在condition队列中的后继节点</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Returns true if node is waiting in shared mode.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        &#x2F;&#x2F;是否为共享锁</span><br><span class="line">        final boolean isShared() &#123;</span><br><span class="line">            return nextWaiter &#x3D;&#x3D; SHARED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Returns previous node, or throws NullPointerException if null.</span><br><span class="line">         * Use when predecessor cannot be null.  The null check could</span><br><span class="line">         * be elided, but is present to help the VM.</span><br><span class="line">         *</span><br><span class="line">         * @return the predecessor of this node</span><br><span class="line">         *&#x2F;</span><br><span class="line">        final Node predecessor() throws NullPointerException &#123;</span><br><span class="line">            Node p &#x3D; prev;</span><br><span class="line">            if (p &#x3D;&#x3D; null)</span><br><span class="line">                throw new NullPointerException();</span><br><span class="line">            else</span><br><span class="line">                return p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node() &#123;    &#x2F;&#x2F; Used to establish initial head or SHARED marker</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;将线程组装成一个Node，添加到队列中</span><br><span class="line">        Node(Thread thread, Node mode) &#123;     &#x2F;&#x2F; Used by addWaiter</span><br><span class="line">            this.nextWaiter &#x3D; mode;</span><br><span class="line">            this.thread &#x3D; thread;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;在condition队列中进行使用</span><br><span class="line">        Node(Thread thread, int waitStatus) &#123; &#x2F;&#x2F; Used by Condition</span><br><span class="line">            this.waitStatus &#x3D; waitStatus;</span><br><span class="line">            this.thread &#x3D; thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h1 id="四、ReentrantLock的源码分析"><a href="#四、ReentrantLock的源码分析" class="headerlink" title="四、ReentrantLock的源码分析"></a>四、ReentrantLock的源码分析</h1><h2 id="4-1-画出ReentrantLock时序图"><a href="#4-1-画出ReentrantLock时序图" class="headerlink" title="4.1 画出ReentrantLock时序图"></a>4.1 画出ReentrantLock时序图</h2><p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d6465503eb58f?w=1600&h=680&f=png&s=77986" alt=""></p>
<h2 id="4-2-ReentrantLock-lock"><a href="#4-2-ReentrantLock-lock" class="headerlink" title="4.2 ReentrantLock.lock()"></a>4.2 ReentrantLock.lock()</h2><p>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void lock() &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d64a181e4952f?w=1231&h=226&f=png&s=30412" alt=""><br>根据源码可以看到具体的实现，分别是FairSync（公平）和NonFairSync（非公平）两个类。</p>
<ul>
<li>FairSync：所有线程严格按照FIFO规则获取锁；</li>
<li>NonFairSync：可以存在抢占锁的功能，不管队列上是否存在其他线程等待，新线程都有机会抢占锁。</li>
</ul>
<h2 id="4-3-NonFairSync-lock"><a href="#4-3-NonFairSync-lock" class="headerlink" title="4.3 NonFairSync.lock()"></a>4.3 NonFairSync.lock()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 7316153563782823691L;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Performs lock.  Try immediate barge, backing up to normal</span><br><span class="line">     * acquire on failure.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final void lock() &#123;</span><br><span class="line">        &#x2F;&#x2F;对于非公平锁，一开始就CAS抢占一下</span><br><span class="line">        &#x2F;&#x2F;如果CAS成功了，就表示获得了锁</span><br><span class="line">        if (compareAndSetState(0, 1))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        else&#x2F;&#x2F;如果CAS失败了，调用acquire()方法走竞争逻辑</span><br><span class="line">            acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        return nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-1-CAS的实现原理"><a href="#4-3-1-CAS的实现原理" class="headerlink" title="4.3.1 CAS的实现原理"></a>4.3.1 CAS的实现原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean compareAndSetState(int expect, int update) &#123;</span><br><span class="line">    &#x2F;&#x2F; See below for intrinsics setup to support this</span><br><span class="line">    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> CAS 就是 Unsafe 类中提供的一个原子操作。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/25/172e9942c6022b84?w=1342&h=265&f=png&s=29677" alt=""></p>
<ul>
<li>var1：需要改变的对象；</li>
<li>var2：偏移量(headOffset的值)；</li>
<li>var4：期待的值；</li>
<li>var5：更新后的值。</li>
</ul>
<p><strong>整个方法更新成功返回true，失败则返回false。</strong></p>
<p>state是AQS中的一个属性，对于重入锁（ReentrantLock）而言，它表示一个同步状态。有两层含义：</p>
<ul>
<li>当state=0时，表示无锁状态；</li>
<li><strong>当state&gt;0时，表示线程获得了锁，state+1，重入多少次数，state会递增；而当锁释放的时候，state次数递减，直到state=0其它线程才有资格抢占锁</strong></li>
</ul>
<p>接下来我们来看unsafe.cpp文件中最终执行的源码方法吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(&quot;Unsafe_CompareAndSwapInt&quot;);</span><br><span class="line">  &#x2F;&#x2F;将Java对象解析成JVM的oop</span><br><span class="line">  oop p &#x3D; JNIHandles::resolve(obj);</span><br><span class="line">  &#x2F;&#x2F;根据对象p和地址偏移量找到地址</span><br><span class="line">  jint* addr &#x3D; (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  &#x2F;&#x2F;基于 cas 比较并替换， x 表示需要更新的值，addr 表示 state 在内存中的地址，e 表示预期值</span><br><span class="line">  return (jint)(Atomic::cmpxchg(x, addr, e)) &#x3D;&#x3D; e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>

<h2 id="4-3-2-Unsafe类"><a href="#4-3-2-Unsafe类" class="headerlink" title="4.3.2 Unsafe类"></a>4.3.2 Unsafe类</h2><p>属于sun.misc包，不属于Java标准。但是很多 Java 的基础类库，包<br>括一些被广泛使用的高性能开发库都是基于 Unsafe 类开发的，比如<strong>Netty、<br>Hadoop、Kafka</strong> 等；</p>
<p>Unsafe 可认为是 Java 中留下的后门，提供了一些低层次操作，如直接内存访问、<br>线程的挂起和恢复、CAS、线程同步、内存屏障等。</p>
<h2 id="4-4-AQS-acquire"><a href="#4-4-AQS-acquire" class="headerlink" title="4.4 AQS.acquire()"></a>4.4 AQS.acquire()</h2><p>从下面源码分析来看，如果CAS未能操作成功，说明state已经不等于0了，此时需要执行acquire(1)方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    if (compareAndSetState(0, 1))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    else</span><br><span class="line">        acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看acquire(1)方法的源码吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>尝试使用tryAcquire(arg)获得独占锁，如果成功返回true，失败返回false；</li>
<li>如果tryAcquire失败，则通过addWaiter方法将当前线程封装成Node对象加入到AQS队列尾部；</li>
<li>acquireQueued，将Node作为参数，通过自旋的方式获得锁，下面是对于的源码。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted &#x3D; false;</span><br><span class="line">        for (;;) &#123;&#x2F;&#x2F;自旋方式获得锁</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                failed &#x3D; false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4-1-NonfairSync-tryAcquire"><a href="#4-4-1-NonfairSync-tryAcquire" class="headerlink" title="4.4.1 NonfairSync.tryAcquire()"></a>4.4.1 NonfairSync.tryAcquire()</h2><p>这个方法的作用是尝试获取锁，如果成功返回 true，不成功返回 false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    return nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来看此方法的具体实现：</p>
<ul>
<li>获得当前线程，判断当前锁的状态；</li>
<li>如果state=0表示无锁状态，通过CAS更新state状态的值；</li>
<li>如果当前线程属于重入，则增加重入次数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    int c &#x3D; getState();</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc &#x3D; c + acquires;</span><br><span class="line">        if (nextc &lt; 0) &#x2F;&#x2F; overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-AQS-addWaiter"><a href="#4-5-AQS-addWaiter" class="headerlink" title="4.5 AQS.addWaiter()"></a>4.5 AQS.addWaiter()</h2><p>当tryAcquire()获取锁失败时，则会调用此方法来将当前线程封装成Node对象加入到AQS队列尾部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">    &#x2F;&#x2F; Try the fast path of enq; backup to full enq on failure</span><br><span class="line">    &#x2F;&#x2F;tail表示AQS队列的尾部，默认为null</span><br><span class="line">    Node pred &#x3D; tail;</span><br><span class="line">    if (pred !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;当前线程的prev执行tail</span><br><span class="line">        node.prev &#x3D; pred;</span><br><span class="line">        &#x2F;&#x2F;通过CAS把node加入到队列中，并设置为tail</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            &#x2F;&#x2F;设置成功后，把tail节点的next指向当前node</span><br><span class="line">            pred.next &#x3D; node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;tail为null时，把node加入到同步队列</span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>enq(node)方法通过自旋的方式，把当前节点node加入到同步队列中去，下面看一下enq源码吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        &#x2F;&#x2F;将新的节点prev指向tail</span><br><span class="line">        Node t &#x3D; tail;</span><br><span class="line">        if (t &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; Must initialize</span><br><span class="line">            &#x2F;&#x2F;通过CAS将tail设置为新的节点</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail &#x3D; head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.prev &#x3D; t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                &#x2F;&#x2F;将原来的tail的next节点指向新的节点</span><br><span class="line">                t.next &#x3D; node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172eea9bb11f862b?w=996&h=529&f=png&s=66511" alt=""></p>
<h2 id="4-6-AQS-acquireQueued"><a href="#4-6-AQS-acquireQueued" class="headerlink" title="4.6 AQS.acquireQueued()"></a>4.6 AQS.acquireQueued()</h2><p>通过 addWaiter 方法把线程添加到链表后，会接着把 Node 作为参数传递给<br>acquireQueued 方法，去竞争锁。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172eed6b9d9d8b11?w=790&h=157&f=png&s=15582" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;线程中断标记</span><br><span class="line">        boolean interrupted &#x3D; false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            &#x2F;&#x2F;获得当前节点的prev节点</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            &#x2F;&#x2F;如果是head节点，说明有资格去抢占锁</span><br><span class="line">            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                &#x2F;&#x2F;获取锁成功，线程A已经释放了锁，然后设置head为线程B获得执行权限</span><br><span class="line">                setHead(node);</span><br><span class="line">                &#x2F;&#x2F;把原来的head节点从链表中移除，弱引用</span><br><span class="line">                p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                failed &#x3D; false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;线程A可能还没释放锁，使得线程B在执行tryAcquire时返回false</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                &#x2F;&#x2F;当前线程在等待过程中有没有中断</span><br><span class="line">                interrupted &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F;取消锁的操作</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-6-1-shouldParkAfterFailedAcquire"><a href="#4-6-1-shouldParkAfterFailedAcquire" class="headerlink" title="4.6.1 shouldParkAfterFailedAcquire()"></a>4.6.1 shouldParkAfterFailedAcquire()</h2><p>线程A的锁可能还没释放，那么此时线程B来抢占锁肯定失败，就会调用此方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    &#x2F;&#x2F;前置节点</span><br><span class="line">    int ws &#x3D; pred.waitStatus;</span><br><span class="line">    &#x2F;&#x2F;如果前置节点为 SIGNAL，意味着只需要等待其他前置节点的线程被释放</span><br><span class="line">    if (ws &#x3D;&#x3D; Node.SIGNAL)</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * This node has already set status asking a release</span><br><span class="line">         * to signal it, so it can safely park.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        &#x2F;&#x2F;返回true，可以放心挂起了</span><br><span class="line">        return true;</span><br><span class="line">    &#x2F;&#x2F;ws 大于 0，意味着 prev 节点取消了排队，直接移除这个节点就行</span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">         * indicate retry.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        do &#123;</span><br><span class="line">            &#x2F;&#x2F;相当于: pred&#x3D;pred.prev;node.prev&#x3D;pred;</span><br><span class="line">            node.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);&#x2F;&#x2F;这里采用循环，从双向列表中移除 CANCELLED 的节点</span><br><span class="line">        pred.next &#x3D; node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="line">         * need a signal, but don&#39;t park yet.  Caller will need to</span><br><span class="line">         * retry to make sure it cannot acquire before parking.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        &#x2F;&#x2F;利用 cas 设置 prev 节点的状态为 SIGNAL(-1)</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Node的状态有5种，默认状态是0，以下是其它四种状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该 Node 的结点, 其结点的 waitStatus为CANCELLED，即结束状态，进入该状态后的结点将不会再变化</span><br><span class="line">static final int CANCELLED &#x3D;  1;</span><br><span class="line">&#x2F;&#x2F;只要前置节点释放锁，就会通知标识为 SIGNAL 状态的后续节点的线程</span><br><span class="line">static final int SIGNAL    &#x3D; -1;</span><br><span class="line">&#x2F;&#x2F;表示该线程在condition队列中阻塞</span><br><span class="line">static final int CONDITION &#x3D; -2;</span><br><span class="line">&#x2F;&#x2F;共享模式下，PROPAGATE 状态的线程处于可运行状态</span><br><span class="line">static final int PROPAGATE &#x3D; -3;</span><br></pre></td></tr></table></figure>

<h2 id="4-6-2-parkAndCheckInterrupt"><a href="#4-6-2-parkAndCheckInterrupt" class="headerlink" title="4.6.2 parkAndCheckInterrupt()"></a>4.6.2 parkAndCheckInterrupt()</h2><p>使用LockSupport.park(this)挂起当前线程为WAITING状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    LockSupport.park(this);</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Thread.interrupted，返回当前线程是否被其他线程触发过中断请求，也就是<br>thread.interrupt(); 如果有触发过中断请求，那么这个方法会返回当前的中断标识<br>true，并且对中断标识进行复位标识已经响应过了中断请求。如果返回 true，意味<br>着在 acquire 方法中会执行 selfInterrupt()。</p>
<h2 id="4-6-3-selfInterrupt"><a href="#4-6-3-selfInterrupt" class="headerlink" title="4.6.3 selfInterrupt()"></a>4.6.3 selfInterrupt()</h2><p>当前线程在acquireQueued中被中断过，则需要产生一个中断请求，原因是线程在调用acquireQueued方法的时候不会响应中断请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void selfInterrupt() &#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-6-4-LockSupport"><a href="#4-6-4-LockSupport" class="headerlink" title="4.6.4 LockSupport"></a>4.6.4 LockSupport</h2><p>从Java6开始引用的一个提供了基本的线程同步原语的类，LockSupport本质还是调用了Unsafe中的方法：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172ef8298e418507?w=757&h=172&f=png&s=11808" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(void, Unsafe_Unpark(JNIEnv *env, jobject unsafe, jobject jthread))</span><br><span class="line">  UnsafeWrapper(&quot;Unsafe_Unpark&quot;);</span><br><span class="line">  Parker* p &#x3D; NULL;</span><br><span class="line">  if (jthread !&#x3D; NULL) &#123;</span><br><span class="line">    oop java_thread &#x3D; JNIHandles::resolve_non_null(jthread);</span><br><span class="line">    if (java_thread !&#x3D; NULL) &#123;</span><br><span class="line">      jlong lp &#x3D; java_lang_Thread::park_event(java_thread);</span><br><span class="line">      if (lp !&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; This cast is OK even though the jlong might have been read</span><br><span class="line">        &#x2F;&#x2F; non-atomically on 32bit systems, since there, one word will</span><br><span class="line">        &#x2F;&#x2F; always be zero anyway and the value set is always the same</span><br><span class="line">        p &#x3D; (Parker*)addr_from_java(lp);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; Grab lock if apparently null or using older version of library</span><br><span class="line">        MutexLocker mu(Threads_lock);</span><br><span class="line">        java_thread &#x3D; JNIHandles::resolve_non_null(jthread);</span><br><span class="line">        if (java_thread !&#x3D; NULL) &#123;</span><br><span class="line">          JavaThread* thr &#x3D; java_lang_Thread::thread(java_thread);</span><br><span class="line">          if (thr !&#x3D; NULL) &#123;</span><br><span class="line">            p &#x3D; thr-&gt;parker();</span><br><span class="line">            if (p !&#x3D; NULL) &#123; &#x2F;&#x2F; Bind to Java thread for next time.</span><br><span class="line">              java_lang_Thread::set_park_event(java_thread, addr_to_java(p));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (p !&#x3D; NULL) &#123;</span><br><span class="line">#ifndef USDT2</span><br><span class="line">    HS_DTRACE_PROBE1(hotspot, thread__unpark, p);</span><br><span class="line">#else &#x2F;* USDT2 *&#x2F;</span><br><span class="line">    HOTSPOT_THREAD_UNPARK(</span><br><span class="line">                          (uintptr_t) p);</span><br><span class="line">#endif &#x2F;* USDT2 *&#x2F;</span><br><span class="line">    p-&gt;unpark();</span><br><span class="line">  &#125;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(void, Unsafe_Park(JNIEnv *env, jobject unsafe, jboolean isAbsolute, jlong time))</span><br><span class="line">  UnsafeWrapper(&quot;Unsafe_Park&quot;);</span><br><span class="line">  EventThreadPark event;</span><br><span class="line">#ifndef USDT2</span><br><span class="line">  HS_DTRACE_PROBE3(hotspot, thread__park__begin, thread-&gt;parker(), (int) isAbsolute, time);</span><br><span class="line">#else &#x2F;* USDT2 *&#x2F;</span><br><span class="line">   HOTSPOT_THREAD_PARK_BEGIN(</span><br><span class="line">                             (uintptr_t) thread-&gt;parker(), (int) isAbsolute, time);</span><br><span class="line">#endif &#x2F;* USDT2 *&#x2F;</span><br><span class="line">  JavaThreadParkedState jtps(thread, time !&#x3D; 0);</span><br><span class="line">  thread-&gt;parker()-&gt;park(isAbsolute !&#x3D; 0, time);</span><br><span class="line">#ifndef USDT2</span><br><span class="line">  HS_DTRACE_PROBE1(hotspot, thread__park__end, thread-&gt;parker());</span><br><span class="line">#else &#x2F;* USDT2 *&#x2F;</span><br><span class="line">  HOTSPOT_THREAD_PARK_END(</span><br><span class="line">                          (uintptr_t) thread-&gt;parker());</span><br><span class="line">#endif &#x2F;* USDT2 *&#x2F;</span><br><span class="line">  if (event.should_commit()) &#123;</span><br><span class="line">    oop obj &#x3D; thread-&gt;current_park_blocker();</span><br><span class="line">    event.set_klass((obj !&#x3D; NULL) ? obj-&gt;klass() : NULL);</span><br><span class="line">    event.set_timeout(time);</span><br><span class="line">    event.set_address((obj !&#x3D; NULL) ? (TYPE_ADDRESS) cast_from_oop&lt;uintptr_t&gt;(obj) : 0);</span><br><span class="line">    event.commit();</span><br><span class="line">  &#125;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>

<h2 id="4-7-ReentrantLock-unlock"><a href="#4-7-ReentrantLock-unlock" class="headerlink" title="4.7 ReentrantLock.unlock()"></a>4.7 ReentrantLock.unlock()</h2><p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172ef99ae113acc9?w=776&h=146&f=png&s=11943" alt=""><br>在unlock()方法中，会调用release()方法来释放锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    &#x2F;&#x2F;释放锁成功</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        &#x2F;&#x2F;得到AQS队列中的head节点</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        &#x2F;&#x2F;如果head不为空并且状态不等于0，调用unpark唤醒后续节点</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-7-1-tryRelease"><a href="#4-7-1-tryRelease" class="headerlink" title="4.7.1 tryRelease()"></a>4.7.1 tryRelease()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    &#x2F;&#x2F;state状态减掉传入的参数1</span><br><span class="line">    int c &#x3D; getState() - releases;</span><br><span class="line">    if (Thread.currentThread() !&#x3D; getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    boolean free &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;如果结果为0，将排它锁的Owner设置为null</span><br><span class="line">    &#x2F;&#x2F;解锁的时候减掉 1，同一个锁，在可以重入后，可能会被叠加为 2、3、4 这些值，只有 unlock()的次数与 lock()的次数对应才会将 Owner 线程设置为空，而且也只有这种情况下才会返回 true</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        free &#x3D; true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-7-2-unparkSuccessor"><a href="#4-7-2-unparkSuccessor" class="headerlink" title="4.7.2 unparkSuccessor()"></a>4.7.2 unparkSuccessor()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">       &#x2F;*</span><br><span class="line">        * If status is negative (i.e., possibly needing signal) try</span><br><span class="line">        * to clear in anticipation of signalling.  It is OK if this</span><br><span class="line">        * fails or if status is changed by waiting thread.</span><br><span class="line">        *&#x2F;</span><br><span class="line">       &#x2F;&#x2F;获得head节点的状态</span><br><span class="line">       int ws &#x3D; node.waitStatus;</span><br><span class="line">       if (ws &lt; 0)</span><br><span class="line">           &#x2F;&#x2F;设置head节点的状态为0</span><br><span class="line">           compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">       &#x2F;*</span><br><span class="line">        * Thread to unpark is held in successor, which is normally</span><br><span class="line">        * just the next node.  But if cancelled or apparently null,</span><br><span class="line">        * traverse backwards from tail to find the actual</span><br><span class="line">        * non-cancelled successor.</span><br><span class="line">        *&#x2F;</span><br><span class="line">       &#x2F;&#x2F;得到head节点的下一个节点</span><br><span class="line">       Node s &#x3D; node.next;</span><br><span class="line">       &#x2F;&#x2F;如果下一个节点为 null 或者 status&gt;0 表示 cancelled 状态</span><br><span class="line">       if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">           s &#x3D; null;</span><br><span class="line">           &#x2F;&#x2F;通过从尾部节点开始扫描，找到距离 head 最近的一个waitStatus&lt;&#x3D;0 的节点</span><br><span class="line">           for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)</span><br><span class="line">               if (t.waitStatus &lt;&#x3D; 0)</span><br><span class="line">                   s &#x3D; t;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F;next 节点不为空，直接唤醒这个线程即可</span><br><span class="line">       if (s !&#x3D; null)</span><br><span class="line">           LockSupport.unpark(s.thread);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-7-3-为什么释放锁的时候是从tail节点开始扫描的？"><a href="#4-7-3-为什么释放锁的时候是从tail节点开始扫描的？" class="headerlink" title="4.7.3 为什么释放锁的时候是从tail节点开始扫描的？"></a>4.7.3 为什么释放锁的时候是从tail节点开始扫描的？</h2><p>我们在加锁的enq()方法中，在 cas 操作之后，t.next=node 操作之前。 存在其他线程调用 unlock 方法从 head开始往后遍历，由于 t.next=node 还没执行意味着链表的关系还没有建立完整。就会导致遍历到 t 节点的时候被中断。所以从后往前遍历，一定不会存在这个问题。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172efa6404e1343a?w=893&h=214&f=png&s=21823" alt=""></p>
<h2 id="4-8-原本挂起的线程如何执行呢？"><a href="#4-8-原本挂起的线程如何执行呢？" class="headerlink" title="4.8 原本挂起的线程如何执行呢？"></a>4.8 原本挂起的线程如何执行呢？</h2><p>通过ReentrantLock.unlock()将原本挂起的线程换唤醒后继续执行，原来被挂起的线程是在 <strong>acquireQueued</strong>() 方法中，所以被唤醒以后继续从这个方法开始执行.</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172efb16874cc2df?w=1156&h=230&f=png&s=24416" alt=""></p>
<h1 id="五、公平锁与非公平锁的区别"><a href="#五、公平锁与非公平锁的区别" class="headerlink" title="五、公平锁与非公平锁的区别"></a>五、公平锁与非公平锁的区别</h1><p>锁的公平性是相对于获取锁的顺序而言的，如果是一个公平锁，那么锁的获取顺序<br>就应该符合请求的绝对时间顺序，也就是 <strong>FIFO</strong>。 只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁则不一样，差异点<br>有两个：</p>
<p>1、FairSync.lock()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、NonfairSync.lock()方法</p>
<p>非公平锁在获取锁的时候，会先通过 CAS 进行抢占，而公平锁则不会。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    if (compareAndSetState(0, 1))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    else</span><br><span class="line">        acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/06/26/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B3%E4%BA%8E%E9%94%81%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%8CReentantLock%E7%9A%84%E5%BA%95%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/" data-id="cke9cjzfh000zf5radbdp9eua" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/07/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86SpringBoot%EF%BC%8C%E6%8E%8C%E6%8F%A1%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          微服务核心重新认识SpringBoot，掌握核心特性及设计思想
        
      </div>
    </a>
  
  
    <a href="/2020/06/20/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E7%AF%87%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">JAVA并发编程阶段总结篇，解决死锁问题以及ThreadLocal原理分析</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/25/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E7%9A%84%E7%8E%8B%E8%80%85Apache-Atlas%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84API/">数据治理的王者Apache-Atlas如何构建自己的API</a>
          </li>
        
          <li>
            <a href="/2020/07/26/CountDownLatch%E3%80%81Semaphore%E3%80%81CyclicBarrier%E3%80%81Condition%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">CountDownLatch、Semaphore、CyclicBarrier、Condition源码分析</a>
          </li>
        
          <li>
            <a href="/2020/07/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86SpringBoot%EF%BC%8C%E6%8E%8C%E6%8F%A1%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/">微服务核心重新认识SpringBoot，掌握核心特性及设计思想</a>
          </li>
        
          <li>
            <a href="/2020/06/26/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B3%E4%BA%8E%E9%94%81%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%8CReentantLock%E7%9A%84%E5%BA%95%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/">JAVA并发编程关于锁的那些事，ReentantLock的底层设计深入浅出</a>
          </li>
        
          <li>
            <a href="/2020/06/20/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E7%AF%87%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">JAVA并发编程阶段总结篇，解决死锁问题以及ThreadLocal原理分析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Kevin Shaw<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>