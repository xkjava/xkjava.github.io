<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>架构师内功心法，软件架构设计的七大原则精选案例 | 来一杯咖啡</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一、软件架构设计的七大原则简介 1.1 开闭原则（Open-Closed Principle，OCP）开闭原则是一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。所谓的开闭也是对扩展和修改两个行为的一个原则。强调是用抽象扩展架构，用实现扩展细节。可以提高软件系统的可复用性及可维护性。开闭原则，是面向对象设计中最基础的设计原则。它指导我们如何建立稳定灵活的系统，例如：版本更新，我们尽可能不修改">
<meta property="og:type" content="article">
<meta property="og:title" content="架构师内功心法，软件架构设计的七大原则精选案例">
<meta property="og:url" content="https://xkjava.github.io/2020/02/19/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%E7%B2%BE%E9%80%89%E6%A1%88%E4%BE%8B/index.html">
<meta property="og:site_name" content="来一杯咖啡">
<meta property="og:description" content="一、软件架构设计的七大原则简介 1.1 开闭原则（Open-Closed Principle，OCP）开闭原则是一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。所谓的开闭也是对扩展和修改两个行为的一个原则。强调是用抽象扩展架构，用实现扩展细节。可以提高软件系统的可复用性及可维护性。开闭原则，是面向对象设计中最基础的设计原则。它指导我们如何建立稳定灵活的系统，例如：版本更新，我们尽可能不修改">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/2/17/17052b314ab91c9f?w=1018&h=812&f=png&s=43050">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/2/17/170533730e78204e?w=667&h=742&f=png&s=45090">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/2/18/17058a6cffb9fefd?w=502&h=589&f=png&s=35867">
<meta property="article:published_time" content="2020-02-19T06:43:44.000Z">
<meta property="article:modified_time" content="2020-02-19T06:44:19.171Z">
<meta property="article:author" content="Kevin Shaw">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="Netty">
<meta property="article:tag" content="Kafka...">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2020/2/17/17052b314ab91c9f?w=1018&h=812&f=png&s=43050">
  
    <link rel="alternate" href="/atom.xml" title="来一杯咖啡" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">来一杯咖啡</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">互联网技术无边界，学习与交流</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://xkjava.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-架构师内功心法，软件架构设计的七大原则精选案例" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/19/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%E7%B2%BE%E9%80%89%E6%A1%88%E4%BE%8B/" class="article-date">
  <time datetime="2020-02-19T06:43:44.000Z" itemprop="datePublished">2020-02-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      架构师内功心法，软件架构设计的七大原则精选案例
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、软件架构设计的七大原则简介"><a href="#一、软件架构设计的七大原则简介" class="headerlink" title="一、软件架构设计的七大原则简介"></a>一、软件架构设计的七大原则简介</h1><p><img src="https://user-gold-cdn.xitu.io/2020/2/17/17052b314ab91c9f?w=1018&h=812&f=png&s=43050" alt=""></p>
<h2 id="1-1-开闭原则（Open-Closed-Principle，OCP）"><a href="#1-1-开闭原则（Open-Closed-Principle，OCP）" class="headerlink" title="1.1 开闭原则（Open-Closed Principle，OCP）"></a>1.1 开闭原则（Open-Closed Principle，OCP）</h2><p>开闭原则是一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。所谓的开闭也是对扩展和修改两个行为的一个原则。强调是用抽象扩展架构，用实现扩展细节。可以提高软件系统的可复用性及可维护性。开闭原则，是面向对象设计中最基础的设计原则。它指导我们如何建立稳定灵活的系统，例如：<strong>版本更新，我们尽可能不修改代码，但是可以增加新功能。</strong></p>
<p>在现实生活中也有很多开闭原则的例子，比如，很多互联网公司都实行弹性的工作时间，规定每天工作8小时。意思就是说，对于工作日每天工作8小时这个规定是关闭的，但是你什么时候来，什么时候走是开放的。早来早走，晚来晚走。</p>
<p>实现开闭原则的核心思想就是面向抽象编程，以某新华书店的图书为例，首先创建一个课程接口类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class IBook &#123;</span><br><span class="line">    Integer getId();</span><br><span class="line">    String getName();</span><br><span class="line">    Double getPrice();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来创建一个计算机图书的类ComputerBook：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class ComputerBook implements IBook &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    protected Double price;</span><br><span class="line">    public ComputerBook(Integer id, String name, Double price) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.price &#x3D; price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return this.id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Double getPrice() &#123;</span><br><span class="line">        return this.price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们要给计算机类的图书做活动，价格优惠。如果修改ComputerBook类的getPrice()方法，则会存在一定的风险，可能会影响其它地方的调用结果。我们如何在不修改原有代码的前提下，实现价格优惠这个功能呢？现在，我们再写一个处理优惠逻辑的类，ComputerDiscountBook类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ComputerDiscountBook extends ComputerBook &#123;</span><br><span class="line">    public ComputerDiscountBook(Integer id, String name, Double price) &#123;</span><br><span class="line">        super(id, name, price);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Double getOriginPrice() &#123;</span><br><span class="line">        return super.price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Double getPrice() &#123;</span><br><span class="line">        return super.price * 0.8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/2/17/170533730e78204e?w=667&h=742&f=png&s=45090" alt=""></p>
<h2 id="1-2-依赖倒置原则（Dependence-Inversion-Principle，DIP）"><a href="#1-2-依赖倒置原则（Dependence-Inversion-Principle，DIP）" class="headerlink" title="1.2 依赖倒置原则（Dependence Inversion Principle，DIP）"></a>1.2 依赖倒置原则（Dependence Inversion Principle，DIP）</h2><p>依赖倒置原则是指设计代码结构时，高层模块不应该依赖底层模块，二者都应该依赖其抽象。抽象不应该依赖细节；细节应该依赖抽象。通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，并能够降低修改程序所造成的风险。</p>
<p>还是以课程为例，创建一个类Kevin：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Kevin &#123;</span><br><span class="line"></span><br><span class="line">    public void readComputerBook() &#123;</span><br><span class="line">        System.out.println(&quot;Kevin正在阅读电脑书籍&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void readScienceBook() &#123;</span><br><span class="line">        System.out.println(&quot;Kevin正在阅读科学书籍&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Kevin kevin &#x3D; new Kevin();</span><br><span class="line">        kevin.readComputerBook();</span><br><span class="line">        kevin.readScienceBook();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kevin正在阅读电脑书籍和科学书籍。大家知道电脑书籍的种类很多，现在人工智能AI这么火热，Kevin想学习关于人工智能方面的电脑书籍。这个时候，业务需要扩展，我们需要从底层到调用层一次修改代码来满足业务要求。在Kevin中增加readAIBook（）的方法，在调用层也要追加调用。这样一来，系统发布的时候，实际上不是很稳定。如何优化我们的代码，创建一个书籍的抽象IBook接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IBook &#123;</span><br><span class="line"></span><br><span class="line">    void read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后写ComputerBook类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ComputerBook implements IBook &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void read() &#123;</span><br><span class="line">        System.out.println(&quot;Kevin正在阅读电脑书籍&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再写ScienceBook类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ScienceBook implements IBook &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void read() &#123;</span><br><span class="line">        System.out.printf(&quot;Kevin正在阅读科学书籍&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改Kevin类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Kevin &#123;</span><br><span class="line"></span><br><span class="line">    public void read(IBook book) &#123;</span><br><span class="line">        book.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Kevin kevin &#x3D; new Kevin();</span><br><span class="line">        kevin.read(new ComputerBook());</span><br><span class="line">        kevin.read(new ScienceBook());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看main方法调用，无论Kevin想读哪些类的新书，只需要创建一个类，通过传参的方式告诉Kevin，而不需要修改底层代码来实现。这种实现方式叫做依赖注入。注入的方式有构造器注入和setter注入两种方式。</p>
<p>构造器注入实现方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Kevin &#123;</span><br><span class="line"></span><br><span class="line">    public IBook book;</span><br><span class="line"></span><br><span class="line">    public Kevin(IBook book) &#123;</span><br><span class="line">        this.book &#x3D; book;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void read() &#123;</span><br><span class="line">        book.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Kevin kevin &#x3D; new Kevin(new ComputerBook());</span><br><span class="line">        kevin.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据构造器注入，在调用时，每次都需要创建实例。如果Kevin是全局单例的话，则只能选择Setter方式来注入，继续修改Kevin类的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Kevin &#123;</span><br><span class="line"></span><br><span class="line">    public IBook book;</span><br><span class="line"></span><br><span class="line">    public void setBook(IBook book) &#123;</span><br><span class="line">        this.book &#x3D; book;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void read() &#123;</span><br><span class="line">        book.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Kevin kevin &#x3D; new Kevin();</span><br><span class="line">        kevin.setBook(new ComputerBook());</span><br><span class="line">        kevin.read();</span><br><span class="line"></span><br><span class="line">        kevin.setBook(new ScienceBook());</span><br><span class="line">        kevin.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>以抽象为基准比以细节为基准搭建起来的代码架构要稳定得多，因此拿到需求任务后，要面向接口编程，先设计顶层再琢磨细节来设计代码结构。</strong></p>
<h2 id="1-3-单一职责原则（Simple-Responsibility-Principle，SRP）"><a href="#1-3-单一职责原则（Simple-Responsibility-Principle，SRP）" class="headerlink" title="1.3 单一职责原则（Simple Responsibility Principle，SRP）"></a>1.3 单一职责原则（Simple Responsibility Principle，SRP）</h2><p>单一职责原则是值不要存在多于一个导致类变更的原因。假设我们有一个类要负责两个职责，一旦发生需求变更，修改其中一个职责的逻辑代码，有可能会导致另一个职责的功能发生故障。这样一来，这个类存在两个导致类变更的原因。怎么来解决这个问题呢？就需要给两个职责分别用两个类来实现，进行解耦。后期需求维护相互不受影响。这样的设计，可以降低类的复杂度，提高类的可读性，提高系统的可维护性，降低变更引起的风险。总体来说就是一个<strong>class/interface/mothod</strong>只负责一项职责。<br>这里用在线直播课程的案例来举例，课程有在线直播课和录播课。直播课不能快进和后退，录播课程可以任意的反复观看，功能职责不一样。创建一个Course类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Course &#123;</span><br><span class="line"></span><br><span class="line">    public static final String COURSE_NAME &#x3D; &quot;直播课&quot;;</span><br><span class="line"></span><br><span class="line">    public void study(String courseName) &#123;</span><br><span class="line">        if(COURSE_NAME.equals(courseName)) &#123;</span><br><span class="line">            System.out.println(courseName + &quot;不能快进和快退&quot;);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            System.out.println(courseName + &quot;可以反复观看&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Course course &#x3D; new Course();</span><br><span class="line">        course.study(&quot;直播课&quot;);</span><br><span class="line">        course.study(&quot;录播课&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码看，Course类承担了两种逻辑。现在需要对课程进行加密，那么直播课和录播课的加密逻辑是不一样的，必须要修改代码。而修改代码逻辑必然会相互影响并且容易造成风险。我们对职责进行解耦，分别创建LiveCourse和ReplayCourse两个类：</p>
<p>LiveCourse类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class LiveCourse &#123;</span><br><span class="line"></span><br><span class="line">    public void study(String courseName) &#123;</span><br><span class="line">        System.out.println(courseName + &quot;不能快进和快退&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReplayCourse类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ReplayCourse &#123;</span><br><span class="line"></span><br><span class="line">    public void study(String courseName) &#123;</span><br><span class="line">        System.out.println(courseName + &quot;可以反复观看&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">     LiveCourse liveCourse &#x3D; new LiveCourse();</span><br><span class="line">     liveCourse.study(&quot;直播课&quot;);</span><br><span class="line">     ReplayCourse replayCourse &#x3D; new ReplayCourse();</span><br><span class="line">     replayCourse.study(&quot;录播课&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随着业务的发展，课程也要做权限。没有付费的vip会员可以获取课程基本信息，已经付费的vip会员可以获得视频流，即获得视频观看权限。对于控制课程层面上至少有两个职责。我们可以把展示职责和管理职责分离出来，实现同一个抽象依赖。设计一个顶层接口，创建ICourse接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public interface ICourse &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获得课程信息</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    String getCourseName();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获得视频流</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    byte[] getCourseVideo();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 学习课程</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void studyCourse();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 退款</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void refundCourse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以把这个接口拆成两个接口，创建一个接口ICourseInfo和ICourseManager：</p>
<p>接口ICourseInfo：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface ICourseInfo &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获得课程信息</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    String getCourseName();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获得视频流</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    byte[] getCourseVideo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口ICourseManager：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface ICourseManager &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 学习课程</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void studyCourse();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 退款</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void refundCourse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来看下方法层面的单一职责的代码设计。有时候我们为了偷懒，通常会把方法写成下面这样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void mofifyUserInfo(String userName, String address) &#123;</span><br><span class="line">    userName &#x3D; &quot;Kevin&quot;;</span><br><span class="line">    address &#x3D; &quot;Beijing&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可能写成这样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void modifyUserInfo(String userName, String... fields) &#123;</span><br><span class="line">    userName &#x3D; &quot;Kevin&quot;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void modifyUserInfo(String userName, String address, boolean bool) &#123;</span><br><span class="line">    if(bool) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    userName &#x3D; &quot;Kevin&quot;;</span><br><span class="line">    address &#x3D; &quot;Beijing&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然上面的modifyUserInfo()方法中承担了多个职责，既可以修改userName，也可以修改address，甚至更多的值，明显不符合单一职责。这样我们需要对代码进行修改，把这个方法拆分成两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void modifyUserName(String userName) &#123;</span><br><span class="line">    userName &#x3D; &quot;Kevin&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void modifyAddress(String address) &#123;</span><br><span class="line">    address &#x3D; &quot;Beijing&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改之后的代码看起来简单，且维护起来更加容易。但是，<strong>我们在实际开发项目过程中，项目直接会相互依赖，组合、聚和这些关系，还有项目的规模，周期，技术人员的水平，对进度的把控，很多类都不符合单一职责。但是，我们在编码的过程中尽量做到单一职责，这样对我们项目的后期维护是有很大的帮助的。</strong></p>
<h2 id="1-4-接口隔离原则-（Interface-Segregation-Principle，ISP）"><a href="#1-4-接口隔离原则-（Interface-Segregation-Principle，ISP）" class="headerlink" title="1.4 接口隔离原则 （Interface Segregation Principle，ISP）"></a>1.4 接口隔离原则 （Interface Segregation Principle，ISP）</h2><p>接口隔离原则是指用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口。这个原则指导我们在设计接口的时候应该注意以下几点：</p>
<p>1、一个类对一类的依赖应该建立在最小的接口之上；</p>
<p>2、建立单一接口，不要建立庞大臃肿的接口；</p>
<p>3、尽量细化接口，接口中的方法尽量少（不是越少越好，要适度）。</p>
<p>接口隔离原则符合我们常说的<strong>高内聚低耦合</strong>的设计思想，从而使得类具有很好的可读性、可扩展性以及可维护性。在设计接口的时候，要多花时间去思考，要考虑业务模型，包括以后有可能发生变更的地方还要做一些预判。所以对于抽象，对于业务模型的理解是非常重要的。下面举例来看一个动物行为的抽象接口：</p>
<p>IAnimal接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface IAnimal &#123;</span><br><span class="line">    void eat();</span><br><span class="line">    void fly();</span><br><span class="line">    void swim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Bird 类实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Bird implements IAnimal &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void fly() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void swim() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dog 类实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Dog implements IAnimal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void fly() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void swim() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，Bird 的 swim()方法可能只能空着，Dog 的fly()方法显然不可能的。这时候，我们针对不同动物行为来设计不同的接口，分别设计 IEatAnimal，IFlyAnimal 和ISwimAnimal 接口，来看代码：</p>
<p>IEatAnimal接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IEatAnimal &#123;</span><br><span class="line">    void eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IFlyAnimal接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IFlyAnimal &#123;</span><br><span class="line">    void fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ISwimAnimal接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ISwimAnimal &#123;</span><br><span class="line">    void swim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dog 只实现 IEatAnimal 和 ISwimAnimal 接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Dog implements IEatAnimal, ISwimAnimal &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void swim() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-迪米特法则（Law-of-Demeter-LoD）"><a href="#1-5-迪米特法则（Law-of-Demeter-LoD）" class="headerlink" title="1.5 迪米特法则（Law of Demeter, LoD）"></a>1.5 迪米特法则（Law of Demeter, LoD）</h2><p>迪米特法则是指一个对象应该对其他对象保持最少的了解，又叫最少知道原则（Least Knowledge Principle， LKP），尽量降低类与类之间的耦合。<strong>主要强调只和朋友说话，不和陌生人说话。出现在成员变量、方法输入、输出参数中的类都可以称之为成员朋友类，而出现在方法体内部的类不属于朋友类。</strong></p>
<p>现在来设计一个权限系统，老板需要查看目前发布到线上的课程数量。这个老板找到项目负责人去进行统计，项目负责人再把统计结果告诉老板。来看一下代码示例：</p>
<p>Course类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class Course &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TeamLeader类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class TeamLeader &#123;</span><br><span class="line">    public void checkNumberOfCourses(List&lt;Course&gt; courseList)&#123;</span><br><span class="line">        System.out.println(&quot;目前已发布的课程数量是：&quot;+courseList.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Boss类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Boss &#123;</span><br><span class="line"></span><br><span class="line">    public void commandCheckNumber(TeamLeader teamLeader)&#123;</span><br><span class="line">        &#x2F;&#x2F;模拟 Boss 一页一页往下翻页，TeamLeader 实时统计</span><br><span class="line">        List&lt;Course&gt; courseList &#x3D; new ArrayList&lt;Course&gt;();</span><br><span class="line">        for (int i&#x3D; 0; i &lt; 10 ;i ++)&#123;</span><br><span class="line">            courseList.add(new Course());</span><br><span class="line">        &#125;</span><br><span class="line">        teamLeader.checkNumberOfCourses(courseList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Boss boss &#x3D; new Boss();</span><br><span class="line">        TeamLeader teamLeader &#x3D; new TeamLeader();</span><br><span class="line">        boss.commandCheckNumber(teamLeader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码根据迪米特原则，老板Boss只想要结果，不需要跟Course产生直接交流。而课程负责人统计要引用Course对象。Boss和Course并不是朋友，我们需要修改代码：</p>
<p>TeamLeader类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class TeamLeader &#123;</span><br><span class="line"></span><br><span class="line">    public void checkNumberOfCourses()&#123;</span><br><span class="line">        List&lt;Course&gt; courseList &#x3D; new ArrayList&lt;Course&gt;();</span><br><span class="line">        for(int i &#x3D; 0 ;i &lt; 10;i++)&#123;</span><br><span class="line">            courseList.add(new Course());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;目前已发布的课程数量是：&quot;+courseList.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Boss类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Boss &#123;</span><br><span class="line"></span><br><span class="line">    public void commandCheckNumber(TeamLeader teamLeader)&#123;</span><br><span class="line">        teamLeader.checkNumberOfCourses();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Boss boss &#x3D; new Boss();</span><br><span class="line">        TeamLeader teamLeader &#x3D; new TeamLeader();</span><br><span class="line">        boss.commandCheckNumber(teamLeader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>得到的：学习软件设计原则，千万不能形成强迫症。碰到业务复杂的场景，我们需要随机应变。</strong></p>
<h2 id="1-6-里氏替换原则（Liskov-Substitution-Principle，LSP）"><a href="#1-6-里氏替换原则（Liskov-Substitution-Principle，LSP）" class="headerlink" title="1.6 里氏替换原则（Liskov Substitution Principle，LSP）"></a>1.6 里氏替换原则（Liskov Substitution Principle，LSP）</h2><p>里氏替换原则是指如果对每一个类型T1的对象o1,都有类型为T2的对象o2,使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。</p>
<p>定义看上去还是比较抽象，可以理解为<strong>如果适应一个父类的话，那一定是适用于子类，所有的引用父类的地方必须能透明的使用子类的对象，子类对象能够替换父类对象，而程序逻辑不变。</strong> 总结一下：</p>
<p>引申含义：子类可以扩展父类的功能，但不能改变父类原有的功能。</p>
<p>1、子类可以实现父类的抽象方法，但不能覆盖父类的抽象方法；</p>
<p>2、子类中可以增加自己特有的方法；</p>
<p>3、当子类的方法覆盖父类的方法时，方法的前置条件（即方法的输入/入参）要比父类方法的输入参数更宽松；</p>
<p>4、当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的输出/返回值）要比父类更严格或者相等。</p>
<p>我们在开闭原则的代码案例中在获取折后时覆盖了父类的getPrice()方法，增加了一个获取优惠价格后的方法getOriginPrice(),显然就违背了里氏替换原则。接下来我们不覆盖getPrice()方法，增加getDiscountBook()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ComputerDiscountBook extends ComputerBook &#123;</span><br><span class="line">    public ComputerDiscountBook(Integer id, String name, Double price) &#123;</span><br><span class="line">        super(id, name, price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Double getDiscountBook() &#123;</span><br><span class="line">        return super.getPrice() * 0.8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用里氏替换原则有以下几个优点：</p>
<p>1、约束继承泛滥，开闭原则的一种体现；</p>
<p>2、加强程序的健壮性，同时变更时可以做到很好的兼容性，提高程序的维护性、扩展性。降低需求变更时引入的风险。</p>
<p>现在用正方形、矩形和四边形来说明里氏替换原则，我们都知道正方形是一个特殊的长方形，创建一个长方形父类Rectangle：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Rectangle &#123;</span><br><span class="line"></span><br><span class="line">    private long width;</span><br><span class="line"></span><br><span class="line">    private long height;</span><br><span class="line"></span><br><span class="line">    public long getWidth() &#123;</span><br><span class="line">        return width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setWidth(long width) &#123;</span><br><span class="line">        this.width &#x3D; width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getHeight() &#123;</span><br><span class="line">        return height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHeight(long height) &#123;</span><br><span class="line">        this.height &#x3D; height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建正方形Square类继承Rectangle长方形类，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Square extends Rectangle &#123;</span><br><span class="line"></span><br><span class="line">    private long length;</span><br><span class="line">    public long getLength() &#123;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setLength(long length) &#123;</span><br><span class="line">        this.length &#x3D; length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public long getWidth() &#123;</span><br><span class="line">        return getLength();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public long getHeight() &#123;</span><br><span class="line">        return getLength();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void setHeight(long height) &#123;</span><br><span class="line">        setLength(height);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void setWidth(long width) &#123;</span><br><span class="line">        setLength(width);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在测试类中创建 resize()方法，根据逻辑长方形的宽应该大于等于高，我们让高一直自增，知道高等于宽变成正方形：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void resize(Rectangle rectangle)&#123;</span><br><span class="line">        while (rectangle.getWidth() &gt;&#x3D; rectangle.getHeight())&#123;</span><br><span class="line">            rectangle.setHeight(rectangle.getHeight() + 1);</span><br><span class="line">            System.out.println(&quot;width:&quot;+rectangle.getWidth() + &quot;,height:&quot;+rectangle.getHeight());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;resize 方法结束&quot; +</span><br><span class="line">                &quot;\nwidth:&quot;+rectangle.getWidth() + &quot;,height:&quot;+rectangle.getHeight());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">        Rectangle rectangle &#x3D; new Rectangle();</span><br><span class="line">        rectangle.setWidth(20);</span><br><span class="line">        rectangle.setHeight(10);</span><br><span class="line">        resize(rectangle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/18/17058a6cffb9fefd?w=502&h=589&f=png&s=35867" alt=""></p>
<p>修改代码把长方形Rectangle替换成它的子类正方形Square：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Square square &#x3D; new Square();</span><br><span class="line">        square.setLength(10);</span><br><span class="line">        resize(square);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候我们运行的时候就出现了死循环，违背了里氏替换原则，将父类替换为子类后，程序运行结果没有达到预期。因此，我们的代码设计是存在一定风险的。里氏替换原则只存在父类与子类之间，约束继承泛滥。再来创建一个基于长方形与正方形共同抽象的四边形Quadrangle接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Quadrangle &#123;</span><br><span class="line">    </span><br><span class="line">    long getWidth();</span><br><span class="line">    </span><br><span class="line">    long getHeight();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改长方形 Rectangle 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Rectangle implements Quadrangle &#123;</span><br><span class="line"></span><br><span class="line">    private long height;</span><br><span class="line">    private long width;</span><br><span class="line">    @Override</span><br><span class="line">    public long getWidth() &#123;</span><br><span class="line">        return width;</span><br><span class="line">    &#125;</span><br><span class="line">    public long getHeight() &#123;</span><br><span class="line">        return height;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setHeight(long height) &#123;</span><br><span class="line">        this.height &#x3D; height;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setWidth(long width) &#123;</span><br><span class="line">        this.width &#x3D; width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改正方形类 Square 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Square implements Quadrangle &#123;</span><br><span class="line"></span><br><span class="line">    private long length;</span><br><span class="line">    public long getLength() &#123;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setLength(long length) &#123;</span><br><span class="line">        this.length &#x3D; length;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public long getWidth() &#123;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public long getHeight() &#123;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，如果我们把 resize()方法的参数换成四边形 Quadrangle类，方法内部就会报错。因为正方形 Square 已经没有了 setWidth()和 setHeight()方法了。因此，为了约束继承泛滥，resize()的方法参数只能用 Rectangle 长方形。</p>
<h2 id="1-7-合成复用原则-（Composite-Aggregate-Reuse-Principle，CARP）"><a href="#1-7-合成复用原则-（Composite-Aggregate-Reuse-Principle，CARP）" class="headerlink" title="1.7 合成复用原则 （Composite/Aggregate Reuse Principle，CARP）"></a>1.7 合成复用原则 （Composite/Aggregate Reuse Principle，CARP）</h2><p>合成复用原则是指尽量使用对象组合/聚和，而不是用继承关系达到对象复用的目的。这样可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其它类造成的影响也较少。</p>
<p><strong>继承又叫做白箱复用，相当于把所有的实现细节暴露给子类。组合/聚和也成为黑箱复用，对类以外的对象是无法获取到实现细节的。</strong> 需要根据具体的业务场景来设计代码，其实也要遵循OOP模型。这里以数据库操作为例，先创建DBConnection类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class DBConnection &#123;</span><br><span class="line"></span><br><span class="line">    public String getConnection()&#123;</span><br><span class="line">        return &quot;MySQL 数据库连接&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 ProductDao 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ProductDao &#123;</span><br><span class="line"></span><br><span class="line">    private DBConnection dbConnection;</span><br><span class="line">    public void setDbConnection(DBConnection dbConnection) &#123;</span><br><span class="line">        this.dbConnection &#x3D; dbConnection;</span><br><span class="line">    &#125;</span><br><span class="line">    public void addProduct()&#123;</span><br><span class="line">        String conn &#x3D; dbConnection.getConnection();</span><br><span class="line">        System.out.println(&quot;使用&quot;+conn+&quot;增加产品&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是非常典型的合成复用原则的应用场景。但是DBConnection还不是一种抽象，不便于系统扩展。目前系统只支持Mysql数据库连接，假设业务发生变化，数据库操作层要支持Oralce数据库。当然，可以在DBConnection中增加对Oracle数据库支持的方法。但是违背了开闭原则。我们可以不修改Dao的代码，将DBConnection改为abstract，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class DBConnection &#123;</span><br><span class="line">    public abstract String getConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，将 MySQL 的逻辑抽离：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MySqlConnection extends DBConnection &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getConnection() &#123;</span><br><span class="line">        return &quot;MySQL 数据库连接&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再创建 Oracle 支持的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class OracleConnection extends DBConnection &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getConnection() &#123;</span><br><span class="line">        return &quot;Oracle 数据库连接&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、-设计原则总结"><a href="#二、-设计原则总结" class="headerlink" title="二、 设计原则总结"></a>二、 设计原则总结</h1><p>学习设计原则，学习设计模式的基础。在实际开发过程中，并不是所有的代码都要遵循设计原则。我们需要考虑人力、时间、成本、质量，不是刻意的追求完美，要在适当的场景下遵循设计原则，体现的是一种平衡的取舍，帮助我们设计出更加优美的代码结构。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/02/19/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%E7%B2%BE%E9%80%89%E6%A1%88%E4%BE%8B/" data-id="ck7sflsea000f1ara8yc4h1s0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/02/21/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E7%BB%8F%E5%85%B8%E6%A1%86%E6%9E%B6%E9%83%BD%E5%9C%A8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          架构师内功心法，经典框架都在用的工厂模式详解
        
      </div>
    </a>
  
  
    <a href="/2020/02/17/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AD%A6%E4%B9%A0JVM%EF%BC%8C%E7%BB%88%E7%BB%93%E7%AF%87%EF%BC%88%E5%85%AD%EF%BC%89/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">如何优雅的学习JVM，终结篇（六）</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/03/11/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E8%BF%9E%E6%8E%A5%E4%B8%A4%E4%B8%AA%E7%A9%BA%E9%97%B4%E7%BB%B4%E5%BA%A6%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，连接两个空间维度的桥接模式详解</a>
          </li>
        
          <li>
            <a href="/2020/03/10/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E4%BD%9C%E4%B8%BA%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%9A%84%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，作为树形结构系统架构的组合模式详解</a>
          </li>
        
          <li>
            <a href="/2020/03/08/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1%E6%9D%A5%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，使用共享对象来提高性能的享元模式详解</a>
          </li>
        
          <li>
            <a href="/2020/03/08/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%A4%96%E7%95%8C%E8%AE%BF%E9%97%AE%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%E5%94%AF%E4%B8%80%E9%80%9A%E9%81%93%E7%9A%84%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，外界访问系统内部唯一通道的门面模式详解</a>
          </li>
        
          <li>
            <a href="/2020/03/01/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E6%B3%A8%E9%87%8D%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F%E7%9A%84%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，注重方法调用顺序的建造者模式详解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Kevin Shaw<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>