<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>架构师内功心法，经典框架都在用的工厂模式详解 | 来一杯咖啡</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一、经典框架都在用设计模式解决问题Spring就是一个把设计模式用的淋漓尽致的经典框架，其实从类的名称就能够看出来，我们来一一列举一下：  特别需要说明的是，设计模式从来都不是单个设计模式独立使用的。 在通常情况下，经常是多个设计模式混合使用，你中有我，我中有你。所有的设计模式讲解都会围绕Spring的IOC、AOP、JDBC、MVC来进行展开。设计模式根据设计类型进行分类如下：  二、工厂模式详">
<meta property="og:type" content="article">
<meta property="og:title" content="架构师内功心法，经典框架都在用的工厂模式详解">
<meta property="og:url" content="https://xkjava.github.io/2020/02/21/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E7%BB%8F%E5%85%B8%E6%A1%86%E6%9E%B6%E9%83%BD%E5%9C%A8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="来一杯咖啡">
<meta property="og:description" content="一、经典框架都在用设计模式解决问题Spring就是一个把设计模式用的淋漓尽致的经典框架，其实从类的名称就能够看出来，我们来一一列举一下：  特别需要说明的是，设计模式从来都不是单个设计模式独立使用的。 在通常情况下，经常是多个设计模式混合使用，你中有我，我中有你。所有的设计模式讲解都会围绕Spring的IOC、AOP、JDBC、MVC来进行展开。设计模式根据设计类型进行分类如下：  二、工厂模式详">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/2/19/1705c4fe88d41ff7?w=946&h=476&f=png&s=21565">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/2/19/1705c5a0b678e0f8?w=721&h=433&f=png&s=47142">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/2/19/1705c649df25e7dd?w=1000&h=562&f=png&s=915663">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/2/19/1705c65b429988c0?w=900&h=600&f=png&s=699085">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/2/19/1705c66e7a3c0afb?w=475&h=261&f=png&s=155298">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/2/19/1705c6777f3ecf54?w=640&h=345&f=png&s=503072">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/2/20/17061184a4c31ec2?w=1465&h=535&f=png&s=108016">
<meta property="article:published_time" content="2020-02-21T07:55:01.000Z">
<meta property="article:modified_time" content="2020-02-21T07:56:42.333Z">
<meta property="article:author" content="Kevin Shaw">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="Netty">
<meta property="article:tag" content="Kafka...">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2020/2/19/1705c4fe88d41ff7?w=946&h=476&f=png&s=21565">
  
    <link rel="alternate" href="/atom.xml" title="来一杯咖啡" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">来一杯咖啡</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">互联网技术无边界，学习与交流</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://xkjava.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-架构师内功心法，经典框架都在用的工厂模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/21/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E7%BB%8F%E5%85%B8%E6%A1%86%E6%9E%B6%E9%83%BD%E5%9C%A8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-02-21T07:55:01.000Z" itemprop="datePublished">2020-02-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      架构师内功心法，经典框架都在用的工厂模式详解
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、经典框架都在用设计模式解决问题"><a href="#一、经典框架都在用设计模式解决问题" class="headerlink" title="一、经典框架都在用设计模式解决问题"></a>一、经典框架都在用设计模式解决问题</h1><p>Spring就是一个把设计模式用的淋漓尽致的经典框架，其实从类的名称就能够看出来，我们来一一列举一下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/19/1705c4fe88d41ff7?w=946&h=476&f=png&s=21565" alt=""></p>
<p><strong>特别需要说明的是，设计模式从来都不是单个设计模式独立使用的。</strong> 在通常情况下，经常是多个设计模式混合使用，<strong>你中有我，我中有你</strong>。所有的设计模式讲解都会围绕Spring的IOC、AOP、JDBC、MVC来进行展开。设计模式根据设计类型进行分类如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/19/1705c5a0b678e0f8?w=721&h=433&f=png&s=47142" alt=""></p>
<h1 id="二、工厂模式详解"><a href="#二、工厂模式详解" class="headerlink" title="二、工厂模式详解"></a>二、工厂模式详解</h1><h2 id="2-1-工厂模式的由来"><a href="#2-1-工厂模式的由来" class="headerlink" title="2.1 工厂模式的由来"></a>2.1 工厂模式的由来</h2><p>在我们的现实生活当中，原始社会自给自足（没有工厂）、农耕社会的小作坊（简单工厂，民间酒坊）、工业革命流水线（工厂方法，自产自销）、现代产业链工厂（抽象工厂，富士康）</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/19/1705c649df25e7dd?w=1000&h=562&f=png&s=915663" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/2/19/1705c65b429988c0?w=900&h=600&f=png&s=699085" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/2/19/1705c66e7a3c0afb?w=475&h=261&f=png&s=155298" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/2/19/1705c6777f3ecf54?w=640&h=345&f=png&s=503072" alt=""></p>
<p>从现实生活联想到我们项目中的代码同样也是由简而繁一步一步迭代而来的，但是对于调用者确是越来越简单化。</p>
<h2 id="2-2-简单工厂模式（Simple-Factory-Pattern）"><a href="#2-2-简单工厂模式（Simple-Factory-Pattern）" class="headerlink" title="2.2 简单工厂模式（Simple Factory Pattern）"></a>2.2 简单工厂模式（Simple Factory Pattern）</h2><p>简单工厂模式是指由一个工厂对象决定创建出哪一种产品的实例，但它不属于GOF，23设计模式。</p>
<p>参考资料维基百科地址：<a href="https://en.wikipedia.org/wiki/Design_Patterns#Patterns_by_Type" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Design_Patterns#Patterns_by_Type</a></p>
<p>简单工厂模式适用于工厂类负责创建的对象较少的场景，且客户端只需要传入工厂类的参数，对于如何创建对象的逻辑不需要关系。</p>
<p>接下来我们来举例，以高中学校课程为例。语文、数学、英语等多门学科。我们可以定义一个课程标准ICourse接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface ICourse &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 学习课程</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void study();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个语文课的实现ChineseCourse类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ChineseCourse implements ICourse &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void study() &#123;</span><br><span class="line">        System.out.println(&quot;学习语文课&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ICourse course &#x3D; new ChineseCourse();</span><br><span class="line">        course.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看上面的main方法中，应用层的代码需要依赖ChineseCourse，如果业务扩展，会继续增加MathCourse甚至更多，这样的话客户端的依赖会越来越臃肿的。所以我们需要对创建代码的细节进行隐藏，我们使用简单工厂模式对代码进行优化。先添加MathCourse类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MathCourse implements ICourse &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void study() &#123;</span><br><span class="line">        System.out.println(&quot;学习数学课&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建CourseFactory工厂类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class CourseFactory &#123;</span><br><span class="line">    public ICourse create(String name) &#123;</span><br><span class="line">        if(&quot;chinese&quot;.equals(name)) &#123;</span><br><span class="line">            return new ChineseCourse();</span><br><span class="line">        &#125;else if(&quot;math&quot;.equals(name)) &#123;</span><br><span class="line">            return new MathCourse();</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mian方法调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">        CourseFactory courseFactory &#x3D; new CourseFactory();</span><br><span class="line">        courseFactory.create(&quot;chinese&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用是简单了，但是我们的业务继续扩展，需要增加英文课，那么工厂中的create()方法要根据增加的业务每次都修改代码逻辑，不符合开闭原则。因此，我们还需要对简单工厂进行优化，利用反射技术：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class CourseFactory &#123;</span><br><span class="line"></span><br><span class="line">    public ICourse create(String className) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if(!(null &#x3D;&#x3D; className || &quot;&quot;.equals(className))) &#123;</span><br><span class="line">                    return (ICourse) Class.forName(className).newInstance();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InstantiationException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CourseFactory courseFactory &#x3D; new CourseFactory();</span><br><span class="line">        ICourse course &#x3D; courseFactory.create(&quot;com.sfp.ChineseCourse&quot;);</span><br><span class="line">        course.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化之后，课程不断增加不需要修改CourseFactory中的代码了。但是，方法参数是字符串，可控性有待提高，而且还需进行强制转换。再次修改代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class CourseFactory &#123;</span><br><span class="line"></span><br><span class="line">    public ICourse create(Class&lt;? extends ICourse&gt; clazz) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if(null !&#x3D; clazz) &#123;</span><br><span class="line">                return clazz.newInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CourseFactory courseFactory &#x3D; new CourseFactory();</span><br><span class="line">        ICourse course &#x3D; courseFactory.create(ChineseCourse.class);</span><br><span class="line">        course.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单工厂模式的例子无处不在，现在我们来看JDK当中的类使用简单工厂模式的例子，例如Calendar类，其中Calendar.getInstance()方法，我们查看源码具体的实现步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">private static Calendar createCalendar(TimeZone zone,</span><br><span class="line">                                           Locale aLocale)</span><br><span class="line">    &#123;</span><br><span class="line">        CalendarProvider provider &#x3D;</span><br><span class="line">            LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)</span><br><span class="line">                                 .getCalendarProvider();</span><br><span class="line">        if (provider !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                return provider.getInstance(zone, aLocale);</span><br><span class="line">            &#125; catch (IllegalArgumentException iae) &#123;</span><br><span class="line">                &#x2F;&#x2F; fall back to the default instantiation</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Calendar cal &#x3D; null;</span><br><span class="line"></span><br><span class="line">        if (aLocale.hasExtensions()) &#123;</span><br><span class="line">            String caltype &#x3D; aLocale.getUnicodeLocaleType(&quot;ca&quot;);</span><br><span class="line">            if (caltype !&#x3D; null) &#123;</span><br><span class="line">                switch (caltype) &#123;</span><br><span class="line">                case &quot;buddhist&quot;:</span><br><span class="line">                cal &#x3D; new BuddhistCalendar(zone, aLocale);</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;japanese&quot;:</span><br><span class="line">                    cal &#x3D; new JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;gregory&quot;:</span><br><span class="line">                    cal &#x3D; new GregorianCalendar(zone, aLocale);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (cal &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; If no known calendar type is explicitly specified,</span><br><span class="line">            &#x2F;&#x2F; perform the traditional way to create a Calendar:</span><br><span class="line">            &#x2F;&#x2F; create a BuddhistCalendar for th_TH locale,</span><br><span class="line">            &#x2F;&#x2F; a JapaneseImperialCalendar for ja_JP_JP locale, or</span><br><span class="line">            &#x2F;&#x2F; a GregorianCalendar for any other locales.</span><br><span class="line">            &#x2F;&#x2F; NOTE: The language, country and variant strings are interned.</span><br><span class="line">            if (aLocale.getLanguage() &#x3D;&#x3D; &quot;th&quot; &amp;&amp; aLocale.getCountry() &#x3D;&#x3D; &quot;TH&quot;) &#123;</span><br><span class="line">                cal &#x3D; new BuddhistCalendar(zone, aLocale);</span><br><span class="line">            &#125; else if (aLocale.getVariant() &#x3D;&#x3D; &quot;JP&quot; &amp;&amp; aLocale.getLanguage() &#x3D;&#x3D; &quot;ja&quot;</span><br><span class="line">                       &amp;&amp; aLocale.getCountry() &#x3D;&#x3D; &quot;JP&quot;) &#123;</span><br><span class="line">                cal &#x3D; new JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cal &#x3D; new GregorianCalendar(zone, aLocale);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cal;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>还有一个大家经常使用的logback，我们可以看到LoggerFactory中有多个重载的方法getLogger():</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Logger getLogger(String name) &#123;</span><br><span class="line">    ILoggerFactory iLoggerFactory &#x3D; getILoggerFactory();</span><br><span class="line">    return iLoggerFactory.getLogger(name);</span><br><span class="line">&#125;</span><br><span class="line">public static Logger getLogger(Class clazz) &#123;</span><br><span class="line">    return getLogger(clazz.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单工厂的缺点：工厂的职责相对过重，不易于扩展过于复杂的代码结构。</p>
<h2 id="2-3-工厂方法模式（Factory-Method-Pattern）"><a href="#2-3-工厂方法模式（Factory-Method-Pattern）" class="headerlink" title="2.3 工厂方法模式（Factory Method Pattern）"></a>2.3 工厂方法模式（Factory Method Pattern）</h2><p>工厂方法模式是指<strong>定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。</strong> 在工厂方法模式中只关心所需产品对应的工厂，无心关注创建细节，而加入新的产品符合开闭原则。</p>
<p>工厂方式模式主要解决产品扩展的问题，根据单一职责原则将职能进行拆分，专人干专事。语文课由语文工厂创建，数据课由数学工厂创建，对工厂本身做一个抽象。示例代码如下：</p>
<p>创建ICourseFactory接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface ICourseFacotry &#123;</span><br><span class="line"></span><br><span class="line">    ICourse create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再分别创建子工厂，ChineseCourseFactory类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ChineseCourseFactory implements ICourseFacotry &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ICourse create() &#123;</span><br><span class="line">        return new ChineseCourse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MathCourseFactory类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MathCourseFactory implements ICourseFacotry &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ICourse create() &#123;</span><br><span class="line">        return new MathCourse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">     ICourseFacotry chineseCourseFactory &#x3D; new ChineseCourseFactory();</span><br><span class="line">     ICourse chineseCourse &#x3D; chineseCourseFactory.create();</span><br><span class="line">     chineseCourse.study();</span><br><span class="line">     </span><br><span class="line">     ICourseFacotry mathCourseFactory &#x3D; new MathCourseFactory();</span><br><span class="line">     ICourse mathCourse &#x3D; mathCourseFactory.create();</span><br><span class="line">     mathCourse.study();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-抽象工厂模式（Abstract-Factory-Pattern）"><a href="#2-4-抽象工厂模式（Abstract-Factory-Pattern）" class="headerlink" title="2.4 抽象工厂模式（Abstract Factory Pattern）"></a>2.4 抽象工厂模式（Abstract Factory Pattern）</h2><p>抽象工厂模式是指<strong>提供一个创建一系列相关或相互依赖对象的接口，无需指定它们具体的类。</strong> 客户端（应用层）不依赖于产品实例如何被创建、实现等细节，强调的是一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复的代码。需要提供一个产品库的类，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</p>
<p>我们还是以课程的例子为例，现在是新冠状病毒疫情的时期，高中学生只能在家利用互联网进行在线直播上课，每个课程不仅要提供课程的录播视频，而且还要提供老师的课堂笔记。相当于现在的业务变更为同一个课程不单纯是课程信息，同时要包括录播视频、课堂笔记等才是一个完整的课程。在产品等级中增加两个产品接口Ivideo录播视频和INote课堂笔记。</p>
<p>Ivideo接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IVideo &#123;</span><br><span class="line"></span><br><span class="line">    void record();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>INote接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface INote &#123;</span><br><span class="line"></span><br><span class="line">    void edit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建抽象工厂类CourseFactory类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface CourseFactory &#123;</span><br><span class="line"></span><br><span class="line">    IVideo createVideo();</span><br><span class="line"></span><br><span class="line">    INote createNote();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建语文课产品族，语文课视频的ChineseVideo类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ChineseVideo implements IVideo &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void record() &#123;</span><br><span class="line">        System.out.println(&quot;录制语文课视频！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建语文课课堂笔记的ChineseNote类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ChineseNote implements INote &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void edit() &#123;</span><br><span class="line">        System.out.println(&quot;编写语文课笔记！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建语文课产品族的具体工厂类ChineseCourseFactory：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ChineseCourseFactory implements CourseFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public IVideo createVideo() &#123;</span><br><span class="line">        return new ChineseVideo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public INote createNote() &#123;</span><br><span class="line">        return new ChineseNote();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再创建数学产品，Math视频MathVideo类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MathVideo implements IVideo &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void record() &#123;</span><br><span class="line">        System.out.println(&quot;录制数学课视频！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建数学课堂笔记的MathNote类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MathNote implements INote &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void edit() &#123;</span><br><span class="line">        System.out.println(&quot;编写数学课笔记！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建数学课产品族的具体工厂类MathCourseFactory：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class MathCourseFactory implements CourseFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public IVideo createVideo() &#123;</span><br><span class="line">        return new MathVideo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public INote createNote() &#123;</span><br><span class="line">        return new MathNote();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MathCourseFactory mathCourseFactory &#x3D; new MathCourseFactory();</span><br><span class="line">        mathCourseFactory.createNote().edit();</span><br><span class="line">        mathCourseFactory.createVideo().record();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的案例代码完整的描述了两个产品族语文课程和数学课程，也描述了两个产品等级的视频和课堂笔记。抽象工厂非常完美清晰地描述了这一层复杂的关系。如果我们再升级扩展产品等级，将课堂作业也加入到课程中，我们的代码需要从抽象工厂，到具体的工厂都要进行调整，很显然不符合开闭原则。所以抽象工厂也是有缺点的：</p>
<p>1、规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口。</p>
<p>2、增加了系统的抽象性和理解难度。</p>
<h1 id="三、工厂模式总结"><a href="#三、工厂模式总结" class="headerlink" title="三、工厂模式总结"></a>三、工厂模式总结</h1><p><img src="https://user-gold-cdn.xitu.io/2020/2/20/17061184a4c31ec2?w=1465&h=535&f=png&s=108016" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/02/21/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E7%BB%8F%E5%85%B8%E6%A1%86%E6%9E%B6%E9%83%BD%E5%9C%A8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="ck7iqzwtd000bq1ra8cr2b4um" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/02/21/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E7%BB%8F%E5%85%B8%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          架构师内功心法，经典高频面试的单例模式详解
        
      </div>
    </a>
  
  
    <a href="/2020/02/19/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%E7%B2%BE%E9%80%89%E6%A1%88%E4%BE%8B/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">架构师内功心法，软件架构设计的七大原则精选案例</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/03/08/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1%E6%9D%A5%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，使用共享对象来提高性能的享元模式详解</a>
          </li>
        
          <li>
            <a href="/2020/03/08/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%A4%96%E7%95%8C%E8%AE%BF%E9%97%AE%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%E5%94%AF%E4%B8%80%E9%80%9A%E9%81%93%E7%9A%84%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，外界访问系统内部唯一通道的门面模式详解</a>
          </li>
        
          <li>
            <a href="/2020/03/01/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E6%B3%A8%E9%87%8D%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F%E7%9A%84%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，注重方法调用顺序的建造者模式详解</a>
          </li>
        
          <li>
            <a href="/2020/02/25/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%B1%9E%E4%BA%8E%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，属于游戏设计模式的策略模式详解</a>
          </li>
        
          <li>
            <a href="/2020/02/25/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%B9%B2%E8%BF%87%E4%B8%AD%E4%BB%8B%E5%B9%B2%E8%BF%87%E5%BF%AB%E9%80%92%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，干过中介干过快递的代理模式详解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Kevin Shaw<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>