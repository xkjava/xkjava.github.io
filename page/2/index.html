<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>来一杯咖啡</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="互联网Java体系平台架构，分布式系统，中间件技术等">
<meta property="og:type" content="website">
<meta property="og:title" content="来一杯咖啡">
<meta property="og:url" content="https://xkjava.github.io/page/2/index.html">
<meta property="og:site_name" content="来一杯咖啡">
<meta property="og:description" content="互联网Java体系平台架构，分布式系统，中间件技术等">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Kevin Shaw">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="Netty">
<meta property="article:tag" content="Kafka...">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="来一杯咖啡" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">来一杯咖啡</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">互联网技术无边界，学习与交流</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://xkjava.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="对于gof-23种设计模式的学习，我们需要掌握的是“道”，而不只是“术”" class="article article-type-对于gof" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/05/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%8C%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E6%98%AF%E2%80%9C%E9%81%93%E2%80%9D%EF%BC%8C%E8%80%8C%E4%B8%8D%E5%8F%AA%E6%98%AF%E2%80%9C%E6%9C%AF%E2%80%9D/" class="article-date">
  <time datetime="2020-05-05T07:45:53.000Z" itemprop="datePublished">2020-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/05/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%8C%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E6%98%AF%E2%80%9C%E9%81%93%E2%80%9D%EF%BC%8C%E8%80%8C%E4%B8%8D%E5%8F%AA%E6%98%AF%E2%80%9C%E6%9C%AF%E2%80%9D/">23种设计模式的学习，我们需要掌握的是“道”，而不只是“术”</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>设计模式是一门艺术，因为它们来源于生活，不要为了套用设计模式而去使用设计模式。我们在编写程序的时候用好设计模式可以防范于未然，它们可以很好地提供一种解决问题的方案。从古至今，我们在遇到问题的时候，都会去寻求帮助，咨询懂的人，或者去图书馆查阅资料，或者在电脑前面搜索，等等方法。在学习23种设计模式之前我们必然需要学习软件架构的设计原则，下面用一句话来概括这七大设计原则。</p>
<h1 id="一、一句话总结设计原则"><a href="#一、一句话总结设计原则" class="headerlink" title="一、一句话总结设计原则"></a>一、一句话总结设计原则</h1><p><img src="https://user-gold-cdn.xitu.io/2020/5/5/171e2f3498f43bac?w=1445&h=699&f=png&s=715467" alt=""></p>
<h1 id="二、设计模式简介"><a href="#二、设计模式简介" class="headerlink" title="二、设计模式简介"></a>二、设计模式简介</h1><p>建筑师克里斯托佛·亚历山大在1977/79年编制了一本汇集设计模式的书，但是这种设计模式的思想在建筑设计领域里的影响远没有后来在软件开发领域里传播的广泛。</p>
<p>肯特·贝克和沃德·坎宁安在1987年，利用克里斯托佛·亚历山大在建筑设计领域里的思想开发了设计模式并把此思想应用在Smalltalk中的图形用户接口（GUI）的生成中。一年后埃里希·伽玛在他的苏黎世大学博士毕业论文中开始尝试把这种思想改写为适用于软件开发。与此同时James Coplien 在1989年至1991年也在利用相同的思想致力于C++的开发，而后于1991年发表了他的著作Advanced C++ Programming Styles and Idioms。同年Erich Gamma 得到了博士学位，然后去了美国，在那与Richard Helm, Ralph Johnson ,John Vlissides 合作出版了《设计模式：可复用面向对象软件的基础》（Design Patterns - Elements of Reusable Object-Oriented Software） 一书，在此书中共收录了 23 种设计模式。</p>
<p>这四位作者在软件开发领域里以“四人帮”（英语，Gang of Four，简称GoF）而闻名，并且他们在此书中的协作导致了软件设计模式的突破。有时，GoF也会用于代指《设计模式》这本书。</p>
<p>设计模式是前人经验的总结，提供给后人去借鉴使用的，前人种树后人乘凉。它不但可以解决复杂的业务问题，也可以帮助我们提高代码的可读性、扩展性，降低维护成本。下面对GoF23种设计模式进行归纳和总结。</p>
<h2 id="2-1-创建型"><a href="#2-1-创建型" class="headerlink" title="2.1 创建型"></a>2.1 创建型</h2><p>创建型全部是关于如何创建实例的。这组范例可以被划分为两组：类创建范例及对象创建范例。类创建实例在实例化过程中有效的使用类之间的继承关系，对象创建范例则使用代理来完成其任务。</p>
<ul>
<li>抽象工厂 (Abstract Factory)</li>
<li>建造者 (Builder Pattern)</li>
<li>工厂方法 (Factory Method pattern)</li>
<li>原型 (Prototype pattern)</li>
<li>单例模式 (Singleton pattern)</li>
</ul>
<h2 id="2-2-结构型"><a href="#2-2-结构型" class="headerlink" title="2.2 结构型"></a>2.2 结构型</h2><p>这组都是关于类及对象复合关系的。</p>
<ul>
<li>适配器(Adapter pattern)</li>
<li>桥接(Bridge pattern)</li>
<li>组合(Composite pattern)</li>
<li>装饰器(Decorator pattern)</li>
<li>门面(Facade pattern)</li>
<li>享元(Flyweight pattern)</li>
<li>代理(Proxy pattern)</li>
</ul>
<h2 id="2-3-行为型"><a href="#2-3-行为型" class="headerlink" title="2.3 行为型"></a>2.3 行为型</h2><p>这组都是关于对象之间如何通讯的。</p>
<ul>
<li>职责链(Chain-of-responsibility pattern)</li>
<li>命令(Command pattern)</li>
<li>翻译器(Interpreter pattern)</li>
<li>迭代器(Iterator pattern)</li>
<li>中介者(Mediator pattern)</li>
<li>备忘录(Memento pattern)</li>
<li>观察者(Observer pattern)</li>
<li>状态(State pattern)</li>
<li>策略(Strategy pattern)</li>
<li>模板方法(Template method pattern)</li>
<li>访问者(Visitor)</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/5/171e3a5306ebdc3b?w=819&h=888&f=jpeg&s=147445" alt=""></p>
<h2 id="2-4-创建型使用频率"><a href="#2-4-创建型使用频率" class="headerlink" title="2.4 创建型使用频率"></a>2.4 创建型使用频率</h2><p><img src="https://user-gold-cdn.xitu.io/2020/5/5/171e37790660d323?w=1396&h=700&f=png&s=207945" alt=""></p>
<h2 id="2-5-结构型使用频率"><a href="#2-5-结构型使用频率" class="headerlink" title="2.5 结构型使用频率"></a>2.5 结构型使用频率</h2><p><img src="https://user-gold-cdn.xitu.io/2020/5/5/171e3785f71efd67?w=1366&h=766&f=png&s=226762" alt=""></p>
<h2 id="2-6-行为型使用频率"><a href="#2-6-行为型使用频率" class="headerlink" title="2.6 行为型使用频率"></a>2.6 行为型使用频率</h2><p><img src="https://user-gold-cdn.xitu.io/2020/5/5/171e37902da27f32?w=1705&h=727&f=png&s=319249" alt=""></p>
<h1 id="三、一句话总结设计模式"><a href="#三、一句话总结设计模式" class="headerlink" title="三、一句话总结设计模式"></a>三、一句话总结设计模式</h1><p><img src="https://user-gold-cdn.xitu.io/2020/5/5/171e3a1f10dc35df?w=1731&h=792&f=jpeg&s=168839" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/5/5/171e39ecef3d60f4?w=1701&h=756&f=png&s=707659" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/5/5/171e39b611a2ebb8?w=1674&h=858&f=jpeg&s=317182" alt=""></p>
<h1 id="四、设计模式之间的关系和对比"><a href="#四、设计模式之间的关系和对比" class="headerlink" title="四、设计模式之间的关系和对比"></a>四、设计模式之间的关系和对比</h1><h2 id="4-1-单例模式和工厂模式"><a href="#4-1-单例模式和工厂模式" class="headerlink" title="4.1 单例模式和工厂模式"></a>4.1 单例模式和工厂模式</h2><p>在实际业务中，通常把工厂类设计为单例模式。</p>
<h2 id="4-2-策略模式和工厂模式"><a href="#4-2-策略模式和工厂模式" class="headerlink" title="4.2 策略模式和工厂模式"></a>4.2 策略模式和工厂模式</h2><p>1、工厂模式包含工厂方法模式和抽象工厂模式，它是创建型模式，而策略模式是行为型模式；</p>
<p>2、工厂模式的目的是封装好创建逻辑，策略模式接收工厂创建好的对象，从而实现不同的行为。</p>
<h2 id="4-3-策略模式和委派模式"><a href="#4-3-策略模式和委派模式" class="headerlink" title="4.3 策略模式和委派模式"></a>4.3 策略模式和委派模式</h2><p>1、策略模式是委派模式内部的一种实现形式，策略模式关注的结构是否能够相互替代。</p>
<p>2、委派模式更关注分发和调度的过程。</p>
<h2 id="4-4-模板方法模式和工厂方法模式"><a href="#4-4-模板方法模式和工厂方法模式" class="headerlink" title="4.4 模板方法模式和工厂方法模式"></a>4.4 模板方法模式和工厂方法模式</h2><p>工厂方法是模板方法的一种特殊实现。</p>
<h2 id="4-5-模板方法模式和策略模式"><a href="#4-5-模板方法模式和策略模式" class="headerlink" title="4.5 模板方法模式和策略模式"></a>4.5 模板方法模式和策略模式</h2><p>1、模板方法模式和策略模式都有封装的算法；</p>
<p>2、策略模式是使不同的算法可以相互替换，且不影响客户端应用层的使用；</p>
<p>3、模板方法是针对定义一个算法的流程，将一些有细微差异的部分交给子类实现；</p>
<p>4、模板方法模式不能改变算法流程，策略模式可以改变算法流程且可以替换。策略模式通常用来代理if…else等分支条件语句。</p>
<h2 id="4-6-装饰者模式和静态代理模式"><a href="#4-6-装饰者模式和静态代理模式" class="headerlink" title="4.6 装饰者模式和静态代理模式"></a>4.6 装饰者模式和静态代理模式</h2><p>1、装饰者模式在于给对象动态添加方法，而代理更加关注控制对象的访问；</p>
<p>2、代理模式通常会在代理类中创建被代理对象的实例，而装饰者模式通常把装饰者作为构造行数。</p>
<h2 id="4-7-装饰者模式和适配器模式"><a href="#4-7-装饰者模式和适配器模式" class="headerlink" title="4.7 装饰者模式和适配器模式"></a>4.7 装饰者模式和适配器模式</h2><p>1、装饰者模式和适配器模式都属于包装器模式；</p>
<p>2、装饰者模式可以实现被装饰者与相同的接口或者继承被装饰者作为它的子类，而适配器和被适配着可以实现不同的接口。</p>
<h2 id="4-8-适配器模式和静态代理模式"><a href="#4-8-适配器模式和静态代理模式" class="headerlink" title="4.8 适配器模式和静态代理模式"></a>4.8 适配器模式和静态代理模式</h2><p>适配器模式可以结合静态代理来实现，保存被适配对象的引用，但不是唯一的实现方式；</p>
<h2 id="4-9-适配器模式和策略模式"><a href="#4-9-适配器模式和策略模式" class="headerlink" title="4.9 适配器模式和策略模式"></a>4.9 适配器模式和策略模式</h2><p>在适配业务复杂的情况下，利用策略模式优化动态适配逻辑。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/05/05/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%8C%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E6%98%AF%E2%80%9C%E9%81%93%E2%80%9D%EF%BC%8C%E8%80%8C%E4%B8%8D%E5%8F%AA%E6%98%AF%E2%80%9C%E6%9C%AF%E2%80%9D/" data-id="cke9cjzbe0000f5ra0bofcijl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-深度阅读Spring5-x源码后，使用Java实现迷你版Spring的基本思路实践" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/05/%E6%B7%B1%E5%BA%A6%E9%98%85%E8%AF%BBSpring5-x%E6%BA%90%E7%A0%81%E5%90%8E%EF%BC%8C%E4%BD%BF%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E8%BF%B7%E4%BD%A0%E7%89%88Spring%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF%E5%AE%9E%E8%B7%B5/" class="article-date">
  <time datetime="2020-04-05T12:33:42.000Z" itemprop="datePublished">2020-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/05/%E6%B7%B1%E5%BA%A6%E9%98%85%E8%AF%BBSpring5-x%E6%BA%90%E7%A0%81%E5%90%8E%EF%BC%8C%E4%BD%BF%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E8%BF%B7%E4%BD%A0%E7%89%88Spring%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF%E5%AE%9E%E8%B7%B5/">深度阅读Spring5.x源码后，使用Java实现迷你版Spring的基本思路实践</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>看过Spring5源码的同学们，一开始肯定会边看边去用断点进行源码调试，调试来调试去时间长了肯定会晕车的，最有效的方式是先猜测后进行验证，当然猜测是建立在对阅读源码相当有经验的基础上的，否则也是一头雾水。对于使用很长时间Spring框架的开发者来说，应该对其架构和结构不会太陌生，可以大胆地进行猜测。</p>
<p>根据源码猜测，整理了迷你版Spring的基本实现思路，如下图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/5/17148ecb3282078e?w=1729&h=661&f=png&s=303698" alt=""></p>
<h1 id="一、web-xml配置文件"><a href="#一、web-xml配置文件" class="headerlink" title="一、web.xml配置文件"></a>一、web.xml配置文件</h1><p>所有依赖于Web容器的项目，基本都是从web.xml文件开始的，首先我们先配置好web.xml的文件内容，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;</span><br><span class="line">         version&#x3D;&quot;4.0&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;display-name&gt;mini-spring&lt;&#x2F;display-name&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;symvc&lt;&#x2F;servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;com.sy.sa.framework.servlet.SyDispatcherServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">            &lt;param-value&gt;application.properties&lt;&#x2F;param-value&gt;</span><br><span class="line">        &lt;&#x2F;init-param&gt;</span><br><span class="line"></span><br><span class="line">        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;</span><br><span class="line">    &lt;&#x2F;servlet&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;symvc&lt;&#x2F;servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">    &lt;&#x2F;servlet-mapping&gt;</span><br><span class="line">    </span><br><span class="line">&lt;&#x2F;web-app&gt;</span><br></pre></td></tr></table></figure>
<p>SyDispatcherServlet是模拟的Spring实现的核心类，后面会讲解具体的实现源码的。</p>
<h1 id="二、配置application-properties"><a href="#二、配置application-properties" class="headerlink" title="二、配置application.properties"></a>二、配置application.properties</h1><p>无论是xml、properties、yml都是配置文件的表现形式，无论格式怎样变化，其表现的内容大致上是没有什么变化的。具体的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scanPackage&#x3D;com.sy.sa</span><br></pre></td></tr></table></figure>

<h1 id="三、自定义注解Annotation"><a href="#三、自定义注解Annotation" class="headerlink" title="三、自定义注解Annotation"></a>三、自定义注解Annotation</h1><h2 id="3-1-SyAutoWired"><a href="#3-1-SyAutoWired" class="headerlink" title="3.1 @SyAutoWired"></a>3.1 @SyAutoWired</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.sy.sa.framework.annotation;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line">@Target(&#123;ElementType.FIELD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface SyAutoWired &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-SyController"><a href="#3-2-SyController" class="headerlink" title="3.2 @SyController"></a>3.2 @SyController</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.sy.sa.framework.annotation;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface SyController &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-SyRequestMapping"><a href="#3-3-SyRequestMapping" class="headerlink" title="3.3 @SyRequestMapping"></a>3.3 @SyRequestMapping</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.sy.sa.framework.annotation;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface SyRequestMapping &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-SyRequestParam"><a href="#3-4-SyRequestParam" class="headerlink" title="3.4 @SyRequestParam"></a>3.4 @SyRequestParam</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.sy.sa.framework.annotation;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line">@Target(&#123;ElementType.PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface SyRequestParam &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-SyService"><a href="#3-5-SyService" class="headerlink" title="3.5 @SyService"></a>3.5 @SyService</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.sy.sa.framework.annotation;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface SyService &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、配置注解Annotation"><a href="#四、配置注解Annotation" class="headerlink" title="四、配置注解Annotation"></a>四、配置注解Annotation</h1><h2 id="4-1-IDemoService接口"><a href="#4-1-IDemoService接口" class="headerlink" title="4.1 IDemoService接口"></a>4.1 IDemoService接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface IDemoService &#123;</span><br><span class="line"></span><br><span class="line">    String get(String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-DemoServiceImpl实现类"><a href="#4-2-DemoServiceImpl实现类" class="headerlink" title="4.2 DemoServiceImpl实现类"></a>4.2 DemoServiceImpl实现类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class DemoService implements IDemoService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String get(String name) &#123;</span><br><span class="line">        return &quot;Hello World, [&quot; + name + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-DemoController类"><a href="#4-3-DemoController类" class="headerlink" title="4.3 DemoController类"></a>4.3 DemoController类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@SyController</span><br><span class="line">@SyRequestMapping(&quot;&#x2F;sy&quot;)</span><br><span class="line">public class DemoController &#123;</span><br><span class="line"></span><br><span class="line">    @SyAutoWired</span><br><span class="line">    private IDemoService demoService;</span><br><span class="line"></span><br><span class="line">    @SyRequestMapping(&quot;&#x2F;query&quot;)</span><br><span class="line">    public void query(HttpServletRequest request, HttpServletResponse response,</span><br><span class="line">                      @SyRequestParam(&quot;name&quot;) String name) &#123;</span><br><span class="line">        String result &#x3D; demoService.get(name);</span><br><span class="line">        try&#123;</span><br><span class="line">            response.getWriter().write(result);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、自定义SyDispatcherServlet的实现"><a href="#五、自定义SyDispatcherServlet的实现" class="headerlink" title="五、自定义SyDispatcherServlet的实现"></a>五、自定义SyDispatcherServlet的实现</h1><h2 id="5-1-覆盖实现HttpServlet中的init-方法"><a href="#5-1-覆盖实现HttpServlet中的init-方法" class="headerlink" title="5.1 覆盖实现HttpServlet中的init()方法"></a>5.1 覆盖实现HttpServlet中的init()方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * mini-spring的第一步初始化阶段</span><br><span class="line"> * @param config</span><br><span class="line"> * @throws ServletException</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public void init(ServletConfig config) throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;1.加载application.properties配置文件</span><br><span class="line">    doLoadConfig(config.getInitParameter(&quot;contextConfigLocation&quot;));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;2.扫描对应包下的所有类</span><br><span class="line">    doScanner(contextConfig.getProperty(&quot;scanPackage&quot;));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;3.初始化扫描到的类，并将它们放入到IoC容器中</span><br><span class="line">    doInstance();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;4.完成DI依赖注入</span><br><span class="line">    doAutowried();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;5.初始化HandlerMapping</span><br><span class="line">    initHandlerMapping();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;Sy Spring framework is init.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 初始化url和Method的一一对应的关系</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void initHandlerMapping() &#123;</span><br><span class="line">    if(ioc.isEmpty()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (Map.Entry&lt;String, Object&gt; entry : ioc.entrySet()</span><br><span class="line">         ) &#123;</span><br><span class="line">        Class&lt;?&gt; clazz &#x3D; entry.getValue().getClass();</span><br><span class="line">        if(!clazz.isAnnotationPresent(SyController.class)) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        String baseUrl &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        if(clazz.isAnnotationPresent(SyRequestMapping.class)) &#123;</span><br><span class="line">            SyRequestMapping requestMapping &#x3D; clazz.getAnnotation(SyRequestMapping.class);</span><br><span class="line">            baseUrl &#x3D; requestMapping.value();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;获取所有的public方法</span><br><span class="line">        for (Method method :</span><br><span class="line">             clazz.getMethods()) &#123;</span><br><span class="line">            if(method.isAnnotationPresent(SyRequestMapping.class)) &#123;</span><br><span class="line">                SyRequestMapping requestMapping &#x3D; method.getAnnotation(SyRequestMapping.class);</span><br><span class="line">                &#x2F;&#x2F; &#x2F;&#x2F;sy&#x2F;&#x2F;&#x2F;query</span><br><span class="line">                String regex &#x3D; (&quot;&#x2F;&quot; + baseUrl + &quot;&#x2F;&quot; + requestMapping.value())</span><br><span class="line">                        .replaceAll(&quot;&#x2F;+&quot;,&quot;&#x2F;&quot;);</span><br><span class="line">                Pattern pattern &#x3D; Pattern.compile(regex);</span><br><span class="line"></span><br><span class="line">                handlerMapping.add(new Handler(pattern, entry.getValue(), method));</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;Mapped :&quot; + pattern + &quot;,&quot; + method);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 将容器中的类进行依赖注入</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void doAutowried() &#123;</span><br><span class="line"></span><br><span class="line">    if(ioc.isEmpty()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (Map.Entry&lt;String, Object&gt; entry:</span><br><span class="line">         ioc.entrySet()) &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Declared 所有的，特定的 字段，包括private&#x2F;protected&#x2F;default</span><br><span class="line">         * 正常来说，普通的OOP编程只能拿到public的属性</span><br><span class="line">         *&#x2F;</span><br><span class="line">        Field[] fields &#x3D; entry.getValue().getClass().getDeclaredFields();</span><br><span class="line">        for(Field field: fields) &#123;</span><br><span class="line">            if(!field.isAnnotationPresent(SyAutoWired.class)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            SyAutoWired autoWired &#x3D; field.getAnnotation(SyAutoWired.class);</span><br><span class="line">            String beanName &#x3D; autoWired.value().trim();</span><br><span class="line">            if(&quot;&quot;.equals(beanName)) &#123;</span><br><span class="line">                &#x2F;&#x2F;获得接口的类型，作为key待会拿这个key到ioc容器中去取值</span><br><span class="line">                beanName &#x3D; field.getType().getName();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;**</span><br><span class="line">             * 如果是public以外的修饰符，只要加了@Autowired注解，都要强制赋值</span><br><span class="line">             * 反射中叫做暴力访问， 强吻</span><br><span class="line">             *&#x2F;</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                field.set(entry.getValue(), ioc.get(beanName));</span><br><span class="line">            &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 初始化类放入IoC容器中，为依赖注入做准备</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void doInstance() &#123;</span><br><span class="line">    if (classNames.isEmpty()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (String className :</span><br><span class="line">                classNames) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz &#x3D; Class.forName(className);</span><br><span class="line">            &#x2F;&#x2F;根据注解实例化对应的类</span><br><span class="line">            if(clazz.isAnnotationPresent(SyController.class)) &#123;</span><br><span class="line">                Object instance &#x3D; clazz.newInstance();</span><br><span class="line">                &#x2F;&#x2F;Spring默认类名首字母小写</span><br><span class="line">                String beanName &#x3D; this.toLowerFirstCase(clazz.getSimpleName());</span><br><span class="line">                &#x2F;&#x2F;获取到的类的实例放入到IoC容器中</span><br><span class="line">                ioc.put(beanName, instance);</span><br><span class="line">            &#125;else if(clazz.isAnnotationPresent(SyService.class)) &#123;</span><br><span class="line">                &#x2F;&#x2F;1、自定义的beanName</span><br><span class="line">                SyService service &#x3D; clazz.getAnnotation(SyService.class);</span><br><span class="line">                String beanName &#x3D; service.value();</span><br><span class="line">                &#x2F;&#x2F;2、默认类名首字母小写</span><br><span class="line">                if(&quot;&quot;.equals(beanName.trim())) &#123;</span><br><span class="line">                    beanName &#x3D; toLowerFirstCase(clazz.getSimpleName());</span><br><span class="line">                &#125;</span><br><span class="line">                Object instance &#x3D; clazz.newInstance();</span><br><span class="line">                ioc.put(beanName, instance);</span><br><span class="line">                &#x2F;&#x2F;3、根据类型自动赋值,投机取巧的方式</span><br><span class="line">                for (Class&lt;?&gt; cls:</span><br><span class="line">                clazz.getInterfaces()) &#123;</span><br><span class="line">                    if(ioc.containsKey(cls.getName())) &#123;</span><br><span class="line">                        throw new Exception(&quot;The “&quot; + cls.getName() + &quot;” is exists!!&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;把接口的类型直接当成key了</span><br><span class="line">                    ioc.put(cls.getName(), instance);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;catch (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (InstantiationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 根据包路径扫描相关的类</span><br><span class="line"> * @param scanPackage</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void doScanner(String scanPackage) &#123;</span><br><span class="line">    &#x2F;&#x2F;将包路径中的“.”替换为“&#x2F;”</span><br><span class="line">    URL url &#x3D; this.getClass().getClassLoader().getResource(&quot;&#x2F;&quot; +</span><br><span class="line">            scanPackage.replaceAll(&quot;\\.&quot;, &quot;&#x2F;&quot;));</span><br><span class="line">    File classPath &#x3D; new File(url.getFile());</span><br><span class="line">    for (File file : classPath.listFiles()</span><br><span class="line">         ) &#123;</span><br><span class="line">        if(file.isDirectory()) &#123;</span><br><span class="line">            doScanner(scanPackage + &quot;.&quot; + file.getName());</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            if(!file.getName().endsWith(&quot;.class&quot;)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            String className &#x3D; (scanPackage + &quot;.&quot;</span><br><span class="line">                    + file.getName().replace(&quot;.class&quot;, &quot;&quot;));</span><br><span class="line">            &#x2F;&#x2F;将完整类名保存到List中</span><br><span class="line">            classNames.add(className);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 加载配置文件application.properties，放到properties中</span><br><span class="line"> * @param contextConfigLocation</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void doLoadConfig(String contextConfigLocation) &#123;</span><br><span class="line">    InputStream is &#x3D; this.getClass().getClassLoader().getResourceAsStream(contextConfigLocation);</span><br><span class="line">    try &#123;</span><br><span class="line">        contextConfig.load(is);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if(null !&#x3D; is) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 将类名首字母变成小写字母</span><br><span class="line"> * @param simpleName</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">private String toLowerFirstCase(String simpleName) &#123;</span><br><span class="line">    char[] chars &#x3D; simpleName.toCharArray();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 之所以加，是因为大小写字母的ASCII码相差32，</span><br><span class="line">     * 而且大写字母的ASCII码要小于小写字母的ASCII码</span><br><span class="line">     * 在Java中对char做算学运算，实际上就是对ASCII码做算学运算</span><br><span class="line">     *&#x2F;</span><br><span class="line">    chars[0] +&#x3D;  32;</span><br><span class="line">    return String.valueOf(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-Handler类"><a href="#5-2-Handler类" class="headerlink" title="5.2 Handler类"></a>5.2 Handler类</h2><p>保存url和method的对应关系，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">package com.sy.sa.framework.handler;</span><br><span class="line"></span><br><span class="line">import com.sy.sa.framework.annotation.SyRequestParam;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.lang.annotation.Annotation;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 保存一个url和一个method的关系</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Handler &#123;</span><br><span class="line"></span><br><span class="line">    private Pattern pattern;</span><br><span class="line">    private Method method;</span><br><span class="line">    private Object controller;</span><br><span class="line">    private Class&lt;?&gt;[] paramTypes;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 形参列表</span><br><span class="line">     * 参数的名字作为key，参数的顺序，位置作为值</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Map&lt;String, Integer&gt; paramIndexMapping;</span><br><span class="line"></span><br><span class="line">    public Pattern getPattern() &#123;</span><br><span class="line">        return pattern;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Method getMethod() &#123;</span><br><span class="line">        return method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getController() &#123;</span><br><span class="line">        return controller;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Class&lt;?&gt;[] getParamTypes() &#123;</span><br><span class="line">        return paramTypes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Handler(Pattern pattern, Object controller, Method method) &#123;</span><br><span class="line">        this.pattern &#x3D; pattern;</span><br><span class="line">        this.method &#x3D; method;</span><br><span class="line">        this.controller &#x3D; controller;</span><br><span class="line"></span><br><span class="line">        paramTypes &#x3D; method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">        paramIndexMapping &#x3D; new HashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">        this.putParamIndexMapping(method);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void putParamIndexMapping(Method method) &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 根据方法得到注解是一个二维数组</span><br><span class="line">         * 一个参数可以有多个注解，而一个方法又有多个参数</span><br><span class="line">         *&#x2F;</span><br><span class="line">        Annotation[][] result &#x3D; method.getParameterAnnotations();</span><br><span class="line">        for(int i &#x3D; 0; i &lt; result.length; i++) &#123;</span><br><span class="line">            for (Annotation annotation : result[i]) &#123;</span><br><span class="line">                if(annotation instanceof SyRequestParam) &#123;</span><br><span class="line">                    String paramName &#x3D; ((SyRequestParam) annotation).value();</span><br><span class="line">                    if(!&quot;&quot;.equals(paramName.trim())) &#123;</span><br><span class="line">                        paramIndexMapping.put(paramName, i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 提取方法中的request、response参数</span><br><span class="line">         *&#x2F;</span><br><span class="line">        Class&lt;?&gt;[] paramTypes &#x3D; method.getParameterTypes();</span><br><span class="line">        for(int i &#x3D; 0 ; i &lt; paramTypes.length; i++) &#123;</span><br><span class="line">            Class&lt;?&gt; type &#x3D; paramTypes[i];</span><br><span class="line">            if(type &#x3D;&#x3D; HttpServletRequest.class ||</span><br><span class="line">                        type &#x3D;&#x3D; HttpServletResponse.class) &#123;</span><br><span class="line">                paramIndexMapping.put(type.getName(), i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-doPost-doGet-方法"><a href="#5-3-doPost-doGet-方法" class="headerlink" title="5.3 doPost()/doGet()方法"></a>5.3 doPost()/doGet()方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"> @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        this.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">    &#x2F;&#x2F;6、调用，运行阶段</span><br><span class="line">    try &#123;</span><br><span class="line">        doDispatch(req,resp);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        resp.getWriter().write(&quot;500 Exection,Detail : &quot; + Arrays.toString(e.getStackTrace()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doDispatch(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123;</span><br><span class="line">    Handler handler &#x3D; this.getHandler(req);</span><br><span class="line">    if(handler &#x3D;&#x3D; null) &#123;</span><br><span class="line">        resp.getWriter().write(&quot;404 Not Found!!!&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Integer&gt; paramIndexMapping &#x3D; handler.getParamIndexMapping();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获得方法的形参列表</span><br><span class="line">    Class&lt;?&gt; [] paramTypes &#x3D; handler.getParamTypes();</span><br><span class="line"></span><br><span class="line">    Object [] paramValues &#x3D; new Object[paramTypes.length];</span><br><span class="line"></span><br><span class="line">    Map&lt;String,String[]&gt; params &#x3D; req.getParameterMap();</span><br><span class="line">    for (Map.Entry&lt;String, String[]&gt; parm : params.entrySet()) &#123;</span><br><span class="line">        String value &#x3D; Arrays.toString(parm.getValue()).replaceAll(&quot;\\[|\\]&quot;,&quot;&quot;)</span><br><span class="line">                .replaceAll(&quot;\\s&quot;,&quot;,&quot;);</span><br><span class="line">        if(!paramIndexMapping.containsKey(parm.getKey()))&#123;continue;&#125;</span><br><span class="line"></span><br><span class="line">        int index &#x3D; paramIndexMapping.get(parm.getKey());</span><br><span class="line">        paramValues[index] &#x3D; convert(paramTypes[index],value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(paramIndexMapping.containsKey(HttpServletRequest.class.getName())) &#123;</span><br><span class="line">        int reqIndex &#x3D; paramIndexMapping.get(HttpServletRequest.class.getName());</span><br><span class="line">        paramValues[reqIndex] &#x3D; req;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(paramIndexMapping.containsKey(HttpServletResponse.class.getName())) &#123;</span><br><span class="line">        int respIndex &#x3D; paramIndexMapping.get(HttpServletResponse.class.getName());</span><br><span class="line">        paramValues[respIndex] &#x3D; resp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object returnValue &#x3D; handler.getMethod().invoke(handler.getController(),paramValues);</span><br><span class="line">    if(returnValue &#x3D;&#x3D; null || returnValue instanceof Void)&#123; return; &#125;</span><br><span class="line">    resp.getWriter().write(returnValue.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doPost()方法中使用了委派模式，委派模式的代码逻辑在doDispath()方法中。</p>
<p>至此，迷你版Spring的基本思路代码实践就完成了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/04/05/%E6%B7%B1%E5%BA%A6%E9%98%85%E8%AF%BBSpring5-x%E6%BA%90%E7%A0%81%E5%90%8E%EF%BC%8C%E4%BD%BF%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E8%BF%B7%E4%BD%A0%E7%89%88Spring%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF%E5%AE%9E%E8%B7%B5/" data-id="cke9cjzdu000qf5ra4bs5f4nx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，23种设计模式中最为复杂的访问者模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/30/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E6%9C%80%E4%B8%BA%E5%A4%8D%E6%9D%82%E7%9A%84%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-03-30T03:37:03.000Z" itemprop="datePublished">2020-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/30/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E6%9C%80%E4%B8%BA%E5%A4%8D%E6%9D%82%E7%9A%84%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，23种设计模式中最为复杂的访问者模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>访问者模式（Visitor Pattern）是一种将数据结构和数据操作分离的设计模式。是指封装一些作用于某种数据结构中的各种元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。</p>
<p>访问者模式被称为最复杂的设计模式，并且使用频率不高，设计模式的作者也评价为：大多情况下，你不需要使用访问者模式，但是一旦需要使用它时，那就真的需要使用了。访问者模式的基本思想是，针对系统中拥有固定类型数的对象结构（元素），在其内提供一个accept()方法用来接受访问者对象的访问。不同的访问者对同一元素的访问内容不同，使得相同的元素集合可以产生不同的数据结果。accept()方法可以接收不同的访问者对象，然后在内部将自己（元素）转发到接收到的访问者对象的visit()方法内。访问者内部对应类型的visit()方法就会得到回调执行，对元素进行操作。也就是通过两次动态分发（第一次是对访问者的分发accept()方法，第二次是对元素的分发visit()方法），才最终将一个具体的元素传递到一个具体的访问者。如此一来，就解耦了数据结构与操作，且数据操作不会改变元素状态。</p>
<h1 id="一、访问者模式的应用场景"><a href="#一、访问者模式的应用场景" class="headerlink" title="一、访问者模式的应用场景"></a>一、访问者模式的应用场景</h1><p>访问者模式在生活场景中也是非常当多的，例如每年年底的KPI考核，KPI考核标准是相对稳定的，但是参与KPI考核的员工可能每年都会发生变化，那么员工就是访问者。我们平时去食堂或者餐厅吃饭，餐厅的菜单和就餐方式是相对稳定的，但是去餐厅就餐的人员是每天都在发生变化的，因此就餐人员就是访问者。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/29/17124e40cf3045f9?w=600&h=327&f=png&s=121106" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/3/29/17124e533c17755f?w=480&h=359&f=png&s=308415" alt=""></p>
<p>访问者模式的核心是，解耦数据结构与数据操作，使得对元素的操作具备优秀的扩展性。可以通过扩展不同的数据操作类型（访问者）实现对相同元素的不同的操作。简而言之就是对集合中的不同类型数据（类型数量稳定）进行多种操作，则使用访问者模式。</p>
<p>访问者模式的应用场景适用于以下几个场景：</p>
<ul>
<li>数据结构稳定，作用于数据结构的操作经常变化的场景；</li>
<li>需要数据结构与数据操作呢分离的场景；</li>
<li>需要对不同数据类型（元素）进行操作，而不使用分支判断具体类型的场景。</li>
</ul>
<p>访问者模式主要包含五种角色：</p>
<ul>
<li>抽象访问者（Visitor)：接口或抽象类，该类地冠以了对每一个具体元素（Element）的访问行为visit()方法，其参数就是具体的元素（Element）对象。理论上来说，Visitor的方法个数与元素（Element）个数是相等的。如果元素（Element）个数经常变动，会导致Visitor的方法也要进行变动，此时，该情形并不适用访问者模式；</li>
<li>具体访问者（ConcreteVisitor）：实现对具体元素的操作；</li>
<li>抽象元素（Element）：接囗或抽象类，定义了一个接受访问者访问的方法accept()表示所有元素类型都支持被访问者访问；</li>
<li>具体元素（ConcreteElement）：具体元素类型，提供接受访问者的具体实现。通常的实现都为：visitor.visit(this)；</li>
<li>结构对象（ObjectStructure）：内部维护了元素集合，并提供方法接受访问者对该集合所有元素进行操作。</li>
</ul>
<h2 id="1-1-利用访问者模式实现公司KPI考核"><a href="#1-1-利用访问者模式实现公司KPI考核" class="headerlink" title="1.1 利用访问者模式实现公司KPI考核"></a>1.1 利用访问者模式实现公司KPI考核</h2><p>每到年底，公司的管理层就要开始评定员工一年的工作绩效了，管理层有CEO和CTO，那么CEO关注的是工程师的KPI和经理的KPI以及新产品的数量，而CTO关心的是工程师的代码量、经理的新产品数量。</p>
<p>由于CEO和CTO对于不同员工的关注点是不一样的，这就需要对不同的员工类型进行不同的处理。此时访问者模式就派上用场了。下面来看下具体的代码实现，首先创建员工Employee类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Employee &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private int kpi;</span><br><span class="line"></span><br><span class="line">    public Employee(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.kpi &#x3D; new Random().nextInt(10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 接收访问者的访问</span><br><span class="line">     * @param visitor</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public abstract void accept(IVisitor visitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Employee类的accept()方法表示接受访问者的访问，由具体的子类实现。<strong>访问者是一个接口，传入不同的实现类，可以访问不同的数据。</strong> 分别创建工程师Engineer类和经理Manager类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Engineer extends Employee &#123;</span><br><span class="line">    public Engineer(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void accept(IVisitor visitor) &#123;</span><br><span class="line">        visitor.visit(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getCodeLines() &#123;</span><br><span class="line">        return new Random().nextInt(10 * 10000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Manager extends Employee &#123;</span><br><span class="line">    public Manager(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void accept(IVisitor visitor) &#123;</span><br><span class="line">        visitor.visit(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getPrducts() &#123;</span><br><span class="line">        return new Random().nextInt(10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工程师考核的是代码数量，经理考核的是产品数量，二者的职责不一样。也正是因为有这样的差异性，才使得访问模式能够在这个场景下发挥作用。将这些员工添加到一个业务报表类中，公司高层可以通过该报表类的showReport()方法查看所有员工的绩效，创建BusinessReport类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class BusinessReport &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;Employee&gt; employeeList &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public BusinessReport() &#123;</span><br><span class="line">        employeeList.add(new Engineer(&quot;工程师1&quot;));</span><br><span class="line">        employeeList.add(new Engineer(&quot;工程师2&quot;));</span><br><span class="line">        employeeList.add(new Engineer(&quot;工程师3&quot;));</span><br><span class="line">        employeeList.add(new Engineer(&quot;工程师4&quot;));</span><br><span class="line"></span><br><span class="line">        employeeList.add(new Manager(&quot;产品经理1&quot;));</span><br><span class="line">        employeeList.add(new Manager(&quot;产品经理2&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * @param visitor 公司高层，如CEO，CTO</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void showReport(IVisitor visitor) &#123;</span><br><span class="line">        for(Employee employee : employeeList) &#123;</span><br><span class="line">            employee.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义访问者类型，创建接口IVisitor，访问者声明了两个visit()方法，分别针对工程师和经理，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface IVisitor &#123;</span><br><span class="line"></span><br><span class="line">    void visit(Engineer engineer);</span><br><span class="line"></span><br><span class="line">    void visit(Manager manager);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体访问者CEOVisitor和CTOVisitor类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class CEOVisitor implements IVisitor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void visit(Engineer engineer) &#123;</span><br><span class="line">        System.out.println(&quot;工程师：&quot; + engineer.name + &quot;, KPI：&quot; + engineer.kpi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void visit(Manager manager) &#123;</span><br><span class="line">        System.out.println(&quot;经理：&quot; + manager.name + &quot;, KPI：&quot; + manager.kpi +</span><br><span class="line">                            &quot;, 新产品数量&quot; + manager.getPrducts() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class CTOVisitor implements IVisitor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void visit(Engineer engineer) &#123;</span><br><span class="line">        System.out.println(&quot;工程师：&quot; + engineer.name + &quot;, 代码数量：&quot; + engineer.getCodeLines());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void visit(Manager manager) &#123;</span><br><span class="line">        System.out.println(&quot;经理：&quot; + manager.name +</span><br><span class="line">                            &quot;, 新产品数量&quot; + manager.getPrducts() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    BusinessReport businessReport &#x3D; new BusinessReport();</span><br><span class="line">    businessReport.showReport(new CEOVisitor());</span><br><span class="line">    businessReport.showReport(new CTOVisitor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/29/171256fdfa21be22?w=721&h=556&f=png&s=46852" alt=""><br>在上述的案例中，Employee扮演了Element角色，而Engineer和Manager都是ConcreteElement；CEOVisitor和CTOVisitor都是具体的Visitor对象；而BusinessReport就是ObjectStructure。</p>
<p>访问者模式最大的优点就是增加访问者非常容，我们从代码中可以看到，如果要增加一访问者，只要新实现一个访问者接口的类，从而达到数据对象与数据操作相分离的效果。如果不实用访问者模式而又不想对不同的元素进行不同的操作，那么必定需要使用if-else和类型转换，这使得代码唯以升级维护。</p>
<p>我们要根据具体情况来评估是否适合使用访问者模式，例如，我们的对象结构是否足够稳定是否需要经常定义新的操作，使用访问者模式是否能优化我们的代码而不是使我们的代码变得更复杂。</p>
<h2 id="1-2-从静态分派到动态分派"><a href="#1-2-从静态分派到动态分派" class="headerlink" title="1.2 从静态分派到动态分派"></a>1.2 从静态分派到动态分派</h2><p><strong>变量被声明时的类型叫做变量的静态类型（Static Type），有些人把静态类型叫做明显类型（Apparent Type）；而变量所引用的对象的真是类型又叫做变量的实际类型（Actual Type）。</strong> 比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List list &#x3D; null;</span><br><span class="line">list &#x3D; new ArrayList();</span><br></pre></td></tr></table></figure>

<p>上面的代码声明了一个list，它的静态类型（也叫明显类型）是List，而它的实际类型是ArrayList。根据对象的类型而对方法进行的选择，就是分派（Dispatch）。分派又分为两种，即动态分派和静态分派。</p>
<h2 id="1-2-1-静态分派"><a href="#1-2-1-静态分派" class="headerlink" title="1.2.1 静态分派"></a>1.2.1 静态分派</h2><p>静态分派（Static Dispatch）就是按照变量的静态类型进行分派，从而确定方法的执行版本，静态分派在编译时期就可以确定方法的版本。而静态分配最经典的就是方法重载，请看下面的这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class StaticDispatch &#123;</span><br><span class="line"></span><br><span class="line">    public void test(String string) &#123;</span><br><span class="line">        System.out.println(&quot;string&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test(Integer integer) &#123;</span><br><span class="line">        System.out.println(&quot;integer&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String string &#x3D; &quot;1&quot;;</span><br><span class="line">        Integer integer &#x3D; 1;</span><br><span class="line">        StaticDispatch staticDispatch &#x3D; new StaticDispatch();</span><br><span class="line">        staticDispatch.test(string);</span><br><span class="line">        staticDispatch.test(integer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在静态分派判断的时候，我们根据多个判断依据（即参数类型和个数）判断出了方法的版本，那么这个就是多分派的概念，因为有一个以上的考量标准。所以<strong>Java语言是静态多分派语言。</strong></p>
<h2 id="1-2-2-动态分派"><a href="#1-2-2-动态分派" class="headerlink" title="1.2.2 动态分派"></a>1.2.2 动态分派</h2><p>动态分派，与静态相反，它不是在编译期间确定方法的版本，而是在运行时确定的。Java是动态单分派语言。</p>
<h2 id="1-2-3-访问者模式中的伪动态双分派"><a href="#1-2-3-访问者模式中的伪动态双分派" class="headerlink" title="1.2.3 访问者模式中的伪动态双分派"></a>1.2.3 访问者模式中的伪动态双分派</h2><p>通过前面分析，我们知道Java是静态多分派、动态单分派的语言。Java底层不支持动态的双分派。但是通过使用设计模式，也可以在Java语言里实现伪动态双分派。在访问者模式中使用的就是伪动态双分派。所谓动态双分派就是在运行时依据两个实际类型去判断一个方法的运行行为，而访问者模式实现的手段是进行了两次动态单分派来达到这个效果。<br>还是回到前面的公司KPI考核业务场景当中，BusinessReport类中的showReport()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line"> *</span><br><span class="line"> * @param visitor 公司高层，如CEO，CTO</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void showReport(IVisitor visitor) &#123;</span><br><span class="line">    for(Employee employee : employeeList) &#123;</span><br><span class="line">        employee.accept(visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是依据Employee和IVisitor两个实际类型决定了showReport()方法的执行结果从而决定了accept()方法的动作。</p>
<p>分析accept()方法的调用过程<br>1、当调用accept()方法时，根据Employee的实际类型决定是调用Engineer还是Manager的accept()方法。</p>
<p>2、这时accept()方法的版本已经确定，假如是Engineer，它的accept()方去是调用下面这行代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void accept(IVisitor visitor) &#123;</span><br><span class="line">    visitor.visit(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时的this是Engineer类型，所以对应的IVisitor接口的visit(Engineer enginner)方法，此时需要再根据访问者的实际类型确定visit()方法的版本，这样一来，就完成了动态分派的过程。</p>
<p>以上的过程就是通过两次动态双分派，第一次对accept()方法进行动态分派，第二次访问者的visit()方法进行动态分派，从而到达了根据两个实际类型确定一个方法的行为结果。</p>
<h1 id="二、访问者模式在源码中的体现"><a href="#二、访问者模式在源码中的体现" class="headerlink" title="二、访问者模式在源码中的体现"></a>二、访问者模式在源码中的体现</h1><h2 id="2-1-NIO中的FileVisitor接口"><a href="#2-1-NIO中的FileVisitor接口" class="headerlink" title="2.1 NIO中的FileVisitor接口"></a>2.1 NIO中的FileVisitor接口</h2><p>JDK中的NIO模块下的FileVisitor接口，它提供递归遍历文件树的支持。来看下源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">public interface FileVisitor&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Invoked for a directory before entries in the directory are visited.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; If this method returns &#123;@link FileVisitResult#CONTINUE CONTINUE&#125;,</span><br><span class="line">     * then entries in the directory are visited. If this method returns &#123;@link</span><br><span class="line">     * FileVisitResult#SKIP_SUBTREE SKIP_SUBTREE&#125; or &#123;@link</span><br><span class="line">     * FileVisitResult#SKIP_SIBLINGS SKIP_SIBLINGS&#125; then entries in the</span><br><span class="line">     * directory (and any descendants) will not be visited.</span><br><span class="line">     *</span><br><span class="line">     * @param   dir</span><br><span class="line">     *          a reference to the directory</span><br><span class="line">     * @param   attrs</span><br><span class="line">     *          the directory&#39;s basic attributes</span><br><span class="line">     *</span><br><span class="line">     * @return  the visit result</span><br><span class="line">     *</span><br><span class="line">     * @throws  IOException</span><br><span class="line">     *          if an I&#x2F;O error occurs</span><br><span class="line">     *&#x2F;</span><br><span class="line">    FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs)</span><br><span class="line">        throws IOException;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Invoked for a file in a directory.</span><br><span class="line">     *</span><br><span class="line">     * @param   file</span><br><span class="line">     *          a reference to the file</span><br><span class="line">     * @param   attrs</span><br><span class="line">     *          the file&#39;s basic attributes</span><br><span class="line">     *</span><br><span class="line">     * @return  the visit result</span><br><span class="line">     *</span><br><span class="line">     * @throws  IOException</span><br><span class="line">     *          if an I&#x2F;O error occurs</span><br><span class="line">     *&#x2F;</span><br><span class="line">    FileVisitResult visitFile(T file, BasicFileAttributes attrs)</span><br><span class="line">        throws IOException;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Invoked for a file that could not be visited. This method is invoked</span><br><span class="line">     * if the file&#39;s attributes could not be read, the file is a directory</span><br><span class="line">     * that could not be opened, and other reasons.</span><br><span class="line">     *</span><br><span class="line">     * @param   file</span><br><span class="line">     *          a reference to the file</span><br><span class="line">     * @param   exc</span><br><span class="line">     *          the I&#x2F;O exception that prevented the file from being visited</span><br><span class="line">     *</span><br><span class="line">     * @return  the visit result</span><br><span class="line">     *</span><br><span class="line">     * @throws  IOException</span><br><span class="line">     *          if an I&#x2F;O error occurs</span><br><span class="line">     *&#x2F;</span><br><span class="line">    FileVisitResult visitFileFailed(T file, IOException exc)</span><br><span class="line">        throws IOException;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Invoked for a directory after entries in the directory, and all of their</span><br><span class="line">     * descendants, have been visited. This method is also invoked when iteration</span><br><span class="line">     * of the directory completes prematurely (by a &#123;@link #visitFile visitFile&#125;</span><br><span class="line">     * method returning &#123;@link FileVisitResult#SKIP_SIBLINGS SKIP_SIBLINGS&#125;,</span><br><span class="line">     * or an I&#x2F;O error when iterating over the directory).</span><br><span class="line">     *</span><br><span class="line">     * @param   dir</span><br><span class="line">     *          a reference to the directory</span><br><span class="line">     * @param   exc</span><br><span class="line">     *          &#123;@code null&#125; if the iteration of the directory completes without</span><br><span class="line">     *          an error; otherwise the I&#x2F;O exception that caused the iteration</span><br><span class="line">     *          of the directory to complete prematurely</span><br><span class="line">     *</span><br><span class="line">     * @return  the visit result</span><br><span class="line">     *</span><br><span class="line">     * @throws  IOException</span><br><span class="line">     *          if an I&#x2F;O error occurs</span><br><span class="line">     *&#x2F;</span><br><span class="line">    FileVisitResult postVisitDirectory(T dir, IOException exc)</span><br><span class="line">        throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口上面定义的方法表示了遍历文件的关键过程，允许在文件被访问、目录被访问、目录已被访问、放生错误过程中进行控制整个流程。调用接口中的方法，会返回访问结果FileVisitResult对象值，用于决定当前操作完成后接下来该如何处理。FileVisitResult的标准返回值存放到枚举类型中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public enum FileVisitResult &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Continue. When returned from a &#123;@link FileVisitor#preVisitDirectory</span><br><span class="line">     * preVisitDirectory&#125; method then the entries in the directory should also</span><br><span class="line">     * be visited.</span><br><span class="line">     *&#x2F;</span><br><span class="line">     &#x2F;&#x2F;当前的遍历过程将会继续</span><br><span class="line">    CONTINUE,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Terminate.</span><br><span class="line">     *&#x2F;</span><br><span class="line">     &#x2F;&#x2F;表示当前的遍历过程将会停止</span><br><span class="line">    TERMINATE,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Continue without visiting the entries in this directory. This result</span><br><span class="line">     * is only meaningful when returned from the &#123;@link</span><br><span class="line">     * FileVisitor#preVisitDirectory preVisitDirectory&#125; method; otherwise</span><br><span class="line">     * this result type is the same as returning &#123;@link #CONTINUE&#125;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">     &#x2F;&#x2F;当前的遍历过程将会继续，但是要忽略当前目录下的所有节点</span><br><span class="line">    SKIP_SUBTREE,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Continue without visiting the &lt;em&gt;siblings&lt;&#x2F;em&gt; of this file or directory.</span><br><span class="line">     * If returned from the &#123;@link FileVisitor#preVisitDirectory</span><br><span class="line">     * preVisitDirectory&#125; method then the entries in the directory are also</span><br><span class="line">     * skipped and the &#123;@link FileVisitor#postVisitDirectory postVisitDirectory&#125;</span><br><span class="line">     * method is not invoked.</span><br><span class="line">     *&#x2F;</span><br><span class="line">     &#x2F;&#x2F;当前的遍历过程将会继续，但是要忽略当前文件&#x2F;目录的兄弟节点</span><br><span class="line">    SKIP_SIBLINGS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-Spring中的BeanDefinitionVisitor类"><a href="#2-2-Spring中的BeanDefinitionVisitor类" class="headerlink" title="2.2 Spring中的BeanDefinitionVisitor类"></a>2.2 Spring中的BeanDefinitionVisitor类</h2><p>在Spring的Ioc中有个BeanDefinitionVisitor类，它有一个visitBeanDefinition()方法，看下源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void visitBeanDefinition(BeanDefinition beanDefinition) &#123;</span><br><span class="line">	visitParentName(beanDefinition);</span><br><span class="line">	visitBeanClassName(beanDefinition);</span><br><span class="line">	visitFactoryBeanName(beanDefinition);</span><br><span class="line">	visitFactoryMethodName(beanDefinition);</span><br><span class="line">	visitScope(beanDefinition);</span><br><span class="line">	if (beanDefinition.hasPropertyValues()) &#123;</span><br><span class="line">		visitPropertyValues(beanDefinition.getPropertyValues());</span><br><span class="line">	&#125;</span><br><span class="line">	if (beanDefinition.hasConstructorArgumentValues()) &#123;</span><br><span class="line">		ConstructorArgumentValues cas &#x3D; beanDefinition.getConstructorArgumentValues();</span><br><span class="line">		visitIndexedArgumentValues(cas.getIndexedArgumentValues());</span><br><span class="line">		visitGenericArgumentValues(cas.getGenericArgumentValues());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在其方法中分别访问了其它的数据，比如父类的名字、自己的类名、在Ioc容器中的名称等各种信息。</p>
<h1 id="三、访问者模式的优缺点"><a href="#三、访问者模式的优缺点" class="headerlink" title="三、访问者模式的优缺点"></a>三、访问者模式的优缺点</h1><p>优点</p>
<ul>
<li>解耦了数据结构与数据操作，使得操作集合可以独立变化；</li>
<li>扩展性好：可以通过扩展访问者角色，实现对数据集的不同操作；</li>
<li>元素具体类型并非单一，访问者均可操作；</li>
<li>各角色职责分离，符合单一职责原则。</li>
</ul>
<p>缺点</p>
<ul>
<li>无法增加元素类型：若系统数据结构对象另于变化，经常有新的数据对象增加进来，则访问者类必须增加对应元素类型的操作，违背了开闭原则。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/03/30/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E6%9C%80%E4%B8%BA%E5%A4%8D%E6%9D%82%E7%9A%84%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="cke9cjzdw000sf5ra8ytjds22" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，被誉为摩斯密码的解释器模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/27/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E8%A2%AB%E8%AA%89%E4%B8%BA%E6%91%A9%E6%96%AF%E5%AF%86%E7%A0%81%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-03-27T06:26:08.000Z" itemprop="datePublished">2020-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/27/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E8%A2%AB%E8%AA%89%E4%B8%BA%E6%91%A9%E6%96%AF%E5%AF%86%E7%A0%81%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，被誉为摩斯密码的解释器模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>解释器模式（Interpreter Pattern）是指给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。是一种按照规定语法进行解析的模式。</p>
<p>就比如编译器可以将源码编译解释为机器码，让CPU能进行识别并运行。解释器模式的作用其实与编译器一样，都是将一些固定的文法（即语法）进行解释，构建出一个解释句子的解释器。简单理解，解释器是一个简单语法分析工具，它可以识别句子语义，分离终结符号和非终结符号，提取出需要的信息，让我们能针对不同的信息做出相应的处理。其核心思想是识别文法，构建解释。</p>
<h1 id="一、解释器模式的应用场景"><a href="#一、解释器模式的应用场景" class="headerlink" title="一、解释器模式的应用场景"></a>一、解释器模式的应用场景</h1><p>其中我们每天都生活在解释器模式中，平时所听到的音乐都可以通过简谱记录下来；还有战争年代发明的摩尔斯密码（又称为摩斯密码，Morse code），其实也是一种解释器。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/25/171103af69c610c0?w=580&h=435&f=png&s=103295" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/3/25/171103b4545d7c3a?w=287&h=270&f=png&s=51822" alt=""></p>
<p>我们在程序中，如果存在一种特定类型的问题，该类型问题涉及多个不同实例，但是具备固定文法描述，那么可以使用解释器模式对该类型问题进行解释，分离出需要的信息，根据获取的信息做出相应的处理。简而言之，对于一些固定文法构建一个解释句子的解释器。解释器模式适用于以下应用场景：</p>
<ul>
<li>一些重复出现的问题可以用一种简单的语言来进行表达；</li>
<li>一个简单语法需要解释的场景。</li>
</ul>
<p>解释器模式主要包含4种角色：</p>
<ul>
<li><p>抽象表达式（Expression）：负责定义一个解释方法interpret，交由具体子类进行具体解释；</p>
</li>
<li><p>终结符表达式（TerminalExpression）：实现文法中与终结符有关的解释操作。文法中的每一个终结符都有一个具体终结表达式与之相对应，比如公式R=R1+R2，R1和R2就是终结符对应的解析R1和R2的解释器就是终结符表达式。通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符（R1，R2）；</p>
</li>
<li><p>非终结符表达式（NonterminalExpression）：实现文法中与非终结符有关的解释操作。文法中的每条规则都对应于一个非终结符表达式。非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，”+”就是非终结符，解析“+“的解释器就是一个非终结符表达式。非终结符表达式根据逻辑的复杂程度而增加原则上每个文法规则都对应一个非终结符表达式；</p>
</li>
<li><p>上下文环境类（Context）：包含解释器之外的全局信息。它的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，给R1赋值100，给R2赋值200，这些信息需要存放到环境中。</p>
</li>
</ul>
<h2 id="使用解释器模式解析数据表达式"><a href="#使用解释器模式解析数据表达式" class="headerlink" title="使用解释器模式解析数据表达式"></a>使用解释器模式解析数据表达式</h2><p>用解释器模式来实现一个数学表达式计算器，包含加减乘除四种运算能力。</p>
<p>首先定义抽象表达式角色接口IArithmeticInterpreter：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface IArithmeticInterpreter &#123;</span><br><span class="line"></span><br><span class="line">    int interpret();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建终结者表达式角色Interpreter抽象类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Interpreter implements IArithmeticInterpreter &#123;</span><br><span class="line"></span><br><span class="line">    protected IArithmeticInterpreter left;</span><br><span class="line">    protected IArithmeticInterpreter right;</span><br><span class="line"></span><br><span class="line">    public Interpreter(IArithmeticInterpreter left, IArithmeticInterpreter right) &#123;</span><br><span class="line">        this.left &#x3D; left;</span><br><span class="line">        this.right &#x3D; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别创建非终结表达式角色加、减、乘、除4个解释器，加法运算表达式AddInterpreter类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class AddInterpreter extends Interpreter &#123;</span><br><span class="line">    public AddInterpreter(IArithmeticInterpreter left, IArithmeticInterpreter right) &#123;</span><br><span class="line">        super(left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int interpret() &#123;</span><br><span class="line">        return this.left.interpret() + this.right.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建减法运算表达式SubInterpreter类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class SubInterpreter extends Interpreter &#123;</span><br><span class="line">    public SubInterpreter(IArithmeticInterpreter left, IArithmeticInterpreter right) &#123;</span><br><span class="line">        super(left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int interpret() &#123;</span><br><span class="line">        return this.left.interpret() - this.right.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建乘法运算表达式MultiInterpreter类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MultiInterpreter extends Interpreter &#123;</span><br><span class="line">    public MultiInterpreter(IArithmeticInterpreter left, IArithmeticInterpreter right) &#123;</span><br><span class="line">        super(left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int interpret() &#123;</span><br><span class="line">        return this.left.interpret() * this.right.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建除法运算表达式DivInterpreter类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class DivInterpreter extends Interpreter &#123;</span><br><span class="line">    public DivInterpreter(IArithmeticInterpreter left, IArithmeticInterpreter right) &#123;</span><br><span class="line">        super(left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int interpret() &#123;</span><br><span class="line">        return this.left.interpret() &#x2F; this.right.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建数学表达式NumInterpreter类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class NumInterpreter implements IArithmeticInterpreter &#123;</span><br><span class="line"></span><br><span class="line">    private int value;</span><br><span class="line"></span><br><span class="line">    public NumInterpreter(int value) &#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int interpret() &#123;</span><br><span class="line">        return this.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建工具OperatorUtil类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class OperatorUtil &#123;</span><br><span class="line"></span><br><span class="line">    public static boolean isOperator(String symbol) &#123;</span><br><span class="line">        return (symbol.equals(&quot;+&quot;) || symbol.equals(&quot;-&quot;) || symbol.equals(&quot;*&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Interpreter getInterpreter(IArithmeticInterpreter left,</span><br><span class="line">                                             IArithmeticInterpreter right, String symbol) &#123;</span><br><span class="line">        if(symbol.equals(&quot;+&quot;)) &#123;</span><br><span class="line">            return new AddInterpreter(left, right);</span><br><span class="line">        &#125;else if(symbol.equals(&quot;-&quot;)) &#123;</span><br><span class="line">            return new SubInterpreter(left, right);</span><br><span class="line">        &#125;else if(symbol.equals(&quot;*&quot;)) &#123;</span><br><span class="line">            return new MultiInterpreter(left, right);</span><br><span class="line">        &#125;else if(symbol.equals(&quot;&#x2F;&quot;)) &#123;</span><br><span class="line">            return new DivInterpreter(left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建计算器Calculator类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class Calculator &#123;</span><br><span class="line"></span><br><span class="line">    private Stack&lt;IArithmeticInterpreter&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public Calculator(String experssion) &#123;</span><br><span class="line">        parse(experssion);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void parse(String expression) &#123;</span><br><span class="line">        String[] elements &#x3D; expression.split(&quot; &quot;);</span><br><span class="line">        IArithmeticInterpreter left, right;</span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; 0; i &lt; elements.length; i++) &#123;</span><br><span class="line">            String operator &#x3D; elements[i];</span><br><span class="line">            if(OperatorUtil.isOperator(operator)) &#123;</span><br><span class="line">                left &#x3D; this.stack.pop();</span><br><span class="line">                right &#x3D; new NumInterpreter(Integer.valueOf(elements[++i]));</span><br><span class="line">                System.out.println(&quot;出栈：&quot; + left.interpret() + &quot;和&quot; + right.interpret());</span><br><span class="line">                this.stack.push(OperatorUtil.getInterpreter(left, right, operator));</span><br><span class="line">                System.out.println(&quot;应用运算符：&quot; + operator);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                NumInterpreter numInterpreter &#x3D; new NumInterpreter(Integer.valueOf(elements[i]));</span><br><span class="line">                this.stack.push(numInterpreter);</span><br><span class="line">                System.out.println(&quot;入栈：&quot; + numInterpreter.interpret());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int calculate() &#123;</span><br><span class="line">        return this.stack.pop().interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    System.out.println(&quot;测试结果是：&quot; + new Calculator(&quot;18 - 12&quot;).calculate());</span><br><span class="line">    System.out.println(&quot;测试结果是：&quot; + new Calculator(&quot;18 + 12&quot;).calculate());</span><br><span class="line">    System.out.println(&quot;测试结果是：&quot; + new Calculator(&quot;18 * 2 + 12 - 6&quot;).calculate());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/3/27/1711a82c4985c352?w=723&h=735&f=png&s=42721" alt=""></p>
<h1 id="二、解释器模式在源码中的体现"><a href="#二、解释器模式在源码中的体现" class="headerlink" title="二、解释器模式在源码中的体现"></a>二、解释器模式在源码中的体现</h1><h2 id="2-1-正则表达式编译和继续Pattern类"><a href="#2-1-正则表达式编译和继续Pattern类" class="headerlink" title="2.1 正则表达式编译和继续Pattern类"></a>2.1 正则表达式编译和继续Pattern类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private Pattern(String p, int f) &#123;</span><br><span class="line">    pattern &#x3D; p;</span><br><span class="line">    flags &#x3D; f;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; to use UNICODE_CASE if UNICODE_CHARACTER_CLASS present</span><br><span class="line">    if ((flags &amp; UNICODE_CHARACTER_CLASS) !&#x3D; 0)</span><br><span class="line">        flags |&#x3D; UNICODE_CASE;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Reset group index count</span><br><span class="line">    capturingGroupCount &#x3D; 1;</span><br><span class="line">    localCount &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    if (pattern.length() &gt; 0) &#123;</span><br><span class="line">        compile();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        root &#x3D; new Start(lastAccept);</span><br><span class="line">        matchRoot &#x3D; lastAccept;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Pattern compile(String regex) &#123;</span><br><span class="line">    return new Pattern(regex, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Pattern compile(String regex, int flags) &#123;</span><br><span class="line">    return new Pattern(regex, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-Spring中的ExpressionParser接口"><a href="#2-2-Spring中的ExpressionParser接口" class="headerlink" title="2.2 Spring中的ExpressionParser接口"></a>2.2 Spring中的ExpressionParser接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface ExpressionParser &#123;</span><br><span class="line">    Expression parseExpression(String expressionString) throws ParseException;</span><br><span class="line"></span><br><span class="line">    Expression parseExpression(String expressionString, ParserContext context) throws ParseException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、解释器模式的优缺点"><a href="#三、解释器模式的优缺点" class="headerlink" title="三、解释器模式的优缺点"></a>三、解释器模式的优缺点</h1><p>优点：</p>
<ul>
<li>扩展性强在解释器模式中由于语法是由很多类表示的，当语法规则更改时，只需修改相应的非终结符表达式即可；若扩展语法时，只需添加相应非终结符类即可；</li>
<li>增加了新的解释表达式的方式；</li>
<li>于实现文法解释器模式对应的文法应当是比较简单目易于实现的，过于复杂的语法并不适合使用解释器模式。</li>
</ul>
<p>缺点：</p>
<ul>
<li>语法规则较复杂时，会引起类膨胀：解释器模式每个语法都要产生一个非终结符表达式，当浯法规则比较复杂时，就会产生大量的解释类，增加系统维护困难；</li>
<li>执行效率比较低解释器模式采用递归调用方法，每个菲终结符表达式只关心与自己有关的表达式，每个表达式需要知道最终的结果，因此完整表达式的最终结果是通过从后往前递归调用的方式获取得到。当完整表达式层级较深时，解释效率下降，且出错时调试困难，因为递归迭代层级太深。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/03/27/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E8%A2%AB%E8%AA%89%E4%B8%BA%E6%91%A9%E6%96%AF%E5%AF%86%E7%A0%81%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="cke9cjzdl000of5rahgzkbz8m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，不需要中间商赚差价的中介者模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/25/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E4%B8%8D%E9%9C%80%E8%A6%81%E4%B8%AD%E9%97%B4%E5%95%86%E8%B5%9A%E5%B7%AE%E4%BB%B7%E7%9A%84%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-03-25T05:21:57.000Z" itemprop="datePublished">2020-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/25/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E4%B8%8D%E9%9C%80%E8%A6%81%E4%B8%AD%E9%97%B4%E5%95%86%E8%B5%9A%E5%B7%AE%E4%BB%B7%E7%9A%84%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，不需要中间商赚差价的中介者模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>中介者模式（Mediator Pattern）又称为调解者模式或者调停者模式。用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地互相作用，从而使其松散耦合，而且可以独立的改变他们之间的交互。</p>
<p>中介者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。当某些对象之间的作用发生改变时，不会立即影响其它的一些对象之间的作用。保证这些作用可以彼此独立的变化。其核心思想是，通过中介者解耦系统各层次对象的直接耦合，层次对象的对外依赖通信统统交由中介者转发。</p>
<h1 id="一、中介者模式的应用场景"><a href="#一、中介者模式的应用场景" class="headerlink" title="一、中介者模式的应用场景"></a>一、中介者模式的应用场景</h1><p>在现实生活中，中介者的存在是不可缺少的，如果没有了中介者，我们就不能与远方的朋友进行交流了。各个对象将会互相进行引用，如果每个对象都与多个对象进行交互时，将会形成如下图所示的网状结构。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/25/1710fac9b4f6a8df?w=603&h=432&f=png&s=44219" alt=""></p>
<p>从上面的图可以发现，每个对象之间过度耦合，这样既不利于信息的复用也不利于扩展。如果引入了中介者模式，那么对象之间的关系将变为星状结构，采用中介者模式后如下图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/25/1710fac782e44b8d?w=582&h=567&f=png&s=43118" alt=""></p>
<p>引入中介者模式后，任何一个类的变化，只会影响中介者合类本身，之前的设计是任何一个类的变化都会引起其关联所有类的变化。这样的设计减少了系统的耦合度。</p>
<p>其实在我们日常生活中每天在刷的微信朋友圈，就是一个中介者。还有信息交易平台，也是中介者模式的体现。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/25/1710fb1bc3473ecf?w=500&h=400&f=png&s=149052" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/25/1710fb27716e6c1a?w=640&h=425&f=png&s=287081" alt=""></p>
<p>中介者模式是用来降低多个对象和类之间的通信复杂性。这种模式通过提供一个中介类，将系统各层次对象间的多对多关系变成一对多关系，中介者对象可以将复杂的网状结构变成以调停者为中心的星形结构，达到降低系统的复杂性，提高可扩展性的作用。</p>
<p>若系统各层次对象之间存在大量的关联关系，即层次对象呈复杂的网状结构，如果直接让它们紧耦合通信，会造成系统结构变得异常复杂，且其中某个层次对象发生改变，则与其紧耦合的相应层次对象也需进行修改，系统很难进行维护。而通过为该系统增加一个中介者层次对象让其他各层次需对外通信的行为统统交由中介者进行转发，系统呈现以中介者为中心进行通讯的星形结构，系统的复杂性大大降低。</p>
<p>简单的说如果多个类相互耦合，形成了网状结构，则需要考虑使用中介者模式进行优化处理。中介者模式适用以下几个场景：</p>
<ul>
<li>系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解；</li>
<li>交互的公共行为，如果需要改变行为则可以新增新的中介者类。</li>
</ul>
<p>中介者模式主要包含4个角色：</p>
<ul>
<li>抽象中介者（Mediator）：定义统一的接口，用户各个同事角色间的通讯；</li>
<li>具体中介者（ConcreateMediator）：从具体的同事对象接收消息，协调各同事对象间的协作；</li>
<li>抽象同事类（Colleague）：每一个同事对象均需要依赖中介者角色，与其他同事通信时，交由中介者进行转发；</li>
<li>具体同事类（ConcreteColleague）：负责实现自发行为（Self-Method），转发依赖方法（Dep-Method）交由中介者进行协调。</li>
</ul>
<h2 id="1-1-简易聊天室系统使用中介者模式"><a href="#1-1-简易聊天室系统使用中介者模式" class="headerlink" title="1.1 简易聊天室系统使用中介者模式"></a>1.1 简易聊天室系统使用中介者模式</h2><p>假设我们要构建一个聊天室系统，用户可以向聊天室发送消息，聊天室会向所有的用户显示消息。实际上就是用户发信息与聊天室显示的通信过程，不过用户无法直接将信息发给聊天室，而是需要将信息先发到服务器上，然后服务器再将该消息发给聊天室进行显示。具体代码如下。</p>
<p>创建User类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private ChatRoom chatRoom;</span><br><span class="line"></span><br><span class="line">    public User(String name, ChatRoom chatRoom) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.chatRoom &#x3D; chatRoom;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sendMsg(String msg) &#123;</span><br><span class="line">        chatRoom.showMsg(this, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建聊天室ChatRoom类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ChatRoom &#123;</span><br><span class="line"></span><br><span class="line">    public void showMsg(User user, String msg) &#123;</span><br><span class="line">        System.out.println(&quot;[&quot; + user.getName() + &quot;] ：&quot; + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    ChatRoom chatRoom &#x3D; new ChatRoom();</span><br><span class="line"></span><br><span class="line">    User kevin &#x3D; new User(&quot;Kevin&quot;, chatRoom);</span><br><span class="line">    User jhon &#x3D; new User(&quot;Jhon&quot;, chatRoom);</span><br><span class="line">    kevin.sendMsg(&quot;Hello, Jhon!&quot;);</span><br><span class="line">    jhon.sendMsg(&quot;Hi, Kevin!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/25/1710fd1ef6a080cd?w=480&h=213&f=png&s=11682" alt=""></p>
<h1 id="二、中介者模式在源码中的体现"><a href="#二、中介者模式在源码中的体现" class="headerlink" title="二、中介者模式在源码中的体现"></a>二、中介者模式在源码中的体现</h1><p><strong>JDK中的Timer类</strong><br>打开Timer类的结构图我们发现Timer类中有很多schedule()方法重载，如下图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/25/1710fd58032837db?w=609&h=612&f=png&s=56835" alt=""></p>
<p>任意点开其中的一个方法，发现所有的方法最终都是调用了私有的sched()方法，看下它们的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> private void sched(TimerTask task, long time, long period) &#123;</span><br><span class="line">    if (time &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal execution time.&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Constrain value of period sufficiently to prevent numeric</span><br><span class="line">    &#x2F;&#x2F; overflow while still being effectively infinitely large.</span><br><span class="line">    if (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; 1))</span><br><span class="line">        period &gt;&gt;&#x3D; 1;</span><br><span class="line"></span><br><span class="line">    synchronized(queue) &#123;</span><br><span class="line">        if (!thread.newTasksMayBeScheduled)</span><br><span class="line">            throw new IllegalStateException(&quot;Timer already cancelled.&quot;);</span><br><span class="line"></span><br><span class="line">        synchronized(task.lock) &#123;</span><br><span class="line">            if (task.state !&#x3D; TimerTask.VIRGIN)</span><br><span class="line">                throw new IllegalStateException(</span><br><span class="line">                    &quot;Task already scheduled or cancelled&quot;);</span><br><span class="line">            task.nextExecutionTime &#x3D; time;</span><br><span class="line">            task.period &#x3D; period;</span><br><span class="line">            task.state &#x3D; TimerTask.SCHEDULED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue.add(task);</span><br><span class="line">        if (queue.getMin() &#x3D;&#x3D; task)</span><br><span class="line">            queue.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不管什么样的任务都加入到一个队列中顺序执行。把这个队列中所有的对象称之为“同事”。同事之间通过Timer来协调完成，Timer承担了中介者的角色。</p>
<h1 id="三、中介者模式的优缺点"><a href="#三、中介者模式的优缺点" class="headerlink" title="三、中介者模式的优缺点"></a>三、中介者模式的优缺点</h1><p>优点</p>
<ul>
<li>减少类间依赖，将多对多依赖转化成了一对多，降低了类间耦合；</li>
<li>类间各司其职，符合迪米特法则。</li>
</ul>
<p>缺点</p>
<ul>
<li>中介者模式中将原本多个对象直接的相互依赖变成了中介者和多个同事类的依赖关系。当同事类越多时，中介者就会越臃肿，变得复杂且难以维护。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/03/25/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E4%B8%8D%E9%9C%80%E8%A6%81%E4%B8%AD%E9%97%B4%E5%95%86%E8%B5%9A%E5%B7%AE%E4%BB%B7%E7%9A%84%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="cke9cjzbv0002f5ra64gn4iqq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，参与富文本编辑器开发的备忘录模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/22/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%8F%82%E4%B8%8E%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E5%BC%80%E5%8F%91%E7%9A%84%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-03-22T05:01:35.000Z" itemprop="datePublished">2020-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/22/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%8F%82%E4%B8%8E%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E5%BC%80%E5%8F%91%E7%9A%84%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，参与富文本编辑器开发的备忘录模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>备忘录模式（Memento Pattern）又称为快照模式（Snapshot Pattern）或者令牌模式（Token Pattern），是指在不破坏封装的前提下，捕获一个内部状态，并在对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p>
<p>在软件系统中，备忘录模式为我们提供了一种“<strong>后悔药</strong>”的机制，它通过存储系统各个历史状态的快照，使得我们可以在任意时刻将系统回滚到某一个历史状态。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/22/171002812f09c741?w=500&h=375&f=png&s=24408" alt=""></p>
<h1 id="一、备忘录模式的应用场景"><a href="#一、备忘录模式的应用场景" class="headerlink" title="一、备忘录模式的应用场景"></a>一、备忘录模式的应用场景</h1><p>我们机会天天都在使用备忘录模式，比如使用Git、SVN提供一种代码版本撤回的功能。还有游戏的存档功能，通过将游戏当前进度存储到本地文件系统或数据库中，使得下次继续游戏时，玩家可以从之前的位置继续进行。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/22/1710023437ec7aba?w=862&h=640&f=png&s=587660" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/3/22/1710020e9a571dc6?w=898&h=568&f=png&s=919989" alt=""></p>
<p>备忘录模式适用于以下两个场景：</p>
<ul>
<li>需要保存历史快照的场景；</li>
<li>希望在对象之外保存状态，且除了自己其它类对象无法访问状态保存具体内容。</li>
</ul>
<p>备忘录模式主要包含三种角色：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/22/171004323610cfc2?w=667&h=616&f=png&s=35027" alt=""></p>
<ul>
<li>发起人角色（Orgainator）：负责创建一个备忘录，记录自身需要保存的状态，具备状态回滚功能；</li>
<li>备忘录角色（Memento）：用于存储发起人的内部状态，且可以防止发起人以外的对象进行访问；</li>
<li>备忘录管理员（Caretaker）：负责存储，提供管理备忘录，无法对备忘录内容进行操作和访问。</li>
</ul>
<h2 id="1-1-利用压栈管理落地备忘录模式"><a href="#1-1-利用压栈管理落地备忘录模式" class="headerlink" title="1.1 利用压栈管理落地备忘录模式"></a>1.1 利用压栈管理落地备忘录模式</h2><p>我们在网页上写文章或者博客都使用过富文本编辑器，它会附带草稿箱、撤销等这样的功能。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/22/17100457db7f8162?w=1330&h=628&f=png&s=46599" alt=""></p>
<p>下面使用代码来实现这样的功能。假设我们需要发布一篇文章，这篇文章的编辑过程需要花很长的时间，编辑的过程中会不停的撤销，保存草稿、修改。首先创建发起人角色编辑器 Editor 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class Editor &#123;</span><br><span class="line"></span><br><span class="line">    private String title;</span><br><span class="line"></span><br><span class="line">    private String content;</span><br><span class="line"></span><br><span class="line">    private String imgs;</span><br><span class="line"></span><br><span class="line">    public Editor(String title, String content, String imgs) &#123;</span><br><span class="line">        this.title &#x3D; title;</span><br><span class="line">        this.content &#x3D; content;</span><br><span class="line">        this.imgs &#x3D; imgs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ArticleMemento save2Memento() &#123;</span><br><span class="line">        ArticleMemento articleMemento &#x3D;</span><br><span class="line">                new ArticleMemento(this.title, this.content, this.imgs);</span><br><span class="line">        return articleMemento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void undoFromMemento(ArticleMemento articleMemento) &#123;</span><br><span class="line">        this.title &#x3D; articleMemento.getTitle();</span><br><span class="line">        this.content &#x3D; articleMemento.getContent();</span><br><span class="line">        this.imgs &#x3D; articleMemento.getImgs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getTitle() &#123;</span><br><span class="line">        return title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTitle(String title) &#123;</span><br><span class="line">        this.title &#x3D; title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getContent() &#123;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setContent(String content) &#123;</span><br><span class="line">        this.content &#x3D; content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getImgs() &#123;</span><br><span class="line">        return imgs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setImgs(String imgs) &#123;</span><br><span class="line">        this.imgs &#x3D; imgs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Editor&#123;&quot; +</span><br><span class="line">                &quot;title&#x3D;&#39;&quot; + title + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, content&#x3D;&#39;&quot; + content + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, imgs&#x3D;&#39;&quot; + imgs + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后创建备忘录角色 ArticleMemento 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class ArticleMemento &#123;</span><br><span class="line"></span><br><span class="line">    private String title;</span><br><span class="line"></span><br><span class="line">    private String content;</span><br><span class="line"></span><br><span class="line">    private String imgs;</span><br><span class="line"></span><br><span class="line">    public ArticleMemento(String title, String content, String imgs) &#123;</span><br><span class="line">        this.title &#x3D; title;</span><br><span class="line">        this.content &#x3D; content;</span><br><span class="line">        this.imgs &#x3D; imgs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getTitle() &#123;</span><br><span class="line">        return title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTitle(String title) &#123;</span><br><span class="line">        this.title &#x3D; title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getContent() &#123;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setContent(String content) &#123;</span><br><span class="line">        this.content &#x3D; content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getImgs() &#123;</span><br><span class="line">        return imgs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setImgs(String imgs) &#123;</span><br><span class="line">        this.imgs &#x3D; imgs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;ArticleMemento&#123;&quot; +</span><br><span class="line">                &quot;title&#x3D;&#39;&quot; + title + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, content&#x3D;&#39;&quot; + content + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, imgs&#x3D;&#39;&quot; + imgs + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建备忘录管理角色草稿箱 DraftBox 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class DraftBox &#123;</span><br><span class="line"></span><br><span class="line">    private final Stack&lt;ArticleMemento&gt; STACK &#x3D; new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public ArticleMemento getMemento() &#123;</span><br><span class="line">        ArticleMemento articleMemento &#x3D; STACK.pop();</span><br><span class="line">        return articleMemento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addMemento(ArticleMemento articleMemento) &#123;</span><br><span class="line">        STACK.push(articleMemento);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>草稿箱的Stack类是Vector的一个子类，它实现了一个标准的后进先出的栈。</p>
<h1 id="二、备忘录模式在源码中的体现"><a href="#二、备忘录模式在源码中的体现" class="headerlink" title="二、备忘录模式在源码中的体现"></a>二、备忘录模式在源码中的体现</h1><p>备忘录模式在框架源码中的应用还是比较少见的，主要还是结合具体的应用场景来使用。spring中的webfolw源码<strong>StateManageableMessageContext</strong>接口，我们来看它的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public interface StateManageableMessageContext extends MessageContext &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Create a serializable memento, or token representing a snapshot of the internal state of this message context.</span><br><span class="line">	 * @return the messages memento</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public Serializable createMessagesMemento();</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Set the state of this context from the memento provided. After this call, the messages in this context will match</span><br><span class="line">	 * what is encapsulated inside the memento. Any previous state will be overridden.</span><br><span class="line">	 * @param messagesMemento the messages memento</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void restoreMessages(Serializable messagesMemento);</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Configure the message source used to resolve messages added to this context. May be set at any time to change how</span><br><span class="line">	 * coded messages are resolved.</span><br><span class="line">	 * @param messageSource the message source</span><br><span class="line">	 * @see MessageContext#addMessage(MessageResolver)</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void setMessageSource(MessageSource messageSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createMessagesMemento()创建一个消息备忘录。可以看一下实现类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultMessageContext implements StateManageableMessageContext &#123;</span><br><span class="line"></span><br><span class="line">	private static final Log logger &#x3D; LogFactory.getLog(DefaultMessageContext.class);</span><br><span class="line"></span><br><span class="line">	private MessageSource messageSource;</span><br><span class="line"></span><br><span class="line">	@SuppressWarnings(&quot;serial&quot;)</span><br><span class="line">	private Map&lt;Object, List&lt;Message&gt;&gt; sourceMessages &#x3D; new AbstractCachingMapDecorator&lt;Object, List&lt;Message&gt;&gt;(</span><br><span class="line">			new LinkedHashMap&lt;Object, List&lt;Message&gt;&gt;()) &#123;</span><br><span class="line"></span><br><span class="line">		protected List&lt;Message&gt; create(Object source) &#123;</span><br><span class="line">			return new ArrayList&lt;Message&gt;();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Creates a new default message context. Defaults to a message source that simply resolves default text and cannot</span><br><span class="line">	 * resolve localized message codes.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public DefaultMessageContext() &#123;</span><br><span class="line">		init(null);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Creates a new default message context.</span><br><span class="line">	 * @param messageSource the message source to resolve messages added to this context</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public DefaultMessageContext(MessageSource messageSource) &#123;</span><br><span class="line">		init(messageSource);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public MessageSource getMessageSource() &#123;</span><br><span class="line">		return messageSource;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; implementing message context</span><br><span class="line"></span><br><span class="line">	public Message[] getAllMessages() &#123;</span><br><span class="line">		List&lt;Message&gt; messages &#x3D; new ArrayList&lt;Message&gt;();</span><br><span class="line">		for (List&lt;Message&gt; list : sourceMessages.values()) &#123;</span><br><span class="line">			messages.addAll(list);</span><br><span class="line">		&#125;</span><br><span class="line">		return messages.toArray(new Message[messages.size()]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Message[] getMessagesBySource(Object source) &#123;</span><br><span class="line">		List&lt;Message&gt; messages &#x3D; sourceMessages.get(source);</span><br><span class="line">		return messages.toArray(new Message[messages.size()]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Message[] getMessagesByCriteria(MessageCriteria criteria) &#123;</span><br><span class="line">		List&lt;Message&gt; messages &#x3D; new ArrayList&lt;Message&gt;();</span><br><span class="line">		for (List&lt;Message&gt; sourceMessages : this.sourceMessages.values()) &#123;</span><br><span class="line">			for (Message message : sourceMessages) &#123;</span><br><span class="line">				if (criteria.test(message)) &#123;</span><br><span class="line">					messages.add(message);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return messages.toArray(new Message[messages.size()]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public boolean hasErrorMessages() &#123;</span><br><span class="line">		for (List&lt;Message&gt; sourceMessages : this.sourceMessages.values()) &#123;</span><br><span class="line">			for (Message message : sourceMessages) &#123;</span><br><span class="line">				if (message.getSeverity() &#x3D;&#x3D; Severity.ERROR) &#123;</span><br><span class="line">					return true;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void addMessage(MessageResolver messageResolver) &#123;</span><br><span class="line">		Locale currentLocale &#x3D; LocaleContextHolder.getLocale();</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Resolving message using &quot; + messageResolver);</span><br><span class="line">		&#125;</span><br><span class="line">		Message message &#x3D; messageResolver.resolveMessage(messageSource, currentLocale);</span><br><span class="line">		List&lt;Message&gt; messages &#x3D; sourceMessages.get(message.getSource());</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Adding resolved message &quot; + message);</span><br><span class="line">		&#125;</span><br><span class="line">		messages.add(message);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void clearMessages() &#123;</span><br><span class="line">		sourceMessages.clear();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; implementing state manageable message context</span><br><span class="line"></span><br><span class="line">	public Serializable createMessagesMemento() &#123;</span><br><span class="line">		return new LinkedHashMap&lt;Object, List&lt;Message&gt;&gt;(sourceMessages);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">	public void restoreMessages(Serializable messagesMemento) &#123;</span><br><span class="line">		sourceMessages.putAll((Map&lt;Object, List&lt;Message&gt;&gt;) messagesMemento);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setMessageSource(MessageSource messageSource) &#123;</span><br><span class="line">		if (messageSource &#x3D;&#x3D; null) &#123;</span><br><span class="line">			messageSource &#x3D; new DefaultTextFallbackMessageSource();</span><br><span class="line">		&#125;</span><br><span class="line">		this.messageSource &#x3D; messageSource;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; internal helpers</span><br><span class="line"></span><br><span class="line">	private void init(MessageSource messageSource) &#123;</span><br><span class="line">		setMessageSource(messageSource);</span><br><span class="line">		&#x2F;&#x2F; create the &#39;null&#39; source message list eagerly to ensure global messages are indexed first</span><br><span class="line">		this.sourceMessages.get(null);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return new ToStringCreator(this).append(&quot;sourceMessages&quot;, sourceMessages).toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static class DefaultTextFallbackMessageSource extends AbstractMessageSource &#123;</span><br><span class="line">		protected MessageFormat resolveCode(String code, Locale locale) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要逻辑就相当于是给Message留一个备份，以备恢复之用。</p>
<h1 id="三、备忘录模式的优缺点"><a href="#三、备忘录模式的优缺点" class="headerlink" title="三、备忘录模式的优缺点"></a>三、备忘录模式的优缺点</h1><p>优点：</p>
<ul>
<li>简化发起人职责，隔离状态存储与获取，实现了信息的封装，客户端无需关心状态的保存细节；</li>
<li>提供状态回滚功能。</li>
</ul>
<p>缺点：<br>消耗资源：如果需要保存的状态过多时，每一次保存都会消耗很多内存。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/03/22/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%8F%82%E4%B8%8E%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E5%BC%80%E5%8F%91%E7%9A%84%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="cke9cjzd6000gf5ra0t3rf153" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，参与电商订单业务开发的状态模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/21/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%8F%82%E4%B8%8E%E7%94%B5%E5%95%86%E8%AE%A2%E5%8D%95%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-03-21T06:47:29.000Z" itemprop="datePublished">2020-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/21/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%8F%82%E4%B8%8E%E7%94%B5%E5%95%86%E8%AE%A2%E5%8D%95%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，参与电商订单业务开发的状态模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>状态模式在生活场景中也是比较常见的。比如我们平时网购的订单状态变化，还有平时坐电梯，电梯状态的变化。<br><img src="https://user-gold-cdn.xitu.io/2020/3/20/170f6a106d4fecd1?w=744&h=564&f=png&s=113326" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/3/20/170f6a1e5d87254f?w=592&h=333&f=png&s=132053" alt=""></p>
<p>在软件开发过程中，对于某一项的操作，可能存在不同的情况。通常处理多情况问题最直接的办法就是使用if…else或者switch…case条件语句进行判断。这种做法对于复杂状态的判断天然存在弊端：判断条件语句过于臃肿，可读性较差，不具备扩展性，维度难度也很大。如果转换一下思维，将这些不同状态独立起来用各种不同的类进行表示，系统处理哪种情况，直接使用相应的状态类进行处理，消除条件判断语句，代码也更加具有层次感，且具备良好的扩展能力。</p>
<p>状态模式（State Pattern）也成为状态机模式（State Machine Pattern），是允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。状态模式中类的行为是由状态决定的，不同的状态下有不同的行为。其意图是让一个对象在其内部改变的时候，其行为也随之改变。状态模式的核心就是状态与行为绑定，不同的状态对应不同的行为。</p>
<h1 id="一、状态模式的应用场景"><a href="#一、状态模式的应用场景" class="headerlink" title="一、状态模式的应用场景"></a>一、状态模式的应用场景</h1><p>状态模式适用于以下几种场景：</p>
<ul>
<li>行为随状态改变而改变场景；</li>
<li>一个操作中含有庞大的多分支机构，并且这些分支取决于对象的状态。</li>
</ul>
<p>状态模式主要包含三种角色：</p>
<ul>
<li>环境类角色（Context）：定义客户端需要的接囗，内部维护一个当前状态实例，并负责具体状态的切换；</li>
<li>抽象状态角色（State）：定义该状态下的行为，可以有一个或多个行为；</li>
<li>具体状态角色（ConcreteState）：具体实现该状态对应的行为并且在需要的肩况下进行状态切换。</li>
</ul>
<h2 id="1-1-状态模式在业务场景中的应用"><a href="#1-1-状态模式在业务场景中的应用" class="headerlink" title="1.1 状态模式在业务场景中的应用"></a>1.1 状态模式在业务场景中的应用</h2><p>我们在某社区阅读文章的时候，如果觉得某篇文章写得好，就会转发、收藏并且评论。如果用户处于登录情况下，我们就可以做评论、转发、收藏这些行为。否则需要跳转到登录页面，登录之后才能执行先前的动作。那么这里涉及到的状态有两种：已登录和未登录，行为有三种：评论、转发、收藏。下面使用代码来实现这些逻辑，首先创建抽象状态角色类UserState：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public abstract class UserState &#123;</span><br><span class="line"></span><br><span class="line">    private AppContext appContext;</span><br><span class="line"></span><br><span class="line">    public void setAppContext(AppContext appContext) &#123;</span><br><span class="line">        this.appContext &#x3D; appContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void forward();</span><br><span class="line"></span><br><span class="line">    public abstract void collect();</span><br><span class="line"></span><br><span class="line">    public abstract void comment(String comment);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建登录状态LoginState类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class LoginState extends UserState &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void forward() &#123;</span><br><span class="line">        System.out.println(&quot;转发成功！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void collect() &#123;</span><br><span class="line">        System.out.println(&quot;收藏成功！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void comment(String comment) &#123;</span><br><span class="line">        System.out.println(&quot;评论成功,内容是：&quot; + comment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着创建未登录状态UnLoginState类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class UnLoginState extends UserState &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void forward() &#123;</span><br><span class="line">        forward2Login();</span><br><span class="line">        this.appContext.forward();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void collect() &#123;</span><br><span class="line">        forward2Login();</span><br><span class="line">        this.appContext.collect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void comment(String comment) &#123;</span><br><span class="line">        forward2Login();</span><br><span class="line">        this.appContext.comment(comment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void forward2Login() &#123;</span><br><span class="line">        System.out.println(&quot;跳转到登录页面！&quot;);</span><br><span class="line">        this.appContext.setState(this.appContext.LOGIN_STATE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建上下文角色AppContext类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class AppContext &#123;</span><br><span class="line"></span><br><span class="line">    public static final UserState LOGIN_STATE &#x3D; new LoginState();</span><br><span class="line"></span><br><span class="line">    public static final UserState UNLOGIN_STATE &#x3D; new UnLoginState();</span><br><span class="line"></span><br><span class="line">    private UserState currentState &#x3D; UNLOGIN_STATE;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        UNLOGIN_STATE.setAppContext(this);</span><br><span class="line">        LOGIN_STATE.setAppContext(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setState(UserState state) &#123;</span><br><span class="line">        this.currentState &#x3D; state;</span><br><span class="line">        this.currentState.setAppContext(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public UserState getState() &#123;</span><br><span class="line">        return this.currentState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void forward() &#123;</span><br><span class="line">        this.currentState.forward();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void collect() &#123;</span><br><span class="line">        this.currentState.collect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void comment(String comment) &#123;</span><br><span class="line">        this.currentState.comment(comment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">    AppContext context &#x3D; new AppContext();</span><br><span class="line">    context.forward();</span><br><span class="line">    context.collect();</span><br><span class="line">    context.comment(&quot;说的太好了，双手双脚给个赞������&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/20/170f76262cd00174?w=571&h=196&f=png&s=14631" alt=""></p>
<h2 id="1-2-利用状态机实现订单状态流转控制"><a href="#1-2-利用状态机实现订单状态流转控制" class="headerlink" title="1.2 利用状态机实现订单状态流转控制"></a>1.2 利用状态机实现订单状态流转控制</h2><p>状态机是状态模式的一种应用，相当于上下文角色的一个升级版本。在工作流或游戏等各种系统中有大量使用，比如各种工作流引擎，它几乎是状态机的子集和实现，封装状态的变化规则。Spring提供了一个很好的解决方案。Spring的组件名称就叫StateMachine（状态机）。状态机帮助开发者简化状态控制的开发过程，让状态机结构更加层次化。下面来用Spring状态机模拟一个订单状态流转的过程。</p>
<p>1、pom依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.statemachine&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-statemachine-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.1.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2、创建订单实体类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Order &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private OrderStatus status;</span><br><span class="line">    public void setStatus(OrderStatus status) &#123;</span><br><span class="line">        this.status &#x3D; status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public OrderStatus getStatus() &#123;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;订单号：&quot; + id + &quot;, 订单状态：&quot; + status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建订单状态枚举类和状态转换枚举类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 订单状态</span><br><span class="line"> *&#x2F;</span><br><span class="line">public enum OrderStatus &#123;</span><br><span class="line">    &#x2F;&#x2F; 待支付，待发货，待收货，订单结束</span><br><span class="line">    WAIT_PAYMENT, WAIT_DELIVER, WAIT_RECEIVE, FINISH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 订单状态改变事件</span><br><span class="line"> *&#x2F;</span><br><span class="line">public enum OrderStatusChangeEvent &#123;</span><br><span class="line">    &#x2F;&#x2F; 支付，发货，确认收货</span><br><span class="line">    PAYED, DELIVERY, RECEIVED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、添加状态流转配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 订单状态机配置</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">@EnableStateMachine(name &#x3D; &quot;orderStateMachine&quot;)</span><br><span class="line">public class OrderStateMachineConfig extends StateMachineConfigurerAdapter&lt;OrderStatus, OrderStatusChangeEvent&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 配置状态</span><br><span class="line">     * @param states</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void configure(StateMachineStateConfigurer&lt;OrderStatus, OrderStatusChangeEvent&gt; states) throws Exception &#123;</span><br><span class="line">        states</span><br><span class="line">                .withStates()</span><br><span class="line">                .initial(OrderStatus.WAIT_PAYMENT)</span><br><span class="line">                .states(EnumSet.allOf(OrderStatus.class));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 配置状态转换事件关系</span><br><span class="line">     * @param transitions</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void configure(StateMachineTransitionConfigurer&lt;OrderStatus, OrderStatusChangeEvent&gt; transitions) throws Exception &#123;</span><br><span class="line">        transitions</span><br><span class="line">                .withExternal().source(OrderStatus.WAIT_PAYMENT).target(OrderStatus.WAIT_DELIVER).event(OrderStatusChangeEvent.PAYED)</span><br><span class="line">                .and()</span><br><span class="line">                .withExternal().source(OrderStatus.WAIT_DELIVER).target(OrderStatus.WAIT_RECEIVE).event(OrderStatusChangeEvent.DELIVERY)</span><br><span class="line">                .and()</span><br><span class="line">                .withExternal().source(OrderStatus.WAIT_RECEIVE).target(OrderStatus.FINISH).event(OrderStatusChangeEvent.RECEIVED);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 持久化配置</span><br><span class="line">     * 实际使用中，可以配合redis等，进行持久化操作</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    public DefaultStateMachinePersister persister()&#123;</span><br><span class="line">        return new DefaultStateMachinePersister&lt;&gt;(new StateMachinePersist&lt;Object, Object, Order&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void write(StateMachineContext&lt;Object, Object&gt; context, Order order) throws Exception &#123;</span><br><span class="line">                &#x2F;&#x2F;此处并没有进行持久化操作</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            @Override</span><br><span class="line">            public StateMachineContext&lt;Object, Object&gt; read(Order order) throws Exception &#123;</span><br><span class="line">                &#x2F;&#x2F;此处直接获取order中的状态，其实并没有进行持久化读取操作</span><br><span class="line">                return new DefaultStateMachineContext(order.getStatus(), null, null, null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、添加订单状态监听器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;orderStateListener&quot;)</span><br><span class="line">@WithStateMachine(name &#x3D; &quot;orderStateMachine&quot;)</span><br><span class="line">public class OrderStateListenerImpl&#123;</span><br><span class="line"> </span><br><span class="line">    @OnTransition(source &#x3D; &quot;WAIT_PAYMENT&quot;, target &#x3D; &quot;WAIT_DELIVER&quot;)</span><br><span class="line">    public boolean payTransition(Message&lt;OrderStatusChangeEvent&gt; message) &#123;</span><br><span class="line">        Order order &#x3D; (Order) message.getHeaders().get(&quot;order&quot;);</span><br><span class="line">        order.setStatus(OrderStatus.WAIT_DELIVER);</span><br><span class="line">        System.out.println(&quot;支付，状态机反馈信息：&quot; + message.getHeaders().toString());</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @OnTransition(source &#x3D; &quot;WAIT_DELIVER&quot;, target &#x3D; &quot;WAIT_RECEIVE&quot;)</span><br><span class="line">    public boolean deliverTransition(Message&lt;OrderStatusChangeEvent&gt; message) &#123;</span><br><span class="line">        Order order &#x3D; (Order) message.getHeaders().get(&quot;order&quot;);</span><br><span class="line">        order.setStatus(OrderStatus.WAIT_RECEIVE);</span><br><span class="line">        System.out.println(&quot;发货，状态机反馈信息：&quot; + message.getHeaders().toString());</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @OnTransition(source &#x3D; &quot;WAIT_RECEIVE&quot;, target &#x3D; &quot;FINISH&quot;)</span><br><span class="line">    public boolean receiveTransition(Message&lt;OrderStatusChangeEvent&gt; message)&#123;</span><br><span class="line">        Order order &#x3D; (Order) message.getHeaders().get(&quot;order&quot;);</span><br><span class="line">        order.setStatus(OrderStatus.FINISH);</span><br><span class="line">        System.out.println(&quot;收货，状态机反馈信息：&quot; + message.getHeaders().toString());</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6、创建IOrderService接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface IOrderService &#123;</span><br><span class="line">    &#x2F;&#x2F;创建新订单</span><br><span class="line">    Order create();</span><br><span class="line">    &#x2F;&#x2F;发起支付</span><br><span class="line">    Order pay(int id);</span><br><span class="line">    &#x2F;&#x2F;订单发货</span><br><span class="line">    Order deliver(int id);</span><br><span class="line">    &#x2F;&#x2F;订单收货</span><br><span class="line">    Order receive(int id);</span><br><span class="line">    &#x2F;&#x2F;获取所有订单信息</span><br><span class="line">    Map&lt;Integer, Order&gt; getOrders();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7、在Service中添加业务逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">@Service(&quot;orderService&quot;)</span><br><span class="line">public class OrderServiceImpl implements IOrderService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StateMachine&lt;OrderStatus, OrderStatusChangeEvent&gt; orderStateMachine;</span><br><span class="line"> </span><br><span class="line">    @Autowired</span><br><span class="line">    private StateMachinePersister&lt;OrderStatus, OrderStatusChangeEvent, Order&gt; persister;</span><br><span class="line"> </span><br><span class="line">    private int id &#x3D; 1;</span><br><span class="line">    private Map&lt;Integer, Order&gt; orders &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public Order create() &#123;</span><br><span class="line">        Order order &#x3D; new Order();</span><br><span class="line">        order.setStatus(OrderStatus.WAIT_PAYMENT);</span><br><span class="line">        order.setId(id++);</span><br><span class="line">        orders.put(order.getId(), order);</span><br><span class="line">        return order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Order pay(int id) &#123;</span><br><span class="line">        Order order &#x3D; orders.get(id);</span><br><span class="line">        System.out.println(&quot;线程名称：&quot; + Thread.currentThread().getName() + &quot; 尝试支付，订单号：&quot; + id);</span><br><span class="line">        Message message &#x3D; MessageBuilder.withPayload(OrderStatusChangeEvent.PAYED).setHeader(&quot;order&quot;, order).build();</span><br><span class="line">        if (!sendEvent(message, order)) &#123;</span><br><span class="line">            System.out.println(&quot;线程名称：&quot; + Thread.currentThread().getName() + &quot; 支付失败, 状态异常，订单号：&quot; + id);</span><br><span class="line">        &#125;</span><br><span class="line">        return orders.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Order deliver(int id) &#123;</span><br><span class="line">        Order order &#x3D; orders.get(id);</span><br><span class="line">        System.out.println(&quot;线程名称：&quot; + Thread.currentThread().getName() + &quot; 尝试发货，订单号：&quot; + id);</span><br><span class="line">        if (!sendEvent(MessageBuilder.withPayload(OrderStatusChangeEvent.DELIVERY).setHeader(&quot;order&quot;, order).build(), orders.get(id))) &#123;</span><br><span class="line">            System.out.println(&quot;线程名称：&quot; + Thread.currentThread().getName() + &quot; 发货失败，状态异常，订单号：&quot; + id);</span><br><span class="line">        &#125;</span><br><span class="line">        return orders.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Order receive(int id) &#123;</span><br><span class="line">        Order order &#x3D; orders.get(id);</span><br><span class="line">        System.out.println(&quot;线程名称：&quot; + Thread.currentThread().getName() + &quot; 尝试收货，订单号：&quot; + id);</span><br><span class="line">        if (!sendEvent(MessageBuilder.withPayload(OrderStatusChangeEvent.RECEIVED).setHeader(&quot;order&quot;, order).build(), orders.get(id))) &#123;</span><br><span class="line">            System.out.println(&quot;线程名称：&quot; + Thread.currentThread().getName() + &quot; 收货失败，状态异常，订单号：&quot; + id);</span><br><span class="line">        &#125;</span><br><span class="line">        return orders.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    public Map&lt;Integer, Order&gt; getOrders() &#123;</span><br><span class="line">        return orders;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发送订单状态转换事件</span><br><span class="line">     *</span><br><span class="line">     * @param message</span><br><span class="line">     * @param order</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private synchronized boolean sendEvent(Message&lt;OrderStatusChangeEvent&gt; message, Order order) &#123;</span><br><span class="line">        boolean result &#x3D; false;</span><br><span class="line">        try &#123;</span><br><span class="line">            orderStateMachine.start();</span><br><span class="line">            &#x2F;&#x2F;尝试恢复状态机状态</span><br><span class="line">            persister.restore(orderStateMachine, order);</span><br><span class="line">            &#x2F;&#x2F;添加延迟用于线程安全测试</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            result &#x3D; orderStateMachine.sendEvent(message);</span><br><span class="line">            &#x2F;&#x2F;持久化状态机状态</span><br><span class="line">            persister.persist(orderStateMachine, order);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            orderStateMachine.stop();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    Thread.currentThread().setName(&quot;主线程&quot;);</span><br><span class="line"></span><br><span class="line">    ConfigurableApplicationContext context &#x3D; SpringApplication.run(Test.class,args);</span><br><span class="line"></span><br><span class="line">    IOrderService orderService &#x3D; (IOrderService)context.getBean(&quot;orderService&quot;);</span><br><span class="line"></span><br><span class="line">    orderService.create();</span><br><span class="line">    orderService.create();</span><br><span class="line"></span><br><span class="line">    orderService.pay(1);</span><br><span class="line"></span><br><span class="line">    new Thread(&quot;客户线程&quot;)&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            orderService.deliver(1);</span><br><span class="line">            orderService.receive(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line"></span><br><span class="line">    orderService.pay(2);</span><br><span class="line">    orderService.deliver(2);</span><br><span class="line">    orderService.receive(2);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;全部订单状态：&quot; + orderService.getOrders());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二、状态模式中的源码体现"><a href="#二、状态模式中的源码体现" class="headerlink" title="二、状态模式中的源码体现"></a>二、状态模式中的源码体现</h1><p>状态模式的具体应用在源码中非常少见，在源码中一般只是提供一种通用的解决方案。如果一定要找，当然也是能找到的。经历千辛万苦，持续烧脑，下面我们来看一个在JSF源码中的Lifecycle类。JSF也算是一个比较经典的前端框架，那么没用过的小伙伴也没关系，我们这是只是分析一下其设计思想。在JSF中它所有页面的处理分为6个阶段，被定义在了Phaseld类中用不同的常量来表示生命周期阶段，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class PhaseId implements Comparable &#123;</span><br><span class="line">    private final int ordinal;</span><br><span class="line">    private String phaseName;</span><br><span class="line">    private static int nextOrdinal &#x3D; 0;</span><br><span class="line">    private static final String ANY_PHASE_NAME &#x3D; &quot;ANY&quot;;</span><br><span class="line">    public static final PhaseId ANY_PHASE &#x3D; new PhaseId(&quot;ANY&quot;);</span><br><span class="line">    private static final String RESTORE_VIEW_NAME &#x3D; &quot;RESTORE_VIEW&quot;;</span><br><span class="line">    public static final PhaseId RESTORE_VIEW &#x3D; new PhaseId(&quot;RESTORE_VIEW&quot;);</span><br><span class="line">    private static final String APPLY_REQUEST_VALUES_NAME &#x3D; &quot;APPLY_REQUEST_VALUES&quot;;</span><br><span class="line">    public static final PhaseId APPLY_REQUEST_VALUES &#x3D; new PhaseId(&quot;APPLY_REQUEST_VALUES&quot;);</span><br><span class="line">    private static final String PROCESS_VALIDATIONS_NAME &#x3D; &quot;PROCESS_VALIDATIONS&quot;;</span><br><span class="line">    public static final PhaseId PROCESS_VALIDATIONS &#x3D; new PhaseId(&quot;PROCESS_VALIDATIONS&quot;);</span><br><span class="line">    private static final String UPDATE_MODEL_VALUES_NAME &#x3D; &quot;UPDATE_MODEL_VALUES&quot;;</span><br><span class="line">    public static final PhaseId UPDATE_MODEL_VALUES &#x3D; new PhaseId(&quot;UPDATE_MODEL_VALUES&quot;);</span><br><span class="line">    private static final String INVOKE_APPLICATION_NAME &#x3D; &quot;INVOKE_APPLICATION&quot;;</span><br><span class="line">    public static final PhaseId INVOKE_APPLICATION &#x3D; new PhaseId(&quot;INVOKE_APPLICATION&quot;);</span><br><span class="line">    private static final String RENDER_RESPONSE_NAME &#x3D; &quot;RENDER_RESPONSE&quot;;</span><br><span class="line">    public static final PhaseId RENDER_RESPONSE &#x3D; new PhaseId(&quot;RENDER_RESPONSE&quot;);</span><br><span class="line">    private static final PhaseId[] values;</span><br><span class="line">    public static final List VALUES;</span><br><span class="line"></span><br><span class="line">    private PhaseId(String newPhaseName) &#123;</span><br><span class="line">        this.ordinal &#x3D; nextOrdinal++;</span><br><span class="line">        this.phaseName &#x3D; null;</span><br><span class="line">        this.phaseName &#x3D; newPhaseName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int compareTo(Object other) &#123;</span><br><span class="line">        return this.ordinal - ((PhaseId)other).ordinal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getOrdinal() &#123;</span><br><span class="line">        return this.ordinal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return null &#x3D;&#x3D; this.phaseName ? String.valueOf(this.ordinal) : this.phaseName + &#39; &#39; + this.ordinal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        values &#x3D; new PhaseId[]&#123;ANY_PHASE, RESTORE_VIEW, APPLY_REQUEST_VALUES, PROCESS_VALIDATIONS, UPDATE_MODEL_VALUES, INVOKE_APPLICATION, RENDER_RESPONSE&#125;;</span><br><span class="line">        VALUES &#x3D; Collections.unmodifiableList(Arrays.asList(values));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这些状态的切换都在Lifecycle的execute()方、去中进行。其中会传一个参数FacesContext对象，最终所有的状态都被FacesContext保存。在此呢，我们就不做继续深入的分析。</p>
<h1 id="三、状态模式的相关模式"><a href="#三、状态模式的相关模式" class="headerlink" title="三、状态模式的相关模式"></a>三、状态模式的相关模式</h1><h2 id="3-1-状态模式与责任链模式"><a href="#3-1-状态模式与责任链模式" class="headerlink" title="3.1 状态模式与责任链模式"></a>3.1 状态模式与责任链模式</h2><p>状态模式和责任链模式都能消除if分支过多的问题。但某些情况下，状态模式中的状态可以理解为责任，那么这种情况下，两种模式都可以使用。</p>
<p>从定义来看，状态模式强调的是一个对象内在状态的改变，而责任链模式强调的是外部节点对象间的改变。</p>
<p>从其代码实现上来看，他们间最大的区别就是状态模式各个状态对象知道自己下一个要进入的状态对象而责任链模式并不清楚其下一个节点处理对象，因为链式组装由客户端负责。</p>
<h2 id="3-2-状态模式与策略模式"><a href="#3-2-状态模式与策略模式" class="headerlink" title="3.2 状态模式与策略模式"></a>3.2 状态模式与策略模式</h2><p>状态模式和策略模式的UML类图架构几乎完全一样，但他们的应用场景是不一样的。策略模式多种算法行为择其一都能满足，彼此之间是独立的用户可自行更换策略算法，而状态模式各个状态间是存在相互关系的，彼此之间在一定条件下存在自动切换状态效果，且用户无法指定状态，只能设置初始状态。</p>
<h1 id="四、状态模式的优缺点"><a href="#四、状态模式的优缺点" class="headerlink" title="四、状态模式的优缺点"></a>四、状态模式的优缺点</h1><p>优点：</p>
<ul>
<li>结构清晰：将状态独立为类，消除了冗余的if…else或switch…case语句，使代码更加简洁，提高系统可维护性；</li>
<li>将状态转换显示化通常的对象内部都是使用数值类型来定义状态，状态的切换是通过賦值进行表现，不够直观，而使用状态类，在切换状态时，是以不同的类进行表示，转换目的更加明确；</li>
<li>状态类职责明确且具备扩展性。</li>
</ul>
<p>缺点：</p>
<ul>
<li>类膨胀：如果一个事物具备很多状态，则会造成状态类太多；</li>
<li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱；</li>
<li>状态模式对开闭原则的支持并不太好，对于可以切换状态的状态模式增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/03/21/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%8F%82%E4%B8%8E%E7%94%B5%E5%95%86%E8%AE%A2%E5%8D%95%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="cke9cjzdy000uf5ra1wrr1o9g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，熟悉电脑中的操作系统的命令模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/21/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E7%86%9F%E6%82%89%E7%94%B5%E8%84%91%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-03-21T05:39:43.000Z" itemprop="datePublished">2020-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/21/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E7%86%9F%E6%82%89%E7%94%B5%E8%84%91%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，熟悉电脑中的操作系统的命令模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>早期的黑白电视机要换台那简直是很不容易，需要跑到电视机前面扳动上面那个切换频道的按钮，一顿折腾下来才能完成一次换台。现如今，我们只需要躺在沙发上按一下遥控器的按钮就可以轻松的躺在沙发上完成一次次的换台了。这里就使用了命令模式，将换台命令和换台处理进行了分离。<br><img src="https://user-gold-cdn.xitu.io/2020/3/19/170f1c65648d2586?w=500&h=333&f=png&s=272912" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/3/19/170f1c6d7af5b576?w=500&h=313&f=png&s=147120" alt=""></p>
<p>还有就是餐厅的点菜单，一般是后厨先把所有的原材料组合配置好了，客户需要用餐只需要点菜即可，将需求和处理进行了解耦。<br><img src="https://user-gold-cdn.xitu.io/2020/3/19/170f2a4fa66acb0c?w=1024&h=539&f=png&s=882436" alt=""></p>
<p>命令模式（Command Pattern）是对命令的封装，每一个命令都是操作：请求一方发出请求要求执行一个操作；接收一方收到请求，并执行操作。命名模式解耦了请求方和接收方，请求方只需要请求执行命令，不用关系命令是怎样被接收，怎样被操作以及是否被执行等等。</p>
<h1 id="一、命令模式的应用场景"><a href="#一、命令模式的应用场景" class="headerlink" title="一、命令模式的应用场景"></a>一、命令模式的应用场景</h1><p>当系统的某项操作具备命令语义时，且命令实现不稳定，那么可以通过命令模式解耦请求与实现，利用抽象命令接口使请求方代码架构稳定，封装接收方具体命令实现细节。命令模式适用于以下几个场景：</p>
<p>如果自己开发一个音乐播放器，它的功能有开始播放功能、暂停播放功能、停止播放功能、拖动进度条功能，自己去操作播放器的时候并不是直接调用播放器的方法，而是通过一个控制条传达指令给播放器的内核，那么具体的指令会封装成一个个按钮。那么每一个按钮就相当于是对一条命令的封装。用控制条实现了用户发送指令与播放器内核接收指令的解耦。<br>首先创建播放器内核Player类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Player &#123;</span><br><span class="line"></span><br><span class="line">    public void play() &#123;</span><br><span class="line">        System.out.println(&quot;播放&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void pause() &#123;</span><br><span class="line">        System.out.println(&quot;暂停&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        System.out.println(&quot;停止&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void speed() &#123;</span><br><span class="line">        System.out.println(&quot;拖动进度条&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建命令接口ICommand：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface ICommand &#123;</span><br><span class="line"></span><br><span class="line">    void execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后分别创建操作播放器可以接收的指令，播放指令PlayCommand类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class PlayCommand implements ICommand &#123;</span><br><span class="line"></span><br><span class="line">    private Player player;</span><br><span class="line"></span><br><span class="line">    public PlayCommand(Player player) &#123;</span><br><span class="line">        this.player &#x3D; player;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        player.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>暂停指令PauseCommand类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class PauseCommand implements ICommand &#123;</span><br><span class="line"></span><br><span class="line">    private Player player;</span><br><span class="line"></span><br><span class="line">    public PauseCommand(Player player) &#123;</span><br><span class="line">        this.player &#x3D; player;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        player.pause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>停止指令StopCommand类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class PauseCommand implements ICommand &#123;</span><br><span class="line"></span><br><span class="line">    private Player player;</span><br><span class="line"></span><br><span class="line">    public PauseCommand(Player player) &#123;</span><br><span class="line">        this.player &#x3D; player;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        player.pause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拖动进度条指令SpeedCommand类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class SpeedCommand implements ICommand &#123;</span><br><span class="line"></span><br><span class="line">    private Player player;</span><br><span class="line"></span><br><span class="line">    public SpeedCommand(Player player) &#123;</span><br><span class="line">        this.player &#x3D; player;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        player.speed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">最后，创建控制条Controller类：</span><br></pre></td></tr></table></figure>
<p>public class Controller {</p>
<pre><code>private List&lt;ICommand&gt; commands = new ArrayList&lt;&gt;();

public void addCommand(ICommand command) {
    commands.add(command);
}

public void execute(ICommand command) {
    command.execute();
}

public void executes() {
    for(ICommand command : commands) {
        command.execute();
    }
    commands.clear();
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">测试main方法：</span><br></pre></td></tr></table></figure>
<p> public static void main(String[] args) {<br>    Player player = new Player();</p>
<pre><code>Controller controller = new Controller();

controller.addCommand(new PlayCommand(player));
controller.addCommand(new PauseCommand(player));
controller.addCommand(new StopCommand(player));
controller.addCommand(new SpeedCommand(player));

controller.executes();</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">由于控制条已经与播放器内核解耦，以后想扩展新的命令，只需要增加命令即可，无需改动控制条结构。</span><br><span class="line"></span><br><span class="line"># 二、命令模式在源码中的体现</span><br><span class="line"></span><br><span class="line">## 2.1 Runnable接口</span><br><span class="line">实际上Runnable接口就相当于是命令的抽象，只要是实现了Runnable接口的类都被认为是一个线程。</span><br></pre></td></tr></table></figure>
<p>public interface Runnable {<br>    /**<br>     * When an object implementing interface <code>Runnable</code> is used<br>     * to create a thread, starting the thread causes the object’s<br>     * <code>run</code> method to be called in that separately executing<br>     * thread.<br>     * <p><br>     * The general contract of the method <code>run</code> is that it may<br>     * take any action whatsoever.<br>     *<br>     * @see     java.lang.Thread#run()<br>     */<br>    public abstract void run();<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**实际上调用的线程的start方法后，就有资格去抢CPU的资源了，而不需要我们编写获得CPU资源的逻辑。而线程抢到CPU资源后，就会去执行run()方法中的内容，用Runnable接口把用户请求和CPU执行进行了解耦。**</span><br><span class="line"></span><br><span class="line">## 2.2 junit.framework.Test接口</span><br><span class="line"></span><br><span class="line">先来看接口源码：</span><br></pre></td></tr></table></figure>
<p>package junit.framework;</p>
<p>public interface Test {<br>    int countTestCases();</p>
<pre><code>void run(TestResult var1);</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上面Test接口中有两个方法，第一个countTestCases()方法用来统计当前需要执行的测试用例总数。第二个run()方法用来执行具体的测试逻辑，其参数TestResult用来返回测试结果的。实际上我们平时在编写测试用例的时候，只需要实现Test接口即便认为就是一个测试用例，那么在执行的时候就自动识别了。平时的通常做法就是继承TestCase类，来看下它的源码：</span><br></pre></td></tr></table></figure>
<p>public TestResult run() {<br>    TestResult result = this.createResult();<br>    this.run(result);<br>    return result;<br>}</p>
<p>public void run(TestResult result) {<br>    result.run(this);<br>}</p>
<pre><code>
实际上TestCase类它也实现了Test接口。我们继承了TestCase类也相当于实现了Test接口，自然也会被扫描成一个测试用例。

# 三、命令模式的优缺点

优点：


* 通过引入中间件（抽象接囗），解耦了命令请求与实现；
* 扩展生良好，可以很容另地增加新命令； 
* 支持组合命令，支持命令队列；
* 可以在现有命令的基础上，增加额外功能（比如日志记录等，结合装饰器模式更酸爽）。

缺点：

* 具体命令类可能过多；
* 命令模式的结果其实就是接收方的执行结果，但是为了以命令的形式进行架构，解耦请求与实现，引入了额外类型结构（引入了请求方与抽象命令接囗），**增加了理解上的困难**（不过这也是设计模式带来的一个通病，抽象必然会引入额外类型；抽象肯定比紧密难理解）。



</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/03/21/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E7%86%9F%E6%82%89%E7%94%B5%E8%84%91%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="cke9cjzbx0004f5ragxnuaa9n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，非常熟知但并不知其所以然的迭代器模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E9%9D%9E%E5%B8%B8%E7%86%9F%E7%9F%A5%E4%BD%86%E5%B9%B6%E4%B8%8D%E7%9F%A5%E5%85%B6%E6%89%80%E4%BB%A5%E7%84%B6%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-03-19T06:34:34.000Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E9%9D%9E%E5%B8%B8%E7%86%9F%E7%9F%A5%E4%BD%86%E5%B9%B6%E4%B8%8D%E7%9F%A5%E5%85%B6%E6%89%80%E4%BB%A5%E7%84%B6%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，非常熟知但并不知其所以然的迭代器模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>迭代器模式（Iterator Pattern）又称为游标模式(Cursor Pattern)，它提供一种顺序访问的集合或容器对象元素的方法，而无需暴露集合内部表示。迭代器模式可以为不同的容器提供一种遍历行为，而不用关心容器内元素组成结构。迭代器模式的本质是抽离集合对象迭代行为到迭代器中，提供一致访问接口。</p>
<h1 id="一、迭代器模式的应用场景"><a href="#一、迭代器模式的应用场景" class="headerlink" title="一、迭代器模式的应用场景"></a>一、迭代器模式的应用场景</h1><p>迭代器模式在我们生活中应用的得也比较广泛，比如物流系统中的传送带，不管传送的是什么物品，都被打包成一个一个的箱子并且有一个统一的二维码。这样我们不需要关心箱子里面是啥，我们在分发时只需要一个一个检发送的目的地即可。再比如，我们平时乘坐交通工具都是统一刷卡或者刷脸进站，而不需要关心是男生还是女性、是残疾人还是正常人等个性化的信息。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/16/170e38aa7950a7e6?w=500&h=322&f=png&s=365992" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/3/16/170e38b659a6822d?w=1024&h=768&f=png&s=1502824" alt=""><br>我们把多个对象聚在一起形成的总体称之为集合（Aggregate），集合对象是能够包容一组对象的容器对象。不同集合其内部元素的聚和结构可能不同，而迭代器模式屏蔽了内部元素获取细节，为外部提供一致的元素访问行为，解耦了元素迭代与集合对象间的耦合，并且提供不同的迭代器，可以为同一个对象提供不同顺序的元素访问行为，扩展了集合对元素迭代功能，符合<strong>开闭原则</strong>。</p>
<p>迭代器模式使用于以下几个场景：</p>
<ul>
<li>访问一个集合对象的内容而无需暴露它的内部表示；</li>
<li>为遍历不同的集合结构提供一个统一的访问接口。</li>
</ul>
<p>迭代器模式主要包括四种角色：</p>
<ul>
<li>抽象迭代器（Iterator）：负责定义访问和遍历元素的接口；</li>
<li>具体迭代器（ConcreteIterator）：提供具体的元素遍历行为；</li>
<li>抽象容器（Aggregate）：负责定义提供具体迭代器的接口；</li>
<li>具体容器（ConcreteAggregate）：创建具体迭代器。</li>
</ul>
<h2 id="1-1-自定义的迭代器"><a href="#1-1-自定义的迭代器" class="headerlink" title="1.1 自定义的迭代器"></a>1.1 自定义的迭代器</h2><p>来以课程为例，创建一个课程的集合，集合中的每一个元素都是课程对象，然后自定义一个迭代器，将集合中的元素每一个课程对象信息读取出来。首先创建集合元素课程对象Course 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Course &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Course(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建自定义接口Iterator：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterator&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    E next();</span><br><span class="line"></span><br><span class="line">    boolean hasNext();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着创建课程集合CourseAggregate接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface CourseAggregate &#123;</span><br><span class="line"></span><br><span class="line">    void add(Course course);</span><br><span class="line"></span><br><span class="line">    void remove(Course course);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;Course&gt; iterator(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后实现迭代器接口和课程结合接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class IteratorImpl&lt;E&gt; implements Iterator&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;E&gt; list;</span><br><span class="line"></span><br><span class="line">    private int cursor;</span><br><span class="line"></span><br><span class="line">    private E element;</span><br><span class="line"></span><br><span class="line">    public IteratorImpl(List&lt;E&gt; list) &#123;</span><br><span class="line">        this.list &#x3D; list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public E next() &#123;</span><br><span class="line">        System.out.println(&quot;当前位置是：&quot; + cursor);</span><br><span class="line">        element &#x3D; list.get(cursor);</span><br><span class="line">        cursor ++ ;</span><br><span class="line">        return element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        if(cursor &gt; list.size() - 1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>课程集合实现类CourseAggregateImpl：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class CourseAggregateImpl implements CourseAggregate &#123;</span><br><span class="line"></span><br><span class="line">    private List list;</span><br><span class="line"></span><br><span class="line">    public CourseAggregateImpl(List list) &#123;</span><br><span class="line">        this.list &#x3D; new ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void add(Course course) &#123;</span><br><span class="line">        list.add(course);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void remove(Course course) &#123;</span><br><span class="line">        list.remove(course);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Iterator&lt;Course&gt; iterator() &#123;</span><br><span class="line">        return new IteratorImpl&lt;Course&gt;(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    Course chinese &#x3D; new Course(&quot;语文&quot;);</span><br><span class="line">    Course math &#x3D; new Course(&quot;数学&quot;);</span><br><span class="line">    Course english &#x3D; new Course(&quot;英语&quot;);</span><br><span class="line"></span><br><span class="line">    CourseAggregate courseAggregate &#x3D; new CourseAggregateImpl();</span><br><span class="line">    courseAggregate.add(chinese);</span><br><span class="line">    courseAggregate.add(math);</span><br><span class="line">    courseAggregate.add(english);</span><br><span class="line"></span><br><span class="line">    courseAggregate.remove(math);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;Course&gt; courseIterator &#x3D; courseAggregate.iterator();</span><br><span class="line">    while (courseIterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(courseIterator.next().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、迭代器模式在源码中的体现"><a href="#二、迭代器模式在源码中的体现" class="headerlink" title="二、迭代器模式在源码中的体现"></a>二、迭代器模式在源码中的体现</h1><h2 id="2-1-JDK中的迭代器Iterator"><a href="#2-1-JDK中的迭代器Iterator" class="headerlink" title="2.1 JDK中的迭代器Iterator"></a>2.1 JDK中的迭代器Iterator</h2><p>Iterator接口源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterator&lt;E&gt; &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns &#123;@code true&#125; if the iteration has more elements.</span><br><span class="line">     * (In other words, returns &#123;@code true&#125; if &#123;@link #next&#125; would</span><br><span class="line">     * return an element rather than throwing an exception.)</span><br><span class="line">     *</span><br><span class="line">     * @return &#123;@code true&#125; if the iteration has more elements</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean hasNext();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns the next element in the iteration.</span><br><span class="line">     *</span><br><span class="line">     * @return the next element in the iteration</span><br><span class="line">     * @throws NoSuchElementException if the iteration has no more elements</span><br><span class="line">     *&#x2F;</span><br><span class="line">    E next();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Removes from the underlying collection the last element returned</span><br><span class="line">     * by this iterator (optional operation).  This method can be called</span><br><span class="line">     * only once per call to &#123;@link #next&#125;.  The behavior of an iterator</span><br><span class="line">     * is unspecified if the underlying collection is modified while the</span><br><span class="line">     * iteration is in progress in any way other than by calling this</span><br><span class="line">     * method.</span><br><span class="line">     *</span><br><span class="line">     * @implSpec</span><br><span class="line">     * The default implementation throws an instance of</span><br><span class="line">     * &#123;@link UnsupportedOperationException&#125; and performs no other action.</span><br><span class="line">     *</span><br><span class="line">     * @throws UnsupportedOperationException if the &#123;@code remove&#125;</span><br><span class="line">     *         operation is not supported by this iterator</span><br><span class="line">     *</span><br><span class="line">     * @throws IllegalStateException if the &#123;@code next&#125; method has not</span><br><span class="line">     *         yet been called, or the &#123;@code remove&#125; method has already</span><br><span class="line">     *         been called after the last call to the &#123;@code next&#125;</span><br><span class="line">     *         method</span><br><span class="line">     *&#x2F;</span><br><span class="line">    default void remove() &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;remove&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Performs the given action for each remaining element until all elements</span><br><span class="line">     * have been processed or the action throws an exception.  Actions are</span><br><span class="line">     * performed in the order of iteration, if that order is specified.</span><br><span class="line">     * Exceptions thrown by the action are relayed to the caller.</span><br><span class="line">     *</span><br><span class="line">     * @implSpec</span><br><span class="line">     * &lt;p&gt;The default implementation behaves as if:</span><br><span class="line">     * &lt;pre&gt;&#123;@code</span><br><span class="line">     *     while (hasNext())</span><br><span class="line">     *         action.accept(next());</span><br><span class="line">     * &#125;&lt;&#x2F;pre&gt;</span><br><span class="line">     *</span><br><span class="line">     * @param action The action to be performed for each element</span><br><span class="line">     * @throws NullPointerException if the specified action is null</span><br><span class="line">     * @since 1.8</span><br><span class="line">     *&#x2F;</span><br><span class="line">    default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        while (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码中，我们看到两个主要的方法定义hasNext()和next()方法，和我们自己写的完全一致。另外，从上面的代码中，我们看到remove()方法实现似曾相识。其实是在组合模式中我们见到过。迭代器模式和组合模式，两者似乎存在一定的相似性。组合模式解决的是统一树形结构各层次访问接囗，迭代器模式解决的是统一各集合对象元素遍历接囗。虽然他们的适配场景不同，但核心理念是相通的。</p>
<p>Iterator接口的实现类，在ArrayList类中的内部实现类Itr，它实现了Iterator接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">    int cursor;       &#x2F;&#x2F; index of next element to return</span><br><span class="line">    int lastRet &#x3D; -1; &#x2F;&#x2F; index of last element returned; -1 if no such</span><br><span class="line">    int expectedModCount &#x3D; modCount;</span><br><span class="line"></span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return cursor !&#x3D; size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public E next() &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        int i &#x3D; cursor;</span><br><span class="line">        if (i &gt;&#x3D; size)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        Object[] elementData &#x3D; ArrayList.this.elementData;</span><br><span class="line">        if (i &gt;&#x3D; elementData.length)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        cursor &#x3D; i + 1;</span><br><span class="line">        return (E) elementData[lastRet &#x3D; i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        if (lastRet &lt; 0)</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            ArrayList.this.remove(lastRet);</span><br><span class="line">            cursor &#x3D; lastRet;</span><br><span class="line">            lastRet &#x3D; -1;</span><br><span class="line">            expectedModCount &#x3D; modCount;</span><br><span class="line">        &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123;</span><br><span class="line">        Objects.requireNonNull(consumer);</span><br><span class="line">        final int size &#x3D; ArrayList.this.size;</span><br><span class="line">        int i &#x3D; cursor;</span><br><span class="line">        if (i &gt;&#x3D; size) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        final Object[] elementData &#x3D; ArrayList.this.elementData;</span><br><span class="line">        if (i &gt;&#x3D; elementData.length) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        while (i !&#x3D; size &amp;&amp; modCount &#x3D;&#x3D; expectedModCount) &#123;</span><br><span class="line">            consumer.accept((E) elementData[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; update once at end of iteration to reduce heap write traffic</span><br><span class="line">        cursor &#x3D; i;</span><br><span class="line">        lastRet &#x3D; i - 1;</span><br><span class="line">        checkForComodification();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final void checkForComodification() &#123;</span><br><span class="line">        if (modCount !&#x3D; expectedModCount)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的next()和hasNext()方法的实现都很简单，ArrayList类中还有几个迭代器对Itr进行了进一步的扩展，来看下ListItr类的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">    ListItr(int index) &#123;</span><br><span class="line">        super();</span><br><span class="line">        cursor &#x3D; index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean hasPrevious() &#123;</span><br><span class="line">        return cursor !&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int nextIndex() &#123;</span><br><span class="line">        return cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int previousIndex() &#123;</span><br><span class="line">        return cursor - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public E previous() &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        int i &#x3D; cursor - 1;</span><br><span class="line">        if (i &lt; 0)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        Object[] elementData &#x3D; ArrayList.this.elementData;</span><br><span class="line">        if (i &gt;&#x3D; elementData.length)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        cursor &#x3D; i;</span><br><span class="line">        return (E) elementData[lastRet &#x3D; i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set(E e) &#123;</span><br><span class="line">        if (lastRet &lt; 0)</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            ArrayList.this.set(lastRet, e);</span><br><span class="line">        &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add(E e) &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            int i &#x3D; cursor;</span><br><span class="line">            ArrayList.this.add(i, e);</span><br><span class="line">            cursor &#x3D; i + 1;</span><br><span class="line">            lastRet &#x3D; -1;</span><br><span class="line">            expectedModCount &#x3D; modCount;</span><br><span class="line">        &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、迭代器模式的优缺点"><a href="#三、迭代器模式的优缺点" class="headerlink" title="三、迭代器模式的优缺点"></a>三、迭代器模式的优缺点</h1><p>优点：</p>
<ul>
<li>多态迭代：为不同的聚合结构提供一致的遍历接囗，即一个迭代接口可以访问不同的集合对象；</li>
<li>简化集合对象接囗：迭代器模式将集合对象本身应该提供的元素迭代接囗抽取到了迭代器中使集合对象无须关心具体迭代行为；</li>
<li>元素迭代功能多样化：每个集合对象都可以提供一个或多个不同的迭代器，使的同种元素聚合结构可以有不同的迭代行为；</li>
<li>解耦迭代与集合：迭代器模式封装了具体的迭代算法，迭代算法的变化，不会影响到集合对象的架构。</li>
</ul>
<p>缺点：</p>
<ul>
<li>对于比较简单的遍历（数组或者有序列表），使用迭代器方式遍历较为繁琐。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/03/19/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E9%9D%9E%E5%B8%B8%E7%86%9F%E7%9F%A5%E4%BD%86%E5%B9%B6%E4%B8%8D%E7%9F%A5%E5%85%B6%E6%89%80%E4%BB%A5%E7%84%B6%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="cke9cjzdr000pf5ra40kqfdr7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，必须完全掌握吃透的踢皮球方式的责任链模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/16/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%BF%85%E9%A1%BB%E5%AE%8C%E5%85%A8%E6%8E%8C%E6%8F%A1%E5%90%83%E9%80%8F%E7%9A%84%E8%B8%A2%E7%9A%AE%E7%90%83%E6%96%B9%E5%BC%8F%E7%9A%84%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-03-16T09:15:01.016Z" itemprop="datePublished">2020-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/16/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%BF%85%E9%A1%BB%E5%AE%8C%E5%85%A8%E6%8E%8C%E6%8F%A1%E5%90%83%E9%80%8F%E7%9A%84%E8%B8%A2%E7%9A%AE%E7%90%83%E6%96%B9%E5%BC%8F%E7%9A%84%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，必须完全掌握吃透的踢皮球方式的责任链模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: 架构师内功心法，必须完全掌握吃透的踢皮球方式的责任链模式详解<br>date: 2020-03-16 17:13:47<br>tags:<br>–</p>
<p>在日常生活中责任链模式还是挺常见的，我们平时工作处理一些事务，往往都是各个部门协同合作完成某一个项目任务。而每个部门都有自己的职责，所以很多时候事情完成了一部分，便会交给下一个部门，直到所有的部门全部完成所有的工作之后，那么这个项目任务才算最终完成。还有平时说的过五关斩六将其实也是一种责任链的模式。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170dccca488997a2?w=640&h=360&f=png&s=562029" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/3/15/170dcd4371ed8b48?w=500&h=350&f=png&s=379783" alt=""></p>
<h1 id="一、责任链模式的应用场景"><a href="#一、责任链模式的应用场景" class="headerlink" title="一、责任链模式的应用场景"></a>一、责任链模式的应用场景</h1><p>责任链模式（Chain of Responsibility Pattern）是将链中的每一个节点看作是一个对象，每个节点处理的请求均不同，且内部自动维护下一个节点对象。当一个请求从链式的首端发出时，会沿着链的路径依次传递给每一个节点对象，直到有对象处理这个请求为止。责任模式主要是解耦请求与处理，客户只要将请求发送到对应的链上即可，无需关心请求的具体内容和处理细节，请求会自动进行传递直至有节点的对象进行处理。</p>
<p>责任链模式适用于以下几个场景：</p>
<ul>
<li>多个对象可以处理同一请求，但是具体由哪个对象处理则在运行时动态决定的；</li>
<li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求；</li>
<li>可动态指定一组对象处理请求。</li>
</ul>
<p>责任链模式主要包含两种角色：</p>
<ul>
<li>抽象处理者（Handler）：定义一个请求处理的方法，并维护下一个处理节点Handler对象的引用；</li>
<li>具体处理者（ConcreteHandler）：对请求进行处理，如果不感兴趣，则进行转发。</li>
</ul>
<p>责任链模式的本质是解耦请求与处理，让请求在处理链中能进行传递与被处理；理解责任链模式应当理解的是其模式（道）而不是其具体实现（术），它的独到之处是其将节点处理者组成了链式结构，并允许节点自身决定是否进行请求处理或转发，相当于让请求流动起来。</p>
<h2 id="1-1-数据校验拦截使用责任链模式"><a href="#1-1-数据校验拦截使用责任链模式" class="headerlink" title="1.1 数据校验拦截使用责任链模式"></a>1.1 数据校验拦截使用责任链模式</h2><p>首先创建一个实体类 User 对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">    private String roleName;</span><br><span class="line"></span><br><span class="line">    public User(String username, String password) &#123;</span><br><span class="line">        this.username &#x3D; username;</span><br><span class="line">        this.password &#x3D; password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username &#x3D; username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password &#x3D; password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getRoleName() &#123;</span><br><span class="line">        return roleName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRoleName(String roleName) &#123;</span><br><span class="line">        this.roleName &#x3D; roleName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;username&#x3D;&#39;&quot; + username + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, password&#x3D;&#39;&quot; + password + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, roleName&#x3D;&#39;&quot; + roleName + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写一个简单的用户登录权限 UserService 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">    private final String ROLE_NAME &#x3D; &quot;administrator&quot;;</span><br><span class="line"></span><br><span class="line">    public void login(String username, String password) &#123;</span><br><span class="line">        if(StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) &#123;</span><br><span class="line">            System.out.println(&quot;用户和密码校验成功了，可以继续往下执行了！&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;用户和密码不能为空，可以继续往下执行了！&quot;);</span><br><span class="line"></span><br><span class="line">        User user &#x3D; check(username, password);</span><br><span class="line">        if(null &#x3D;&#x3D; user) &#123;</span><br><span class="line">            System.out.println(&quot;用户不存在！&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;恭喜，登录成功了！&quot;);</span><br><span class="line"></span><br><span class="line">        if(!ROLE_NAME.equals(user.getRoleName())) &#123;</span><br><span class="line">            System.out.println(&quot;不是管理员，所以没有操作权限！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;允许操作！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User check(String username, String password) &#123;</span><br><span class="line">        User user &#x3D; new User(username, password);</span><br><span class="line">        user.setRoleName(ROLE_NAME);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UserService userService &#x3D;  new UserService();</span><br><span class="line">        userService.login(&quot;kevin&quot;, &quot;123456&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码主要功能做了登录前的数据验证，判断逻辑是有先后顺序的。首先判断非空，然后判断用户名和密码，最后根据用户名密码获得用户角色。如果有角色的话就可以获得用户得操作权限。这样的代码在业务中实现显得非常的臃肿，我们来进行改造，<strong>可以使用责任链模式，将这些检查步骤串联起来，这样可以使得我们在编码的时候更加关注某个具体业务逻辑的实现处理。</strong></p>
<p>首先创建一个抽象的 Handler 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Handler &#123;</span><br><span class="line"></span><br><span class="line">    protected Handler chain;</span><br><span class="line"></span><br><span class="line">    public void next(Handler handler) &#123;</span><br><span class="line">        this.chain &#x3D; handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void doHandle(User user);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后分别创建校验ValidateHandler类，登录验证LoginHandler类，还有权限验证AuthHandler类：</p>
<p>ValidateHandler类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ValidateHandler extends Handler &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doHandle(User user) &#123;</span><br><span class="line">        if(StringUtils.isEmpty(user.getUsername()) ||</span><br><span class="line">                StringUtils.isEmpty(user.getPassword())) &#123;</span><br><span class="line">            System.out.println(&quot;用户和密码校验成功了，可以继续往下执行了！&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;用户和密码不能为空，可以继续往下执行了！&quot;);</span><br><span class="line">        chain.doHandle(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LoginHandler类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class LoginHandler extends Handler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doHandle(User user) &#123;</span><br><span class="line">        System.out.println(&quot;恭喜，登录成功了！&quot;);</span><br><span class="line">        user.setRoleName(ROLE_NAME);</span><br><span class="line">        chain.doHandle(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AuthHandler类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class AuthHandler extends Handler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doHandle(User user) &#123;</span><br><span class="line">        if(!ROLE_NAME.equals(user.getRoleName())) &#123;</span><br><span class="line">            System.out.println(&quot;不是管理员，所以没有操作权限！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;允许操作！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来改造 UserService 类，使得前面定义的几个Handler串联起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">    public void login(String username, String password) &#123;</span><br><span class="line">        Handler validateHandler &#x3D; new ValidateHandler();</span><br><span class="line">        Handler loginHandler &#x3D; new LoginHandler();</span><br><span class="line">        Handler authHandler &#x3D; new AuthHandler();</span><br><span class="line"></span><br><span class="line">        validateHandler.next(loginHandler);</span><br><span class="line">        loginHandler.next(authHandler);</span><br><span class="line">        validateHandler.doHandle(new User(username, password));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UserService userService &#x3D;  new UserService();</span><br><span class="line">        userService.login(&quot;kevin&quot;, &quot;123456&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实我们平时使用的很多验证框架的运用这样的一个原理，将各个维度的权限处理后解耦之后再进行串联，各自只负责各自相关的职责即可。如果职责与自己不相关则抛给链上的下一个Handler，俗称<strong>踢皮球</strong>。</p>
<h2 id="1-2-责任链模式和建造者模式结合使用"><a href="#1-2-责任链模式和建造者模式结合使用" class="headerlink" title="1.2 责任链模式和建造者模式结合使用"></a>1.2 责任链模式和建造者模式结合使用</h2><p>我们看到前面的代码在UserService类中，当链式结构比较长的话，那么其代码也是很臃肿的，如果在后面修改业务逻辑的话，都需要在UserService类中去进行修改，<strong>不符合开闭原则</strong>。产生这些问题的原因就是链式结构的组装过于复杂，而且对于结构的创建我们很容易就想到<strong>建造者模式</strong>，使用建造者模式，完成可以对UserService指定的处理节点对象进行<strong>自动链式组装</strong>，只需要指定处理节点对象，其它任何事情无需关心，并且可以指定处理对象节点的顺序不同，构造出来的链式结构也随之不同。来对Handler的代码进行改造：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Handler&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    protected final String ROLE_NAME &#x3D; &quot;administrator&quot;;</span><br><span class="line"></span><br><span class="line">    protected Handler chain;</span><br><span class="line"></span><br><span class="line">    public void next(Handler handler) &#123;</span><br><span class="line">        this.chain &#x3D; handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void doHandle(User user);</span><br><span class="line"></span><br><span class="line">    public static class Builer&lt;T&gt; &#123;</span><br><span class="line">        private Handler&lt;T&gt; head;</span><br><span class="line">        private Handler&lt;T&gt; tail;</span><br><span class="line"></span><br><span class="line">        public Builer&lt;T&gt; addHandler(Handler&lt;T&gt; handler) &#123;</span><br><span class="line">            if(this.head &#x3D;&#x3D; null) &#123;</span><br><span class="line">                this.head &#x3D; this.tail &#x3D; handler;</span><br><span class="line">                return this;</span><br><span class="line">            &#125;</span><br><span class="line">            this.tail.next(handler);</span><br><span class="line">            this.tail &#x3D; handler;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Handler&lt;T&gt; build() &#123;</span><br><span class="line">            return this.head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改 UserService类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">    public void login(String username, String password) &#123;</span><br><span class="line">        Handler validateHandler &#x3D; new ValidateHandler();</span><br><span class="line">        Handler loginHandler &#x3D; new LoginHandler();</span><br><span class="line">        Handler authHandler &#x3D; new AuthHandler();</span><br><span class="line"></span><br><span class="line">        Handler.Builer builer &#x3D; new Handler.Builer();</span><br><span class="line">        builer.addHandler(validateHandler)</span><br><span class="line">                .addHandler(loginHandler)</span><br><span class="line">                .addHandler(authHandler);</span><br><span class="line"></span><br><span class="line">        builer.build().doHandle(new User(username, password));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UserService userService &#x3D;  new UserService();</span><br><span class="line">        userService.login(&quot;kevin&quot;, &quot;123456&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、责任链模式在源码中的体现"><a href="#二、责任链模式在源码中的体现" class="headerlink" title="二、责任链模式在源码中的体现"></a>二、责任链模式在源码中的体现</h1><h2 id="2-1-Servlet中的Filter类"><a href="#2-1-Servlet中的Filter类" class="headerlink" title="2.1 Servlet中的Filter类"></a>2.1 Servlet中的Filter类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package javax.servlet;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public interface Filter &#123;</span><br><span class="line">    default void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException;</span><br><span class="line"></span><br><span class="line">    default void destroy() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个Filter接口定义很简单，相当于责任链模式中Handler抽象角色，那么它是如何形成一条责任链的呢？在doFilter()方法的最后一个参数我们已经看到了FilterChain类，来看下这个类的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface FilterChain &#123;</span><br><span class="line">    void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FilterChain类中也是只定义了一个doFilter()方法，具体的逻辑是由使用者自己去进行实现的。我们来看一个Spring中实现的MockFilterChain类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException &#123;</span><br><span class="line">    Assert.notNull(request, &quot;Request must not be null&quot;);</span><br><span class="line">    Assert.notNull(response, &quot;Response must not be null&quot;);</span><br><span class="line">    Assert.state(this.request &#x3D;&#x3D; null, &quot;This FilterChain has already been called!&quot;);</span><br><span class="line">    if (this.iterator &#x3D;&#x3D; null) &#123;</span><br><span class="line">        this.iterator &#x3D; this.filters.iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.iterator.hasNext()) &#123;</span><br><span class="line">        Filter nextFilter &#x3D; (Filter)this.iterator.next();</span><br><span class="line">        nextFilter.doFilter(request, response, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.request &#x3D; request;</span><br><span class="line">    this.response &#x3D; response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>它把链条中所有的Filter放到List中，然后在调用doFilter()方法时循环迭代List，也就是List中的Filter会顺序执行。</strong></p>
<h2 id="2-2-Netty中的Pipeline"><a href="#2-2-Netty中的Pipeline" class="headerlink" title="2.2 Netty中的Pipeline"></a>2.2 Netty中的Pipeline</h2><p>Netty中的串行化处理Pipeline采用了责任链模式设计。底层采用双向列表的数据结构，将链式的处理器串联起来。客户端每一个请求过来，Netty认为Pipeline中所有的处理器都有机会处理它。<strong>对于入栈的请求全部从头节点开始往后传播，一直传播到尾部节点才会把消息释放掉。</strong> 负责处理器的接口<strong>ChannelHandler</strong>源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public interface ChannelHandler &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Gets called after the &#123;@link ChannelHandler&#125; was added to the actual context and it&#39;s ready to handle events.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void handlerAdded(ChannelHandlerContext ctx) throws Exception;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Gets called after the &#123;@link ChannelHandler&#125; was removed from the actual context and it doesn&#39;t handle events</span><br><span class="line">     * anymore.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void handlerRemoved(ChannelHandlerContext ctx) throws Exception;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Gets called if a &#123;@link Throwable&#125; was thrown.</span><br><span class="line">     *</span><br><span class="line">     * @deprecated is part of &#123;@link ChannelInboundHandler&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Deprecated</span><br><span class="line">    void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Indicates that the same instance of the annotated &#123;@link ChannelHandler&#125;</span><br><span class="line">     * can be added to one or more &#123;@link ChannelPipeline&#125;s multiple times</span><br><span class="line">     * without a race condition.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * If this annotation is not specified, you have to create a new handler</span><br><span class="line">     * instance every time you add it to a pipeline because it has unshared</span><br><span class="line">     * state such as member variables.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * This annotation is provided for documentation purpose, just like</span><br><span class="line">     * &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.javaconcurrencyinpractice.com&#x2F;annotations&#x2F;doc&#x2F;&quot;&gt;the JCIP annotations&lt;&#x2F;a&gt;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Inherited</span><br><span class="line">    @Documented</span><br><span class="line">    @Target(ElementType.TYPE)</span><br><span class="line">    @Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">    @interface Sharable &#123;</span><br><span class="line">        &#x2F;&#x2F; no value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Netty对负责处理接口做了更细粒度的划分，处理器被分为两种，一种是<strong>入栈处理器 ChannelInboundHandler</strong>，另外一种是<strong>出栈处理器ChannelOutboundHandler</strong>，这两个接口都继承ChannelHandler接口。所有的处理都添加在Pipeline上。所以，<strong>添加删除责任处理器的接口行为都在ChannelPipeline中进行了规定</strong>：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/16/170e27c312a7ba5d?w=898&h=694&f=png&s=81454" alt=""></p>
<p>在默认的实现类中将所有的Handler都串成了一个链表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultChannelPipeline implements ChannelPipeline &#123;</span><br><span class="line"></span><br><span class="line">    static final InternalLogger logger &#x3D; InternalLoggerFactory.getInstance(DefaultChannelPipeline.class);</span><br><span class="line"></span><br><span class="line">    private static final String HEAD_NAME &#x3D; generateName0(HeadContext.class);</span><br><span class="line">    private static final String TAIL_NAME &#x3D; generateName0(TailContext.class);</span><br><span class="line"></span><br><span class="line">    private static final FastThreadLocal&lt;Map&lt;Class&lt;?&gt;, String&gt;&gt; nameCaches &#x3D;</span><br><span class="line">            new FastThreadLocal&lt;Map&lt;Class&lt;?&gt;, String&gt;&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected Map&lt;Class&lt;?&gt;, String&gt; initialValue() throws Exception &#123;</span><br><span class="line">            return new WeakHashMap&lt;Class&lt;?&gt;, String&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    private static final AtomicReferenceFieldUpdater&lt;DefaultChannelPipeline, MessageSizeEstimator.Handle&gt; ESTIMATOR &#x3D;</span><br><span class="line">            AtomicReferenceFieldUpdater.newUpdater(</span><br><span class="line">                    DefaultChannelPipeline.class, MessageSizeEstimator.Handle.class, &quot;estimatorHandle&quot;);</span><br><span class="line">    final AbstractChannelHandlerContext head;</span><br><span class="line">    final AbstractChannelHandlerContext tail;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<p><strong>在Pipeline中的任意一个节点，只要我们不手动往下传播下去，这个事件就会终止传播在当前节点。对于入栈的数据，默认会传递到尾部节点进行回收。如果我们不进行下一步传播，事件就会终止在当前节点。对于出栈的数据把数据写回客户端也意味着事件的终止。</strong></p>
<h1 id="三、责任链模式的优缺点"><a href="#三、责任链模式的优缺点" class="headerlink" title="三、责任链模式的优缺点"></a>三、责任链模式的优缺点</h1><p>优点：</p>
<ul>
<li>将请求与处理解耦；</li>
<li>请求处理者（节点对象）只需要关注自己感兴趣的请求进行处理即可，对于不感兴趣的请求，直接转到下一级节点对象；</li>
<li>具备链式传递处理请求功能，请求发送者无需知晓链路结构，只需等待请求处理结果；</li>
<li>链路结构灵活，可以通过改变链路结构动态的新增或者删除责任；</li>
<li>易于扩展新的请求处理类，符合开闭原则。</li>
</ul>
<p>缺点：</p>
<ul>
<li>责任链太长或者处理时间太长，会影响整体性能；</li>
<li>如果节点对象存在循环引用时，会造成死循环，导致系统崩溃。</li>
</ul>
<p>-</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/03/16/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%BF%85%E9%A1%BB%E5%AE%8C%E5%85%A8%E6%8E%8C%E6%8F%A1%E5%90%83%E9%80%8F%E7%9A%84%E8%B8%A2%E7%9A%AE%E7%90%83%E6%96%B9%E5%BC%8F%E7%9A%84%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="cke9cjzdh000kf5ra8m54h9ro" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/25/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E7%9A%84%E7%8E%8B%E8%80%85Apache-Atlas%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84API/">数据治理的王者Apache-Atlas如何构建自己的API</a>
          </li>
        
          <li>
            <a href="/2020/07/26/CountDownLatch%E3%80%81Semaphore%E3%80%81CyclicBarrier%E3%80%81Condition%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">CountDownLatch、Semaphore、CyclicBarrier、Condition源码分析</a>
          </li>
        
          <li>
            <a href="/2020/07/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86SpringBoot%EF%BC%8C%E6%8E%8C%E6%8F%A1%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/">微服务核心重新认识SpringBoot，掌握核心特性及设计思想</a>
          </li>
        
          <li>
            <a href="/2020/06/26/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B3%E4%BA%8E%E9%94%81%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%8CReentantLock%E7%9A%84%E5%BA%95%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/">JAVA并发编程关于锁的那些事，ReentantLock的底层设计深入浅出</a>
          </li>
        
          <li>
            <a href="/2020/06/20/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E7%AF%87%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">JAVA并发编程阶段总结篇，解决死锁问题以及ThreadLocal原理分析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Kevin Shaw<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>