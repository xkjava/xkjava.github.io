<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>来一杯咖啡</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="互联网Java体系平台架构，分布式系统，中间件技术等">
<meta property="og:type" content="website">
<meta property="og:title" content="来一杯咖啡">
<meta property="og:url" content="https://xkjava.github.io/page/3/index.html">
<meta property="og:site_name" content="来一杯咖啡">
<meta property="og:description" content="互联网Java体系平台架构，分布式系统，中间件技术等">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Kevin Shaw">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="Netty">
<meta property="article:tag" content="Kafka...">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="来一杯咖啡" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">来一杯咖啡</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">互联网技术无边界，学习与交流</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://xkjava.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-架构师内功心法，软件架构设计的七大原则精选案例" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/19/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%E7%B2%BE%E9%80%89%E6%A1%88%E4%BE%8B/" class="article-date">
  <time datetime="2020-02-19T06:43:44.000Z" itemprop="datePublished">2020-02-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/19/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%E7%B2%BE%E9%80%89%E6%A1%88%E4%BE%8B/">架构师内功心法，软件架构设计的七大原则精选案例</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、软件架构设计的七大原则简介"><a href="#一、软件架构设计的七大原则简介" class="headerlink" title="一、软件架构设计的七大原则简介"></a>一、软件架构设计的七大原则简介</h1><p><img src="https://user-gold-cdn.xitu.io/2020/2/17/17052b314ab91c9f?w=1018&h=812&f=png&s=43050" alt=""></p>
<h2 id="1-1-开闭原则（Open-Closed-Principle，OCP）"><a href="#1-1-开闭原则（Open-Closed-Principle，OCP）" class="headerlink" title="1.1 开闭原则（Open-Closed Principle，OCP）"></a>1.1 开闭原则（Open-Closed Principle，OCP）</h2><p>开闭原则是一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。所谓的开闭也是对扩展和修改两个行为的一个原则。强调是用抽象扩展架构，用实现扩展细节。可以提高软件系统的可复用性及可维护性。开闭原则，是面向对象设计中最基础的设计原则。它指导我们如何建立稳定灵活的系统，例如：<strong>版本更新，我们尽可能不修改代码，但是可以增加新功能。</strong></p>
<p>在现实生活中也有很多开闭原则的例子，比如，很多互联网公司都实行弹性的工作时间，规定每天工作8小时。意思就是说，对于工作日每天工作8小时这个规定是关闭的，但是你什么时候来，什么时候走是开放的。早来早走，晚来晚走。</p>
<p>实现开闭原则的核心思想就是面向抽象编程，以某新华书店的图书为例，首先创建一个课程接口类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class IBook &#123;</span><br><span class="line">    Integer getId();</span><br><span class="line">    String getName();</span><br><span class="line">    Double getPrice();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来创建一个计算机图书的类ComputerBook：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class ComputerBook implements IBook &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    protected Double price;</span><br><span class="line">    public ComputerBook(Integer id, String name, Double price) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.price &#x3D; price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return this.id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Double getPrice() &#123;</span><br><span class="line">        return this.price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们要给计算机类的图书做活动，价格优惠。如果修改ComputerBook类的getPrice()方法，则会存在一定的风险，可能会影响其它地方的调用结果。我们如何在不修改原有代码的前提下，实现价格优惠这个功能呢？现在，我们再写一个处理优惠逻辑的类，ComputerDiscountBook类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ComputerDiscountBook extends ComputerBook &#123;</span><br><span class="line">    public ComputerDiscountBook(Integer id, String name, Double price) &#123;</span><br><span class="line">        super(id, name, price);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Double getOriginPrice() &#123;</span><br><span class="line">        return super.price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Double getPrice() &#123;</span><br><span class="line">        return super.price * 0.8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/2/17/170533730e78204e?w=667&h=742&f=png&s=45090" alt=""></p>
<h2 id="1-2-依赖倒置原则（Dependence-Inversion-Principle，DIP）"><a href="#1-2-依赖倒置原则（Dependence-Inversion-Principle，DIP）" class="headerlink" title="1.2 依赖倒置原则（Dependence Inversion Principle，DIP）"></a>1.2 依赖倒置原则（Dependence Inversion Principle，DIP）</h2><p>依赖倒置原则是指设计代码结构时，高层模块不应该依赖底层模块，二者都应该依赖其抽象。抽象不应该依赖细节；细节应该依赖抽象。通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，并能够降低修改程序所造成的风险。</p>
<p>还是以课程为例，创建一个类Kevin：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Kevin &#123;</span><br><span class="line"></span><br><span class="line">    public void readComputerBook() &#123;</span><br><span class="line">        System.out.println(&quot;Kevin正在阅读电脑书籍&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void readScienceBook() &#123;</span><br><span class="line">        System.out.println(&quot;Kevin正在阅读科学书籍&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Kevin kevin &#x3D; new Kevin();</span><br><span class="line">        kevin.readComputerBook();</span><br><span class="line">        kevin.readScienceBook();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kevin正在阅读电脑书籍和科学书籍。大家知道电脑书籍的种类很多，现在人工智能AI这么火热，Kevin想学习关于人工智能方面的电脑书籍。这个时候，业务需要扩展，我们需要从底层到调用层一次修改代码来满足业务要求。在Kevin中增加readAIBook（）的方法，在调用层也要追加调用。这样一来，系统发布的时候，实际上不是很稳定。如何优化我们的代码，创建一个书籍的抽象IBook接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IBook &#123;</span><br><span class="line"></span><br><span class="line">    void read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后写ComputerBook类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ComputerBook implements IBook &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void read() &#123;</span><br><span class="line">        System.out.println(&quot;Kevin正在阅读电脑书籍&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再写ScienceBook类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ScienceBook implements IBook &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void read() &#123;</span><br><span class="line">        System.out.printf(&quot;Kevin正在阅读科学书籍&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改Kevin类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Kevin &#123;</span><br><span class="line"></span><br><span class="line">    public void read(IBook book) &#123;</span><br><span class="line">        book.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Kevin kevin &#x3D; new Kevin();</span><br><span class="line">        kevin.read(new ComputerBook());</span><br><span class="line">        kevin.read(new ScienceBook());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看main方法调用，无论Kevin想读哪些类的新书，只需要创建一个类，通过传参的方式告诉Kevin，而不需要修改底层代码来实现。这种实现方式叫做依赖注入。注入的方式有构造器注入和setter注入两种方式。</p>
<p>构造器注入实现方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Kevin &#123;</span><br><span class="line"></span><br><span class="line">    public IBook book;</span><br><span class="line"></span><br><span class="line">    public Kevin(IBook book) &#123;</span><br><span class="line">        this.book &#x3D; book;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void read() &#123;</span><br><span class="line">        book.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Kevin kevin &#x3D; new Kevin(new ComputerBook());</span><br><span class="line">        kevin.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据构造器注入，在调用时，每次都需要创建实例。如果Kevin是全局单例的话，则只能选择Setter方式来注入，继续修改Kevin类的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Kevin &#123;</span><br><span class="line"></span><br><span class="line">    public IBook book;</span><br><span class="line"></span><br><span class="line">    public void setBook(IBook book) &#123;</span><br><span class="line">        this.book &#x3D; book;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void read() &#123;</span><br><span class="line">        book.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Kevin kevin &#x3D; new Kevin();</span><br><span class="line">        kevin.setBook(new ComputerBook());</span><br><span class="line">        kevin.read();</span><br><span class="line"></span><br><span class="line">        kevin.setBook(new ScienceBook());</span><br><span class="line">        kevin.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>以抽象为基准比以细节为基准搭建起来的代码架构要稳定得多，因此拿到需求任务后，要面向接口编程，先设计顶层再琢磨细节来设计代码结构。</strong></p>
<h2 id="1-3-单一职责原则（Simple-Responsibility-Principle，SRP）"><a href="#1-3-单一职责原则（Simple-Responsibility-Principle，SRP）" class="headerlink" title="1.3 单一职责原则（Simple Responsibility Principle，SRP）"></a>1.3 单一职责原则（Simple Responsibility Principle，SRP）</h2><p>单一职责原则是值不要存在多于一个导致类变更的原因。假设我们有一个类要负责两个职责，一旦发生需求变更，修改其中一个职责的逻辑代码，有可能会导致另一个职责的功能发生故障。这样一来，这个类存在两个导致类变更的原因。怎么来解决这个问题呢？就需要给两个职责分别用两个类来实现，进行解耦。后期需求维护相互不受影响。这样的设计，可以降低类的复杂度，提高类的可读性，提高系统的可维护性，降低变更引起的风险。总体来说就是一个<strong>class/interface/mothod</strong>只负责一项职责。<br>这里用在线直播课程的案例来举例，课程有在线直播课和录播课。直播课不能快进和后退，录播课程可以任意的反复观看，功能职责不一样。创建一个Course类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Course &#123;</span><br><span class="line"></span><br><span class="line">    public static final String COURSE_NAME &#x3D; &quot;直播课&quot;;</span><br><span class="line"></span><br><span class="line">    public void study(String courseName) &#123;</span><br><span class="line">        if(COURSE_NAME.equals(courseName)) &#123;</span><br><span class="line">            System.out.println(courseName + &quot;不能快进和快退&quot;);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            System.out.println(courseName + &quot;可以反复观看&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Course course &#x3D; new Course();</span><br><span class="line">        course.study(&quot;直播课&quot;);</span><br><span class="line">        course.study(&quot;录播课&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码看，Course类承担了两种逻辑。现在需要对课程进行加密，那么直播课和录播课的加密逻辑是不一样的，必须要修改代码。而修改代码逻辑必然会相互影响并且容易造成风险。我们对职责进行解耦，分别创建LiveCourse和ReplayCourse两个类：</p>
<p>LiveCourse类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class LiveCourse &#123;</span><br><span class="line"></span><br><span class="line">    public void study(String courseName) &#123;</span><br><span class="line">        System.out.println(courseName + &quot;不能快进和快退&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReplayCourse类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ReplayCourse &#123;</span><br><span class="line"></span><br><span class="line">    public void study(String courseName) &#123;</span><br><span class="line">        System.out.println(courseName + &quot;可以反复观看&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">     LiveCourse liveCourse &#x3D; new LiveCourse();</span><br><span class="line">     liveCourse.study(&quot;直播课&quot;);</span><br><span class="line">     ReplayCourse replayCourse &#x3D; new ReplayCourse();</span><br><span class="line">     replayCourse.study(&quot;录播课&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随着业务的发展，课程也要做权限。没有付费的vip会员可以获取课程基本信息，已经付费的vip会员可以获得视频流，即获得视频观看权限。对于控制课程层面上至少有两个职责。我们可以把展示职责和管理职责分离出来，实现同一个抽象依赖。设计一个顶层接口，创建ICourse接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public interface ICourse &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获得课程信息</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    String getCourseName();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获得视频流</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    byte[] getCourseVideo();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 学习课程</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void studyCourse();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 退款</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void refundCourse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以把这个接口拆成两个接口，创建一个接口ICourseInfo和ICourseManager：</p>
<p>接口ICourseInfo：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface ICourseInfo &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获得课程信息</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    String getCourseName();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获得视频流</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    byte[] getCourseVideo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口ICourseManager：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface ICourseManager &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 学习课程</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void studyCourse();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 退款</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void refundCourse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来看下方法层面的单一职责的代码设计。有时候我们为了偷懒，通常会把方法写成下面这样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void mofifyUserInfo(String userName, String address) &#123;</span><br><span class="line">    userName &#x3D; &quot;Kevin&quot;;</span><br><span class="line">    address &#x3D; &quot;Beijing&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可能写成这样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void modifyUserInfo(String userName, String... fields) &#123;</span><br><span class="line">    userName &#x3D; &quot;Kevin&quot;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void modifyUserInfo(String userName, String address, boolean bool) &#123;</span><br><span class="line">    if(bool) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    userName &#x3D; &quot;Kevin&quot;;</span><br><span class="line">    address &#x3D; &quot;Beijing&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然上面的modifyUserInfo()方法中承担了多个职责，既可以修改userName，也可以修改address，甚至更多的值，明显不符合单一职责。这样我们需要对代码进行修改，把这个方法拆分成两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void modifyUserName(String userName) &#123;</span><br><span class="line">    userName &#x3D; &quot;Kevin&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void modifyAddress(String address) &#123;</span><br><span class="line">    address &#x3D; &quot;Beijing&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改之后的代码看起来简单，且维护起来更加容易。但是，<strong>我们在实际开发项目过程中，项目直接会相互依赖，组合、聚和这些关系，还有项目的规模，周期，技术人员的水平，对进度的把控，很多类都不符合单一职责。但是，我们在编码的过程中尽量做到单一职责，这样对我们项目的后期维护是有很大的帮助的。</strong></p>
<h2 id="1-4-接口隔离原则-（Interface-Segregation-Principle，ISP）"><a href="#1-4-接口隔离原则-（Interface-Segregation-Principle，ISP）" class="headerlink" title="1.4 接口隔离原则 （Interface Segregation Principle，ISP）"></a>1.4 接口隔离原则 （Interface Segregation Principle，ISP）</h2><p>接口隔离原则是指用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口。这个原则指导我们在设计接口的时候应该注意以下几点：</p>
<p>1、一个类对一类的依赖应该建立在最小的接口之上；</p>
<p>2、建立单一接口，不要建立庞大臃肿的接口；</p>
<p>3、尽量细化接口，接口中的方法尽量少（不是越少越好，要适度）。</p>
<p>接口隔离原则符合我们常说的<strong>高内聚低耦合</strong>的设计思想，从而使得类具有很好的可读性、可扩展性以及可维护性。在设计接口的时候，要多花时间去思考，要考虑业务模型，包括以后有可能发生变更的地方还要做一些预判。所以对于抽象，对于业务模型的理解是非常重要的。下面举例来看一个动物行为的抽象接口：</p>
<p>IAnimal接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface IAnimal &#123;</span><br><span class="line">    void eat();</span><br><span class="line">    void fly();</span><br><span class="line">    void swim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Bird 类实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Bird implements IAnimal &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void fly() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void swim() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dog 类实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Dog implements IAnimal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void fly() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void swim() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，Bird 的 swim()方法可能只能空着，Dog 的fly()方法显然不可能的。这时候，我们针对不同动物行为来设计不同的接口，分别设计 IEatAnimal，IFlyAnimal 和ISwimAnimal 接口，来看代码：</p>
<p>IEatAnimal接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IEatAnimal &#123;</span><br><span class="line">    void eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IFlyAnimal接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IFlyAnimal &#123;</span><br><span class="line">    void fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ISwimAnimal接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ISwimAnimal &#123;</span><br><span class="line">    void swim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dog 只实现 IEatAnimal 和 ISwimAnimal 接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Dog implements IEatAnimal, ISwimAnimal &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void swim() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-迪米特法则（Law-of-Demeter-LoD）"><a href="#1-5-迪米特法则（Law-of-Demeter-LoD）" class="headerlink" title="1.5 迪米特法则（Law of Demeter, LoD）"></a>1.5 迪米特法则（Law of Demeter, LoD）</h2><p>迪米特法则是指一个对象应该对其他对象保持最少的了解，又叫最少知道原则（Least Knowledge Principle， LKP），尽量降低类与类之间的耦合。<strong>主要强调只和朋友说话，不和陌生人说话。出现在成员变量、方法输入、输出参数中的类都可以称之为成员朋友类，而出现在方法体内部的类不属于朋友类。</strong></p>
<p>现在来设计一个权限系统，老板需要查看目前发布到线上的课程数量。这个老板找到项目负责人去进行统计，项目负责人再把统计结果告诉老板。来看一下代码示例：</p>
<p>Course类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class Course &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TeamLeader类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class TeamLeader &#123;</span><br><span class="line">    public void checkNumberOfCourses(List&lt;Course&gt; courseList)&#123;</span><br><span class="line">        System.out.println(&quot;目前已发布的课程数量是：&quot;+courseList.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Boss类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Boss &#123;</span><br><span class="line"></span><br><span class="line">    public void commandCheckNumber(TeamLeader teamLeader)&#123;</span><br><span class="line">        &#x2F;&#x2F;模拟 Boss 一页一页往下翻页，TeamLeader 实时统计</span><br><span class="line">        List&lt;Course&gt; courseList &#x3D; new ArrayList&lt;Course&gt;();</span><br><span class="line">        for (int i&#x3D; 0; i &lt; 10 ;i ++)&#123;</span><br><span class="line">            courseList.add(new Course());</span><br><span class="line">        &#125;</span><br><span class="line">        teamLeader.checkNumberOfCourses(courseList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Boss boss &#x3D; new Boss();</span><br><span class="line">        TeamLeader teamLeader &#x3D; new TeamLeader();</span><br><span class="line">        boss.commandCheckNumber(teamLeader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码根据迪米特原则，老板Boss只想要结果，不需要跟Course产生直接交流。而课程负责人统计要引用Course对象。Boss和Course并不是朋友，我们需要修改代码：</p>
<p>TeamLeader类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class TeamLeader &#123;</span><br><span class="line"></span><br><span class="line">    public void checkNumberOfCourses()&#123;</span><br><span class="line">        List&lt;Course&gt; courseList &#x3D; new ArrayList&lt;Course&gt;();</span><br><span class="line">        for(int i &#x3D; 0 ;i &lt; 10;i++)&#123;</span><br><span class="line">            courseList.add(new Course());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;目前已发布的课程数量是：&quot;+courseList.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Boss类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Boss &#123;</span><br><span class="line"></span><br><span class="line">    public void commandCheckNumber(TeamLeader teamLeader)&#123;</span><br><span class="line">        teamLeader.checkNumberOfCourses();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Boss boss &#x3D; new Boss();</span><br><span class="line">        TeamLeader teamLeader &#x3D; new TeamLeader();</span><br><span class="line">        boss.commandCheckNumber(teamLeader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>得到的：学习软件设计原则，千万不能形成强迫症。碰到业务复杂的场景，我们需要随机应变。</strong></p>
<h2 id="1-6-里氏替换原则（Liskov-Substitution-Principle，LSP）"><a href="#1-6-里氏替换原则（Liskov-Substitution-Principle，LSP）" class="headerlink" title="1.6 里氏替换原则（Liskov Substitution Principle，LSP）"></a>1.6 里氏替换原则（Liskov Substitution Principle，LSP）</h2><p>里氏替换原则是指如果对每一个类型T1的对象o1,都有类型为T2的对象o2,使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。</p>
<p>定义看上去还是比较抽象，可以理解为<strong>如果适应一个父类的话，那一定是适用于子类，所有的引用父类的地方必须能透明的使用子类的对象，子类对象能够替换父类对象，而程序逻辑不变。</strong> 总结一下：</p>
<p>引申含义：子类可以扩展父类的功能，但不能改变父类原有的功能。</p>
<p>1、子类可以实现父类的抽象方法，但不能覆盖父类的抽象方法；</p>
<p>2、子类中可以增加自己特有的方法；</p>
<p>3、当子类的方法覆盖父类的方法时，方法的前置条件（即方法的输入/入参）要比父类方法的输入参数更宽松；</p>
<p>4、当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的输出/返回值）要比父类更严格或者相等。</p>
<p>我们在开闭原则的代码案例中在获取折后时覆盖了父类的getPrice()方法，增加了一个获取优惠价格后的方法getOriginPrice(),显然就违背了里氏替换原则。接下来我们不覆盖getPrice()方法，增加getDiscountBook()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ComputerDiscountBook extends ComputerBook &#123;</span><br><span class="line">    public ComputerDiscountBook(Integer id, String name, Double price) &#123;</span><br><span class="line">        super(id, name, price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Double getDiscountBook() &#123;</span><br><span class="line">        return super.getPrice() * 0.8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用里氏替换原则有以下几个优点：</p>
<p>1、约束继承泛滥，开闭原则的一种体现；</p>
<p>2、加强程序的健壮性，同时变更时可以做到很好的兼容性，提高程序的维护性、扩展性。降低需求变更时引入的风险。</p>
<p>现在用正方形、矩形和四边形来说明里氏替换原则，我们都知道正方形是一个特殊的长方形，创建一个长方形父类Rectangle：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Rectangle &#123;</span><br><span class="line"></span><br><span class="line">    private long width;</span><br><span class="line"></span><br><span class="line">    private long height;</span><br><span class="line"></span><br><span class="line">    public long getWidth() &#123;</span><br><span class="line">        return width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setWidth(long width) &#123;</span><br><span class="line">        this.width &#x3D; width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getHeight() &#123;</span><br><span class="line">        return height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHeight(long height) &#123;</span><br><span class="line">        this.height &#x3D; height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建正方形Square类继承Rectangle长方形类，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Square extends Rectangle &#123;</span><br><span class="line"></span><br><span class="line">    private long length;</span><br><span class="line">    public long getLength() &#123;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setLength(long length) &#123;</span><br><span class="line">        this.length &#x3D; length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public long getWidth() &#123;</span><br><span class="line">        return getLength();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public long getHeight() &#123;</span><br><span class="line">        return getLength();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void setHeight(long height) &#123;</span><br><span class="line">        setLength(height);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void setWidth(long width) &#123;</span><br><span class="line">        setLength(width);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在测试类中创建 resize()方法，根据逻辑长方形的宽应该大于等于高，我们让高一直自增，知道高等于宽变成正方形：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void resize(Rectangle rectangle)&#123;</span><br><span class="line">        while (rectangle.getWidth() &gt;&#x3D; rectangle.getHeight())&#123;</span><br><span class="line">            rectangle.setHeight(rectangle.getHeight() + 1);</span><br><span class="line">            System.out.println(&quot;width:&quot;+rectangle.getWidth() + &quot;,height:&quot;+rectangle.getHeight());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;resize 方法结束&quot; +</span><br><span class="line">                &quot;\nwidth:&quot;+rectangle.getWidth() + &quot;,height:&quot;+rectangle.getHeight());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">        Rectangle rectangle &#x3D; new Rectangle();</span><br><span class="line">        rectangle.setWidth(20);</span><br><span class="line">        rectangle.setHeight(10);</span><br><span class="line">        resize(rectangle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/18/17058a6cffb9fefd?w=502&h=589&f=png&s=35867" alt=""></p>
<p>修改代码把长方形Rectangle替换成它的子类正方形Square：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Square square &#x3D; new Square();</span><br><span class="line">        square.setLength(10);</span><br><span class="line">        resize(square);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候我们运行的时候就出现了死循环，违背了里氏替换原则，将父类替换为子类后，程序运行结果没有达到预期。因此，我们的代码设计是存在一定风险的。里氏替换原则只存在父类与子类之间，约束继承泛滥。再来创建一个基于长方形与正方形共同抽象的四边形Quadrangle接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Quadrangle &#123;</span><br><span class="line">    </span><br><span class="line">    long getWidth();</span><br><span class="line">    </span><br><span class="line">    long getHeight();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改长方形 Rectangle 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Rectangle implements Quadrangle &#123;</span><br><span class="line"></span><br><span class="line">    private long height;</span><br><span class="line">    private long width;</span><br><span class="line">    @Override</span><br><span class="line">    public long getWidth() &#123;</span><br><span class="line">        return width;</span><br><span class="line">    &#125;</span><br><span class="line">    public long getHeight() &#123;</span><br><span class="line">        return height;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setHeight(long height) &#123;</span><br><span class="line">        this.height &#x3D; height;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setWidth(long width) &#123;</span><br><span class="line">        this.width &#x3D; width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改正方形类 Square 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Square implements Quadrangle &#123;</span><br><span class="line"></span><br><span class="line">    private long length;</span><br><span class="line">    public long getLength() &#123;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setLength(long length) &#123;</span><br><span class="line">        this.length &#x3D; length;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public long getWidth() &#123;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public long getHeight() &#123;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，如果我们把 resize()方法的参数换成四边形 Quadrangle类，方法内部就会报错。因为正方形 Square 已经没有了 setWidth()和 setHeight()方法了。因此，为了约束继承泛滥，resize()的方法参数只能用 Rectangle 长方形。</p>
<h2 id="1-7-合成复用原则-（Composite-Aggregate-Reuse-Principle，CARP）"><a href="#1-7-合成复用原则-（Composite-Aggregate-Reuse-Principle，CARP）" class="headerlink" title="1.7 合成复用原则 （Composite/Aggregate Reuse Principle，CARP）"></a>1.7 合成复用原则 （Composite/Aggregate Reuse Principle，CARP）</h2><p>合成复用原则是指尽量使用对象组合/聚和，而不是用继承关系达到对象复用的目的。这样可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其它类造成的影响也较少。</p>
<p><strong>继承又叫做白箱复用，相当于把所有的实现细节暴露给子类。组合/聚和也成为黑箱复用，对类以外的对象是无法获取到实现细节的。</strong> 需要根据具体的业务场景来设计代码，其实也要遵循OOP模型。这里以数据库操作为例，先创建DBConnection类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class DBConnection &#123;</span><br><span class="line"></span><br><span class="line">    public String getConnection()&#123;</span><br><span class="line">        return &quot;MySQL 数据库连接&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 ProductDao 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ProductDao &#123;</span><br><span class="line"></span><br><span class="line">    private DBConnection dbConnection;</span><br><span class="line">    public void setDbConnection(DBConnection dbConnection) &#123;</span><br><span class="line">        this.dbConnection &#x3D; dbConnection;</span><br><span class="line">    &#125;</span><br><span class="line">    public void addProduct()&#123;</span><br><span class="line">        String conn &#x3D; dbConnection.getConnection();</span><br><span class="line">        System.out.println(&quot;使用&quot;+conn+&quot;增加产品&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是非常典型的合成复用原则的应用场景。但是DBConnection还不是一种抽象，不便于系统扩展。目前系统只支持Mysql数据库连接，假设业务发生变化，数据库操作层要支持Oralce数据库。当然，可以在DBConnection中增加对Oracle数据库支持的方法。但是违背了开闭原则。我们可以不修改Dao的代码，将DBConnection改为abstract，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class DBConnection &#123;</span><br><span class="line">    public abstract String getConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，将 MySQL 的逻辑抽离：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MySqlConnection extends DBConnection &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getConnection() &#123;</span><br><span class="line">        return &quot;MySQL 数据库连接&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再创建 Oracle 支持的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class OracleConnection extends DBConnection &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getConnection() &#123;</span><br><span class="line">        return &quot;Oracle 数据库连接&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、-设计原则总结"><a href="#二、-设计原则总结" class="headerlink" title="二、 设计原则总结"></a>二、 设计原则总结</h1><p>学习设计原则，学习设计模式的基础。在实际开发过程中，并不是所有的代码都要遵循设计原则。我们需要考虑人力、时间、成本、质量，不是刻意的追求完美，要在适当的场景下遵循设计原则，体现的是一种平衡的取舍，帮助我们设计出更加优美的代码结构。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/02/19/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%E7%B2%BE%E9%80%89%E6%A1%88%E4%BE%8B/" data-id="ck9tm3e6t000phyraebip65if" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-如何优雅的学习JVM，终结篇（六）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/17/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AD%A6%E4%B9%A0JVM%EF%BC%8C%E7%BB%88%E7%BB%93%E7%AF%87%EF%BC%88%E5%85%AD%EF%BC%89/" class="article-date">
  <time datetime="2020-02-17T07:30:08.000Z" itemprop="datePublished">2020-02-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/17/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AD%A6%E4%B9%A0JVM%EF%BC%8C%E7%BB%88%E7%BB%93%E7%AF%87%EF%BC%88%E5%85%AD%EF%BC%89/">如何优雅的学习JVM，终结篇（六）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、如何计算一个对象占用的内存大小？"><a href="#一、如何计算一个对象占用的内存大小？" class="headerlink" title="一、如何计算一个对象占用的内存大小？"></a>一、如何计算一个对象占用的内存大小？</h1><p>我们在编写代码的过程中会创建大量的对象，有没有考虑到底某个对象占用了多少内存呢？</p>
<p>在C/C++中，我们可以通过sizeof()函数来计算一个变量或者类型所占用的大小，然而在Java中并没有这样的系统调用，那么在Java中如何实现类似的计算对象占用的内存大小呢？Java对象的内存结构，我们在前面的章节也进行了学习，它包括<strong>对象头（标记位、对象指针）、实例数据、对齐填充</strong>。那么我们只要按照顺序计算出各个区域所占用的内存并求和就可以了。其实仔细想想肯定没有这么简单，其中还有很多细节问题需要考虑。</p>
<ul>
<li>对象头</li>
</ul>
<p>在不开启JVM对象头压缩的情况下：</p>
<p><strong>32位</strong> JRE中一个对象头大小是<strong>8个字节</strong>（4 + 4）</p>
<p><strong>64位</strong> JRE中则是<strong>16个字节</strong>（8 + 8）</p>
<ul>
<li>实例数据</li>
</ul>
<p>成员变量主要包括两种：基本类型和引用类型，非静态成员变量所占用的数据。在确定JRE运行环境中，基本类型和引用类型占用的内存大小都是确定的，因此需要简单通过反射做个加法似乎就可以了。但是实际情况不是你想的这样简单，让我们来写代码测试一下吧。</p>
<p>通过jol工具可以查看到一个对象的实际内存布局，我们使用OpenJDK，提供了JOL包，<strong>官网：</strong> <a href="http://openjdk.java.net/projects/code-tools/jol/" target="_blank" rel="noopener">http://openjdk.java.net/projects/code-tools/jol/</a></p>
<p>POM依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jol&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jol-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.8&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>


<p>创建一个如下示例代码的测试类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line">public class Pojo &#123;</span><br><span class="line">    public int a;</span><br><span class="line">    public String b;</span><br><span class="line">    public int c;</span><br><span class="line">    public boolean d;</span><br><span class="line">    private long e; &#x2F;&#x2F; e设置为私有的，后面讲解为什么</span><br><span class="line">    public Object f;</span><br><span class="line">    Pojo() &#123; e &#x3D; 1024L;&#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Pojo pojo &#x3D; new Pojo();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(pojo).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 jol 工具查看其内存布局如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> OFFSET  SIZE               TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4                    (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4                    (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4                    (object header)                           05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315)</span><br><span class="line">     12     4                int Pojo.a                                    0</span><br><span class="line">     16     8               long Pojo.e                                    1024</span><br><span class="line">     24     4                int Pojo.c                                    0</span><br><span class="line">     28     1            boolean Pojo.d                                    false</span><br><span class="line">     29     3                    (alignment&#x2F;padding gap)                  </span><br><span class="line">     32     4   java.lang.String Pojo.b                                    null</span><br><span class="line">     36     4   java.lang.Object Pojo.f                                    null</span><br><span class="line">Instance size: 40 bytes</span><br><span class="line">Space losses: 3 bytes internal + 0 bytes external &#x3D; 3 bytes total</span><br></pre></td></tr></table></figure>

<p>由此可以看出对象头所占用的大小为12字节。从这个内存布局表上不难看出，成员变量在实际分配内存时，并不是按照声明的顺序来储存的，此外在变量d之后，还出现了一块用于对齐内存的padding gap，这说明计算对象实际数据所占用的内存大小时，并不是简单的求和就可以的。</p>
<p>在上面的内存布局表中，可以看到OFFSET一列，这就是对应变量的偏移地址，如同C++中的指针，其实就是告诉了CPU要从什么位置取出对应的数据。举个例子，假设 Pojo 类的一个对象pojo存放在以 0x0010 开始的内存空间中，我们需要获取它的成员变量 b ，由于其偏移地址是 32（转换成十六进制为20），占用大小是 4 ，那么实际储存变量b的内存空间就是 0 x0030 ~ 0x0033 ，根据这个 CPU 就可以很容易地获取到变量了。</p>
<p>实际上在反射中，正式通过这样的方式来获取指定属性的值，具体实际上则需要借助强大的Unsafe工具。Unsafe可以实现系统底层不可思议的操作（比如修改变量的可见性，分配和回收堆外内存等），不过正因为其功能的强大性，随意使用有可能引发程序崩溃，所以官方不建议在除系统之外（如反射等）以外的场景使用，使用Unsafe如何通过变量偏移地址来获取一个变量。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testUnsafe() throws Exception &#123;</span><br><span class="line">        Class&lt;?&gt; unsafeClass &#x3D; null;</span><br><span class="line">        Unsafe unsafe &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            unsafeClass &#x3D; Class.forName(&quot;sun.misc.Unsafe&quot;);</span><br><span class="line">            final Field unsafeField &#x3D; unsafeClass.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">            unsafeField.setAccessible(true);</span><br><span class="line">            unsafe &#x3D; (Unsafe) unsafeField.get(null);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Pojo pojo &#x3D; new Pojo();&#x2F;&#x2F;上面案例的测试实体类</span><br><span class="line">        Field field &#x3D; Pojo.class.getDeclaredField(&quot;e&quot;);</span><br><span class="line">        long offset &#x3D; unsafe.objectFieldOffset(field);</span><br><span class="line">        if(offset &gt; 0L) &#123;</span><br><span class="line">            long eVal &#x3D; unsafe.getLong(pojo, offset);</span><br><span class="line">            System.out.println(eVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果打印：<strong>1024</strong></p>
<p>出于安全起见，一般情况下在正常的代码中是无法直接获取 Unsafe的实例的，这里我们通过反射的方式hack了一把来拿到 unsafe实例。接着通过调用 <strong>objectFieldOffset</strong> 方法获取到成员变量 e的地址偏移为 16（和 jol 中的结果一致），最终我们通过 <strong>getLong()</strong> 方法，传入e 的地址偏移量，便获取到了 e 的值。可以看到尽管 Pojo 类中 e是一个私有属性，通过这种方法依然是可以获取到它的值的</p>
<p>有了调用Unsafe的objectFieldOffset，我们可以通过代码精确的计算一个对象在内存中所占用的空间大小了，递归遍历对象中所有的引用并计算他们指向的实际对象的浅内存占用，最终求和即可。考虑到会有大量重复的类出现，我们可以使用一个数组来缓存已经计算过浅内存占用的class，避免重复计算。</p>
<p>如果引用指向了数组或者集合类型，那么只需要计算其基本元素的大小，然后乘以数组长度/集合大小即可。</p>
<p>具体实现代码在此不过多赘述，可以直接参考源代码（ from Apache luence ，入口方法为 sizeOf ( Object )）。</p>
<p>源代码：<br><a href="https://github.com/MarkLux/Java-Memory-Monitor/blob/master/src/main/java/cn/marklux/memory/RamUsageEstimator.java" target="_blank" rel="noopener">https://github.com/MarkLux/Java-Memory-Monitor/blob/master/src/main/java/cn/marklux/memory/RamUsageEstimator.java</a></p>
<p>需要注意的是，<strong>这种计算对象内存的方法并不是毫无代价的，由于使用了递归、反射和缓存，在性能和空间上都会有一定的消耗。</strong></p>
<h1 id="二、性能优化经验总结"><a href="#二、性能优化经验总结" class="headerlink" title="二、性能优化经验总结"></a>二、性能优化经验总结</h1><h2 id="2-1-性能优化的背景"><a href="#2-1-性能优化的背景" class="headerlink" title="2.1 性能优化的背景"></a>2.1 性能优化的背景</h2><p>大家平时一定遇到过这样的问题：单机的线程池队列爆满，使用集群扩容增加集群；系统内存占用高，高峰时段OOM，重启就分分钟解决了等一系列的问题。如果临时性的补救措施只能是给应用埋雷，同时只能解决部分问题，治标不治本。</p>
<p>添加硬件资源并不一定能够解决系统的性能问题，反而有时候会造成资源的浪费，得不偿失。因此对系统进行合理的性能优化，可以在系统稳定性、成本核算获得很大的收益。</p>
<p>假设现在我们的系统已经出现了性能问题，需要准备开始进行优化工作，那么在这个优化过程中，潜在的痛点有哪些呢？</p>
<p><strong>1、对性能优化的流程不是很清晰。</strong> 最终需要解决的问题其实是一个浅层次的性能瓶颈，真实的问题的根源并不能触达。</p>
<p><strong>2、对性能瓶颈点的分析思路不是很清晰。</strong> 网路、CPU、内存等这么多的性能指标，到底该关注什么，应该从哪一块开始入手呢？</p>
<p><strong>3、对性能优化的工具不是很了解。</strong> 遇到问题后，不清楚使用哪个工具，不知道通过工具得到的指标代表着什么。</p>
<h2 id="2-2-性能优化的流程"><a href="#2-2-性能优化的流程" class="headerlink" title="2.2 性能优化的流程"></a>2.2 性能优化的流程</h2><p><strong>1、准备阶段：</strong> 通过性能测试，了解系统的概况、瓶颈的大概方向，明确优化目标；</p>
<p><strong>2、分析阶段：</strong> 通过各种工具或手段，初步定为性能瓶颈点；</p>
<p><strong>3、调优阶段：</strong> 根据定位到的瓶颈点，进行系统性能调优。</p>
<p><strong>4、测试阶段：</strong> 让调优后的系统进行性能测试，与准备阶段的各项指标进行对比，观察其是否属于预期，如果瓶颈点没有消除或者性能指标不符合预期，则重复2和3步骤。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/15/1704814cc768f998?w=748&h=967&f=png&s=46807" alt=""></p>
<ul>
<li><p>准备阶段详解：</p>
<p>  <strong>对性能问题进行粗略评估，</strong> 比如线上应用日志级别不合理，可能会在大流量的时候导致CPU和磁盘的负载过高，这种情况需要调整日志级别；</p>
<p>  <strong>了解应用的总体架构，</strong> 应用依赖的外部接口和本身核心接口有哪些，使用了哪些框架和组件，哪些接口，模块的使用率较高，上下游的数据链路是怎么样的；</p>
<p>  <strong>了解应用对应的服务器信息，</strong> 服务器所在的集群信息、服务器的CPU、内存等信息，安装的操作系统Linux版本信息，服务器是容器还是虚拟机，所在的宿主机混部（把集群混合起来，将不同类型的任务调度到相同的物理资源上，通过调度，资源隔离等控制手段 , 在保障 SLO（服务等级目标） 的基础上，充分使用资源能力，极大降低成本）后是否当前应用有影响等。</p>
<p>  a、通过压测工具或者压测平台（如果公司有的话），对应用进行压力测试，获取当前应用的宏观指标。也可以结合当前的实际业务和过往的监控数据，去统计一些核心业务指标，比如午高峰的服务TPS。</p>
</li>
</ul>
<pre><code>* 响应时间


* 吞吐量


* TPS


* QPS


* 消费速率（对于使用MQ的中间件）


b、可以Linux基准测试工具，得到文件系统、磁盘I/O、网络等性能报告，还有GC、Web服务器、网卡流量等信息。


* jmeter


* ab


* loadrunnerwrk


* wrk</code></pre><ul>
<li><p>测试阶段详解：</p>
<p>  <strong>性能瓶颈点通常呈现2/8分布，</strong> 即80%的性能问题通常是由20%的性能瓶颈点导致的，2/8原则也以为着并不是所有的性能问题都值得去优化；</p>
<p>  <strong>不要过度追求应用的单机性能，</strong> 如果单机表现良好，则应该从架构的角度去思考；比如过滤追求CPU的性能而忽略了内存方面的瓶颈；</p>
<p>  <strong>整个应用的优化，应与线上系统隔离</strong>， 新的代码上线应该有降级方案。</p>
</li>
</ul>
<h2 id="2-3-工具箱"><a href="#2-3-工具箱" class="headerlink" title="2.3 工具箱"></a>2.3 工具箱</h2><p>工欲善其事必先利其器，我们该如何选择合适的工具呢？先来看看Linux性能工具图吧。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/15/17048d7bd472a3b7?w=3000&h=2100&f=png&s=941208" alt=""></p>
<p>上面的这张图非常经典，是做性能优化时候非常好的参考资料，但是事实上，我们在实际运用的时候，会发现可能并不合适。所以需要给出一张更为实用的图，该图从系统层、应用层（含组件层）的角度，列举我们在分析性能问题需要关注的各项指标，这些点是最有可能出现性能瓶颈的地方。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/15/1704919977f1208e?w=1246&h=1850&f=png&s=109125" alt=""></p>
<p>下面针对不同层次的核心性能指标做如下分析，同时也会介绍如何初步根据这些指标，判断系统或者应用是否存在性能瓶颈点。</p>
<h2 id="2-3-1-网络"><a href="#2-3-1-网络" class="headerlink" title="2.3.1 网络"></a>2.3.1 网络</h2><p>这里说的网络指的是应用层的网络，通常指的是：</p>
<ul>
<li>网络带宽：表示链路的最大传输速率；</li>
<li>网络吞吐：表示单位时间内成功传输的数据量大小；</li>
<li>网络延时：表示从网络从请求发出后直到收到远端响应，所需要的时间；</li>
<li>网络连接数和错误数。</li>
</ul>
<p>应用层的网络瓶颈有如下几类：</p>
<ul>
<li>网络出现分区；</li>
<li>集群或机器所在的机房的网络带宽饱和，影响应用的<strong>TPS/QPS</strong>的提升；</li>
<li>网络吞吐出现异常，如接口存在大量的数据传输，造成贷款占用过高；</li>
<li>网络连接出现异常或错误。</li>
</ul>
<p>带宽和网络吞吐两个指标，一般会关注整个应用的，并通过监控系统可以直接得到，如一段时间内出现了明显的指标上升，说明存在网络瓶颈。对于单机，可以使用<strong>sar命令</strong>得到网络接口，进程的网络吞吐。</p>
<p>使用<strong>ping</strong>或<strong>hping3</strong>可以得到是否出现网络分区、网络具体时延。整个应用链路的时延，可以通过中间件埋点后输出的trace日志得到链路上各个环节的时延信息。</p>
<p>使用<strong>netstat、ss</strong>和<strong>sar</strong>可以获取网络连接数或网络错误数。系统可以支撑的网络连接数是有限的，一是会占用<strong>文件描述符</strong>，二是会占用<strong>缓存</strong>。</p>
<h2 id="2-3-2-磁盘和文件"><a href="#2-3-2-磁盘和文件" class="headerlink" title="2.3.2 磁盘和文件"></a>2.3.2 磁盘和文件</h2><p>磁盘以及文件系统主要关注的指标有，常用命令有iostat（用于真个系统）和pidstat（用于具体的I/O进程）：</p>
<ul>
<li>磁盘I/O利用率：是指磁盘处理I/O的时间百分比；</li>
<li>磁盘吞吐量：是指每秒的I/O请求大小，单位为KB；</li>
<li>I/O响应时间：是指I/O请求从发出到收到响应的间隔，包含在队列中等待的时间和处理时间；</li>
<li>IOPS（Input/Output Per Second）：每秒I/O请求数；</li>
<li>I/O等待队列大小：是指平均I/O队列长度，队列长度越短越好。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zea13o0oyywo7z5hawlz ~]# iostat -dx</span><br><span class="line">Linux 3.10.0-693.2.2.el7.x86_64 (iz2zea13o0oyywo7z5hawlz) 	02&#x2F;16&#x2F;2020 	_x86_64_	(1 CPU)</span><br><span class="line"></span><br><span class="line">Device:         rrqm&#x2F;s   wrqm&#x2F;s     r&#x2F;s     w&#x2F;s    rkB&#x2F;s    wkB&#x2F;s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">vda               0.00     0.11    0.01    0.29     0.23     2.61    18.68     0.00    5.97    4.32    6.03   0.16   0.00</span><br></pre></td></tr></table></figure>

<p><strong>%util：</strong> 磁盘的I/O利用率，同CPU利用率一样，这个值也可能超过100%（存在并行I/O）；</p>
<p><strong>rKB/s、wKB/s：</strong> 每秒从磁盘读取和写入的数据量，即吞吐量，单位为KB；</p>
<p><strong>r_await、w_await：</strong> 读和写请求处理的响应时间；</p>
<p><strong>r/s、w/s：</strong> 每秒发送给磁盘的读请求数和写请求数；</p>
<p><strong>svctm：</strong> 该指标废弃，表示处理I/O所需的平均时间；</p>
<p><strong>pidstat</strong> 的输出大部分和 <strong>iostat</strong> 类似，区别在于它可以实时查看每个进程的 I/O 情况。</p>
<p><strong>如何判断磁盘的指标出现了异常？</strong></p>
<p>1、当 <strong>%util</strong> （磁盘利用率）长时间超过<strong>80%</strong>，或者响应时间过大（<strong>SSD，从0.0x毫秒到1.x毫秒不等，机械硬盘一般为5毫秒到10毫秒</strong>），通常意味着磁盘I/O存在性能瓶颈。</p>
<p>2、如果 <strong>%util</strong> 很大，而rKB/s和wKB/s很小，一般因为存在较多的磁盘随机读写，<strong>最好把随机读写优化成顺序读写</strong>，可以通过<strong>strace</strong>或<strong>blktrace</strong>观察I/O是否连续判断是否是顺序读写行为，<strong>随机读写应该关注IOPS指标，顺序读写可以关注吞吐量指标。</strong></p>
<p>3、如果<strong>avgqu-sz</strong> 比较大，说明有很多I/O<strong>在请求队列中等待</strong>。如果单块磁盘的队列长度持续<strong>超过2</strong>，一般认为该磁盘存在I/O性能问题。</p>
<h2 id="2-3-3-CPU和线程"><a href="#2-3-3-CPU和线程" class="headerlink" title="2.3.3 CPU和线程"></a>2.3.3 CPU和线程</h2><p>CPU关注的指标主要有以下几个。常用的命令有top、ps、uptime、vmstat、pidstat等。</p>
<ul>
<li>CPU利用率（CPU Utilization）</li>
<li>CPU平均负载（Load Average）</li>
<li>上下文切换次数（Context Switch）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">top - 14:58:36 up 18 days,  1:31,  1 user,  load average: 0.00, 0.01, 0.05</span><br><span class="line">Tasks:  63 total,   1 running,  62 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.3 us,  0.3 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  1883420 total,   109840 free,   187712 used,  1585868 buff&#x2F;cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.  1494900 avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                              </span><br><span class="line"> 1008 root      10 -10  132300  14672   9420 S  1.0  0.8 210:54.23 AliYunDun                                                            </span><br><span class="line">    1 root      20   0   43264   3708   2500 S  0.0  0.2   0:12.20 systemd</span><br></pre></td></tr></table></figure>
<p>第一行显示内容：当前时间、系统运行时间以及正在登录的用户数。<strong>load average</strong>后的三个数字，依次表示过去1分钟、5分钟、15分钟的平均负载。<strong>CPU的平均负载和CPU的使用率没有直接的关系</strong>。</p>
<p>第三行显示内容：表示CPU利用率，计算公式：<strong>CPU利用率 = 1 - CPU空闲时间/CPU总的时间。</strong> 注：top工具显示的CPU利用率是把所有的CPU核的数值加起来，即<strong>8核CPU的利用率最大可以达到800%</strong>，可以用（<strong>htop命令代替top进行查看</strong>）。</p>
<p>查看<strong>CPU上下文切换次数</strong>可以用<strong>vmstat</strong>命令进行查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zea13o0oyywo7z5hawlz ~]# vmstat</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 2  0      0 109592 141200 1445092    0    0     0     3   12   22  0  0 99  0  0</span><br></pre></td></tr></table></figure>

<p>上面的 <strong>cs（Context Swtich）</strong> 就是每秒上下文切换次数，过多的上下文切换次数，会把CPU时间消耗<strong>在寄存器、内核栈以及虚拟内存等</strong>数据保存和恢复上，从而缩短进程真正的运行时间，导致系统的整体性能大幅下降。</p>
<p><strong>us、sy分别是用户态和内核态的CPU利用率。</strong></p>
<p><strong>vmstat</strong>给出的是系统总体的上下文切换情况，想要查看每个进程的上下文切换详情，需要使用<strong>pidstat</strong>命令，<strong>该命令还可以查看某个进程用户态和内核态的CPU利用率。</strong></p>
<p><strong>CPU相关指标异常的分析思路是什么呢？</strong></p>
<p><strong>1、CPU利用率：</strong> 观察某段时间系统或者应用进程的CPU利用率一直很高（<strong>单个超过80%</strong>），可以多次使用jstack命令dump应用线程栈查看热点线程代码。</p>
<p><strong>2、CPU平均负载：</strong> <strong>平均负载高与CPU数量70%</strong>，意味着系统存在瓶颈，通过监控系统检测平均负载的变化趋势，更容易定位问题，有时候加载大文件的时候，也会导致平均负载瞬时升高。<strong>如果1分钟/5分钟/15分钟的三个值相差不是很大，则说明系统负载很平稳，如果这三个值逐渐降低，说明负载在逐渐升高</strong>，需要重点关注。</p>
<p><strong>3、CPU上下文切换次数：</strong> 这个指标取决于系统本身的CPU性能，以及当前应用的工作情况。<strong>如果系统或者应用的上下文切换次数出现数量级的增长的时候，则说明有很大概率存在性能问题，如果是非自愿的上下文切换次数大幅度上升，说明有太多的线程竞争CPU。</strong></p>
<p><strong>这三个指标是密切相关的，如频繁的CPU上下文切换，可能会导致平均负载升高。</strong></p>
<p><strong>关于线程，可关注的异常有：</strong></p>
<ul>
<li><strong>线程的总数是否过多。</strong> 线程过多，就会在CPU上频繁的进行上下文切换，同时线程过多也会消耗内存，线程的总数大小和应用本身和机器配置相关。</li>
<li><strong>线程的状态是否异常。</strong> 观察<strong>WAITING/BLOCKED</strong> 状态线程是否过多（线程数量设置过多或锁竞争剧烈），综合应用内部锁使用的情况进行进一步分析。</li>
<li><strong>结合CPU利用率，观察是否存在大量消耗CPU的线程。</strong></li>
</ul>
<h2 id="2-3-4-内存和堆"><a href="#2-3-4-内存和堆" class="headerlink" title="2.3.4 内存和堆"></a>2.3.4 内存和堆</h2><p>和内存相关的指标主要有以下几个，常用命令是<strong>top、free、vmstat、pidstat</strong>以及JDK自带的一些工具。</p>
<ul>
<li>系统内存使用情况，包括剩余内存、已用内存、可用内存、缓存/缓冲区；</li>
<li>进程（包含Java进程）的虚拟内存、常驻内存、共享内存；</li>
<li>进程的缺页异常数、包含主缺页异常和次缺页异常；</li>
<li>Swap换入和换出的内存大小、Swap参数配置；</li>
<li>JVM堆的分配、JVM启动参数；</li>
<li>JVM堆的回收、GC情况。</li>
</ul>
<p>使用free查看系统内存使用情况和Swap分区使用情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zea13o0oyywo7z5hawlz ~]# free -h</span><br><span class="line">              total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:           1.8G        182M        106M        364K        1.5G        1.4G</span><br><span class="line">Swap:            0B          0B          0B</span><br></pre></td></tr></table></figure>
<p>Swap：把一个本地文件或者一块磁盘的空间作为内存来使用，包括换入和换出两个过程。<strong>Swap分区的升高一般和磁盘的使用强相关，具体分析，需要结合缓存的使用情况，swappiness阈值以及匿名页和文件页的活跃情况综合分析。</strong></p>
<p>buff/cache：缓存和缓冲区大小。<strong>缓存（cache）：</strong> 从磁盘读取的文件或者向磁盘写文件的临时存储数据，面向文件。<strong>使用cachestat可以查看真个系统缓存的读写命中情况，使用cachetop可以观察每个进程缓存的读写命中情况。</strong> <strong>缓冲区（buff）：</strong> 写入磁盘数据或者从磁盘直接读取的数据的临时存储，面向块设备。<strong>free 命令的输出中，这两个指标是加在一起的，使用 vmstat 命令可以区分缓存和缓冲区，还可以看到 Swap 分区换入和换出的内存大小。</strong></p>
<p><strong>性能优化中常见的内存问题有哪些呢？</strong></p>
<p>1、系统剩余内存/可用内存不足（某个进程占用太多、系统本身内存不足），内存溢出；</p>
<p>2、内存回收异常：内存泄漏（进程在一段时间内内存使用持续走高），GC频率异常；</p>
<p>3、缓存使用过大（大文件读取或写入）、缓存命中率不高；</p>
<p>4、缺页异常过多（频繁的I/O读）；</p>
<p>5、Swap分区使用异常（使用过大）。</p>
<p><strong>内存相关指标异常后，分析的思路是怎么样的？</strong></p>
<p>1、使用free发现缓存/缓冲区占用不大，排序缓存/缓冲区对内存的影响；</p>
<p>2、使用vmstat或者sar观察一下各个进程内存使用变化的趋势，发现某个进程的内存使用持续走高；</p>
<p>3、Java应用，使用jmap/VisualVM/heap dump等分析工具观察对象内存的分配，或者通过jstat观察GC后应用的内存变化；</p>
<p>4、结合业务场景，定位内存泄漏/GC参数配置不合理/业务代码异常等。</p>
<h2 id="2-4-使用总结"><a href="#2-4-使用总结" class="headerlink" title="2.4 使用总结"></a>2.4 使用总结</h2><p>有一些工具频繁出现，总结如下：</p>
<ul>
<li><p>CPU：top、vmstat、pidstat、sar、perf、jstack、jstat；</p>
</li>
<li><p>内存：top、free、vmstat、cachetop、cachestat、sar、jmap；</p>
</li>
<li><p>磁盘：top、iostat、vmstat、pidstat、du/df；</p>
</li>
<li><p>网络：netstat、sar、dstat、tcpdump；</p>
</li>
<li><p>应用：profiler、dump。</p>
</li>
</ul>
<h1 id="三、-性能优化思路总结"><a href="#三、-性能优化思路总结" class="headerlink" title="三、 性能优化思路总结"></a>三、 性能优化思路总结</h1><p><img src="https://user-gold-cdn.xitu.io/2020/2/17/17051e88cc4fdb78?w=1967&h=4959&f=png&s=2143045" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/02/17/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AD%A6%E4%B9%A0JVM%EF%BC%8C%E7%BB%88%E7%BB%93%E7%AF%87%EF%BC%88%E5%85%AD%EF%BC%89/" data-id="ck9tm3e6p000lhyraerezcwn9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-如何优雅的学习JVM，综合篇（五）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/13/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AD%A6%E4%B9%A0JVM%EF%BC%8C%E7%BB%BC%E5%90%88%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89/" class="article-date">
  <time datetime="2020-02-13T13:30:03.000Z" itemprop="datePublished">2020-02-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/13/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AD%A6%E4%B9%A0JVM%EF%BC%8C%E7%BB%BC%E5%90%88%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89/">如何优雅的学习JVM，综合篇（五）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、重新认识JVM"><a href="#一、重新认识JVM" class="headerlink" title="一、重新认识JVM"></a>一、重新认识JVM</h1><p>在之前的我们画过一张图，是从class文件到类装载器，再到运行时数据区的过程。今天把这张图进行升级，画一张完整的JVM大体的物理结构图。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/13/1703d58ce61dfd9e?w=1041&h=697&f=png&s=62727" alt=""></p>
<h1 id="二、-GC优化"><a href="#二、-GC优化" class="headerlink" title="二、 GC优化"></a>二、 GC优化</h1><p>内存被使用了之后，难免会有不够用或者达到设定值的时候，就需要对内存空间进行垃圾回收。</p>
<h2 id="2-1-垃圾收集发生的时间"><a href="#2-1-垃圾收集发生的时间" class="headerlink" title="2.1 垃圾收集发生的时间"></a>2.1 垃圾收集发生的时间</h2><p>GC由JVM自动完成的，根据JVM系统环境而定的，所以时机是不确定的。当然，我们也可以进行手动垃圾回收，比如调用System.gc()方法通知JVM进行一次垃圾回收，但是具体什么时刻运行也无法控制。也就是System.gc()只是通知要回收，什么时候回收由JVM自行决定。但是不建议手动进行垃圾回收，因为消耗的资源比较大。</p>
<p><strong>一般以下几种情况会进行垃圾回收</strong></p>
<ul>
<li>当Eden区或者S区不够用</li>
<li>老年代空间不够用</li>
<li>方法区看空间不够用</li>
<li>System.gc()</li>
</ul>
<h2 id="2-2-项目环境准备"><a href="#2-2-项目环境准备" class="headerlink" title="2.2 项目环境准备"></a>2.2 项目环境准备</h2><p>此次案例我们使用SpringBoot来创建项目，然后配置对应的参数。</p>
<h2 id="2-3-GC日志文件"><a href="#2-3-GC日志文件" class="headerlink" title="2.3 GC日志文件"></a>2.3 GC日志文件</h2><p><img src="https://user-gold-cdn.xitu.io/2020/2/13/1703d8a38b0e96c9?w=1174&h=633&f=png&s=59828" alt=""></p>
<p>要分析日志的信息，首先得拿到GC日志文件才行，所以得配置一下启动参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -Xloggc:gc.log</span><br></pre></td></tr></table></figure>

<p>然后启动项目</p>
<p>可以看到默认使用的是<strong>ParallelGC</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/13/1703d9807b8b571c?w=1594&h=193&f=png&s=98461" alt=""></p>
<p>1、ParallelGC日志</p>
<ul>
<li>吞吐量优先，日志分析</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-02-13T16:01:45.974+0800: 3.592: [GC (Allocation Failure) [PSYoungGen: 65536K【Young区回收前】-&gt;8294K【Young区回收后】(76288K【Young区总大小】)] 65536K【整个堆回收前】-&gt;8310K【整个堆回收后】(251392K【整个堆总大小】), 0.0253276 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.03 secs]</span><br></pre></td></tr></table></figure>

<p><strong>如果回收的差值有出入，则说明这部分空间是Old区释放出来的</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/13/1703da02d79da864?w=1609&h=520&f=png&s=258949" alt=""></p>
<p>2、CMS GC日志</p>
<ul>
<li>停顿时间优先</li>
</ul>
<p><code>参数设置：-XX:+UseConcMarkSweepGC -Xloggc:cms-gc.log</code></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/13/1703da8b88f3d7ed?w=1627&h=868&f=png&s=466196" alt=""></p>
<p>3、G1 GC日志</p>
<ul>
<li>停顿时间优先</li>
</ul>
<p><code>参数设置：-XX:+UseG1GC -Xloggc:g1-gc.log</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC  # 使用了G1垃圾收集器</span><br><span class="line"></span><br><span class="line">#什么时候发生的GC，相对的时间刻，GC发生的区域young，总共花费的时间，0.00444s</span><br><span class="line"></span><br><span class="line">2020-02-13T16:31:01.099+0800: 2.230: [GC pause (G1 Evacuation Pause) (young), 0.0044422 secs]</span><br><span class="line"></span><br><span class="line">#多少个垃圾回收线程，并行的时间</span><br><span class="line"></span><br><span class="line">[Parallel Time: 3.4 ms, GC Workers: 4]</span><br><span class="line"></span><br><span class="line">#GC线程开始相对于上面的0.2230的时间刻</span><br><span class="line">[GC Worker Start (ms): Min: 2230.2, Avg: 2230.2, Max: 2230.3, Diff: 0.1]</span><br><span class="line"></span><br><span class="line">#每个工作线程扫描根的时间</span><br><span class="line"></span><br><span class="line">[Ext Root Scanning (ms): Min: 0.5, Avg: 0.7, Max: 1.0, Diff: 0.5, Sum: 2.9]</span><br><span class="line"></span><br><span class="line">#每个线程更新记忆集所花费的时间</span><br><span class="line"></span><br><span class="line">[Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br></pre></td></tr></table></figure>

<p><strong>理解G1日志格式：</strong> <a href="https://blogs.oracle.com/poonam/understanding-g1-gc-logs" target="_blank" rel="noopener">https://blogs.oracle.com/poonam/understanding-g1-gc-logs</a></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/13/1703db30649ae319?w=1603&h=865&f=png&s=321487" alt=""></p>
<h2 id="2-4-GC日志文件分析工具"><a href="#2-4-GC日志文件分析工具" class="headerlink" title="2.4 GC日志文件分析工具"></a>2.4 GC日志文件分析工具</h2><p>1、gceasy</p>
<p><strong>官网：</strong> <a href="https://gceasy.io/" target="_blank" rel="noopener">https://gceasy.io/</a></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/13/1703db93c64d20e3?w=1759&h=751&f=png&s=197662" alt=""></p>
<p>可以比较不同的垃圾收集器的<strong>吞吐量</strong>和<strong>停顿时间</strong>，比如打开cms-gc.log和g1-gc.log</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/13/1703dc210eea9809?w=1840&h=739&f=png&s=121378" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/13/1703dc2f9be32a4a?w=1750&h=508&f=png&s=64580" alt=""></p>
<p>2、GCViewer</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/13/1703dd0c62e0f1fe?w=1924&h=1036&f=png&s=133027" alt=""></p>
<h2 id="2-5-G1调优与最佳指南"><a href="#2-5-G1调优与最佳指南" class="headerlink" title="2.5 G1调优与最佳指南"></a>2.5 G1调优与最佳指南</h2><p>是否选用G1垃圾收集器的判断依据，<strong>官网：</strong> <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/G1.html#use_cases" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/G1.html#use_cases</a></p>
<ul>
<li>50%以上的堆被存活对象占用</li>
<li>对象分配和晋升的速度变化非常大</li>
<li>垃圾回收时间比较长</li>
</ul>
<p><strong>思考：使用G1 GC增加堆使用率</strong><br><a href="https://blogs.oracle.com/poonam/increased-heap-usage-with-g1-gc" target="_blank" rel="noopener">https://blogs.oracle.com/poonam/increased-heap-usage-with-g1-gc</a></p>
<p>1、使用G1GC垃圾收集器: -XX:+UseG1GC</p>
<p>修改配置参数，获取到gc日志，使用GCViewer分析吞吐量和响应时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Throughput    Min Pause    Max Pause   Avg Pause    GC count</span><br><span class="line">99.16%         0.00016s     0.0137s    0.00559s     12</span><br></pre></td></tr></table></figure>
<p>2、调整内存大小再获取gc日志分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize&#x3D;100M</span><br><span class="line">-Xms300M</span><br><span class="line">-Xmx300M</span><br></pre></td></tr></table></figure>
<p>比如设置堆内存的大小，获取到gc日志，使用GCViewer分析吞吐量和响应时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Throughput    Min Pause    Max Pause   Avg Pause    GC count</span><br><span class="line">98.89%        0.00021s     0.01531s    0.00538s      12</span><br></pre></td></tr></table></figure>

<p>3、调整最大停顿时间</p>
<p><code>-XX:MaxGCPauseMillis=20  设置最大GC停顿时间指标</code></p>
<p>比如设置最大停顿时间，获取到gc日志，使用GCViewer分析吞吐量和响应时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Throughput    Min Pause    Max Pause   Avg Pause    GC count</span><br><span class="line">98.96%        0.00015s     0.01737s    0.00574s     12</span><br></pre></td></tr></table></figure>
<p>4、启动并发GC时堆内存占用百分比</p>
<p><code>-XX:InitiatingHeapOccupancyPercent=45</code></p>
<p>G1用它来触发并发GC周期,基于整个堆的使用率,而不只是某一代内存的<br>使用比例。值为 0 则表示“一直执行GC循环)’. 默认值为 45 (例如, 全部的 45% 或者使用了45%).</p>
<p>比如设置该百分比参数，获取到gc日志，使用GCViewer分析吞吐量和响应时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Throughput    Min Pause    Max Pause   Avg Pause    GC count</span><br><span class="line">  98.11%      0.00406s     0.00532s    0.00469s     12</span><br></pre></td></tr></table></figure>
<p><strong>最佳指南</strong></p>
<p><strong>官网建议：</strong> <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#recommendations" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#recommendations</a></p>
<p>1、<strong>不要手动设置新生代和老年代的大小，只要设置整个堆的大小</strong></p>
<p>G1收集器在运行过程中，会自己调整新生代和老年代大小，其实是通过adapt代的大小调整对象晋升的速度和年龄，从而到达为收集器设置的暂停时间目标，如果是手动设置了大小就意味着放弃了G1的自动调优</p>
<p>2、<strong>不断调优暂停时间目标</strong></p>
<p>一般情况下这个时间值设置到100ms或者200ms都是可以的（不同情况会不一样），但是如果设置成50ms就太不合理了。暂停时间设置的太短，就会出现G1 GC跟不上垃圾生产的速度，最终退化成Full GC。所以对这个参数的调优是一个持续的过程，逐步调整到最佳状态。暂停时间只是一个目标，并不是总能得到满足。</p>
<p>3、<strong>使用-XX:ConcGCThreads=n来增加标记线程的数量</strong></p>
<p>IHOP如果阀值设置过高，可能会遇到转移失败的风险，比如对象进行转移时空间不足。如果阀值设置过低，就会使标记周期运行过于频繁，并且有可能混合收集期回收不到空间。IHOP值如果设置合理，但是在并发周期时间过长时，可以尝试增加并发线程数，调高ConcGCThreads。</p>
<p>4、<strong>MixedGC调优</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:InitiatingHeapOccupancyPercent</span><br><span class="line">-XX:G1MixedGCLiveThresholdPercent</span><br><span class="line">-XX:G1MixedGCCountTarger</span><br><span class="line">-XX:G1OldCSetRegionThresholdPercent</span><br></pre></td></tr></table></figure>

<p>5、适当增加堆内存大小</p>
<h1 id="三、高并发场景案例分析"><a href="#三、高并发场景案例分析" class="headerlink" title="三、高并发场景案例分析"></a>三、高并发场景案例分析</h1><p><img src="https://user-gold-cdn.xitu.io/2020/2/13/1703e8f4a591c5ad?w=1299&h=904&f=png&s=75088" alt=""></p>
<h1 id="四、JVM性能优化指南"><a href="#四、JVM性能优化指南" class="headerlink" title="四、JVM性能优化指南"></a>四、JVM性能优化指南</h1><p><img src="https://user-gold-cdn.xitu.io/2020/2/13/1703ea8f325397ab?w=1041&h=838&f=png&s=48953" alt=""></p>
<h1 id="五、常见问题的思考与解决"><a href="#五、常见问题的思考与解决" class="headerlink" title="五、常见问题的思考与解决"></a>五、常见问题的思考与解决</h1><h2 id="5-1-内存泄漏与内存溢出的区别"><a href="#5-1-内存泄漏与内存溢出的区别" class="headerlink" title="5.1 内存泄漏与内存溢出的区别"></a>5.1 内存泄漏与内存溢出的区别</h2><p>内存泄漏：对象无法得到及时的回收，持续占用内存空间，从而造成内存空间的浪费。</p>
<p>内存溢出：内存泄漏到一定的程度就会导致内存溢出，但是内存溢出也有可能是大对象导致的。</p>
<h2 id="5-2-young-gc会有stw吗？"><a href="#5-2-young-gc会有stw吗？" class="headerlink" title="5.2 young gc会有stw吗？"></a>5.2 young gc会有stw吗？</h2><p>不管什么 GC，都会有 stop-the-world，只是发生时间的长短。</p>
<h2 id="5-3-major-gc和full-gc的区别"><a href="#5-3-major-gc和full-gc的区别" class="headerlink" title="5.3 major gc和full gc的区别"></a>5.3 major gc和full gc的区别</h2><p>major gc指的是老年代的gc，而full gc等于young+old+metaspace的gc。</p>
<h2 id="5-4-G1与CMS的区别是什么"><a href="#5-4-G1与CMS的区别是什么" class="headerlink" title="5.4 G1与CMS的区别是什么"></a>5.4 G1与CMS的区别是什么</h2><p>CMS 用于老年代的回收，而 G1 用于新生代和老年代的回收。<br>G1 使用了 Region 方式对堆内存进行了划分，且基于标记整理算法实现，整体减少了垃圾碎片的产生。</p>
<h2 id="5-5-什么是直接内存"><a href="#5-5-什么是直接内存" class="headerlink" title="5.5 什么是直接内存"></a>5.5 什么是直接内存</h2><p>直接内存是在java堆外的、直接向系统申请的内存空间。通常访问直接内存的速度会优于Java堆。因此出于性能的考<br>虑，读写频繁的场合可能会考虑使用直接内存。</p>
<h2 id="5-6不可达的对象一定要被回收吗？"><a href="#5-6不可达的对象一定要被回收吗？" class="headerlink" title="5.6不可达的对象一定要被回收吗？"></a>5.6不可达的对象一定要被回收吗？</h2><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p>
<h2 id="5-7-方法区中的无用类回收"><a href="#5-7-方法区中的无用类回收" class="headerlink" title="5.7 方法区中的无用类回收"></a>5.7 方法区中的无用类回收</h2><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 “无用的类” ：</p>
<p>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</p>
<p>加载该类的 ClassLoader 已经被回收。</p>
<p>该类对应的 java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p>
<h2 id="5-8-不同的引用"><a href="#5-8-不同的引用" class="headerlink" title="5.8 不同的引用"></a>5.8 不同的引用</h2><p>JDK1.2以后，Java对引用进行了扩充：强引用、软引用、弱引用和虚引用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/02/13/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AD%A6%E4%B9%A0JVM%EF%BC%8C%E7%BB%BC%E5%90%88%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89/" data-id="ck9tm3e620008hyrah23bcwp8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-如何优雅的学习JVM，实战篇（四）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/12/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AD%A6%E4%B9%A0JVM%EF%BC%8C%E5%AE%9E%E6%88%98%E7%AF%87%EF%BC%88%E5%9B%9B%EF%BC%89/" class="article-date">
  <time datetime="2020-02-12T12:30:13.000Z" itemprop="datePublished">2020-02-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/12/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AD%A6%E4%B9%A0JVM%EF%BC%8C%E5%AE%9E%E6%88%98%E7%AF%87%EF%BC%88%E5%9B%9B%EF%BC%89/">如何优雅的学习JVM，实战篇（四）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、JVM参数"><a href="#一、JVM参数" class="headerlink" title="一、JVM参数"></a>一、JVM参数</h1><h2 id="1-1-标准参数"><a href="#1-1-标准参数" class="headerlink" title="1.1 标准参数"></a>1.1 标准参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-version</span><br><span class="line">-help</span><br><span class="line">-server</span><br><span class="line">-cp</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/2/11/17033422dd966708?w=754&h=97&f=png&s=15298" alt=""></p>
<h2 id="1-2-X参数"><a href="#1-2-X参数" class="headerlink" title="1.2 -X参数"></a>1.2 -X参数</h2><p>非标准参数，也就是在JDK各个版本中可能会变动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xint   解释执行</span><br><span class="line">-Xcomp  第一次使用就编译成本地代码</span><br><span class="line">-Xmixed  混合模式，JVM自己来决定</span><br></pre></td></tr></table></figure>


<p><img src="https://user-gold-cdn.xitu.io/2020/2/11/170334b1bda80536?w=778&h=265&f=png&s=45325" alt=""></p>
<h2 id="1-3-XX参数"><a href="#1-3-XX参数" class="headerlink" title="1.3 -XX参数"></a>1.3 -XX参数</h2><p>使用得最多的参数类型，非标准化参数，相对不稳定，主要用于JVM调优和Debug</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a.Boolean类型</span><br><span class="line">格式：-XX:[+-]&lt;name&gt;      +或-表示启用或者禁用name属性</span><br><span class="line">比如：-XX:+UseConcMarkSweepGC  表示启用CMS类型的垃圾回收器</span><br><span class="line">-XX:+UseG1GC       表示启用G1类型的垃圾回收器</span><br><span class="line">b.非Boolean类型</span><br><span class="line">格式：-XX&lt;name&gt;&#x3D;&lt;value&gt; 表示name属性的值是value</span><br><span class="line">比如：-XX:MaxGCPauseMillis&#x3D;500</span><br></pre></td></tr></table></figure>

<h2 id="1-4-其它参数"><a href="#1-4-其它参数" class="headerlink" title="1.4 其它参数"></a>1.4 其它参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xms1000等价于 -XX:InitialHeapSize&#x3D;1000</span><br><span class="line">-Xmx1000等价于 -XX:MaxHeapSize&#x3D;1000</span><br><span class="line">-Xss1000等价于 -XX:ThreadStackSize&#x3D;1000</span><br></pre></td></tr></table></figure>

<p><strong>这一块内容也相当于-XX类型的参数</strong></p>
<h2 id="1-5-查看参数"><a href="#1-5-查看参数" class="headerlink" title="1.5 查看参数"></a>1.5 查看参数</h2><p>java -XX:+PrintFlagsFinal -version &gt; flags.txt</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/11/170338b5ff967b44?w=943&h=112&f=png&s=21998" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/11/170338be4f741920?w=1603&h=859&f=png&s=263483" alt=""></p>
<p>上图值得注意的是“=”表示默认值，“:=”表示被用户或JVM修改后的值</p>
<p>一般需要设置参数，可以先查下当前参数是什么，然后再进行修改</p>
<h2 id="1-6-设置参数的方式"><a href="#1-6-设置参数的方式" class="headerlink" title="1.6 设置参数的方式"></a>1.6 设置参数的方式</h2><ul>
<li><p>开发工具中进行设置IDEA、eclipse</p>
</li>
<li><p>运行jar包的时候：java -XX:+UseG1GC xxx.jar</p>
</li>
</ul>
<ul>
<li>Web容器比如Tomcat，可以在脚本中进行设置</li>
</ul>
<ul>
<li>通过<strong>jinfo</strong>命令实时调整某个java进程的参数（参数只有被标记位<strong>manageable</strong>的flags可以被<strong>实时修改</strong>）</li>
</ul>
<h1 id="1-7-单位换算和实践"><a href="#1-7-单位换算和实践" class="headerlink" title="1.7 单位换算和实践"></a>1.7 单位换算和实践</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1Byte(字节)&#x3D;8bit(位)</span><br><span class="line">1KB&#x3D;1024Byte(字节)</span><br><span class="line">1MB&#x3D;1024KB</span><br><span class="line">1GB&#x3D;1024MB</span><br><span class="line">1TB&#x3D;1024GB</span><br></pre></td></tr></table></figure>

<p>1、设置堆内存大小和参数打印</p>
<p><code>-Xmx100M -Xms100M -XX:+PrintFlagsFinal</code></p>
<p>2、查询+PrintFlagsFinal</p>
<p><code>:=true</code></p>
<p>3、查询堆内存大小MaxHeapSize</p>
<p><code>:= 104857600</code></p>
<p>4、换算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">104857600(Byte)&#x2F;1024&#x3D;102400(KB)</span><br><span class="line">102400(KB)&#x2F;1024&#x3D;100(MB)</span><br></pre></td></tr></table></figure>
<p>5、结论</p>
<p><code>104857600是字节单位</code></p>
<h1 id="1-8-常用参数的含义"><a href="#1-8-常用参数的含义" class="headerlink" title="1.8 常用参数的含义"></a>1.8 常用参数的含义</h1><p><img src="https://user-gold-cdn.xitu.io/2020/2/11/1703482834a408a5?w=1234&h=1442&f=png&s=351332" alt=""></p>
<h1 id="二、常用命令"><a href="#二、常用命令" class="headerlink" title="二、常用命令"></a>二、常用命令</h1><h2 id="2-1-jps"><a href="#2-1-jps" class="headerlink" title="2.1 jps"></a>2.1 jps</h2><p>查看java进程</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/12/1703866272e82bad?w=457&h=121&f=png&s=13304" alt=""></p>
<h2 id="2-2-jinfo"><a href="#2-2-jinfo" class="headerlink" title="2.2 jinfo"></a>2.2 jinfo</h2><p>1、实时查看</p>
<p><code>jinfo -flag name PID 查看某个java进程的name属性的值</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jinfo -flag MaxHeapSize PID</span><br><span class="line">jinfo -flag UseG1GC PID</span><br></pre></td></tr></table></figure>


<p><img src="https://user-gold-cdn.xitu.io/2020/2/12/170386eebf0094f8?w=725&h=114&f=png&s=16369" alt=""></p>
<p>2、调整JVM配置参数</p>
<p><code>参数只有被标记为manageable的flags可以被实时修改</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jinfo -flag [+|-] PID</span><br><span class="line">jinfo -flag &#x3D; PID</span><br></pre></td></tr></table></figure>

<p>3、查看曾经赋过值的一些参数</p>
<p><code>jinfo -flags PID</code></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/12/170386eaf6af31aa?w=1696&h=434&f=png&s=100222" alt=""></p>
<h2 id="2-3-jstat"><a href="#2-3-jstat" class="headerlink" title="2.3 jstat"></a>2.3 jstat</h2><p>1、查看虚拟机性能统计信息</p>
<p>2、查看java进程的类装载信息</p>
<p><code>jstat -class PID 1000 10   查看某个java进程的类装载信息，每1000毫秒输出一次，共输出10
次</code></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/12/170387305945c922?w=675&h=350&f=png&s=34167" alt=""></p>
<p>3、查看垃圾收集信息</p>
<p><code>jstat -gc PID 1000 10</code></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/12/170387393a7a3a64?w=1542&h=163&f=png&s=32941" alt=""></p>
<h2 id="2-4-jstack"><a href="#2-4-jstack" class="headerlink" title="2.4 jstack"></a>2.4 jstack</h2><p>1、查看线程堆栈信息</p>
<p><code>jstack PID</code></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/12/17038754ec59b241?w=1441&h=794&f=png&s=137786" alt=""></p>
<p>2、排查死锁的案例</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class DeadLockDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        DeadLock deadLock1 &#x3D; new DeadLock(true);</span><br><span class="line">        DeadLock deadLock2 &#x3D; new DeadLock(false);</span><br><span class="line">        Thread thread1 &#x3D; new Thread(deadLock1);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(deadLock2);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class MyLock &#123;</span><br><span class="line">        public static Object obj1 &#x3D; new Object();</span><br><span class="line">        public static Object obj2 &#x3D; new Object();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class DeadLock implements Runnable &#123;</span><br><span class="line">        private boolean flag;</span><br><span class="line"></span><br><span class="line">        DeadLock(boolean flag) &#123;</span><br><span class="line">            this.flag &#x3D; flag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            if(flag) &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    synchronized (MyLock.obj1) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + &quot;如果获得obj1的锁&quot;);</span><br><span class="line">                        synchronized (MyLock.obj2) &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + &quot;如果获得obj2的锁&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    synchronized (MyLock.obj2) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + &quot;否则获得obj2的锁&quot;);</span><br><span class="line">                        synchronized (MyLock.obj1) &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + &quot;否则获得obj1的锁&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行main方法的结果</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/12/17038a63fd979870?w=667&h=169&f=png&s=16683" alt=""></p>
<p><strong>jstack分析</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/12/17038a777471c0bb?w=1357&h=715&f=png&s=140748" alt=""></p>
<p><strong>把打印信息拉到最后可以发现</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/12/17038a84747b1bb4?w=1117&h=718&f=png&s=108521" alt=""></p>
<h2 id="2-5-jmap"><a href="#2-5-jmap" class="headerlink" title="2.5 jmap"></a>2.5 jmap</h2><p>1、生成堆转存储快照</p>
<p>2、打印出堆内存相关信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintFlagsFinal -Xms300M -Xmx300M</span><br><span class="line">jmap -heap PID</span><br></pre></td></tr></table></figure>


<p><img src="https://user-gold-cdn.xitu.io/2020/2/12/17038d5b914397a0?w=915&h=726&f=png&s=84750" alt=""></p>
<p>3、dump堆内存相关信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format&#x3D;b,file&#x3D;heap.hprof PID</span><br><span class="line">jmap -dump:format&#x3D;b,file&#x3D;heap.hprof 44808</span><br></pre></td></tr></table></figure>


<p><img src="https://user-gold-cdn.xitu.io/2020/2/12/17038d6a11e0946f?w=941&h=173&f=png&s=21428" alt=""></p>
<p>4、要是能在发生堆内存溢出的时候，能自动dump出该文件就好了</p>
<p>一般在开发过程中，JVM参数可以加上下面两句，这样在程序内存溢出的时候，会自动dump该文件</p>
<p><code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap.hprof</code></p>
<h1 id="三、常用工具"><a href="#三、常用工具" class="headerlink" title="三、常用工具"></a>三、常用工具</h1><h2 id="3-1-jconsole"><a href="#3-1-jconsole" class="headerlink" title="3.1 jconsole"></a>3.1 jconsole</h2><p>JConsole工具是JDK自带的可视化监控工具。查看java应用程序的运行概况、监控堆信息、永久区使用<br>情况、类加载情况等。</p>
<p><strong>命令行中输入：jconsole</strong></p>
<h2 id="3-2-jvisualvm"><a href="#3-2-jvisualvm" class="headerlink" title="3.2 jvisualvm"></a>3.2 jvisualvm</h2><p><strong>1、可以监控本地的java进程的CPU，类，线程等</strong></p>
<p><strong>2、可以监控远端tomcat，演示部署在阿里云服务器上的tomcat</strong></p>
<p>(1)在visualvm中选中“远程”，右击“添加”<br>(2)主机名上写服务器的ip地址，比如39.105.32.236，然后点击“确定”<br>(3)右击该主机“39.105.32.236”，添加“JMX”[也就是通过JMX技术具体监控远端服务器哪个Java进程]<br>(4)要想让服务器上的tomcat被连接，需要改一下 bin/catalina.sh 这个文件</p>
<p><strong>注意下面的8998不要和服务器上其他端口冲突</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS&#x3D;&quot;$JAVA_OPTS -Dcom.sun.management.jmxremote -Djava.rmi.server.hostname&#x3D;39.105.32.236 -Dcom.sun.management.jmxremote.port&#x3D;8998 -Dcom.sun.management.jmxremote.ssl&#x3D;false -Dcom.sun.management.jmxremote.authenticate&#x3D;true -Dcom.sun.management.jmxremote.access.file&#x3D;..&#x2F;conf&#x2F;jmxremote.access -Dcom.sun.management.jmxremote.password.file&#x3D;..&#x2F;conf&#x2F;jmxremote.password&quot;</span><br></pre></td></tr></table></figure>

<p>(5)在 ../conf 文件中添加两个文件jmxremote.access和jmxremote.password</p>
<p><strong>jmxremote.access 文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">guest readonly</span><br><span class="line">manager readwrite</span><br></pre></td></tr></table></figure>

<p><strong>jmxremote.password 文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">guest guest</span><br><span class="line">manager manager</span><br></pre></td></tr></table></figure>

<p>授予权限 : chmod 600 <em>jmxremot</em></p>
<p>(6)将连接服务器地址改为公网ip地址</p>
<p>hostname -i  查看输出情况<br>172.17.6.246 172.17.0.1<br>vim /etc/hosts<br>172.17.6.246 339.105.32.236</p>
<p>(7)设置上述端口对应的阿里云安全策略和防火墙策略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --add-port&#x3D;8080&#x2F;tcp --permanent</span><br><span class="line">firewall-cmd --add-port&#x3D;8998&#x2F;tcp --permanent</span><br><span class="line">systemctl restart firewalld</span><br></pre></td></tr></table></figure>

<p>(8)启动tomcat，来到bin目录</p>
<p><code>./startup.sh</code></p>
<p>(9)查看tomcat启动日志以及端口监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tail -f ..&#x2F;logs&#x2F;catalina.out</span><br><span class="line">lsof -i tcp:8080</span><br></pre></td></tr></table></figure>
<p>(10)查看8998监听情况，可以发现多开了几个端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsof -i:8998  得到PID</span><br><span class="line">netstat -antup | grep PID</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/2/12/17039203026409e6?w=1021&h=139&f=png&s=24301" alt=""></p>
<p>(11)在刚才的JMX中输入8998端口，并且输入用户名和密码则登录成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">端口:8998</span><br><span class="line">用户名:manager</span><br><span class="line">密码:manager</span><br></pre></td></tr></table></figure>

<h2 id="3-3-阿里的Arthas"><a href="#3-3-阿里的Arthas" class="headerlink" title="3.3 阿里的Arthas"></a>3.3 阿里的Arthas</h2><p>Arthas是阿里巴巴开源的Java诊断工具，采用命令行交互模式，是排查jvm相关问题的利器。</p>
<p><strong>github：</strong> <a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">https://github.com/alibaba/arthas</a></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/12/1703942cb1cc7a0b?w=1324&h=532&f=png&s=181930" alt=""></p>
<p><strong>下载arthas-boot.jar，然后用java -jar的方式启动：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -O https:&#x2F;&#x2F;alibaba.github.io&#x2F;arthas&#x2F;arthas-boot.jar</span><br><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure>

<p><strong>打印帮助信息：</strong></p>
<p><code>java -jar arthas-boot.jar -h</code></p>
<p><strong>常用命令</strong></p>
<p>具体每个命令怎么使用，大家可以自己查阅资料！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">version:查看arthas版本号</span><br><span class="line">help:查看命名帮助信息</span><br><span class="line">cls:清空屏幕</span><br><span class="line">session:查看当前会话信息</span><br><span class="line">quit:退出arthas客户端</span><br><span class="line">---</span><br><span class="line">dashboard:当前进程的实时数据面板</span><br><span class="line">thread:当前JVM的线程堆栈信息</span><br><span class="line">jvm:查看当前JVM的信息</span><br><span class="line">sysprop:查看JVM的系统属性</span><br><span class="line">---</span><br><span class="line">sc:查看JVM已经加载的类信息</span><br><span class="line">dump:dump已经加载类的byte code到特定目录</span><br><span class="line">jad:反编译指定已加载类的源码</span><br><span class="line">---</span><br><span class="line">monitor:方法执行监控</span><br><span class="line">watch:方法执行数据观测</span><br><span class="line">trace:方法内部调用路径，并输出方法路径上的每个节点上耗时</span><br><span class="line">stack:输出当前方法被调用的调用路径</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h2 id="3-4-MAT"><a href="#3-4-MAT" class="headerlink" title="3.4 MAT"></a>3.4 MAT</h2><p>Java堆分析器，用于查找内存泄漏</p>
<p>Heap Dump，称为堆转储文件，是Java进程在某个时间内的快照</p>
<p><strong>下载地址：</strong> <a href="https://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">https://www.eclipse.org/mat/downloads.php</a></p>
<p>1、Dump信息包含的内容</p>
<ul>
<li>All Objects</li>
</ul>
<p>Class, fields, primitive values and references</p>
<ul>
<li>All Classes</li>
</ul>
<p>Classloader, name, super class, static fields</p>
<ul>
<li>Garbage Collection Roots</li>
</ul>
<p>Objects defined to be reachable by the JVM</p>
<ul>
<li>Thread Stacks and Local Variables</li>
</ul>
<p>The call-stacks of threads at the moment of the snapshot, and per-frame information about local<br>objects</p>
<p>2、获取Dump文件</p>
<ul>
<li>手动</li>
</ul>
<p><code>jmap -dump:format=b,file=heap.hprof 44808</code></p>
<p>自动</p>
<p><code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap.hprof</code></p>
<p>3、使用</p>
<ul>
<li>Histogram</li>
</ul>
<p>Histogram可以<strong>列出内存中的对象，对象的个数及其大小</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class Name:类名称，java类名</span><br><span class="line">Objects:类的对象的数量，这个对象被创建了多少个</span><br><span class="line">Shallow Heap:一个对象内存的消耗大小，不包含对其他对象的引用</span><br><span class="line">Retained Heap:是shallow Heap的总和，即该对象被GC之后所能回收到内存的总和</span><br></pre></td></tr></table></figure>

<p><code>右击类名---&gt;List Objects---&gt;with incoming references---&gt;列出该类的实例</code></p>
<p><code>右击Java对象名---&gt;Merge Shortest Paths to GC Roots---&gt;exclude all ...---&gt;找到GC
Root以及原因</code></p>
<ul>
<li>Leak Suspects</li>
</ul>
<p><strong>查找并分析内存泄漏的可能原因</strong></p>
<p><code>Reports---&gt;Leak Suspects---&gt;Details</code></p>
<ul>
<li>Top Consumers</li>
</ul>
<p><strong>列出大对象</strong></p>
<h2 id="3-5-GC日志分析工具"><a href="#3-5-GC日志分析工具" class="headerlink" title="3.5 GC日志分析工具"></a>3.5 GC日志分析工具</h2><p>要想分析日志的信息，得先拿到GC日志文件才行，所以得先配置一下</p>
<p>根据前面参数的学习，下面的配置很容易看懂</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps</span><br><span class="line">-Xloggc:gc.log</span><br></pre></td></tr></table></figure>


<ul>
<li>在线工具</li>
</ul>
<p><a href="https://gceasy.io/" target="_blank" rel="noopener">https://gceasy.io/</a></p>
<ul>
<li>GCViewer</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/02/12/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AD%A6%E4%B9%A0JVM%EF%BC%8C%E5%AE%9E%E6%88%98%E7%AF%87%EF%BC%88%E5%9B%9B%EF%BC%89/" data-id="ck9tm3e600006hyraedzf6maq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-如何优雅的学习JVM，升华篇（三）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/10/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AD%A6%E4%B9%A0JVM%EF%BC%8C%E5%8D%87%E5%8D%8E%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89/" class="article-date">
  <time datetime="2020-02-10T12:32:51.000Z" itemprop="datePublished">2020-02-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/10/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AD%A6%E4%B9%A0JVM%EF%BC%8C%E5%8D%87%E5%8D%8E%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89/">如何优雅的学习JVM，升华篇（三）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>此次内容和大家分享JVM中关于垃圾回收（Garbage Collect）的相关知识。</p>
<h1 id="一、如何确定一个对象是垃圾？"><a href="#一、如何确定一个对象是垃圾？" class="headerlink" title="一、如何确定一个对象是垃圾？"></a>一、如何确定一个对象是垃圾？</h1><p><strong>要想进行垃圾回收，得先知道什么样的对象是垃圾。</strong></p>
<h2 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 引用计数法</h2><p>对于某个对象而言，只要应用程序中持有该对象的引用，就说明该对象不是垃圾，如果一个对象没有任何指针对其引用，它就是垃圾。</p>
<p><strong>注意：</strong> 如果A、B两个对象互相持有引用，会导致永远不能被回收。</p>
<h2 id="1-2-可达性分析"><a href="#1-2-可达性分析" class="headerlink" title="1.2 可达性分析"></a>1.2 可达性分析</h2><p>通过GC Root的对象，可以开始向下寻找，看某个对象是否可达。<br>可以作为GC Root：类加载器、Thread、虚拟机栈的本地变量表、静态成员、常量引用、本地方法栈的变量等。</p>
<h1 id="二、垃圾回收算法"><a href="#二、垃圾回收算法" class="headerlink" title="二、垃圾回收算法"></a>二、垃圾回收算法</h1><h2 id="2-1-标记-清除（Mark-Sweep）"><a href="#2-1-标记-清除（Mark-Sweep）" class="headerlink" title="2.1 标记-清除（Mark-Sweep）"></a>2.1 标记-清除（Mark-Sweep）</h2><p><strong>标记（Mark）</strong></p>
<p>找出内存中需要回收的对象，并把它们标记出来。此时堆中所有的对象都会被扫描一遍，从而才能确定需要回收的对象，比较耗时。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/9/170291940db6274f?w=1089&h=405&f=png&s=27984" alt=""></p>
<p><strong>清除（Sweep）</strong></p>
<p>清除掉被标记需要回收的对象，释放出对应的内存空间。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/9/170291f1cf91e70f?w=1089&h=405&f=png&s=27600" alt=""></p>
<p><strong>不足</strong></p>
<p>1、标记和清除两个过程都比较耗时，效率不高</p>
<p>2、会产生大量的不连续的内存碎片，空间碎片太多可能会导致在以后程序运行的过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发一次垃圾回收动作。</p>
<h2 id="2-2-复制（Copying）"><a href="#2-2-复制（Copying）" class="headerlink" title="2.2 复制（Copying）"></a>2.2 复制（Copying）</h2><p>将内存划分为两块相等的区域，每次只使用其中一块，如下图</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/9/17029f3b74f9396f?w=1089&h=405&f=png&s=29603" alt=""></p>
<p>当其中一块内存使用完了，就将还存活的对象复制到另一块上面，然后把已经使用过的内存空间一次清除掉。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/9/17029f8ffbf82088?w=1089&h=405&f=png&s=28597" alt=""></p>
<p><strong>不足</strong></p>
<p>空间利用率降低。</p>
<h2 id="2-3-标记-整理（Mark-Compact）"><a href="#2-3-标记-整理（Mark-Compact）" class="headerlink" title="2.3 标记-整理（Mark-Compact）"></a>2.3 标记-整理（Mark-Compact）</h2><p>标记的过程仍然与“标记-清除”的算法一样，但是后续的步骤不是直接对回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/10/1702dc55145466eb?w=1089&h=405&f=png&s=27984" alt=""></p>
<p>让所有存活的对象都向一端移动，清掉边界外的内存。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/10/1702dc7ad25a5df8?w=1089&h=405&f=png&s=25892" alt=""></p>
<h1 id="三、分代收集算法"><a href="#三、分代收集算法" class="headerlink" title="三、分代收集算法"></a>三、分代收集算法</h1><p>上面介绍了三种垃圾回收算法，那么在堆内存中到底用哪一种呢？</p>
<p>1.<strong>Yonug区</strong>：复制算法（对象被分配之后，可能生命周期比较短，此区的复制效率比较高）</p>
<p>2、<strong>Old区</strong>：标记清除或标记整理（Old区对象存活时间比较长，复制来复制去没必要，不如做个标记再清理）</p>
<h1 id="四、-垃圾收集器"><a href="#四、-垃圾收集器" class="headerlink" title="四、 垃圾收集器"></a>四、 垃圾收集器</h1><h2 id="4-1-Serial收集器"><a href="#4-1-Serial收集器" class="headerlink" title="4.1 Serial收集器"></a>4.1 Serial收集器</h2><p>在JDK1.3.1之前，曾经是虚拟机新生代收集的唯一选择，它是最基本、发展历史最悠久的收集器。</p>
<p>它是一种<strong>单线程</strong>收集器，不仅仅意味着它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是其在进行收集的同时需要暂停其它线程。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/10/1702e0a78a1eb434?w=1017&h=576&f=png&s=38780" alt=""></p>
<p>优点：简单高效，拥有很高的单线程收集效率</p>
<p>缺点：收集过程中需要暂停其它所有的线程</p>
<p>算法：复制算法</p>
<p>使用范围：新生代</p>
<p>应用：client模式下的默认新生代收集器</p>
<h2 id="4-2-ParNew收集器"><a href="#4-2-ParNew收集器" class="headerlink" title="4.2 ParNew收集器"></a>4.2 ParNew收集器</h2><p>可以把ParNew收集器当作多线程版本的Serial收集器。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/10/1702e16d4741267a?w=1017&h=595&f=png&s=41599" alt=""></p>
<p>优点：在多CPU下，比Serial收集器效率高</p>
<p>缺点：收集过程中需要暂停其它所有的线程，单CPU时比Serial效率差</p>
<p>算法：复制算法</p>
<p>使用范围：新生代</p>
<p>应用：运行在server模式下的虚拟机首选新生代收集器</p>
<h2 id="4-3-Parallel-Scavenge收集器"><a href="#4-3-Parallel-Scavenge收集器" class="headerlink" title="4.3 Parallel Scavenge收集器"></a>4.3 Parallel Scavenge收集器</h2><p>它是一个新生代收集器，使用<strong>复制算法</strong>，又是并行多线程收集器，看上去和ParNew一样，但是更多关注的是<strong>系统的吞吐量</strong>。</p>
<p>吞吐量 = 运行用户程序的时间 / (运行用户程序时间 + 垃圾收集时间)</p>
<p>例如：虚拟机总共运行了100m，垃圾收集用了1m，吞吐量 =(100 - 1) / 100 = 99%</p>
<p>吞吐量越大，则垃圾收集时间越短，则用户程序可以充分利用CPU资源，尽快完成程序的运算任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间，</span><br><span class="line">-XX:GC Time Ratio 直接设置吞吐量的大小。</span><br></pre></td></tr></table></figure>

<h2 id="4-4-Serial-Old收集器"><a href="#4-4-Serial-Old收集器" class="headerlink" title="4.4 Serial Old收集器"></a>4.4 Serial Old收集器</h2><p>它是Serial收集器的老年代版本，也是一个单线程收集器，不同的是采用“标记-整理”的算法，运行过程和Serial收集器一样。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/10/1702e5514f36024b?w=1626&h=576&f=png&s=78910" alt=""></p>
<h2 id="4-5-Parallel-Old收集器"><a href="#4-5-Parallel-Old收集器" class="headerlink" title="4.5 Parallel Old收集器"></a>4.5 Parallel Old收集器</h2><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用“标记-整理”的算法进行垃圾回收。吞吐量优先。</p>
<h2 id="4-6-CMS（Concurrent-Mark-Sweep）收集器"><a href="#4-6-CMS（Concurrent-Mark-Sweep）收集器" class="headerlink" title="4.6 CMS（Concurrent Mark Sweep）收集器"></a>4.6 CMS（Concurrent Mark Sweep）收集器</h2><p>CMS收集器是一种以获取<strong>最短回收停顿时间</strong>为目标的收集器。采用“标记-清除”算法，整个过程分为4步：</p>
<p>1、<strong>初始标记</strong>（CMS initial mark），标记GC Roots能关联到的对象，Stop The World–&gt;速度很快</p>
<p>2、<strong>并发标记</strong>（CMS ConCurrent mark），进行GC Roots Tracing</p>
<p>3、<strong>重新标记</strong>（CMS remark），修改并发标记因用户程序变动的内容，Stop The World</p>
<p>4、<strong>并发清除</strong>（CMS Concurrent Sweep）</p>
<p>由于整个过程，并发标记和并发清除，收集器线程可以和用户线程一起工作，所以总体上来说，<strong>CMS收集器的内存回收过程是和用户线程一起并发执行的</strong>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/10/1702e886eccea396?w=1626&h=596&f=png&s=60610" alt=""><br>优点：并发收集、低停顿</p>
<p>缺点：产生大量空间碎片，并发阶段会降低吞吐量</p>
<h2 id="4-7-G1收集器"><a href="#4-7-G1收集器" class="headerlink" title="4.7 G1收集器"></a>4.7 G1收集器</h2><p>使用G1收集器时，Java堆的内存布局与其它收集器的差别很大，它<strong>将整个Java堆划分为多个大小相等的独立区域</strong>（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离了，它们都是一部分Region（不需要连续）的集合。整体上属于“<strong>标记-整理</strong>”算法，不会到处连续的空间碎片，<strong>可预测的停顿</strong>（比CMS更先进的地方在于能够让使用者明确指定一个长度为m毫秒的时间片段内，消耗在垃圾收集上的时间不得超过m毫秒）。整个过程分为4部分：</p>
<p>1、<strong>初始标记</strong>（Initial Marking）,标记一下GC Roots能够关联的对象，并且修改TAMS(top at mark start)的值，需要暂停用户线程</p>
<p>2、<strong>并发标记</strong>（Concurrent Marking），从GC Roots进行可达性分析，找出存活的对象，与用户线程并发执行</p>
<p>3、<strong>最终标记</strong>（Final Marking），修正在并发标记阶段因为用户程序的并发执行导致变动的数据，需暂停用户线程</p>
<p>4、<strong>筛选回收</strong>（Live Data Counting And Evacuation），对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间制定回收计划。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/10/1702ea2c3b877a18?w=1638&h=590&f=png&s=65534" alt=""></p>
<h2 id="4-8-垃圾收集器分类"><a href="#4-8-垃圾收集器分类" class="headerlink" title="4.8 垃圾收集器分类"></a>4.8 垃圾收集器分类</h2><ul>
<li><p>串行收集器</p>
<p>  Serial、Old Serial</p>
<p>  <strong>只有一个垃圾回收线程执行，用户线程暂停。</strong></p>
<p>  适用于内存比较小的嵌入式设备。</p>
</li>
<li><p>并行收集</p>
<p>  Parallel Scanvenge、Parallel Old</p>
<p>  <strong>多条垃圾收集器线程并行工作，但此时用户线程仍然处于等待状态。</strong></p>
<p>  适用于科学计算、后台处理等若干交互场景。</p>
<p>  <strong>吞吐量优先</strong></p>
</li>
<li><p>并发收集器</p>
<p>  CMS、G1</p>
<p>  <strong>用户线程和垃圾收集器线程同时执行</strong>（但不一定是并行，可能是交替执行），垃圾收集线程在执行的时候不会停顿用户线程的运行。</p>
<p>  适用于相对时间有要求的场景，比如Web</p>
<p>  <strong>停顿时间优先</strong></p>
</li>
</ul>
<h2 id="4-9-如何选择合适的垃圾收集器"><a href="#4-9-如何选择合适的垃圾收集器" class="headerlink" title="4.9 如何选择合适的垃圾收集器"></a>4.9 如何选择合适的垃圾收集器</h2><ul>
<li>优先调整堆的大小让服务器自己来选择</li>
<li>如果内存小于100M,使用串行收集器</li>
<li>如果是CPU单核，并且没有停顿时间的要求，使用串行或者JVM自行选择</li>
<li>如果允许停顿时间超过1S，选择并行或者JVM自行选择</li>
<li>如果响应时间最重要，并且不能超过1S,使用并发收集器。</li>
<li>来看看官网如何给出答案的： <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref28" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref28</a></li>
</ul>
<h2 id="4-10-如何开启垃圾收集器"><a href="#4-10-如何开启垃圾收集器" class="headerlink" title="4.10 如何开启垃圾收集器"></a>4.10 如何开启垃圾收集器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">（1）串行</span><br><span class="line">-XX：+UseSerialGC</span><br><span class="line">-XX：+UseSerialOldGC</span><br><span class="line">（2）并行(吞吐量优先)：</span><br><span class="line"> -XX：+UseParallelGC</span><br><span class="line"> -XX：+UseParallelOldGC</span><br><span class="line">（3）并发收集器(响应时间优先)</span><br><span class="line">-XX：+UseConcMarkSweepGC</span><br><span class="line">-XX：+UseG1GC</span><br></pre></td></tr></table></figure>

<h2 id="4-11-如何理解吞吐量和停顿时间"><a href="#4-11-如何理解吞吐量和停顿时间" class="headerlink" title="4.11 如何理解吞吐量和停顿时间"></a>4.11 如何理解吞吐量和停顿时间</h2><ul>
<li><p>吞吐量</p>
<p>  <strong>运行用户代码时间/(运行用户代码时间+垃圾收集时间)</strong></p>
<p>  高吞吐量则可以高效地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任<br>务。</p>
</li>
</ul>
<ul>
<li><p>停顿时间</p>
<p>  <strong>垃圾收集器进行垃圾回收终端应用执行响应的时间</strong></p>
<p>  停顿时间越短就越适合需要和用户交互的程序，良好的响应速度能提升用户体验。</p>
</li>
</ul>
<h2 id="4-12-在什么情况下使用G1？"><a href="#4-12-在什么情况下使用G1？" class="headerlink" title="4.12 在什么情况下使用G1？"></a>4.12 在什么情况下使用G1？</h2><p>JDK 7开始使用，JDK 8非常成熟，<strong>JDK 9</strong>默认的垃圾收集器，适用于<strong>新老生代</strong>。</p>
<p>判断是否需要使用G1收集器？</p>
<ul>
<li>50%以上的堆被存活对象占用</li>
<li>对象分配和晋升的速度变化非常大</li>
<li>垃圾回收时间比较长</li>
</ul>
<h1 id="未完待续……"><a href="#未完待续……" class="headerlink" title="未完待续……"></a>未完待续……</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/02/10/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AD%A6%E4%B9%A0JVM%EF%BC%8C%E5%8D%87%E5%8D%8E%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89/" data-id="ck9tm3e5z0005hyra00b77ia5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-如何优雅的学习JVM，进行篇（二）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/08/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AD%A6%E4%B9%A0JVM%EF%BC%8C%E8%BF%9B%E8%A1%8C%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/" class="article-date">
  <time datetime="2020-02-08T10:10:01.000Z" itemprop="datePublished">2020-02-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/08/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AD%A6%E4%B9%A0JVM%EF%BC%8C%E8%BF%9B%E8%A1%8C%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/">如何优雅的学习JVM，进行篇（二）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、理解Java虚拟机栈和栈帧"><a href="#一、理解Java虚拟机栈和栈帧" class="headerlink" title="一、理解Java虚拟机栈和栈帧"></a>一、理解Java虚拟机栈和栈帧</h2><p><strong>1.1 什么是栈帧呢？</strong></p>
<p>每个栈帧被认为对应是一个被调用的方法，可以理解为一个方法的运行空间。</p>
<p><strong>官方地址</strong>：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6</a></p>
<p>栈帧的组成部分：</p>
<p>1、局部变量表（Local Variables）：方法中的局部变量以及方法的参数存放在这张表中，局部变量中的变量不可以直接使用，如果需要使用的话，必须<strong>通过相关指令将其加载到操作数栈中作为操作数使用。</strong></p>
<p>2、操作数栈（Operand Stack）：以<strong>压栈</strong>和<strong>出栈</strong>的方式存储操作数。</p>
<p>3、动态链接（Dynamic Linking）：每个栈帧都包含<strong>指向运行时常量池中该栈帧所属方法的引用</strong>，持有这个引用是为了支持方法调用过程中的动态链接。</p>
<p>4、方法返回地址（Return Address）：当一个方法执行时，只有两种方式可以退出，<strong>一种是遇到方法返回的字节码指令，一种是遇见异常</strong>，并且这个异常没有在方法体内得到处理。</p>
<p>5、附加信息</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/5/17014951f1bbb3d3?w=530&h=535&f=png&s=27757" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/5/17014b874c1a2f2e?w=255&h=255&f=png&s=55454" alt=""></p>
<p><strong>Person.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name &#x3D; &quot;Kevin&quot;;</span><br><span class="line">    private int age;</span><br><span class="line">    private final double salary &#x3D; 100;</span><br><span class="line">    private static String address;</span><br><span class="line">    private final static String hobby &#x3D; &quot;Programming&quot;;</span><br><span class="line">    public void say() &#123;</span><br><span class="line">        System.out.println(&quot;person say...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static int calc(int op1,int op2) &#123;</span><br><span class="line">        op1 &#x3D; 3;</span><br><span class="line">        int result &#x3D; op1 + op2;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void order() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        calc(1,2);</span><br><span class="line">        order();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>反编译指令宝典</strong>，oracle官网：</p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;Person.java&quot;</span><br><span class="line">public class Person &#123;</span><br><span class="line">...     </span><br><span class="line"> public static int calc(int, int);</span><br><span class="line">  Code:</span><br><span class="line">   0: iconst_3   &#x2F;&#x2F;将int类型常量3压入[操作数栈]</span><br><span class="line">   1: istore_0   &#x2F;&#x2F;将int类型值存入[局部变量0]</span><br><span class="line">   2: iload_0    &#x2F;&#x2F;从[局部变量0]中装载int类型值入栈</span><br><span class="line">   3: iload_1    &#x2F;&#x2F;从[局部变量1]中装载int类型值入栈</span><br><span class="line">   4: iadd     &#x2F;&#x2F;将栈顶元素弹出栈，执行int类型的加法，结果入栈</span><br><span class="line">   【For example, the iadd instruction (§iadd) adds two int values together. It</span><br><span class="line">requires that the int values to be added be the top two values of the operand stack, pushed</span><br><span class="line">there by previous instructions. Both of the int values are popped from the operand stack.</span><br><span class="line">They are added, and their sum is pushed back onto the operand stack. Subcomputations may be</span><br><span class="line">nested on the operand stack, resulting in values that can be used by the encompassing</span><br><span class="line">computation.】</span><br><span class="line">   5: istore_2   &#x2F;&#x2F;将栈顶int类型值保存到[局部变量2]中</span><br><span class="line">   6: iload_2    &#x2F;&#x2F;从[局部变量2]中装载int类型值入栈</span><br><span class="line">   7: ireturn    &#x2F;&#x2F;从方法中返回int类型的数据</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例子中的Java虚拟机和栈帧，如图：</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/5/170155a0ebeb2122?w=936&h=900&f=png&s=87800" alt=""></p>
<p><strong>1.2 栈指向堆</strong></p>
<p>如果在栈帧中有一个变量，类型为引用类型，比如Object obj = new Object()，这个时候就是典型的<strong>栈中的元素指向堆中的对象</strong>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/5/1701573b6b7e82bb?w=1557&h=900&f=png&s=160972" alt=""></p>
<p><strong>1.3 方法区指向堆</strong></p>
<p>方法区会存放静态变量，常量等数据。如果是下面这种情况，就是典型的<strong>方法区中的元素指向堆中的对象</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static Object obj &#x3D; new Object();</span><br></pre></td></tr></table></figure>


<p><img src="https://user-gold-cdn.xitu.io/2020/2/5/170157f9e339acc8?w=652&h=540&f=png&s=61891" alt=""></p>
<p><strong>1.4 堆指向方法区</strong></p>
<p>方法区中会包含类的信息，堆中会有对象，那么一个对象是由哪个类创建出来的呢？它是如何记录信息的呢？我们需要了解一个Java对象的具体信息。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/5/1701585ffd9d184f?w=652&h=540&f=png&s=62365" alt=""></p>
<p><strong>1.5 Java对象内存布局</strong></p>
<p>一个Java对象在内存中的布局分为3个部分：</p>
<p>1、对象头：一系列的标记位（Mark Word）、指向对象对应的类元数据的内存地址（Class Pointer）、数组长度（Length）</p>
<p>2、实例数据：包含各对象所有的成员变量，其大小由变量类型决定</p>
<p>3、对齐填充：为了对象的大小为8字节的整数倍</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/6/170195a0b832430c?w=1282&h=613&f=png&s=103107" alt=""></p>
<h2 id="二、JVM内存模型"><a href="#二、JVM内存模型" class="headerlink" title="二、JVM内存模型"></a>二、JVM内存模型</h2><p><strong>2.1 内存模型结构</strong></p>
<p>内存模型结构分为2个部分：</p>
<p>1、非堆区：</p>
<p>2、堆区：一个是<strong>Old区</strong>，另一个是<strong>Young区</strong></p>
<p>另：Young区分为2个部分，一个是Survivor区（S0+S1），另一个是Eden区。</p>
<p>Eden : S0 : S1 = 8 : 1 : 1，S0和S1一样大，也可以叫做From和To。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/6/1701a8bb065949dd?w=1149&h=586&f=png&s=34782" alt=""></p>
<p><strong>2.2 对象创建所在区域</strong></p>
<p>在一般情况下：</p>
<p>1、<strong>新创建的对象</strong>都会分配到<strong>Eden区</strong></p>
<p>2、一些<strong>特殊的大对象</strong>都会分配到<strong>Old区</strong></p>
<p>例如：有对象A、B、C等创建在Eden区，但是由于Eden区的内存空间有限，其大小只有100M，假如意见使用了100M或达到了一个设定的临界值，这个时候就需要对Eden区的内存空间进行清理，即<strong>垃圾回收</strong>（Garbage Collect），这样的GC也被称为Minor GC,<br><strong>Minor GC指的是Young区的GC</strong>。</p>
<p><strong>2.3 Survivor区</strong></p>
<p>Survivor分为两块，即S0和S1，也可以叫做From和To。</p>
<p>在同一个时间点上，S0和S1只能有一区有数据，另一区只能空着。</p>
<p>例如：接着上面示例的GC来说，一开始只有Eden区和S0中有对象，S1是空的。此时<strong>进行一次GC操作</strong>，S0区中的对象年龄<strong>就会+1</strong>，Eden区中的所有存活的对象会被复制到S1区，S0区中还能存活的对象会有两个去处。</p>
<p>若对象年龄达到之前设置好的年龄阈值，此时对象会被移动到<strong>Old区</strong>，没有达到阈值的对象会被复制到<strong>S1区</strong>。此时Eden区和S0区已经被清空（被GC的对象肯定是没有了，没有被GC的对象都有各自的去处了）。</p>
<p>这个时候S0和S1交换角色，之前的<strong>S0变成S1</strong>，之前的<strong>S1变成S0</strong>了。也就是说无论如何<strong>都要保证名为S1的Survivor区域都是空的</strong>。</p>
<p>Minor GC会一直重复这样的过程，直到S1区被填满，然后会将所有的对象复制到Old区中。</p>
<p><strong>2.4 Old区</strong></p>
<p>一般Old区都是年龄较大的对象，或者相对超过了某个阈值的对象。在Old区也会有GC操作，Old区的GC操作我们被称为<strong>Major GC</strong>，每次GC之后还能存活的对象年龄<strong>也会+1</strong>，如果超过了某个阈值，也会被回收的。</p>
<p><strong>2.5 如何理解对象的一辈子</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/7/1701ff221cd8682d?w=1689&h=1020&f=png&s=128968" alt=""></p>
<p>我是一个普通的Java对象，我出生在Eden区，在Eden区我还看到了跟我长得很像的兄弟，我们在Eden区玩了挺长时间。有一天Eden区的人实在太多了，我就被迫去了Survivor区的S0区，自从去了Survivor区，我就开始漂了，有时候在Survivor区的S0区，有时候在Survivor区的S1区，居无定所。直到我18岁的时候，爸爸说我成人了，该去社会上闯荡了。</p>
<p>于是我就去Old区了，老年代里，人很多，并且年龄都挺大的，我在这里认识了很多人。在Old区里我生活了20年（每次GC加一岁），最后就被回收了。</p>
<p><strong>2.6 常见的问题</strong></p>
<p>1、如何理解Minor/Major/Full GC?</p>
<p><strong>Minor GC</strong>：新生代</p>
<p><strong>Major GC</strong>：老年代</p>
<p><strong>Full GC</strong>：新生代+老年代</p>
<p>2、为什么需要Survivor区？只有Eden区不行吗？</p>
<p>如果没有Survivor，Eden区每次进行一次Minor GC，存活的对象就会被送到老年代。这样一来，老年代很快被填满，触发Major GC（因为Major GC一直伴随Minor GC，也可以看做触发了Full GC）。</p>
<p>老年代的空间远远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多。执行时间长有什么坏处呢？<strong>频繁的Full GC消耗的时间很长，会影响程序的执行和响应速度</strong>。</p>
<p>如果对老年代的空间进行增加或者减少呢，能够解决以上问题吗？</p>
<p>假如增加老年代的空间，更多的存活对象才能填满老年代。虽然降低了Full GC的频率，但是随着老年代的空间加大，一旦发生Full GC，执行所需要的时间更长。<br>假如减少老年代的空间，虽然Full GC的时间减少，但是老年代很快被存活的对象填满，Full GC的频率增加。</p>
<p>所以Survivor存在的意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。</p>
<p>3、为什么需要两个Survivor区？</p>
<p>最大的好处就是解决了碎片化。如果只有一个Survivor区，在刚刚新建的对象在Eden中，一单Eden满了，触发一次Minor GC，Eden中的存活对象就会被移动到Survivor区中，这样循环下去，下一次Eden满了的时候，那么这样问题就来了，<strong>此时进行Minor GC，Eden和Survivor各有一些存活的对象，如果此时把Eden区中存活的对象硬是放到Survivor区，很明显这两部分对象所占的内存是不连续的，也就导致了内存碎片化</strong>。永远只有一个Survivor 空间是空的，而另一个Survivor 空间无碎片。</p>
<p>4、新生代中的Eden:S0:S1为什么是8:1:1?</p>
<p>新生代中的可用内存：复制算法用来担保的内存为9：1<br>可用内存中的Eden:S0为8:1<br>即新生代中的Eden:S0:S1位8:1:1</p>
<h2 id="三、使用与验证"><a href="#三、使用与验证" class="headerlink" title="三、使用与验证"></a>三、使用与验证</h2><p><strong>3.1 使用VisualVM</strong></p>
<p>使用JDK自带的VisualVM工具进行查看：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/8/17023e7660f8ad4c?w=1468&h=826&f=png&s=86397" alt=""></p>
<p><strong>3.2 堆内存溢出</strong></p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class HeapOut &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Person&gt; personList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            personList.add(new Person());</span><br><span class="line">            Thread.sleep(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>设置启动参数</strong>：-Xmx20M -Xms20M，我们启动main方法后，让程序持续运行一段时间可以看到控制台出现如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> com.gooagoo.dop.trans.test.json.HeapOut</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:3181)</span><br><span class="line">	at java.util.ArrayList.grow(ArrayList.java:261)</span><br><span class="line">	at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:235)</span><br><span class="line">	at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:227)</span><br><span class="line">	at java.util.ArrayList.add(ArrayList.java:458)</span><br><span class="line">	at com.gooagoo.dop.trans.test.json.HeapOut.main(HeapOut.java:12)</span><br></pre></td></tr></table></figure>
<p>使用visualVM查看：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/8/17023ff92d4190fb?w=1477&h=889&f=png&s=107310" alt=""></p>
<p><strong>3.3 方法区内存溢出</strong></p>
<p>示例：向方法区中添加class信息</p>
<p><strong>asm依赖</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;asm&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;asm&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;3.3.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.gooagoo.dop.trans.test.json;</span><br><span class="line">import org.objectweb.asm.ClassWriter;</span><br><span class="line">import org.objectweb.asm.MethodVisitor;</span><br><span class="line">import org.objectweb.asm.Opcodes;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">public class MyMetaspace extends ClassLoader &#123;</span><br><span class="line">    public static List&lt;Class&lt;?&gt;&gt; createClasses() &#123;</span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; classes &#x3D; new ArrayList&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10000000; ++i) &#123;</span><br><span class="line">        ClassWriter cw &#x3D; new ClassWriter(0);</span><br><span class="line">        cw.visit(Opcodes.V1_1, Opcodes.ACC_PUBLIC, &quot;Class&quot; + i, null, &quot;java&#x2F;lang&#x2F;Object&quot;, null);</span><br><span class="line">        MethodVisitor mw &#x3D; cw.visitMethod(Opcodes.ACC_PUBLIC, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null);</span><br><span class="line">        mw.visitVarInsn(Opcodes.ALOAD, 0);</span><br><span class="line">        mw.visitMethodInsn(Opcodes.INVOKESPECIAL, &quot;java&#x2F;lang&#x2F;Object&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);</span><br><span class="line">        mw.visitInsn(Opcodes.RETURN);</span><br><span class="line">        mw.visitMaxs(1, 1);</span><br><span class="line">        mw.visitEnd();</span><br><span class="line">        MyMetaspace test &#x3D; new MyMetaspace();</span><br><span class="line">        byte[] code &#x3D; cw.toByteArray();</span><br><span class="line">        Class&lt;?&gt; exampleClass &#x3D; test.defineClass(&quot;Class&quot; + i, code, 0, code.length);</span><br><span class="line">        classes.add(exampleClass);</span><br><span class="line">    &#125;</span><br><span class="line">    return classes;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">     public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; list&#x3D;new ArrayList&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            list.addAll(MyMetaspace.createClasses());</span><br><span class="line">            Thread.sleep(5); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>设置启动参数Metaspace的大小</strong>，比如-XX:MetaspaceSize=50M -XX:MaxMetaspaceSize=50M，我们启动main方法后，让程序持续运行一段时间可以看到控制台出现如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">	at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">	at java.lang.ClassLoader.defineClass(ClassLoader.java:763)</span><br><span class="line">	at java.lang.ClassLoader.defineClass(ClassLoader.java:642)</span><br><span class="line">	at com.gooagoo.dop.trans.test.json.MyMetaspace.createClasses(MyMetaspace.java:21)</span><br><span class="line">	at com.gooagoo.dop.trans.test.json.MyMetaspace.main(MyMetaspace.java:30)</span><br></pre></td></tr></table></figure>

<p><strong>3.4 虚拟机栈StackOvewFlow</strong></p>
<p>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class JvmStack &#123;</span><br><span class="line"></span><br><span class="line">    public static long count &#x3D; 0;</span><br><span class="line">    public static void method(long i) &#123;</span><br><span class="line">        System.out.println(count++);</span><br><span class="line">        method(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        method(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动main方法后，让程序持续运行一段时间可以看到控制台出现如下信息：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/8/170242b7df81ac22?w=505&h=454&f=png&s=15477" alt=""></p>
<p><strong>说明：</strong></p>
<p>Stack Space用来做方法的递归调用时压入Stack Frame（栈帧）。所以当递归调用太深的时候，就有可能耗尽Stack Space，所以出现StackOverFlow的错误。</p>
<p>线程栈的大小是个双刃剑，如果设置过小，可能会出现溢出，特别是在该线程递归、大的循环时出现溢出的可能性更大；如果设置过大，就有影响到创建栈的数量，如果是多线程应用，就会出现内存溢出的错误。</p>
<p>-Xss128k：设置每个线程的堆栈大小。JDK 5以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。根据应用的线<br>程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有<br>限制的，不能无限生成，经验值在3000~5000左右。</p>
<h2 id="未完待续……"><a href="#未完待续……" class="headerlink" title="未完待续……"></a>未完待续……</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/02/08/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AD%A6%E4%B9%A0JVM%EF%BC%8C%E8%BF%9B%E8%A1%8C%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/" data-id="ck9tm3e630009hyradc5d2sdj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-如何优雅的学习JVM，揭开篇（一）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/05/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AD%A6%E4%B9%A0JVM%EF%BC%8C%E6%8F%AD%E5%BC%80%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/" class="article-date">
  <time datetime="2020-02-05T05:39:38.000Z" itemprop="datePublished">2020-02-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/05/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AD%A6%E4%B9%A0JVM%EF%BC%8C%E6%8F%AD%E5%BC%80%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/">如何优雅的学习JVM，揭开篇（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>尽管目前oracle官方给出JDK的最新版本已经到达V13了，经过调查得知还是有很多公司使用的是V8，本次学习JVM中所有的内容针对的V8版本。</p>
<h2 id="一、官网（权威文档）"><a href="#一、官网（权威文档）" class="headerlink" title="一、官网（权威文档）"></a>一、官网（权威文档）</h2><p>链接地址：<a href="https://docs.oracle.com/javase/8/" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/</a></p>
<p>如何看待JDK/JRE/JVM之间的关系，官方给出下面的图应该很容易看明白了</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/9/16eea90d6fa365bf?w=1159&h=784&f=png&s=232601" alt=""></p>
<p>Oracle有两个产品实现了Java平台标准版（Java SE）8:JavaSE开发工具包（JDK）8和JavaSE运行时环境（JRE）8。</p>
<p>JDK 8是jre8的超集，包含jre8中的所有内容，另外开发applet和应用。JRE8提供了库、Java虚拟机（JVM）和运行用Java编程编写的小程序和应用程序的其他组件语言。注意，JRE包含Java SE不需要的组件规范，包括标准和非标准Java组件。</p>
<h2 id="二、源码到类文件"><a href="#二、源码到类文件" class="headerlink" title="二、源码到类文件"></a>二、源码到类文件</h2><p><strong>2.1 源代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Student&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private static String sex;</span><br><span class="line">    public void say()&#123;</span><br><span class="line">        System.out.println(&quot;student say...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public int calcStudents(int op1,int op2)&#123;</span><br><span class="line">        return op1 + op2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译: javac Student.java —&gt; Student.class</p>
<p><strong>2.2 编译过程</strong></p>
<p>Student.java -&gt; 词法分析器 -&gt; tokens流 -&gt; 语法分析器 -&gt; 语法树/抽象语法树 -&gt; 语义分析器-&gt; 注解抽象语法树 -&gt; 字节码生成器 -&gt; Student.class文件</p>
<p><strong>2.3 类文件</strong></p>
<p>The class File Format，官方地址：</p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cafe babe 0000 0031 0028 0a00 0600 1a09</span><br><span class="line">001b 001c 0800 1d0a 001e 001f 0700 2007</span><br><span class="line">0021 0100 046e 616d 6501 0012 4c6a 6176</span><br><span class="line">612f 6c61 6e67 2f53 7472 696e 673b 0100</span><br><span class="line">0361 6765 0100 0149 0100 0373 6578 0100</span><br><span class="line">063c 696e 6974 3e01 0003 2829 5601 0004</span><br><span class="line">436f 6465 0100 0f4c 696e 654e 756d 6265</span><br><span class="line">7254 6162 6c65 0100 124c 6f63 616c 5661</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>magic(魔数)</p>
<p>The magic item supplies the magic number identifying the class file format; it has the value 0xCAFEBABE.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cafe babe</span><br></pre></td></tr></table></figure>

<p>minor_version, major_version</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000 0031</span><br></pre></td></tr></table></figure>
<p>31对应10进制的49，代表JDK 8中的一个版本</p>
<p>constant_pool_count</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0028</span><br></pre></td></tr></table></figure>
<p>对应十进制28，代表常量池中28个常量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;</span><br><span class="line">    u2             minor_version;</span><br><span class="line">    u2             major_version;</span><br><span class="line">    u2             constant_pool_count;</span><br><span class="line">    cp_info        constant_pool[constant_pool_count-1];</span><br><span class="line">    u2             access_flags;</span><br><span class="line">    u2             this_class;</span><br><span class="line">    u2             super_class;</span><br><span class="line">    u2             interfaces_count;</span><br><span class="line">    u2             interfaces[interfaces_count];</span><br><span class="line">    u2             fields_count;</span><br><span class="line">    field_info     fields[fields_count];</span><br><span class="line">    u2             methods_count;</span><br><span class="line">    method_info    methods[methods_count];</span><br><span class="line">    u2             attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>.class字节码文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">魔数与class文件版本</span><br><span class="line">常量池</span><br><span class="line">访问标志</span><br><span class="line">类索引、父类索引、接口索引</span><br><span class="line">字段表集合</span><br><span class="line">方法表集合</span><br><span class="line">属性表集合</span><br></pre></td></tr></table></figure>

<h2 id="三、类文件到虚拟机（类加载机制）"><a href="#三、类文件到虚拟机（类加载机制）" class="headerlink" title="三、类文件到虚拟机（类加载机制）"></a>三、类文件到虚拟机（类加载机制）</h2><p><strong>3.1 图解</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/9/16eeacb6bfe81f72?w=1190&h=327&f=png&s=55252" alt=""></p>
<p>上图中的使用和卸载不属于类加载的过程阶段，为了表现完整，所以全画上去了。</p>
<p><strong>3.2 装载(Load)</strong></p>
<p>查找和导入class文件</p>
<ul>
<li>(1)通过一个类的全限定名获取定义此类的二进制字节流</li>
</ul>
<ul>
<li>(2)将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
</ul>
<ul>
<li>(3)在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口</li>
</ul>
<p>在装载(Load)阶段，其中第(1)步:通过类的全限定名获取其定义的二进制字节流，需要借助类装载器完成，顾名思义，就是用来装载Class文件的。</p>
<p>(1)通过一个类的全限定名获取定义此类的二进制字节流</p>
<p>在装载阶段的第(2),(3)步可以发现有运行时数据，堆，方法区等名词</p>
<p>(2)将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p>
<p>(3)在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口<br>说白了就是类文件被类装载器装载进来之后，类中的内容(比如变量，常量，方法，对象等这些数<br>据得要有个去处，也就是要存储起来，存储的位置肯定是在JVM中有对应的空间)</p>
<p><strong>3.3 链接(Link)</strong></p>
<p><strong>3.3.1 验证（Verify）</strong></p>
<ul>
<li>保证被加载类的正确性</li>
</ul>
<ul>
<li>文件格式验证</li>
</ul>
<ul>
<li>元数据验证</li>
</ul>
<ul>
<li>字节码验证</li>
</ul>
<ul>
<li>符号引用验证</li>
</ul>
<p><strong>3.3.2 准备(Prepare)</strong></p>
<p>为类的静态变量分配内存，并将其初始化为默认值</p>
<p><strong>3.3.3 解析(Resolve)</strong></p>
<p>把类中的符号引用转换为直接引用</p>
<p><strong>3.4 初始化(Initialize)</strong></p>
<p>对类的静态变量，静态代码块执行初始化操作</p>
<h2 id="四、类装载器（ClassLoader）"><a href="#四、类装载器（ClassLoader）" class="headerlink" title="四、类装载器（ClassLoader）"></a>四、类装载器（ClassLoader）</h2><p><strong>4.1 图解</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/9/16eeadc9eec271ba?w=1141&h=500&f=png&s=151270" alt=""></p>
<p><strong>4.2 分类解释</strong></p>
<ul>
<li>（1）Bootstrap ClassLoader 负责加载$JAVA_HOME中 jre/lib/rt.jar 里所有的class或Xbootclassoath选项指定的jar包。由C++实现，不是ClassLoader子类。</li>
</ul>
<ul>
<li>（2）Extension ClassLoader 负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar 或 -Djava.ext.dirs指定目录下的jar包。</li>
</ul>
<ul>
<li>（3）App ClassLoader 负责加载classpath中指定的jar包及Djava.class.path 所指定目录下的类和jar包。</li>
</ul>
<ul>
<li>（4）Custom ClassLoader 通过java.lang.ClassLoader的子类自定义加载class，属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader。</li>
</ul>
<p>4.3 加载原则</p>
<p>检查某个类是否已经加载：顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个Classloader已加载，就视为已加载此类，保证此类只所有ClassLoader加载一次。<br>加载的顺序：加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。</p>
<p><strong>双亲委派机制</strong></p>
<p>定义：如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</p>
<p>优势：Java类随着加载它的类加载器一起具备了一种带有优先级的层次关系。比如，Java中的Object类，它存放在rt.jar之中,无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object在各种类加载环境中都是同一个类。如果不采用双亲委派模型，那么由各个类加载器自己取加载的话，那么系统中会存在多种不同的Object类。</p>
<p>破坏：可以继承ClassLoader类，然后重写其中的loadClass方法，其他方式大家可以自己了解拓展一下。</p>
<h2 id="五、运行时数据区（Run-Time-Data-Areas）"><a href="#五、运行时数据区（Run-Time-Data-Areas）" class="headerlink" title="五、运行时数据区（Run-Time Data Areas）"></a>五、运行时数据区（Run-Time Data Areas）</h2><p><strong>官方地址：</strong></p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5</a></p>
<p>Java虚拟机定义了在程序执行期间使用的各种运行时数据区域。这些数据区域中的一些是在Java虚拟机启动时创建的，只有在Java虚拟机退出时才被销毁。其他数据区域是每个线程。当线程在线程退出时创建和销毁时，每个线程数据区域都会创建。</p>
<p><strong>5.1 图解</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/9/16eeae7891ffb9c6?w=1131&h=397&f=png&s=57530" alt=""></p>
<p><strong>5.2 常规理解</strong></p>
<p><strong>5.2.1 Method Area（方法区）</strong></p>
<p>方法区是各个线程共享的内存区域，在虚拟机启动时创建。<br>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做Non-Heap(非堆)，目<br>的是与Java堆区分开来。<br>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The Java Virtual Machine defines various run-time data areas that are used</span><br><span class="line">during execution of a program. Some of these data areas are created on Java</span><br><span class="line">Virtual Machine start-up and are destroyed only when the Java Virtual Machine</span><br><span class="line">exits. Other data areas are per thread. Per-thread data areas are created when a</span><br><span class="line">thread is created and destroyed when the thread exits.</span><br></pre></td></tr></table></figure>

<p>此时回看装载阶段的第2步：</p>
<p>(2)将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p>
<p>如果这时候把从Class文件到装载的第(1)和(2)步合并起来理解的话，可以画个图</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/9/16eeaea54583b040?w=1200&h=459&f=png&s=71516" alt=""></p>
<ul>
<li>(1)方法区在JDK 8中就是Metaspace，在JDK6或7中就是Perm Space</li>
</ul>
<ul>
<li>(2)Run-Time Constant Pool</li>
</ul>
<p>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<p><strong>5.2.2 Heap（堆）</strong></p>
<p>Java堆是Java虚拟机所管理内存中最大的一块，在虚拟机启动时创建，被所有线程共享。</p>
<p>Java对象实例以及数组都在堆上分配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The Java Virtual Machine has a heap that is shared among all Java Virtual Machine threads. The heap is the run-time data area from which memory for all class instances and arrays is allocated.</span><br><span class="line"></span><br><span class="line">The heap is created on virtual machine start-up.</span><br></pre></td></tr></table></figure>

<p>此时回看装载阶段的第3步：<br>(3)在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口<br>此时装载(1)(2)(3)的图可以改动一下</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/9/16eeaedf98e263cc?w=1166&h=546&f=png&s=85350" alt=""></p>
<p><strong>5.2.3 Java Virtual Machine Stacks（虚拟机栈）</strong></p>
<p>经过上面的分析，类加载机制的装载过程已经完成，后续的链接，初始化也会相应的生效。</p>
<p>假如目前的阶段是初始化完成了，后续做啥呢？肯定是Use使用咯，不用的话这样折腾来折腾去<br>有什么意义？那怎样才能被使用到？换句话说里面内容怎样才能被执行？比如通过主函数main调<br>用其他方法，这种方式实际上是main线程执行之后调用的方法，即要想使用里面的各种内容，得<br>要以线程为单位，执行相应的方法才行。</p>
<p>那一个线程执行的状态如何维护？一个线程可以执行多少个方法？这样的关系怎么维护呢？</p>
<p>虚拟机栈是一个线程执行的区域，保存着一个线程中方法的调用状态。换句话说，一个Java线程的运行<br>状态，由一个虚拟机栈来保存，所以虚拟机栈肯定是线程私有的，独有的，随着线程的创建而创建。</p>
<p>每一个被线程执行的方法，为该栈中的栈帧，即每个方法对应一个栈帧。</p>
<p>调用一个方法，就会向栈中压入一个栈帧；一个方法调用完成，就会把该栈帧从栈中弹出。</p>
<p><strong>画图理解栈和栈帧</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/9/16eeaf06dbd40151?w=1131&h=391&f=png&s=48456" alt=""></p>
<p><strong>5.2.4 The pc Register（程序计数器）</strong></p>
<p>我们都知道一个JVM进程中有多个线程在执行，而线程中的内容是否能够拥有执行权，是根据<br>CPU调度来的。</p>
<p>假如线程A正在执行到某个地方，突然失去了CPU的执行权，切换到线程B了，然后当线程A再获<br>得CPU执行权的时候，怎么能继续执行呢？这就是需要在线程中维护一个变量，记录线程执行到<br>的位置。</p>
<p>程序计数器占用的内存空间很小，由于Java虚拟机的多线程是通过线程轮流切换，并分配处理器执行时<br>间的方式来实现的，在任意时刻，一个处理器只会执行一条线程中的指令。因此，为了线程切换后能够<br>恢复到正确的执行位置，每条线程需要有一个独立的程序计数器(线程私有)。</p>
<p>如果线程正在执行Java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址；<br>如果正在执行的是Native方法，则这个计数器为空。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">The Java Virtual Machine can support many threads of execution at once (JLS</span><br><span class="line">§17). Each Java Virtual Machine thread has its own pc (program counter)</span><br><span class="line">register. At any point, each Java Virtual Machine thread is executing the code</span><br><span class="line">of a single method, namely the current method (§2.6) for that thread. If that</span><br><span class="line">method is not native, the pc register contains the address of the Java Virtual</span><br><span class="line">Machine instruction currently being executed. If the method currently being</span><br><span class="line">executed by the thread is native, the value of the Java Virtual Machine&#39;s pc</span><br><span class="line">register is undefined. The Java Virtual Machine&#39;s pc register is wide enough to</span><br><span class="line">hold a returnAddress or a native pointer on the specific platform.</span><br></pre></td></tr></table></figure>

<p>5.2.5 Native Method Stacks（本地方法栈）</p>
<p>如果当前线程执行的方法是Native类型的，这些方法就会在本地方法栈中执行。</p>
<h2 id="未完待续。。。。。。"><a href="#未完待续。。。。。。" class="headerlink" title="未完待续。。。。。。"></a>未完待续。。。。。。</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/02/05/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AD%A6%E4%B9%A0JVM%EF%BC%8C%E6%8F%AD%E5%BC%80%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/" data-id="ck9tm3e610007hyra3etcb5ne" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/29/hello-world/" class="article-date">
  <time datetime="2020-01-29T07:03:24.955Z" itemprop="datePublished">2020-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/29/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/01/29/hello-world/" data-id="ck9tm3e5b0001hyra9t5c8oin" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/05/05/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%8C%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E6%98%AF%E2%80%9C%E9%81%93%E2%80%9D%EF%BC%8C%E8%80%8C%E4%B8%8D%E5%8F%AA%E6%98%AF%E2%80%9C%E6%9C%AF%E2%80%9D/">23种设计模式的学习，我们需要掌握的是“道”，而不只是“术”</a>
          </li>
        
          <li>
            <a href="/2020/04/05/%E6%B7%B1%E5%BA%A6%E9%98%85%E8%AF%BBSpring5-x%E6%BA%90%E7%A0%81%E5%90%8E%EF%BC%8C%E4%BD%BF%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E8%BF%B7%E4%BD%A0%E7%89%88Spring%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF%E5%AE%9E%E8%B7%B5/">深度阅读Spring5.x源码后，使用Java实现迷你版Spring的基本思路实践</a>
          </li>
        
          <li>
            <a href="/2020/03/30/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E6%9C%80%E4%B8%BA%E5%A4%8D%E6%9D%82%E7%9A%84%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，23种设计模式中最为复杂的访问者模式详解</a>
          </li>
        
          <li>
            <a href="/2020/03/27/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E8%A2%AB%E8%AA%89%E4%B8%BA%E6%91%A9%E6%96%AF%E5%AF%86%E7%A0%81%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，被誉为摩斯密码的解释器模式详解</a>
          </li>
        
          <li>
            <a href="/2020/03/25/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E4%B8%8D%E9%9C%80%E8%A6%81%E4%B8%AD%E9%97%B4%E5%95%86%E8%B5%9A%E5%B7%AE%E4%BB%B7%E7%9A%84%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，不需要中间商赚差价的中介者模式详解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Kevin Shaw<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>