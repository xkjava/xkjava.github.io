<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>来一杯咖啡</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="互联网Java体系平台架构，分布式系统，中间件技术等">
<meta property="og:type" content="website">
<meta property="og:title" content="来一杯咖啡">
<meta property="og:url" content="https://xkjava.github.io/index.html">
<meta property="og:site_name" content="来一杯咖啡">
<meta property="og:description" content="互联网Java体系平台架构，分布式系统，中间件技术等">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Kevin Shaw">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="Netty">
<meta property="article:tag" content="Kafka...">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="来一杯咖啡" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">来一杯咖啡</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">互联网技术无边界，学习与交流</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://xkjava.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-架构师内功心法，作为树形结构系统架构的组合模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/10/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E4%BD%9C%E4%B8%BA%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%9A%84%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-03-10T06:11:49.012Z" itemprop="datePublished">2020-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/10/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E4%BD%9C%E4%B8%BA%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%9A%84%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，作为树形结构系统架构的组合模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: 架构师内功心法，作为树形结构系统架构的组合模式详解<br>date: 2020-03-10 14:08:50<br>tags:<br>–</p>
<p>在古代皇帝要想管理整个国家，他是不可能直接管理到具体每一个老百姓的，因此皇帝设置了很多机构，比如三省六部，这些机构下面又有很多小的组织，它们共同管理着整个国家。再比如有一个很大的公司，下面有很多部门，每一个部门下面又有很多个部门，这些就是组合模式的体现。比如树形菜单，操作系统目录结构等，所以组合模式在我们生活中也是非常常见的。<br><img src="https://user-gold-cdn.xitu.io/2020/3/8/170b94613880e925?w=640&h=227&f=png&s=89247" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/3/8/170b9463f6890abb?w=764&h=364&f=png&s=239325" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/3/8/170b96877fa79fbe?w=567&h=286&f=png&s=174802" alt=""></p>
<h1 id="一、组合模式的应用场景"><a href="#一、组合模式的应用场景" class="headerlink" title="一、组合模式的应用场景"></a>一、组合模式的应用场景</h1><p>组合模式（Composite Pattern）也称为整体-部分（Part-Whole）模式，它的宗旨是通过将单个对象（叶子节点）和组合对象（树枝节点）用相同的接口进行表示，使得客户对单个对象和组合对象使用具有一致性。</p>
<h2 id="1-1-组合关系与聚和关系的区别"><a href="#1-1-组合关系与聚和关系的区别" class="headerlink" title="1.1 组合关系与聚和关系的区别"></a>1.1 组合关系与聚和关系的区别</h2><p>组合关系：在古代皇宫的三宫六院，贵妃很多，但是每一个贵妃都属于一个皇帝（具有相同的生命周期）；</p>
<p>聚和关系：一个老师有很多学生，但是每一个学生也属于多个老师（具有不同的生命周期）。</p>
<p>组合模式一般用来描述整体与部分的关系，它将对象组织到树形结构中，最顶层的节点成为根节点，根节点下面包括树枝节点和叶子节点，树枝节点下面又包括树枝节点和叶子节点。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/8/170b95ab6ade04b0?w=1195&h=665&f=png&s=332684" alt=""><br>由上图可以看出，其实根节点和树枝节点本质上是同一种数据类型，可以作为容器使用；而叶子节点与树枝节点在语义上不属于同一种类型，但是在组合模式中，会把树枝节点和叶子节点认为是同一种数据类型（用同一接口定义），让它们具备一致行为。这样，在组合模式中，整个树形结构中的对象都是同一种类型，带来的一个好处就是客户无需辨别树枝节点还是叶子节点，而是可以直接进行操作，给客户使用带来极大的便利。</p>
<h2 id="1-2-组合模式的角色"><a href="#1-2-组合模式的角色" class="headerlink" title="1.2 组合模式的角色"></a>1.2 组合模式的角色</h2><p>组合模式包含 3 个角色：</p>
<ul>
<li>抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性；</li>
<li>树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构；</li>
<li>叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。</li>
</ul>
<p>组合模式在代码具体实现上，有两种不同的方式，分别是<strong>透明组合模式和安全组合模式。</strong></p>
<h2 id="1-3-组合模式应用场景"><a href="#1-3-组合模式应用场景" class="headerlink" title="1.3 组合模式应用场景"></a>1.3 组合模式应用场景</h2><p>当子系统与其内各个对象层次呈现树形结构时，可以使用组合模式让子系统内各个对象层次的行为操作具备一致性。客户端使用该子系统内任意一个层次对象时，无须进行区分，直接使用通用操作即可，为客户端的使用带来了便捷。</p>
<p>组合模式有以下两个应用场景：</p>
<ul>
<li>希望客户端可以忽略组合对象与单个对象的差异时；</li>
<li>对象层次具备整体和部分，呈树形结构。</li>
</ul>
<h2 id="1-4-透明组合模式的写法"><a href="#1-4-透明组合模式的写法" class="headerlink" title="1.4 透明组合模式的写法"></a>1.4 透明组合模式的写法</h2><p>透明组合模式是把所有的公共方法都定义在Component中，这样做的好处是客户度无需分辨树枝节点（Composite）和叶子节点（Leaf），它们具备完全一致的接口。来看一下UML类图吧：<br><img src="https://user-gold-cdn.xitu.io/2020/3/9/170bf36b37bf19d3?w=525&h=475&f=png&s=222437" alt=""><br>下面来看一个实际的案例吧。以某IT教育培训的课程为例，来设计一个课程的关系结构。有嵌入式编程、Web前端、Java编程、云计算、Hadoop、Flink等课程。而云计算、Hadoop、Flink都属于大数据系列课程，每个课程的定价也是不一样的。但是这些课程不管怎么组合，都有一些共性，而且都是整体和部分的关系，可以用组合模式来设计。先创建一个顶层的抽象类 CourseComponent：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public abstract class CourseComponent &#123;</span><br><span class="line"></span><br><span class="line">    public void addChild(CourseComponent catalogComponent) &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;不支持添加操作！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void removeChild(CourseComponent catalogComponent) &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;不支持删除操作！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName(CourseComponent catalogComponent) &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;不支持获取名称操作！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getPrice(CourseComponent catalogComponent) &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;不支持获取价格操作！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print() &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;不支持打印操作！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把所有可能用到的方法都定义到这个最顶层的抽象类中，但是不写任何逻辑处理的代码，而是直接抛异常。这里，有些小伙伴会有疑惑，为什么不用抽象方法？因为，<strong>用了抽象方法，其子类就必须实现，这样便体现不出各子类的细微差异。</strong> 因此，子类继承此抽象类后，只需要重写有差异的方法覆盖父类的方法即可。接下来分别创建课程类Course 和课程包 CoursePackage类。先创建Course类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Course extends CourseComponent &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private double price;</span><br><span class="line"></span><br><span class="line">    public Course(String name, double price) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.price &#x3D; price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getName(CourseComponent catalogComponent) &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public double getPrice(CourseComponent catalogComponent) &#123;</span><br><span class="line">        return this.price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(name + &quot; (￥&quot; + price + &quot;元)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再创建CoursePackage类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class CoursePackage extends CourseComponent &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;CourseComponent&gt; items &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer level;</span><br><span class="line"></span><br><span class="line">    public CoursePackage(String name, Integer level) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.level &#x3D; level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addChild(CourseComponent catalogComponent) &#123;</span><br><span class="line">        items.add(catalogComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void removeChild(CourseComponent catalogComponent) &#123;</span><br><span class="line">        items.remove(catalogComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getName(CourseComponent catalogComponent) &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        for(CourseComponent courseComponent : items) &#123;</span><br><span class="line">            &#x2F;&#x2F;控制显示格式</span><br><span class="line">            if(this.level !&#x3D; null)&#123;</span><br><span class="line">                for(int i &#x3D; 0; i &lt; this.level; i ++)&#123;</span><br><span class="line">                    &#x2F;&#x2F;打印空格控制格式</span><br><span class="line">                    System.out.print(&quot; &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                for(int i &#x3D; 0; i &lt; this.level; i ++)&#123;</span><br><span class="line">                    &#x2F;&#x2F;每一行开始打印一个+号</span><br><span class="line">                    if(i &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                        System.out.print(&quot;+&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.print(&quot;-&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;打印标题</span><br><span class="line">                courseComponent.print();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;透明组合模式&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line"></span><br><span class="line">    CourseComponent course &#x3D; new Course(&quot;嵌入式编程&quot;, 3000.00);</span><br><span class="line">    CourseComponent webFront &#x3D; new Course(&quot;Web前端&quot;, 10000.00);</span><br><span class="line">    CourseComponent java &#x3D; new Course(&quot;Java编程&quot;, 8000.00);</span><br><span class="line"></span><br><span class="line">    CoursePackage bigData &#x3D; new CoursePackage(&quot;大数据&quot;, 2);</span><br><span class="line"></span><br><span class="line">    CourseComponent cloudCalc &#x3D; new Course(&quot;云计算&quot;, 3000.00);</span><br><span class="line">    CourseComponent hadoop &#x3D; new Course(&quot;hadoop&quot;, 3500.00);</span><br><span class="line">    CourseComponent flink &#x3D; new Course(&quot;flink&quot;, 4000.00);</span><br><span class="line">    bigData.addChild(cloudCalc);</span><br><span class="line">    bigData.addChild(hadoop);</span><br><span class="line">    bigData.addChild(flink);</span><br><span class="line"></span><br><span class="line">    CourseComponent catalog &#x3D; new CoursePackage(&quot;课程主目录&quot;,1);</span><br><span class="line">    catalog.addChild(course);</span><br><span class="line">    catalog.addChild(webFront);</span><br><span class="line">    catalog.addChild(java);</span><br><span class="line">    catalog.addChild(bigData);</span><br><span class="line"></span><br><span class="line">    catalog.print();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/9/170bf7e86d12d180?w=574&h=499&f=png&s=28502" alt=""></p>
<p>透明组合模式把所有公共方法都定义在Component中，这样做的好处是客户端无需分辨是叶子节点（Leaf）和树枝节点（Composite），它们具备完全一致的接口；缺点是叶子节点（Leaf）会继承得到一些它所不需要（管理子类操作的方法）的方法，这与设计模式 接口隔离原则相违背。</p>
<p>为了让大家更加透彻理解，下面我们来看安全组合模式的写法。</p>
<h2 id="1-5-安全组合模式的写法"><a href="#1-5-安全组合模式的写法" class="headerlink" title="1.5 安全组合模式的写法"></a>1.5 安全组合模式的写法</h2><p>安全组合模式是只规定系统各个层次的最基础的一致行为，而把组合（树节点）本身的方法（管理子类对象的添加，删除等）放到自身当中。其 UML 类图如下所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/9/170bf88b74198cb4?w=553&h=403&f=png&s=175824" alt=""></p>
<p>再举一个大家都熟悉的例子吧。电脑里面的文件系统其实就是一个典型的树形结构，目录包含文件夹和文件，文件夹里面又包含文件夹和文件……接下来就用代码来实现这个目录系统。<br>文件系统有两个大的层次：文件夹，文件。其中，文件夹能容纳其他层次，为树枝节点；文件为最小单位，为叶子节点。由于目录系统层次较少，且树枝节点（文件夹）结构相对稳定，而文件其实可以有很多类型，所以这里我们选择使用 安全组合模式 来实现目录系统，可以避免为叶子类型（文件）引入冗余方法。先创建最顶层的抽象组件 Directory 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Directory &#123;</span><br><span class="line"></span><br><span class="line">    protected String name;</span><br><span class="line"></span><br><span class="line">    public Directory(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后分别创建Folder和File类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class Folder extends Directory &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;Directory&gt; dirs;</span><br><span class="line"></span><br><span class="line">    private Integer level;</span><br><span class="line"></span><br><span class="line">    public Folder(String name, Integer level) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.level &#x3D; level;</span><br><span class="line">        this.dirs &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean add(Directory dir) &#123;</span><br><span class="line">        return dirs.add(dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean remove(Directory dir) &#123;</span><br><span class="line">        return dirs.remove(dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object get(int index) &#123;</span><br><span class="line">        return dirs.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void list() &#123;</span><br><span class="line">        for(Directory dir : dirs) &#123;</span><br><span class="line">            System.out.println(dir.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(this.name);</span><br><span class="line">        for (Directory dir : this.dirs) &#123;</span><br><span class="line">            &#x2F;&#x2F;控制显示格式</span><br><span class="line">            if (this.level !&#x3D; null) &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; this.level; i++) &#123;</span><br><span class="line">                    &#x2F;&#x2F;打印空格控制格式</span><br><span class="line">                    System.out.print(&quot; &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; this.level; i++) &#123;</span><br><span class="line">                    &#x2F;&#x2F;每一行开始打印一个+号</span><br><span class="line">                    if (i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        System.out.print(&quot;+&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.print(&quot;-&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;打印名称</span><br><span class="line">            dir.show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class File extends Directory &#123;</span><br><span class="line"></span><br><span class="line">    public File(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;安全组合模式&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">    File chrome &#x3D; new File(&quot;谷歌浏览器&quot;);</span><br><span class="line">    File safe360 &#x3D; new File(&quot;360浏览器&quot;);</span><br><span class="line">    File edge &#x3D; new File(&quot;微软Edge浏览器&quot;);</span><br><span class="line"></span><br><span class="line">    Folder browser &#x3D; new Folder(&quot;浏览器&quot;, 2);</span><br><span class="line">    browser.add(chrome);</span><br><span class="line">    browser.add(safe360);</span><br><span class="line">    browser.add(edge);</span><br><span class="line"></span><br><span class="line">    File wx &#x3D; new File(&quot;wechat.exe&quot;);</span><br><span class="line">    File qq &#x3D; new File(&quot;QQ.exe&quot;);</span><br><span class="line">    File dd &#x3D; new File(&quot;DingDing.exe&quot;);</span><br><span class="line"></span><br><span class="line">    Folder root &#x3D; new Folder(&quot;root&quot;, 1);</span><br><span class="line">    root.add(wx);</span><br><span class="line">    root.add(qq);</span><br><span class="line">    root.add(dd);</span><br><span class="line">    root.add(browser);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;----------show()方法效果-----------&quot;);</span><br><span class="line">    root.show();</span><br><span class="line">    System.out.println(&quot;----------list()方法效果-----------&quot;);</span><br><span class="line">    root.list();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/10/170c273472c3ac19?w=583&h=685&f=png&s=31850" alt=""><br>安全组合模式的好处是接口定义职责清晰，符合设计模式单一职责原则和接口隔离原则；缺点是客户需要区分树枝节点（Composite）和叶子节点（Leaf），这样才能正确处理各个层次的操作，客户端无法依赖抽象（Component），违背了设计模式依赖倒置原则。</p>
<h1 id="二、组合模式在源码中的体现"><a href="#二、组合模式在源码中的体现" class="headerlink" title="二、组合模式在源码中的体现"></a>二、组合模式在源码中的体现</h1><h2 id="2-1-HashMap中的putAll-方法"><a href="#2-1-HashMap中的putAll-方法" class="headerlink" title="2.1 HashMap中的putAll()方法"></a>2.1 HashMap中的putAll()方法</h2><p>组合模式在源码中应用也是非常广泛的。首先我们来看一个非常熟悉的HashMap，他里面有一个putAll()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">    putMapEntries(m, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123;</span><br><span class="line">    int s &#x3D; m.size();</span><br><span class="line">    if (s &gt; 0) &#123;</span><br><span class="line">        if (table &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; pre-size</span><br><span class="line">            float ft &#x3D; ((float)s &#x2F; loadFactor) + 1.0F;</span><br><span class="line">            int t &#x3D; ((ft &lt; (float)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (int)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            if (t &gt; threshold)</span><br><span class="line">                threshold &#x3D; tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key &#x3D; e.getKey();</span><br><span class="line">            V value &#x3D; e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, false, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>putAll()方法传入的是Map对象，Map就是一个抽象构件（同时这个构件中只支持键值对的存储方式），而HashMap是一个中间构件，<strong>HashMap中间的Node节点是叶子节点</strong>。说到中间构件就会有规定的存储方式。HashMap中的存储方式是一个静态内部类的数组Node&lt;K,V&gt;，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        this.hash &#x3D; hash;</span><br><span class="line">        this.key &#x3D; key;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">        this.next &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final K getKey()        &#123; return key; &#125;</span><br><span class="line">    public final V getValue()      &#123; return value; &#125;</span><br><span class="line">    public final String toString() &#123; return key + &quot;&#x3D;&quot; + value; &#125;</span><br><span class="line"></span><br><span class="line">    public final int hashCode() &#123;</span><br><span class="line">        return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final V setValue(V newValue) &#123;</span><br><span class="line">        V oldValue &#x3D; value;</span><br><span class="line">        value &#x3D; newValue;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object o) &#123;</span><br><span class="line">        if (o &#x3D;&#x3D; this)</span><br><span class="line">            return true;</span><br><span class="line">        if (o instanceof Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e &#x3D; (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-ArrayList中的addAll-方法"><a href="#2-2-ArrayList中的addAll-方法" class="headerlink" title="2.2 ArrayList中的addAll()方法"></a>2.2 ArrayList中的addAll()方法</h2><p>常用的 ArrayList 对象也有 addAll()方法，其参数也是 ArrayList 的父类 Collection，来看源代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    Object[] a &#x3D; c.toArray();</span><br><span class="line">    int numNew &#x3D; a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  &#x2F;&#x2F; Increments modCount</span><br><span class="line">    System.arraycopy(a, 0, elementData, size, numNew);</span><br><span class="line">    size +&#x3D; numNew;</span><br><span class="line">    return numNew !&#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组合对象和被组合对象都应该有统一的接口实现或者统一的抽象父类。</p>
<h1 id="三、组合模式的优缺点"><a href="#三、组合模式的优缺点" class="headerlink" title="三、组合模式的优缺点"></a>三、组合模式的优缺点</h1><p>优点：</p>
<ul>
<li>清楚地定义分层次的复杂对象，表示对象的全部或部分层次；</li>
<li>让客户端忽略了层次的差异，方便对整个层次结构进行控制；</li>
<li>简化客户端代码；</li>
<li>符合开闭原则。</li>
</ul>
<p>缺点：</p>
<ul>
<li>限制类型时会较为复杂；</li>
<li>使设计变得更加抽象。</li>
</ul>
<p>-</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/03/10/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E4%BD%9C%E4%B8%BA%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%9A%84%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="ck7lialue00076xra79rjf2yc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，使用共享对象来提高性能的享元模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/08/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1%E6%9D%A5%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-03-08T08:01:05.887Z" itemprop="datePublished">2020-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/08/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1%E6%9D%A5%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，使用共享对象来提高性能的享元模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: 架构师内功心法，使用共享对象来提高性能的享元模式详解<br>date: 2020-03-08 16:00:12<br>tags:<br>–</p>
<h1 id="一、享元模式的应用场景"><a href="#一、享元模式的应用场景" class="headerlink" title="一、享元模式的应用场景"></a>一、享元模式的应用场景</h1><p>在我们的日常生活中享元模式很常见，比如各种中介机构的房源共享，再比如全国社保联网。面向对象技术很好的解决一些灵活性或者扩展性问题，但是很多情况下需要在系统内增加对象的个数。当对象太多时，将导致运行代价过高，带来性能下降等问题。享元模式正式为解决这一类问题而诞生的。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/8/170b89e48f9d05a5?w=1056&h=559&f=png&s=1145889" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/3/8/170b89e5ec72042f?w=946&h=536&f=png&s=799191" alt=""></p>
<p>享元模式（FlyWeight Pattern）又称为<strong>轻量级模式，是对象池的一种实现。类似线程池</strong>，线程池可以避免不停的创建和销毁对象，消耗性能。提供了减少对象数量从而改善应用所需的对象结构方式。其宗旨是共享细粒度对象，将多个多同一对象的访问集中起来，不必为每个访问者创建一个单独的对象，以此来降低内存的消耗。</p>
<p><strong>享元模式把一个对象的状态分为内部状态和外部状态，内部状态是不变的，外部状态是变化的。</strong> 然后通过共享不变的部分，达到减少对象数量并节约内存的目的。<strong>享元模式的本质是缓存共享对象，降低内存消耗。</strong> </p>
<h2 id="1-1-享元模式的角色"><a href="#1-1-享元模式的角色" class="headerlink" title="1.1 享元模式的角色"></a>1.1 享元模式的角色</h2><p>享元模式有三个参与角色：</p>
<ul>
<li>抽象享元角色（Flyweight）：享元对象抽象基类或者接口，同时定义出对象的外部状态和内部状态的接口或实现；</li>
<li>具体享元角色（ConcreteFlyweight）：实现抽象角色定义的业务。该角色的内部状态处理应该与环境无关，不能出现会有一个操作改变内部状态，同时修改了外部状态；</li>
<li>享元工厂（FlyweightFactory）：负责管理享元对象池和创建享元对象。</li>
</ul>
<p><strong>享元模式通用的UML图</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/8/170b8b19d4e10b5b?w=382&h=430&f=png&s=147486" alt=""></p>
<p>享元模式有以下两个应用场景：</p>
<ul>
<li>常常应用于系统底层的开发，以便解决系统的性能问题；</li>
<li>系统有大量的相似对象、需要缓冲池的场景。</li>
</ul>
<h2 id="1-2-刷火车票软件的享元模式应用"><a href="#1-2-刷火车票软件的享元模式应用" class="headerlink" title="1.2 刷火车票软件的享元模式应用"></a>1.2 刷火车票软件的享元模式应用</h2><p>我们每年春节为了抢到一张回家的火车票都要大费周折，进而出现了很多刷票<br>软件，刷票软件会将我们填写的信息缓存起来，然后定时检查余票信息。抢票的时候，我们肯定是要查询下有没有我们需要的票信息，这里我们假设一张火车的信息包含：出发站，目的站，价格，座位类别。现在要求编写一个查询火车票查询伪代码，可以通过出发站，目的站查到相关票的信息。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/8/170b8b93759f8471?w=500&h=310&f=png&s=310089" alt=""></p>
<p>比如要求通过出发站，目的站查询火车票的相关信息，只需要构建火车票对象，然后提供一个查询出发站、目的站的接口给客户进行查询即可，首先创建一个ITicket接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface ITicket &#123;</span><br><span class="line"></span><br><span class="line">    void showInfo(String bunk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建TrainTicket 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class TrainTicket implements ITicket &#123;</span><br><span class="line"></span><br><span class="line">    private String from;</span><br><span class="line"></span><br><span class="line">    private String to;</span><br><span class="line"></span><br><span class="line">    private double price;</span><br><span class="line"></span><br><span class="line">    public TrainTicket(String from, String to) &#123;</span><br><span class="line">        this.from &#x3D; from;</span><br><span class="line">        this.to &#x3D; to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void showInfo(String bunk) &#123;</span><br><span class="line">        this.price &#x3D; new Random().nextDouble();</span><br><span class="line">        System.out.println(String.format(&quot;%s-&gt;%s：%s 价格：%s 元&quot;, this.from, this.to, bunk, this.price));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后创建TicketFactory 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class TicketFacotry &#123;</span><br><span class="line"></span><br><span class="line">    public static ITicket queryTicket(String from, String to) &#123;</span><br><span class="line">        return new TrainTicket(from, to);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ITicket ticket &#x3D; TicketFacotry.queryTicket(&quot;北京西&quot;, &quot;武汉&quot;);</span><br><span class="line">    ticket.showInfo(&quot;二等座&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析上面的代码，我们发现客户端进行查询时，系统通过TicketFactory直接创建一个火车票对象，但是这样做的话，当某个瞬间如果有大量的用户请求同一张票的信息时，系统就会创建出大量该火车票对象，系统内存压力骤增。而其实更好的做法应该是缓存该票对象，然后复用提供给其他查询请求，这样一个对象就足以支撑数以千计的查询请求，对内存完全无压力，使用享元模式可以很好地解决这个问题。我们继续优化代码，只需在 TicketFactory 类中进行更改，增加缓存机制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class TicketFacotry &#123;</span><br><span class="line"></span><br><span class="line">    private static Map&lt;String, ITicket&gt; ticketTool &#x3D; new ConcurrentHashMap();</span><br><span class="line"></span><br><span class="line">    public static ITicket queryTicket(String from, String to) &#123;</span><br><span class="line">        String key &#x3D; from + &quot;-&gt;&quot; + to;</span><br><span class="line">        if(ticketTool.containsKey(key)) &#123;</span><br><span class="line">            System.out.println(&quot;使用缓存&quot; + key);</span><br><span class="line">            return ticketTool.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;首次查询，创建对象: &quot; + key);</span><br><span class="line">        ITicket ticket &#x3D; new TrainTicket(from, to);</span><br><span class="line">        ticketTool.put(key, ticket);</span><br><span class="line">        return ticket;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改main测试方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ITicket ticket &#x3D; TicketFacotry.queryTicket(&quot;北京西&quot;, &quot;武汉&quot;);</span><br><span class="line">    ticket.showInfo(&quot;二等座&quot;);</span><br><span class="line">    ITicket ticket1 &#x3D; TicketFacotry.queryTicket(&quot;北京西&quot;, &quot;武汉&quot;);</span><br><span class="line">    ticket1.showInfo(&quot;一等座&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果:</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/8/170b8d6b80036783?w=565&h=298&f=png&s=21503" alt=""><br>可以看到，除了第一次查询创建对象后，后续查询相同车次票信息都是使用缓存对象，无需创建新对象了。来看一下类结构图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/8/170b8d7effd99951?w=616&h=568&f=png&s=29253" alt=""></p>
<p>其中 ITicket 就是抽象享元角色，TrainTicket 就是具体享元角色，TicketFactory 就是享元工厂。有些小伙伴一定会有疑惑了，这不就是注册式单例模式吗？对，这就是注册式单例模式。虽然，结构上很像，但是享元模式的重点在结构上，而不是在创建对象上。</p>
<h2 id="1-3-数据库连接池Connection对象"><a href="#1-3-数据库连接池Connection对象" class="headerlink" title="1.3 数据库连接池Connection对象"></a>1.3 数据库连接池Connection对象</h2><p>我们经常使用的数据库连接池，因为我们使用Connection对象时主要性能消耗在建立连接和关闭连接的时候，为了提高 Connection 在调用时的性能，我们和将 Connection 对象在调用前创建好缓存起来，用的时候从缓存中取值，用完再放回去，达到资源重复利用的目的。来看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class ConnectionPool &#123;</span><br><span class="line"></span><br><span class="line">    private Vector&lt;Connection&gt; pool;</span><br><span class="line">    private String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;testDB&quot;;</span><br><span class="line">    private String username &#x3D; &quot;root&quot;;</span><br><span class="line">    private String password &#x3D; &quot;123456&quot;;</span><br><span class="line">    private String driverClassName &#x3D; &quot;com.mysql.jdbc.Driver&quot;;</span><br><span class="line">    private int poolSize &#x3D; 100;</span><br><span class="line">    public ConnectionPool() &#123;</span><br><span class="line">        pool &#x3D; new Vector&lt;Connection&gt;(poolSize);</span><br><span class="line">        try&#123;</span><br><span class="line">            Class.forName(driverClassName);</span><br><span class="line">            for (int i &#x3D; 0; i &lt; poolSize; i++) &#123;</span><br><span class="line">                Connection conn &#x3D; DriverManager.getConnection(url,username,password);</span><br><span class="line">                pool.add(conn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized Connection getConnection()&#123;</span><br><span class="line">        if(pool.size() &gt; 0)&#123;</span><br><span class="line">            Connection conn &#x3D; pool.get(0);</span><br><span class="line">            pool.remove(conn);</span><br><span class="line">            return conn;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void release(Connection conn)&#123;</span><br><span class="line">        pool.add(conn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的连接池，普遍应用于开源框架，有效提升底层的运行性能。</p>
<h1 id="二、享元模式在源码中的体现"><a href="#二、享元模式在源码中的体现" class="headerlink" title="二、享元模式在源码中的体现"></a>二、享元模式在源码中的体现</h1><h2 id="2-1-String中的享元模式"><a href="#2-1-String中的享元模式" class="headerlink" title="2.1 String中的享元模式"></a>2.1 String中的享元模式</h2><p>Java 中将 String 类定义为final（不可改变的），JVM中字符串一般保存在字符串常量池中，java会确保一个字符串在常量池中只有一个拷贝，这个字符串常量池在 JDK6.0 以前是位于常量池中，位于永久代，而在JDK7.0中，JVM将其从永久代拿出来放置于堆中。</p>
<p>关于String 的测试类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class StringTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        String s1 &#x3D; &quot;hello&quot;;</span><br><span class="line">        String s2 &#x3D; &quot;hello&quot;;</span><br><span class="line">        String s3 &#x3D; &quot;hell&quot; + &quot;o&quot;;</span><br><span class="line">        String s4 &#x3D; &quot;hello&quot; + new String(&quot;o&quot;);</span><br><span class="line">        String s5 &#x3D; new String(&quot;hello&quot;);</span><br><span class="line">        String s6 &#x3D; s5.intern();</span><br><span class="line">        String s7 &#x3D; &quot;hell&quot;;</span><br><span class="line">        String s8 &#x3D; &quot;o&quot;;</span><br><span class="line">        String s9 &#x3D; s7 + s8;</span><br><span class="line">        System.out.println(s1 &#x3D;&#x3D; s2);&#x2F;&#x2F;true</span><br><span class="line">        System.out.println(s1 &#x3D;&#x3D; s3);&#x2F;&#x2F;ture</span><br><span class="line">        System.out.println(s1 &#x3D;&#x3D; s4);&#x2F;&#x2F;false</span><br><span class="line">        System.out.println(s4 &#x3D;&#x3D; s5);&#x2F;&#x2F;false</span><br><span class="line">        System.out.println(s1 &#x3D;&#x3D; s6);&#x2F;&#x2F;true</span><br><span class="line">        System.out.println(s1 &#x3D;&#x3D; s9);&#x2F;&#x2F;false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String类是用final修饰的，以字面量的形式创建String变量时，JVM会在编译的时候把该字面的“hello”放到<strong>字符串常量池</strong>中，Java程序启动的时候就已经加载到内存里面了。这个字符串常量池的特点就是有且仅有一份相同的字面量，如果有其它相同的字面量，JVM则返回这个字面量的引用，如果没有相同的字面量，则在字符串常量池中创建字面量并返回它的引用。</p>
<ul>
<li>s2 指向的字面量”hello”在常量池中已经存在了（s1 先于 s2），于是 JVM 就返回这个字面量绑定的引用，所以 s1==s2。</li>
<li>s3 中字面量的拼接其实就是”hello”，JVM 在编译期间就已经对它进行优化，所以 s1 和 s3 也是相等的。</li>
<li>s4 中的 new String(“o”)生成了两个对象，lo，new String(“o”)，o 存在字符串常量池，new String(“o”)存在堆中，String s4 = “hell” + new String(“o”)实质上是两个对象的相加，编译器不会进行优化，相加的结果存在堆中，而 s1 存在字符串常量池中，当然不相等。s1==s9 的原理一样。</li>
<li>s4==s5 两个相加的结果都在堆中，不用说，肯定不相等。</li>
<li>s1==s6 中，s5.intern()方法能使一个位于堆中的字符串在运行期间动态地加入到字符串常量池中（字符串常量池的内容是程序启动的时候就已经加载好了），如果字符串常量池中有该对象对应的字面量，则返回该字面量在字符串常量池中的引用，否则，创建复制一份该字面量到字符串常量池并返回它的引用。因此 s1==s6 输出 true。</li>
</ul>
<h2 id="2-2-Integer的享元模式"><a href="#2-2-Integer的享元模式" class="headerlink" title="2.2 Integer的享元模式"></a>2.2 Integer的享元模式</h2><p>再举例一个大家都非常熟悉的对象Integer，也用到了享元模式，其中暗藏玄机，我们来看个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class IntegerTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Integer a &#x3D; 100;</span><br><span class="line">        Integer b &#x3D; Integer.valueOf(100);</span><br><span class="line"></span><br><span class="line">        Integer c &#x3D; 1000;</span><br><span class="line">        Integer d &#x3D; Integer.valueOf(1000);</span><br><span class="line"></span><br><span class="line">        System.out.println(a &#x3D;&#x3D; b);</span><br><span class="line">        System.out.println(c &#x3D;&#x3D; d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们跑完程序之后才发现总有些不对，得到了一个意向不到的结果，其运行结果如下：<br><img src="https://user-gold-cdn.xitu.io/2020/3/8/170b901a88493689?w=772&h=142&f=png&s=8585" alt=""></p>
<p>之所以得到这样的结果，是因为 Integer 用到的享元模式，我们来看 Integer 的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> public static Integer valueOf(int i) &#123;</span><br><span class="line">    if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high)</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现 Integer 源码中的 valueOf()方法做了一个条件判断，如果目标值在-128 到 127 之间，则直接从缓存中取值，否则新建对象。那JDK为何要这样做呢？因为在-128 到 127 之间的数据在int范围内是使用最频繁的，为了节省频繁创建对象带来的内存消耗，这里就用到了享元模式，来提高性能。</p>
<h2 id="2-3-Long的享元模式"><a href="#2-3-Long的享元模式" class="headerlink" title="2.3 Long的享元模式"></a>2.3 Long的享元模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public final class Long extends Number implements Comparable&lt;Long&gt; &#123;</span><br><span class="line">    public static Long valueOf(long var0) &#123;</span><br><span class="line">        return var0 &gt;&#x3D; -128L &amp;&amp; var0 &lt;&#x3D; 127L ? Long.LongCache.cache[(int)var0 + 128] : new Long(var0);</span><br><span class="line">    &#125;</span><br><span class="line">    private static class LongCache &#123;</span><br><span class="line">    private LongCache()&#123;&#125;</span><br><span class="line">    static final Long cache[] &#x3D; new Long[-(-128) + 127 + 1];</span><br><span class="line">    static &#123;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] &#x3D; new Long(i - 128);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，Long 中也有缓存，不过不能指定缓存最大值。</p>
<h2 id="2-4-Apache-Commons-Pool2-中的享元模式"><a href="#2-4-Apache-Commons-Pool2-中的享元模式" class="headerlink" title="2.4 Apache Commons Pool2 中的享元模式"></a>2.4 Apache Commons Pool2 中的享元模式</h2><p>对象池化的基本思路：将用过的对象保存起来，等下次需要再次使用这种对象的时候，再拿出来重复使用，从一定程度上减少频繁创建对象所造成的开销。用于充当保存对象的“容器”的对象，被称之为对象池。（Object Pool，或简称Pool）。</p>
<ul>
<li>Apache Commons Pool</li>
</ul>
<p>实现了对象池的功能。定义了对象的生成、销毁、激活、钝化等操作及其状态转换，并提供几个默认的对象池实现。有几个重要的对象：</p>
<ul>
<li>PooledObject（池对象）</li>
</ul>
<p>用于封装对象（如：线程、数据库连接、TCP连接），将其包裹成可被池管理的对象。</p>
<ul>
<li><p>PooledObjectFactory（池对象工厂）：<br>定义了操作 PooledObject实例生命周期的一些方法，PooledObjectFactory必须实现线程安全。</p>
</li>
<li><p>ObjectPool （对象池）</p>
</li>
</ul>
<p>ObjectPool 负责管理 PooledObject，如：借出对象，返回对象，校验对象，有多少激活对象，有多少空闲对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final Map&lt;IdentityWrapper&lt;T&gt;, PooledObject&lt;T&gt;&gt; allObjects;</span><br></pre></td></tr></table></figure>
<p>这里我们就不分析其具体源码了。</p>
<h1 id="三、享元模式的内部状态和外部状态"><a href="#三、享元模式的内部状态和外部状态" class="headerlink" title="三、享元模式的内部状态和外部状态"></a>三、享元模式的内部状态和外部状态</h1><p>享元模式的定义为我们提出了两个要求：细粒度和共享对象。因为要求细粒度对象，所以不可避免地会使对象数量多且性质相近，此时我们就将这些对象的信息分为两个部分：内部状态和外部状态。</p>
<p><strong>内部状态指对象共享出来的信息，存储在享元对象内部并且不会随环境的改变而改变；外部状态指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态</strong>。</p>
<p>比如，连接池中的连接对象，保存在连接对象中的用户名、密码、连接 url 等信息，在创建对象的时候就设置好了，不会随环境的改变而改变，这些为内部状态。而每个连接要回收利用时，我们需要给它标记为可用状态，这些为外部状态。</p>
<h1 id="四、享元模式的优缺点"><a href="#四、享元模式的优缺点" class="headerlink" title="四、享元模式的优缺点"></a>四、享元模式的优缺点</h1><p>优点:</p>
<ul>
<li>减少对象的创建，降低内存中对象的数量，降低系统的内存，提高效率;</li>
<li>减少内存之外的其他资源占用。</li>
</ul>
<p>缺点：</p>
<ul>
<li>关注内、外部状态、关注线程安全问题；</li>
<li>使系统、程序的逻辑复杂化。</li>
</ul>
<p>-</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/03/08/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1%E6%9D%A5%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="ck7lialuf00086xra11bbh5jp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，外界访问系统内部唯一通道的门面模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/08/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%A4%96%E7%95%8C%E8%AE%BF%E9%97%AE%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%E5%94%AF%E4%B8%80%E9%80%9A%E9%81%93%E7%9A%84%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-03-08T03:27:32.000Z" itemprop="datePublished">2020-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/08/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%A4%96%E7%95%8C%E8%AE%BF%E9%97%AE%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%E5%94%AF%E4%B8%80%E9%80%9A%E9%81%93%E7%9A%84%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，外界访问系统内部唯一通道的门面模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、门面模式的应用场景"><a href="#一、门面模式的应用场景" class="headerlink" title="一、门面模式的应用场景"></a>一、门面模式的应用场景</h1><p>门面模式（Facade Pattern）又叫外观模式，提供了一个统一的接口，用来访问子系统中的一群接口。主要特征是定义了一个高层接口，让子系统更容易使用。在我们的日常工作中，都在有意无意大量使用门面模式，但凡只要高层模块需要调度多个子系统，我们都会封装一个新类，提供精简接口，让高层模块很容易的间接调用这些子系统的功能。尤其是现阶段各种第三方API，各种开源类库，很大概率都会使用门面模式。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/7/170b41dceb2532a0?w=522&h=369&f=png&s=80554" alt=""></p>
<p>门面模式适用于以下几种场景：</p>
<ul>
<li>子系统越来越复杂，增加门面模式提供简单接口；</li>
<li>构建多层系统结构，利用门面对象作为每层的入口，简化层间调用。</li>
</ul>
<p>门面模式主要有2种角色：</p>
<ul>
<li>外观角色（Facade）：也成为门面角色，系统对外的统一接口；</li>
<li>子系统角色（SubSystem）：可以有一个或者多个子系统角色。</li>
</ul>
<h2 id="1-1-门面模式的通用写法"><a href="#1-1-门面模式的通用写法" class="headerlink" title="1.1 门面模式的通用写法"></a>1.1 门面模式的通用写法</h2><p>下面是门面模式的通用代码，首先分别创建 3 个子系统的业务逻辑 SubSystemA、SubSystemB、SubSystemC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class SubSystemA &#123;</span><br><span class="line">    public void doA() &#123;</span><br><span class="line">        System.out.println(&quot;doing A stuff&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SubSystemB &#123;</span><br><span class="line">    public void doB() &#123;</span><br><span class="line">        System.out.println(&quot;doing B stuff&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SubSystemC &#123;</span><br><span class="line">    public void doC() &#123;</span><br><span class="line">        System.out.println(&quot;doing C stuff&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，创建外观角色 Facade 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Facade &#123;</span><br><span class="line">    private SubSystemA a &#x3D; new SubSystemA();</span><br><span class="line">    private SubSystemB b &#x3D; new SubSystemB();</span><br><span class="line">    private SubSystemC c &#x3D; new SubSystemC();</span><br><span class="line">    &#x2F;&#x2F; 对外接口</span><br><span class="line">    public void doA() &#123;</span><br><span class="line">        this.a.doA();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 对外接口</span><br><span class="line">    public void doB() &#123;</span><br><span class="line">        this.b.doB();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 对外接口</span><br><span class="line">    public void doC() &#123;</span><br><span class="line">        this.c.doC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">    Facade facade &#x3D; new Facade();</span><br><span class="line">    facade.doA();</span><br><span class="line">    facade.doB();</span><br><span class="line">    facade.doC();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、门面模式在源码中的体现"><a href="#二、门面模式在源码中的体现" class="headerlink" title="二、门面模式在源码中的体现"></a>二、门面模式在源码中的体现</h1><h2 id="2-1-Spring-JDBC中的JdbcUtils"><a href="#2-1-Spring-JDBC中的JdbcUtils" class="headerlink" title="2.1 Spring JDBC中的JdbcUtils"></a>2.1 Spring JDBC中的JdbcUtils</h2><p>JdbcUtils封装了和JDBC 相关的所有操作，它一个代码片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public abstract class JdbcUtils &#123;</span><br><span class="line">    public static final int TYPE_UNKNOWN &#x3D; -2147483648;</span><br><span class="line">    private static final Log logger &#x3D; LogFactory.getLog(JdbcUtils.class);</span><br><span class="line">    public JdbcUtils() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void closeConnection(Connection con) &#123;</span><br><span class="line">    if(con !&#x3D; null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            con.close();</span><br><span class="line">        &#125; catch (SQLException var2) &#123;</span><br><span class="line">            logger.debug(&quot;Could not close JDBC Connection&quot;, var2);</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            logger.debug(&quot;Unexpected exception on closing JDBC Connection&quot;, var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void closeStatement(Statement stmt) &#123;</span><br><span class="line">        if(stmt !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; catch (SQLException var2) &#123;</span><br><span class="line">                logger.trace(&quot;Could not close JDBC Statement&quot;, var2);</span><br><span class="line">            &#125; catch (Throwable var3) &#123;</span><br><span class="line">                logger.trace(&quot;Unexpected exception on closing JDBC Statement&quot;, var3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void closeResultSet(ResultSet rs) &#123;</span><br><span class="line">        if(rs !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; catch (SQLException var2) &#123;</span><br><span class="line">                logger.trace(&quot;Could not close JDBC ResultSet&quot;, var2);</span><br><span class="line">            &#125; catch (Throwable var3) &#123;</span><br><span class="line">                logger.trace(&quot;Unexpected exception on closing JDBC ResultSet&quot;, var3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-Tomcat-的源码中的RequestFacade-类"><a href="#2-2-Tomcat-的源码中的RequestFacade-类" class="headerlink" title="2.2  Tomcat 的源码中的RequestFacade 类"></a>2.2  Tomcat 的源码中的RequestFacade 类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class RequestFacade implements HttpServletRequest &#123;</span><br><span class="line">...</span><br><span class="line">    @Override</span><br><span class="line">    public String getContentType() &#123;</span><br><span class="line">        if (request &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(</span><br><span class="line">                sm.getString(&quot;requestFacade.nullRequest&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        return request.getContentType();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public ServletInputStream getInputStream() throws IOException &#123;</span><br><span class="line">        if (request &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(</span><br><span class="line">                sm.getString(&quot;requestFacade.nullRequest&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        return request.getInputStream();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String getParameter(String name) &#123;</span><br><span class="line">        if (request &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(</span><br><span class="line">                sm.getString(&quot;requestFacade.nullRequest&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        if (Globals.IS_SECURITY_ENABLED)&#123;</span><br><span class="line">            return AccessController.doPrivileged(</span><br><span class="line">            new GetParameterPrivilegedAction(name));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return request.getParameter(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看名字就知道它用了门面模式。它封装了非常多的request的操作，也整合了很多 servlet-api 以外的一些内容，给用户使用提供了很大便捷。同样，Tomcat 对 Response 和 Session 当也封装了<strong>ResponseFacade</strong> 和 <strong>StandardSessionFacade</strong> 类，感兴趣的小伙伴可以去深入了解一下。</p>
<h1 id="三、门面模式的优缺点"><a href="#三、门面模式的优缺点" class="headerlink" title="三、门面模式的优缺点"></a>三、门面模式的优缺点</h1><p>优点：</p>
<ul>
<li>简化了调用过程，无需深入了解子系统，以防给子系统带来风险；</li>
<li>减少系统依赖、松散耦合；</li>
<li>更好地划分访问层次，提高了安全性；</li>
<li>遵循迪米特法则，即最少知道原则。</li>
</ul>
<p>缺点：</p>
<ul>
<li>当增加子系统和扩展子系统行为时，可能容易带来未知风险；</li>
<li>不符合开闭原则；</li>
<li>某些情况下可能违背单一职责原则。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/03/08/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%A4%96%E7%95%8C%E8%AE%BF%E9%97%AE%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%E5%94%AF%E4%B8%80%E9%80%9A%E9%81%93%E7%9A%84%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="ck7lialta00016xradsshgv3e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，注重方法调用顺序的建造者模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/01/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E6%B3%A8%E9%87%8D%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F%E7%9A%84%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-03-01T07:51:27.000Z" itemprop="datePublished">2020-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/01/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E6%B3%A8%E9%87%8D%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F%E7%9A%84%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，注重方法调用顺序的建造者模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、建造者模式的定义"><a href="#一、建造者模式的定义" class="headerlink" title="一、建造者模式的定义"></a>一、建造者模式的定义</h1><p>大家平时都去过肯德基用餐，那里不变的是炸鸡、汉堡、薯条、可乐等，这些都是一直都有的，不变的，而其它组合是经常变化的，从而生成不同的“套餐”罢了。而建造模式（Builder Pattern）是将一个复杂的对象的构建过程与它的表示分离，使得同样的构建过程构建不同的表示。使用建造者模式对于用户而言只需要关注指定需要建造的类型就可以获得对象，而不需要了解建造的过程以及细节。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/1/170950ed1508a094?w=750&h=423&f=png&s=768819" alt=""></p>
<p>建造者模式适用于创建对象需要很多步骤，但是步骤的顺序不是固定不变的。先看一下建造者模式的类图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/1/17094b9a96e4f1ee?w=456&h=405&f=png&s=150230" alt=""></p>
<p>建造者模式中的四个重要角色：</p>
<ul>
<li>产品（Product）：要创建的产品类对象</li>
<li>抽象建造者（Builder）：规范产品对象的各个组成部分的建造</li>
<li>建造者（Concrete Builder）：具体化对象的各个组成部分的创建</li>
<li>调用者（Director）：负责保证对象各部分完整创建或按某种顺序创建</li>
</ul>
<h1 id="二、建造者模式的应用场景"><a href="#二、建造者模式的应用场景" class="headerlink" title="二、建造者模式的应用场景"></a>二、建造者模式的应用场景</h1><p>建造者模式适用于一个具有较多的零件的复杂产品的创建过程，由于需求的变化，组成这个复杂产品的各个零件经常猛烈变化，但是它们的组合方式却相对稳定。</p>
<p>建造者模式适用于以下几种场景：</p>
<ul>
<li>相同的方法，不同的执行顺序，产生的结果也不同</li>
<li>多个部件或零件，装配到一个对象中，产生的结果不同</li>
<li>产品类复杂，或者产品类中调用顺序不同产生不同的作用</li>
<li>初始化对象特别复杂，参数多，而且很多参数都有默认值</li>
</ul>
<h2 id="2-1-建造者模式的基本写法"><a href="#2-1-建造者模式的基本写法" class="headerlink" title="2.1 建造者模式的基本写法"></a>2.1 建造者模式的基本写法</h2><p>我们以公司的技术培训为例，一个完整的技术培训需要由发布培训通知、制作培训PPT、组织员工培训、现场（远程）培训、提交培训问卷等步骤。下面我们用建造模式的代码来简单实现这类场景，首先创建一个技术培训的 TechnicalTraining 产品类  ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class TechnicalTraining &#123;</span><br><span class="line"></span><br><span class="line">    private String notice;</span><br><span class="line">    private String ppt;</span><br><span class="line">    private String training;</span><br><span class="line">    private String questionnaire;</span><br><span class="line"></span><br><span class="line">    public String getNotice() &#123;</span><br><span class="line">        return notice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNotice(String notice) &#123;</span><br><span class="line">        this.notice &#x3D; notice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPpt() &#123;</span><br><span class="line">        return ppt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPpt(String ppt) &#123;</span><br><span class="line">        this.ppt &#x3D; ppt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getTraining() &#123;</span><br><span class="line">        return training;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTraining(String training) &#123;</span><br><span class="line">        this.training &#x3D; training;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getQuestionnaire() &#123;</span><br><span class="line">        return questionnaire;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setQuestionnaire(String questionnaire) &#123;</span><br><span class="line">        this.questionnaire &#x3D; questionnaire;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;TechnicalTraining&#123;&quot; +</span><br><span class="line">                &quot;notice&#x3D;&#39;&quot; + notice + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, ppt&#x3D;&#39;&quot; + ppt + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, training&#x3D;&#39;&quot; + training + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, questionnaire&#x3D;&#39;&quot; + questionnaire + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着创建建造者 TrainingBuilder 类，将复杂的构造过程封装起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class TrainingBuilder &#123;</span><br><span class="line"></span><br><span class="line">    private TechnicalTraining technicalTraining &#x3D; new TechnicalTraining();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发布培训通知</span><br><span class="line">     * @param notice</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void PostNotice(String notice) &#123;</span><br><span class="line">        technicalTraining.setNotice(notice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 制作培训PPT</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void createPPT(String ppt) &#123;</span><br><span class="line">        technicalTraining.setPpt(ppt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 组织员工培训</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void organizeTraining(String training) &#123;</span><br><span class="line">        technicalTraining.setTraining(training);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 提交培训问卷</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void sumitQuestionnaire(String questionnaire) &#123;</span><br><span class="line">        technicalTraining.setQuestionnaire(questionnaire);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     public TechnicalTraining build() &#123;</span><br><span class="line">        return technicalTraining;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试main方法：</p>
<p>public static void main(String[] args) {</p>
<pre><code>TrainingBuilder builder = new TrainingBuilder();
builder.PostNotice(&quot;发布培训通知&quot;);
builder.createPPT(&quot;创建ppt&quot;);
builder.organizeTraining(&quot;组织员工培训&quot;);
builder.sumitQuestionnaire(&quot;提交培训问卷&quot;);
System.out.println(builder.build());</code></pre><p>}</p>
<p>最后来看一下类图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/1/17094dea480736e2?w=868&h=586&f=png&s=60246" alt=""></p>
<h2 id="2-2-建造者模式的链式写法"><a href="#2-2-建造者模式的链式写法" class="headerlink" title="2.2 建造者模式的链式写法"></a>2.2 建造者模式的链式写法</h2><p>在平时的应用中，建造者模式通常是采用链式编程的方式构造对象，下面我们来改造上面的案例代码，将TechnicalTraining变成TrainingBuilder的内部类，将构造步骤添加进去，每完成一个步骤，都返回 this：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">public class TrainingBuilder &#123;</span><br><span class="line"></span><br><span class="line">    public class TechnicalTraining &#123;</span><br><span class="line"></span><br><span class="line">        private String notice;</span><br><span class="line">        private String ppt;</span><br><span class="line">        private String training;</span><br><span class="line">        private String questionnaire;</span><br><span class="line"></span><br><span class="line">        public String getNotice() &#123;</span><br><span class="line">            return notice;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setNotice(String notice) &#123;</span><br><span class="line">            this.notice &#x3D; notice;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getPpt() &#123;</span><br><span class="line">            return ppt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setPpt(String ppt) &#123;</span><br><span class="line">            this.ppt &#x3D; ppt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getTraining() &#123;</span><br><span class="line">            return training;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setTraining(String training) &#123;</span><br><span class="line">            this.training &#x3D; training;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getQuestionnaire() &#123;</span><br><span class="line">            return questionnaire;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setQuestionnaire(String questionnaire) &#123;</span><br><span class="line">            this.questionnaire &#x3D; questionnaire;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private TechnicalTraining technicalTraining &#x3D; new TechnicalTraining();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发布培训通知</span><br><span class="line">     * @param notice</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public TrainingBuilder PostNotice(String notice) &#123;</span><br><span class="line">        technicalTraining.setNotice(notice);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 制作培训PPT</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public TrainingBuilder createPPT(String ppt) &#123;</span><br><span class="line">        technicalTraining.setPpt(ppt);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 组织员工培训</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public TrainingBuilder organizeTraining(String training) &#123;</span><br><span class="line">        technicalTraining.setTraining(training);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 提交培训问卷</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public TrainingBuilder sumitQuestionnaire(String questionnaire) &#123;</span><br><span class="line">        technicalTraining.setQuestionnaire(questionnaire);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TechnicalTraining build() &#123;</span><br><span class="line">        return this.technicalTraining;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    TrainingBuilder builder &#x3D; new TrainingBuilder();</span><br><span class="line">    builder.PostNotice(&quot;发布培训通知&quot;)</span><br><span class="line">    .createPPT(&quot;创建ppt&quot;)</span><br><span class="line">    .organizeTraining(&quot;组织员工培训&quot;)</span><br><span class="line">    .sumitQuestionnaire(&quot;提交培训问卷&quot;);</span><br><span class="line">    System.out.println(builder.build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后再来看下类图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/1/17094e9be66020c5?w=574&h=589&f=png&s=42023" alt=""></p>
<h1 id="三、建造者模式在源码中的体现"><a href="#三、建造者模式在源码中的体现" class="headerlink" title="三、建造者模式在源码中的体现"></a>三、建造者模式在源码中的体现</h1><h2 id="3-1-StringBuilder类"><a href="#3-1-StringBuilder类" class="headerlink" title="3.1 StringBuilder类"></a>3.1 StringBuilder类</h2><p>使用StringBuilder类，我们常用的有append()、toString()方法，我们来看下append()方法的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public StringBuilder(CharSequence seq) &#123;</span><br><span class="line">    this(seq.length() + 16);</span><br><span class="line">    append(seq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public StringBuilder append(Object obj) &#123;</span><br><span class="line">    return append(String.valueOf(obj));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public StringBuilder append(String str) &#123;</span><br><span class="line">    super.append(str);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-Spring中的BeanDefinitionBuilder类"><a href="#3-2-Spring中的BeanDefinitionBuilder类" class="headerlink" title="3.2 Spring中的BeanDefinitionBuilder类"></a>3.2 Spring中的BeanDefinitionBuilder类</h2><p>比如 BeanDefinitionBuilder 通过调用 getBeanDefinition()方法获得一个 BeanDefinition 对象，比如下面的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private BeanDefinitionBuilder(AbstractBeanDefinition beanDefinition) &#123;</span><br><span class="line">    this.beanDefinition &#x3D; beanDefinition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public AbstractBeanDefinition getRawBeanDefinition() &#123;</span><br><span class="line">    return this.beanDefinition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public AbstractBeanDefinition getBeanDefinition() &#123;</span><br><span class="line">    this.beanDefinition.validate();</span><br><span class="line">    return this.beanDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、建造者模式的优缺点"><a href="#四、建造者模式的优缺点" class="headerlink" title="四、建造者模式的优缺点"></a>四、建造者模式的优缺点</h1><p>建造者模式的优点：</p>
<ul>
<li><p>封装性好，创建和使用分离；</p>
</li>
<li><p>扩展性好，建造类之间独立、一定程度上解耦。</p>
</li>
</ul>
<p>建造者模式的缺点：</p>
<ul>
<li><p>产生多余的 Builder 对象；</p>
</li>
<li><p>产品内部发生变化，建造者都要修改，成本较大。</p>
</li>
</ul>
<h1 id="建造者模式和工厂模式的区别"><a href="#建造者模式和工厂模式的区别" class="headerlink" title="建造者模式和工厂模式的区别"></a>建造者模式和工厂模式的区别</h1><p>通过前面的学习，我们已经了解建造者模式，那么它和工厂模式有什么区别呢？<br>1、建造者模式更加注重方法的调用顺序，工厂模式注重于创建对象。</p>
<p>2、创建对象的力度不同，建造者模式创建复杂的对象，由各种复杂的部件组成，工厂模式创建出来的都一样。</p>
<p>3、关注重点不一样，工厂模式模式只需要把对象创建出来就可以了，而建造者模式中不仅要创建出这个对象，还要知道这个对象由哪些部件组成。</p>
<p>4、建造者模式根据建造过程中的顺序不一样，最终的对象部件组成也不一样。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/03/01/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E6%B3%A8%E9%87%8D%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F%E7%9A%84%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="ck7lialui000b6xra7frmh3dz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，属于游戏设计模式的策略模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/25/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%B1%9E%E4%BA%8E%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-02-25T09:03:29.000Z" itemprop="datePublished">2020-02-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/25/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%B1%9E%E4%BA%8E%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，属于游戏设计模式的策略模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、策略模式的应用场景"><a href="#一、策略模式的应用场景" class="headerlink" title="一、策略模式的应用场景"></a>一、策略模式的应用场景</h1><p>策略模式（Strategy Pattern）是指定义了算法家族、分别封装起来，让它们之间可以相互替换，此模式让算法的变化不会影响到使用算法的用户。</p>
<h2 id="1-1-应用场景"><a href="#1-1-应用场景" class="headerlink" title="1.1 应用场景"></a>1.1 应用场景</h2><ul>
<li>假如系统中有很多类，而他们的区别仅仅在于他们的行为不同。</li>
</ul>
<ul>
<li>一个系统需要动态地在几种算法中选择一种。</li>
</ul>
<h2 id="1-2-实现餐饮行业选择支付方式的业务场景"><a href="#1-2-实现餐饮行业选择支付方式的业务场景" class="headerlink" title="1.2 实现餐饮行业选择支付方式的业务场景"></a>1.2 实现餐饮行业选择支付方式的业务场景</h2><p>我们在外面去吃饭的时候，不同的饭店经常会有优惠活动，优惠策略也有很多很多，比如优惠券折扣、返现促销、拼团下单等等。我们来用程序模拟这样的业务场景，首先创建一个促销策略的接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IPromotionStrategy &#123;</span><br><span class="line"></span><br><span class="line">    void doPromotion();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后分别创建优惠券抵扣策略 CouponStrategy 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class CouponStrategy implements IPromotionStrategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doPromotion() &#123;</span><br><span class="line">        System.out.println(&quot;领取的优惠券在指定时间到店消费，订单的价格直接减优惠券面额抵扣！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返现促销策略 CashBackStrategy 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class CashBackStrategy implements IPromotionStrategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doPromotion() &#123;</span><br><span class="line">        System.out.println(&quot;返现促销，返回的金额转到支付账号！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拼团优惠策略 GroupBuyStrategy 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class GroupBuyStrategy implements IPromotionStrategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doPromotion() &#123;</span><br><span class="line">        System.out.println(&quot;拼团，满5人成团，全团享受团购价！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无优惠策略 EmptyStrategy 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class EmptyStrategy implements IPromotionStrategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doPromotion() &#123;</span><br><span class="line">        System.out.println(&quot;无促销活动！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建促销活动方案 PromotionActivity 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class PromotionActivity &#123;</span><br><span class="line"></span><br><span class="line">    private IPromotionStrategy promotionStrategy;</span><br><span class="line"></span><br><span class="line">    public PromotionActivity(IPromotionStrategy promotionStrategy) &#123;</span><br><span class="line">        this.promotionStrategy &#x3D; promotionStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        promotionStrategy.doPromotion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    PromotionActivity activity_618 &#x3D; new PromotionActivity(new CouponStrategy());</span><br><span class="line">    PromotionActivity activity_1212 &#x3D; new PromotionActivity(new CashBackStrategy());</span><br><span class="line">    activity_618.execute();</span><br><span class="line">    activity_1212.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，上面的这段测试代码放到实际的业务场景并不实用，因为餐饮门店做活动的时候是要根据不同需求对促销策略进行动态选择的，并不会一次性执行多种优惠。所以代码会这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">    PromotionActivity promotionActivity &#x3D; null;</span><br><span class="line">    String promotionKey &#x3D; &quot;COUPON&quot;;</span><br><span class="line">    if(promotionKey.equals(&quot;COUPON&quot;))&#123;</span><br><span class="line">        promotionActivity &#x3D; new PromotionActivity(new CouponStrategy());</span><br><span class="line">    &#125;else if(promotionKey.equals(&quot;CASHBACK&quot;))&#123;</span><br><span class="line">        promotionActivity &#x3D; new PromotionActivity(new CashBackStrategy());</span><br><span class="line">    &#125;&#x2F;&#x2F;......</span><br><span class="line">    promotionActivity.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样改造之后，满足了业务需求，客户可根据自己的需求选择不同的优惠策略了。但是，经过一段时间的业务积累，我们的促销活动会越来越多。于是，我们的程序猿小哥哥就忙不赢了，每次上活动之前都要通宵改代码，而且要做重复测试，判断逻辑可能也变得越来越复杂。这时候，我们是不需要思考代码是不是应该重构了？</p>
<p>其实我们可以结合工厂模式和单例模式来进行优化改造。创建PromotionActivityFactory：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class PromotionActivityFactory &#123;</span><br><span class="line"></span><br><span class="line">    public interface PromotionKey &#123;</span><br><span class="line">        String COUPON &#x3D; &quot;COUPON&quot;;</span><br><span class="line">        String CASHBACK &#x3D; &quot;CASHBACK&quot;;</span><br><span class="line">        String GROUPBUY &#x3D; &quot;GROUPBUY&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Map&lt;String, IPromotionStrategy&gt; PROMOTION_STRATEGY_MAP &#x3D;</span><br><span class="line">            new HashMap&lt;&gt;();</span><br><span class="line">    static &#123;</span><br><span class="line">        PROMOTION_STRATEGY_MAP.put(PromotionKey.COUPON, new CouponStrategy());</span><br><span class="line">        PROMOTION_STRATEGY_MAP.put(PromotionKey.CASHBACK, new CashBackStrategy());</span><br><span class="line">        PROMOTION_STRATEGY_MAP.put(PromotionKey.GROUPBUY, new GroupBuyStrategy());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final IPromotionStrategy NO_PROMOTION &#x3D; new EmptyStrategy();</span><br><span class="line"></span><br><span class="line">    private PromotionActivityFactory() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static IPromotionStrategy getPromotionStrategy(String promotionKey) &#123;</span><br><span class="line">        IPromotionStrategy promotionStrategy &#x3D; PROMOTION_STRATEGY_MAP.get(promotionKey);</span><br><span class="line">        return promotionStrategy &#x3D;&#x3D; null ? NO_PROMOTION : promotionStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String promotionKey &#x3D; &quot;COUPON&quot;;</span><br><span class="line">    PromotionActivity promotionActivity &#x3D;  new PromotionActivity(PromotionActivityFactory.getPromotionStrategy(promotionKey));</span><br><span class="line">    promotionActivity.execute();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改代码之后维护工作应该轻松了很多，每次上新活动，不会影响原来的代码逻辑。来看一下完整的类图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/25/1707b0d517cdd627?w=1246&h=490&f=png&s=43282" alt=""></p>
<p>为了加深大家对策略模式的理解，结合实际生活场景再举一个例子。大家都用过移动支付进行付款，比较流行的支付方式有支付宝、微信、银联等。一个场景的支付场景就是在支付的时候提示会选择支付方式，如果用户没有进行选择，那么系统会使用默认的支付方式进行结算。</p>
<p>创建抽象类Payment：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Payment &#123;</span><br><span class="line"></span><br><span class="line">    public abstract String getType();</span><br><span class="line"></span><br><span class="line">    public PayState pay(String id, double amount) &#123;</span><br><span class="line">        if(queryBalance(id) &lt; amount) &#123;</span><br><span class="line">            return new PayState(500,&quot;支付失败&quot;,&quot;余额不足&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return new PayState(200,&quot;支付成功&quot;,&quot;支付金额：&quot; + amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract double queryBalance(String id);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别创建具体的支付方式，支付宝 AliPay 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class AliPay extends Payment &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return &quot;支付宝&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public double queryBalance(String id) &#123;</span><br><span class="line">        return 1000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>微信支付 WechatPay 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class WechatPay extends Payment &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return &quot;微信支付&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public double queryBalance(String id) &#123;</span><br><span class="line">        return 512;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>银联云闪付支付 UnionPay 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class UnionPay extends Payment &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return &quot;云闪付&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public double queryBalance(String id) &#123;</span><br><span class="line">        return 380;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建支付状态的包装类 PayState:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class PayState &#123;</span><br><span class="line"></span><br><span class="line">    private int code;</span><br><span class="line">    private Object data;</span><br><span class="line">    private String msg;</span><br><span class="line"></span><br><span class="line">    public PayState(int code, Object data, String msg) &#123;</span><br><span class="line">        this.code &#x3D; code;</span><br><span class="line">        this.data &#x3D; data;</span><br><span class="line">        this.msg &#x3D; msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;PayState&#123;&quot; +</span><br><span class="line">                &quot;code&#x3D;&quot; + code +</span><br><span class="line">                &quot;, data&#x3D;&quot; + data +</span><br><span class="line">                &quot;, msg&#x3D;&#39;&quot; + msg + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建支付策略管理工厂类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class PayStrategyFactory &#123;</span><br><span class="line"></span><br><span class="line">    public interface PayKey &#123;</span><br><span class="line">        String DEFAULTPAY &#x3D; &quot;ALIPAY&quot;;</span><br><span class="line">        String ALIPAY &#x3D; &quot;ALIPAY&quot;;</span><br><span class="line">        String WECHATPAY &#x3D; &quot;WECHATPAY&quot;;</span><br><span class="line">        String UNIONPAY &#x3D; &quot;UNIONPAY&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final Map&lt;String, Payment&gt; PAYMENT_MAP &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    static  &#123;</span><br><span class="line">        PAYMENT_MAP.put(PayKey.ALIPAY, new AliPay());</span><br><span class="line">        PAYMENT_MAP.put(PayKey.WECHATPAY, new WechatPay());</span><br><span class="line">        PAYMENT_MAP.put(PayKey.UNIONPAY, new UnionPay());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Payment getPayment(String payKey) &#123;</span><br><span class="line">        if(!PAYMENT_MAP.containsKey(payKey))&#123;</span><br><span class="line">            return PAYMENT_MAP.get(PayKey.DEFAULTPAY);</span><br><span class="line">        &#125;</span><br><span class="line">        return PAYMENT_MAP.get(payKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建订单 Order 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Order &#123;</span><br><span class="line"></span><br><span class="line">    private String id;</span><br><span class="line">    private String orderId;</span><br><span class="line">    private double amount;</span><br><span class="line"></span><br><span class="line">    public Order(String id, String orderId, double amount) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.orderId &#x3D; orderId;</span><br><span class="line">        this.amount &#x3D; amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PayState pay()&#123;</span><br><span class="line">        return pay(PayStrategyFactory.PayKey.DEFAULTPAY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PayState pay(String payKey)&#123;</span><br><span class="line">        Payment payment &#x3D; PayStrategyFactory.PAYMENT_MAP.get(payKey);</span><br><span class="line">        System.out.println(&quot;欢迎使用&quot; + payment.getType());</span><br><span class="line">        System.out.println(&quot;本次交易金额为：&quot; + amount + &quot;，开始扣款...&quot;);</span><br><span class="line">        return payment.pay(id,amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    Order order &#x3D; new Order(&quot;1&quot;, &quot;20200225000001&quot;, 120.98);</span><br><span class="line"></span><br><span class="line">    System.out.println(order.pay(PayStrategyFactory.PayKey.ALIPAY));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/25/1707b50d93119f88?w=742&h=214&f=png&s=22506" alt=""></p>
<p>最后来看一下类图结构：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/25/1707b54365747dac?w=1066&h=769&f=png&s=67982" alt=""></p>
<h1 id="二、源码中的策略模式"><a href="#二、源码中的策略模式" class="headerlink" title="二、源码中的策略模式"></a>二、源码中的策略模式</h1><h2 id="2-1-Compartor接口"><a href="#2-1-Compartor接口" class="headerlink" title="2.1 Compartor接口"></a>2.1 Compartor接口</h2><p>Compartor接口中的compare()方法就是一个策略模式的抽象实现。</p>
<p>int compare(T o1, T o2);</p>
<p>Comparator 接口下面有非常多的实现类，我们经常会把 Comparator 作为参数传入作为排序策略，例如 Arrays 类的 parallelSort 方法等：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/25/1707b643e817639c?w=1645&h=496&f=png&s=70716" alt=""></p>
<p>还有 TreeMap 的构造方法:</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/25/1707b6689c6d7218?w=1162&h=259&f=png&s=36243" alt=""></p>
<h2 id="2-2-Spring中的策略模式"><a href="#2-2-Spring中的策略模式" class="headerlink" title="2.2 Spring中的策略模式"></a>2.2 Spring中的策略模式</h2><h2 id="2-2-1-Resouce类"><a href="#2-2-1-Resouce类" class="headerlink" title="2.2.1 Resouce类"></a>2.2.1 Resouce类</h2><p>我们来看Resource类的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.core.io;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.URI;</span><br><span class="line">import java.net.URL;</span><br><span class="line">import java.nio.channels.Channels;</span><br><span class="line">import java.nio.channels.ReadableByteChannel;</span><br><span class="line">import org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line">public interface Resource extends InputStreamSource &#123;</span><br><span class="line">    boolean exists();</span><br><span class="line"></span><br><span class="line">    default boolean isReadable() &#123;</span><br><span class="line">        return this.exists();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default boolean isOpen() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default boolean isFile() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    URL getURL() throws IOException;</span><br><span class="line"></span><br><span class="line">    URI getURI() throws IOException;</span><br><span class="line"></span><br><span class="line">    File getFile() throws IOException;</span><br><span class="line"></span><br><span class="line">    default ReadableByteChannel readableChannel() throws IOException &#123;</span><br><span class="line">        return Channels.newChannel(this.getInputStream());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    long contentLength() throws IOException;</span><br><span class="line"></span><br><span class="line">    long lastModified() throws IOException;</span><br><span class="line"></span><br><span class="line">    Resource createRelative(String var1) throws IOException;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    String getFilename();</span><br><span class="line"></span><br><span class="line">    String getDescription();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们虽然没有直接使用 Resource 类，但是我们经常使用它的子类，例如：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/25/1707b7cc055b952d?w=1885&h=568&f=png&s=186061" alt=""></p>
<p>Spring 的初始化也采用了策略模式，不同的类型的类采用不<br>同的初始化策略。首先有一个 <strong>InstantiationStrategy</strong> 接口，我们来看一下源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface InstantiationStrategy &#123;</span><br><span class="line">    Object instantiate(RootBeanDefinition var1, @Nullable String var2, BeanFactory var3) throws BeansException;</span><br><span class="line"></span><br><span class="line">    Object instantiate(RootBeanDefinition var1, @Nullable String var2, BeanFactory var3, Constructor&lt;?&gt; var4, Object... var5) throws BeansException;</span><br><span class="line"></span><br><span class="line">    Object instantiate(RootBeanDefinition var1, @Nullable String var2, BeanFactory var3, @Nullable Object var4, Method var5, Object... var6) throws BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顶层的策略抽象非常简单，但是它下面有两种策略 <strong>SimpleInstantiationStrategy</strong> 和<strong>CglibSubclassingInstantiationStrategy</strong>，我们看一下类图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/25/1707b81615f908ef?w=1057&h=724&f=png&s=80916" alt=""><br>打开类图我们还发现 CglibSubclassingInstantiationStrategy 策略类还继承了<br>SimpleInstantiationStrategy类，说明在实际应用中多种策略之间还可以继承使用。</p>
<h1 id="三、策略模式的优缺点"><a href="#三、策略模式的优缺点" class="headerlink" title="三、策略模式的优缺点"></a>三、策略模式的优缺点</h1><p>优点：</p>
<ul>
<li>策略模式符合开闭原则；</li>
</ul>
<ul>
<li>避免使用多重条件转移语句，如 if…else…语句、switch 语句；</li>
</ul>
<ul>
<li>使用策略模式可以提高算法的保密性和安全性。</li>
</ul>
<p>缺点：</p>
<ul>
<li>客户端必须知道所有的策略，并且自行决定使用哪一个策略类；</li>
</ul>
<ul>
<li>代码中会产生非常多策略类，增加维护难度。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/02/25/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%B1%9E%E4%BA%8E%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="ck7lialuh000a6xraebr8cmso" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，干过中介干过快递的代理模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/25/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%B9%B2%E8%BF%87%E4%B8%AD%E4%BB%8B%E5%B9%B2%E8%BF%87%E5%BF%AB%E9%80%92%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-02-25T09:01:55.000Z" itemprop="datePublished">2020-02-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/25/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%B9%B2%E8%BF%87%E4%B8%AD%E4%BB%8B%E5%B9%B2%E8%BF%87%E5%BF%AB%E9%80%92%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，干过中介干过快递的代理模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、代理模式的应用场景"><a href="#一、代理模式的应用场景" class="headerlink" title="一、代理模式的应用场景"></a>一、代理模式的应用场景</h1><p>在我们的生活中，经常会见到这样的场景，如：租售房中介、婚介、经纪人、快递等，这些都是代理模式的现实生活体现。代理模式（Proxy Pattern）是指为其它对象提供一种代理，以控制对这个对象的访问。代理对象在客户端和目标对象中间起到了中介的作用，使用代理模式主要有两个目的：<strong>一是保护目标对象，二是增强目标对象。</strong> </p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/23/17070809577156fb?w=1712&h=1080&f=png&s=3560244" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/23/1707081485369be2?w=1280&h=853&f=png&s=1671129" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/23/1707082136eaba87?w=650&h=487&f=png&s=547465" alt=""></p>
<p>代理模式的类图结构：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/23/170702e8a82b99b5?w=451&h=379&f=png&s=126867" alt=""></p>
<p>Subject是顶层设计的接口，RealSubject是真实的对象，Proxy是代理对象，代理对象持有真实对象的引用，客户端Client调用代理对象的方法，同时也调用真实对象的方法，在代理对象前后增加一些处理。我们一想到代理模式，就会理解为<strong>代码增强</strong>，其实就是在原本的代码逻辑前后增加一些逻辑，而使得调用者无感知。代理模式分为静态代理和动态代理。</p>
<h1 id="二、代理模式的分类"><a href="#二、代理模式的分类" class="headerlink" title="二、代理模式的分类"></a>二、代理模式的分类</h1><h2 id="2-1-静态代理"><a href="#2-1-静态代理" class="headerlink" title="2.1 静态代理"></a>2.1 静态代理</h2><p>我们直接来举例说明静态代理，青年男女到了适婚的年龄，如果没有对象，周围的亲戚朋友总是张罗着要给某某某介绍对象，这个介绍对象相亲的过程，就是一种我们人人都有份的代理。来看代码实现：</p>
<p>顶层接口设计Person类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Person &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 寻找伴侣</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void lookForMate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>女儿要求找对象，实现Person接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Daughter implements Person &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void lookForMate() &#123;</span><br><span class="line">        System.out.println(&quot;女儿要求：高大英俊且有钱！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>母亲要帮闺女相亲，实现Mother类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Mother &#123;</span><br><span class="line"></span><br><span class="line">    private Daughter daughter;</span><br><span class="line">    &#x2F;&#x2F;如何扩展呢</span><br><span class="line">    public Mother(Daughter daughter) &#123;</span><br><span class="line">        this.daughter &#x3D; daughter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;目标对象的引用daughter拿到，可以调用</span><br><span class="line">    public void lookForMate() &#123;</span><br><span class="line">        System.out.println(&quot;母亲物色女儿的对象&quot;);</span><br><span class="line">        daughter.lookForMate();</span><br><span class="line">        System.out.println(&quot;双方同意交往并确立关系&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;只能帮女儿找对象，不能帮表妹、不能帮陌生人</span><br><span class="line">    Mother mother &#x3D; new Mother(new Daughter());</span><br><span class="line">    mother.lookForMate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/23/170709c04b74144d?w=475&h=229&f=png&s=16047" alt=""></p>
<p>上面的这个例子是生活中的例子，我们用代码实现了生活中的代理模式。再来一个具体的实际业务场景的例子吧。我们经常会对数据库进行分库分表，分库分表后用Java代码来操作，就需要配置多个数据源，通过设置数据源路由来动态动态切换数据源。<br>创建订单实体类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 订单实体类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Order &#123;</span><br><span class="line"></span><br><span class="line">    private String id;</span><br><span class="line"></span><br><span class="line">    private Object orderInfo;</span><br><span class="line"></span><br><span class="line">    private Long createTime;</span><br><span class="line"></span><br><span class="line">    public String getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(String id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getOrderInfo() &#123;</span><br><span class="line">        return orderInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOrderInfo(Object orderInfo) &#123;</span><br><span class="line">        this.orderInfo &#x3D; orderInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Long getCreateTime() &#123;</span><br><span class="line">        return createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCreateTime(Long createTime) &#123;</span><br><span class="line">        this.createTime &#x3D; createTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建OrderDao持久层操作类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class OrderDao &#123;</span><br><span class="line">    public int insert(Order order) &#123;</span><br><span class="line">        System.out.println(&quot;创建order对象成功!&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 IOrderService 接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IOrderService &#123;</span><br><span class="line">    int createOrder(Order order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 OrderService 实现类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class OrderService implements IOrderService &#123;</span><br><span class="line"></span><br><span class="line">    private OrderDao orderDao;</span><br><span class="line"></span><br><span class="line">    public OrderService(OrderDao orderDao) &#123;</span><br><span class="line">        orderDao &#x3D; new OrderDao();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int createOrder(Order order) &#123;</span><br><span class="line">        System.out.println(&quot;OrderService调用OrderDao创建订单&quot;);</span><br><span class="line">        return orderDao.insert(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来使用静态代理，完成订单创建时间自动按年份进行分库，通过使用代理对象来完成接下来的代码。创建数据源路由对象，使用ThreadLocal单例实现，DynamicDataSourceEntity：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicDataSourceEntity &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 默认数据源</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final String DEFAULT_DATA_SOURCE &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private static final ThreadLocal&lt;String&gt; local &#x3D; new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private DynamicDataSourceEntity() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取当前正在使用的数据源</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String get() &#123;</span><br><span class="line">        return local.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 设置已知名字的数据源</span><br><span class="line">     * @param dataSource</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void set(String dataSource) &#123;</span><br><span class="line">        local.set(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 还原当前切面的数据源</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void restore() &#123;</span><br><span class="line">        local.set(DEFAULT_DATA_SOURCE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 根据年份动态设置数据源</span><br><span class="line">     * @param year</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void set(int year) &#123;</span><br><span class="line">        local.set(&quot;DB_&quot; + year);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 清空数据源</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void remove() &#123;</span><br><span class="line">        local.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建切换数据源代理OrderServiceStaticProxy：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class OrderServiceStaticProxy implements IOrderService &#123;</span><br><span class="line"></span><br><span class="line">    private SimpleDateFormat yearFormat &#x3D; new SimpleDateFormat(&quot;yyyy&quot;);</span><br><span class="line"></span><br><span class="line">    private IOrderService orderService;</span><br><span class="line"></span><br><span class="line">    public OrderServiceStaticProxy(IOrderService orderService) &#123;</span><br><span class="line">        this.orderService &#x3D; orderService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int createOrder(Order order) &#123;</span><br><span class="line">        before();</span><br><span class="line">        Long time &#x3D; order.getCreateTime();</span><br><span class="line">        Integer dbRouter &#x3D; Integer.valueOf(yearFormat.format(new Date(time)));</span><br><span class="line">        System.out.println(&quot;静态代理类自动分配到【DB_&quot; + dbRouter + &quot;】数据源处理数据。&quot;);</span><br><span class="line">        DynamicDataSourceEntity.set(dbRouter);</span><br><span class="line">        orderService.createOrder(order);</span><br><span class="line">        after();</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void before()&#123;</span><br><span class="line">        System.out.println(&quot;代理方法执行开始了......&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private void after()&#123;</span><br><span class="line">        System.out.println(&quot;代理方法执行结束了......&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main方法的代码：</p>
<p> public static void main(String[] args) throws ParseException {</p>
<pre><code>Order order = new Order();
order.setId(&quot;010101001&quot;);
//Date today = new Date();
//order.setCreateTime(today.getTime());

SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd&quot;);
Date date = sdf.parse(&quot;2019/02/01&quot;);
order.setCreateTime(date.getTime());


IOrderService orderService = new OrderServiceStaticProxy(new OrderService());
orderService.createOrder(order);</code></pre><p>}</p>
<p>运行结果是：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/23/17070e2f728d86b3?w=610&h=346&f=png&s=26911" alt=""></p>
<p>符合我们的预期效果。现在我们再来回顾一下类图，看是不是和我们最先画的类结构一致：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/23/17070e41a9eadcfb?w=1197&h=476&f=png&s=346255" alt=""></p>
<h2 id="2-2-动态代理"><a href="#2-2-动态代理" class="headerlink" title="2.2 动态代理"></a>2.2 动态代理</h2><p>动态代理和静态代理的思路基本是一致的，只不过动态代理的功能更加强大，随着业务的扩展适应性更强。前面说到的母亲替闺女找对象的例子，如果找对象的业务发展为一个行业，那么就是婚姻中介了。来升级代码的实现过程，以满足帮助更多的单身人士找对象的需求。下面使用JDK的方式实现婚姻介绍所。</p>
<h2 id="2-2-1-JDK实现方式"><a href="#2-2-1-JDK实现方式" class="headerlink" title="2.2.1 JDK实现方式"></a>2.2.1 JDK实现方式</h2><p>创建婚姻介绍JDKMarriage类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class JDKMarriage implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    private Object target;</span><br><span class="line"></span><br><span class="line">    public Object getInstance(Object target) &#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz &#x3D; target.getClass();</span><br><span class="line">        return Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        before();</span><br><span class="line">        Object object &#x3D; method.invoke(this.target, args);</span><br><span class="line">        after();</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void before()&#123;</span><br><span class="line">        System.out.println(&quot;我是婚姻介绍所：要给你找对象，现在已经拿到你的需求&quot;);</span><br><span class="line">        System.out.println(&quot;开始物色&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private void after()&#123;</span><br><span class="line">        System.out.println(&quot;如果合适的话，就准备办事&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建单身客户Customer类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Customer implements Person &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void lookForMate() &#123;</span><br><span class="line">        System.out.println(&quot;高富帅&quot;);</span><br><span class="line">        System.out.println(&quot;身高180cm&quot;);</span><br><span class="line">        System.out.println(&quot;有房有车&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试main方法代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    JDKMarriage marriage &#x3D; new JDKMarriage();</span><br><span class="line"></span><br><span class="line">    Person person &#x3D; (Person) marriage.getInstance(new Customer());</span><br><span class="line">    person.lookForMate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/23/170712617edfebb2?w=670&h=364&f=png&s=25490" alt=""></p>
<p>上面的动态代理案例通过实现InvocationHandler接口来完成的，在前面的数据源路由业务，也要用动态代理来实现一下，我们来看下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class OrderServiceDynamicProxy implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    private SimpleDateFormat yearFormat &#x3D; new SimpleDateFormat(&quot;yyyy&quot;);</span><br><span class="line"></span><br><span class="line">    public Object target;</span><br><span class="line"></span><br><span class="line">    public Object getInstance(Object target) &#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">        Class&lt;?&gt; clazz &#x3D; target.getClass();</span><br><span class="line">        return Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        before(args[0]);</span><br><span class="line">        Object object &#x3D; method.invoke(target, args);</span><br><span class="line">        after();</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void before(Object target) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;代理方法执行开始了......&quot;);</span><br><span class="line">            Long time &#x3D; (Long)target.getClass().getMethod(&quot;getCreateTime&quot;).invoke(target);</span><br><span class="line">            Integer dbRouter &#x3D; Integer.valueOf(yearFormat.format(new Date(time)));</span><br><span class="line">            System.out.println(&quot;动态代理类自动分配到【DB_&quot; + dbRouter + &quot;】数据源处理数据&quot;);</span><br><span class="line">            DynamicDataSourceEntity.set(dbRouter);</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void after() &#123;</span><br><span class="line">        System.out.println(&quot;代理方法执行结束了......&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试main方法代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws ParseException &#123;</span><br><span class="line">        Order order &#x3D; new Order();</span><br><span class="line">        order.setId(&quot;010101001&quot;);</span><br><span class="line">&#x2F;&#x2F;        Date today &#x3D; new Date();</span><br><span class="line">&#x2F;&#x2F;        order.setCreateTime(today.getTime());</span><br><span class="line"></span><br><span class="line">        SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy&#x2F;MM&#x2F;dd&quot;);</span><br><span class="line">        Date date &#x3D; sdf.parse(&quot;2019&#x2F;02&#x2F;01&quot;);</span><br><span class="line">        order.setCreateTime(date.getTime());</span><br><span class="line"></span><br><span class="line">        IOrderService orderService &#x3D; (IOrderService) new OrderServiceDynamicProxy().getInstance(new OrderService());</span><br><span class="line">        orderService.createOrder(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/23/170715f8efe2d262?w=553&h=298&f=png&s=25414" alt=""></p>
<p>依然可以达到想要的运行效果。但是，动态代理实现之后，我们不仅能实现 Order 的数据源动态路由，还可以实现其他任何类的数据源路由。</p>
<h2 id="2-2-2-CGLib代理调用API及原理分析"><a href="#2-2-2-CGLib代理调用API及原理分析" class="headerlink" title="2.2.2 CGLib代理调用API及原理分析"></a>2.2.2 CGLib代理调用API及原理分析</h2><p>pom依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;cglib&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;cglib&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;3.3.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>还是以婚姻介绍所为例，创建CglibMarriage类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class CglibMarriage implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    public Object getInstance(Class&lt;?&gt; clazz) throws Exception &#123;</span><br><span class="line">        Enhancer enhancer &#x3D; new Enhancer();</span><br><span class="line">        &#x2F;&#x2F;要把哪个类设置成为生成的新类的父类</span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        enhancer.setCallback(this);</span><br><span class="line"></span><br><span class="line">        return enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object o, Method method, Object[] objects,</span><br><span class="line">                            MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        before();</span><br><span class="line">        Object obj &#x3D; methodProxy.invokeSuper(o, objects);</span><br><span class="line">        after();</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void before()&#123;</span><br><span class="line">        System.out.println(&quot;我是婚姻介绍所：要给你找对象，现在已经拿到你的需求&quot;);</span><br><span class="line">        System.out.println(&quot;开始物色&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private void after()&#123;</span><br><span class="line">        System.out.println(&quot;如果合适的话，就准备办事&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着创建单身客户类Customer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Customer &#123;</span><br><span class="line">    </span><br><span class="line">    public void lookForMate() &#123;</span><br><span class="line">        System.out.println(&quot;高富帅&quot;);</span><br><span class="line">        System.out.println(&quot;身高180cm&quot;);</span><br><span class="line">        System.out.println(&quot;有房有车&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>CGLib代理的目标对象不需要实现任何接口，它是通过动态继承目标对象实现动态代理的。</strong> 来看测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Customer customer &#x3D; (Customer)new CglibMarriage().getInstance(Customer.class);</span><br><span class="line">            customer.lookForMate();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CGLib代理执行代理对象的方法效率之所以比JDK的高，是因为CGLib采用了FastClass机制，FastClass的原理是：为代理类和被代理类各生成一个class，这个class会为代理类或被代理类的方法分配一个index(int类型)，这个index当作入参，FastClass就可以直接定位要调用的方法直接进行调用，这样省去了反射调用，所以调用效率比JDK动态代理通过反射调用高。</strong></p>
<h2 id="2-2-3-CGLib和JDK动态代理对比"><a href="#2-2-3-CGLib和JDK动态代理对比" class="headerlink" title="2.2.3 CGLib和JDK动态代理对比"></a>2.2.3 CGLib和JDK动态代理对比</h2><p>1、JDK动态代理实现了被代理对象的接口，CGLib代理继承了被代理对象。</p>
<p>2、JDK和CGLib都在运行期间生成字节码，JDK动态代理直接生成class字节码，CGLib代理通过asm框架生成class字节码，CGLib代理实现更复杂，生成代理类比JDK动态代理效率低。</p>
<p>3、JDK动态代理调用代理方法是通过反射机制调用的，CGLib代理是通过FastClass机制直接调用方法的，CGLib代理的执行效率高。</p>
<h1 id="三、Spring与代理模式"><a href="#三、Spring与代理模式" class="headerlink" title="三、Spring与代理模式"></a>三、Spring与代理模式</h1><h2 id="3-1-代理模式在Spring源码中的应用"><a href="#3-1-代理模式在Spring源码中的应用" class="headerlink" title="3.1 代理模式在Spring源码中的应用"></a>3.1 代理模式在Spring源码中的应用</h2><p>先看 <strong>ProxyFactoryBean</strong>  核心的方法就是 <strong>getObject()</strong> 方法，我们来看一下源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">public Object getObject() throws BeansException &#123;</span><br><span class="line">    this.initializeAdvisorChain();</span><br><span class="line">    if (this.isSingleton()) &#123;</span><br><span class="line">        return this.getSingletonInstance();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (this.targetName &#x3D;&#x3D; null) &#123;</span><br><span class="line">            this.logger.info(&quot;Using non-singleton proxies with singleton targets is often undesirable. Enable prototype proxies by setting the &#39;targetName&#39; property.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return this.newPrototypeInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 getObject()方法中，主要调用 <strong>getSingletonInstance()</strong> 和<strong>newPrototypeInstance()</strong> ；<br>在 Spring 的配置中，如果不做任何设置，那么 Spring 代理生成的 Bean 都是单例对象。如果修改 scope则每次创建一个新的原型对象。newPrototypeInstance()里面的逻辑比较复杂，我们后面的课程再做深入研究，这里我们先做简单的了解。</p>
<h2 id="3-2-Spring-中的代理选择原则"><a href="#3-2-Spring-中的代理选择原则" class="headerlink" title="3.2 Spring 中的代理选择原则"></a>3.2 Spring 中的代理选择原则</h2><p>Spring 利用动态代理实现 AOP 有两个非常重要的类，一个是 <strong>JdkDynamicAopProxy</strong> 类和 <strong>CglibAopProxy</strong> 类，来看一下类图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/24/17075edc2fd9e1a9?w=1195&h=469&f=png&s=29406" alt=""></p>
<ul>
<li>当 Bean 有实现接口时，Spring 就会用 JDK 的动态代理；</li>
</ul>
<ul>
<li>当 Bean 没有实现接口时，Spring 选择 CGLib。</li>
</ul>
<h1 id="三、-静态代理和动态的本质区别"><a href="#三、-静态代理和动态的本质区别" class="headerlink" title="三、 静态代理和动态的本质区别"></a>三、 静态代理和动态的本质区别</h1><p>1、静态代理只能通过手动完成代理操作，如果被代理类增加新的方法，代理类需要同步新增，违背开闭原则。</p>
<p>2、动态代理采用在运行时动态生成代码的方式，取消了对被代理类的扩展限制，遵循开闭原则。</p>
<p>3、若动态代理要对目标类的增强逻辑扩展，结合策略模式，只需要新增策略类便可完成，无需修改代理类的代码。</p>
<h1 id="四、代理模式的优缺点"><a href="#四、代理模式的优缺点" class="headerlink" title="四、代理模式的优缺点"></a>四、代理模式的优缺点</h1><p>使用代理模式具有以下几个优点：</p>
<ul>
<li>代理模式能将代理对象与真实被调用的目标对象分离；</li>
</ul>
<ul>
<li>一定程度上降低了系统的耦合度，扩展性好；</li>
</ul>
<ul>
<li>可以起到保护目标对象的作用；</li>
</ul>
<ul>
<li>可以对目标对象的功能增强。</li>
</ul>
<p>当然，代理模式也是有缺点的：</p>
<ul>
<li>代理模式会造成系统设计中类的数量增加；</li>
</ul>
<ul>
<li>在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢；</li>
</ul>
<ul>
<li>增加了系统的复杂度。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/02/25/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%B9%B2%E8%BF%87%E4%B8%AD%E4%BB%8B%E5%B9%B2%E8%BF%87%E5%BF%AB%E9%80%92%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="ck7lialvg000e6xra0l4yaer1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，只是单纯听说过的原型模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/22/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%8F%AA%E6%98%AF%E5%8D%95%E7%BA%AF%E5%90%AC%E8%AF%B4%E8%BF%87%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-02-22T13:12:08.000Z" itemprop="datePublished">2020-02-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/22/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%8F%AA%E6%98%AF%E5%8D%95%E7%BA%AF%E5%90%AC%E8%AF%B4%E8%BF%87%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，只是单纯听说过的原型模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、原型模式的应用场景"><a href="#一、原型模式的应用场景" class="headerlink" title="一、原型模式的应用场景"></a>一、原型模式的应用场景</h1><p>你一定遇到过这样的代码场景，有大量的getter、setter赋值的场景。例如这样的代码片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private SafetyStockMessage createKafkaMessage(SafetyStock safetyStock, HttpServletRequest request) &#123;</span><br><span class="line">        SafetyStockMessage safetyStockMessage &#x3D; new SafetyStockMessage();</span><br><span class="line">        safetyStockMessage.setId(safetyStock.getId());</span><br><span class="line">        safetyStockMessage.setProvinceCode(safetyStock.getProvinceCode());</span><br><span class="line">        safetyStockMessage.setRequestId(CodeConstants.REQUEST_ID);</span><br><span class="line">        safetyStockMessage.setRequestIp(CodeConstants.REQUEST_IP);</span><br><span class="line">        safetyStockMessage.setSerial(IdMakerUtil.make32Id());</span><br><span class="line">        safetyStockMessage.setStockMax(safetyStock.getStockMax());</span><br><span class="line">        safetyStockMessage.setStockMin(safetyStock.getStockMin());</span><br><span class="line">        safetyStockMessage.setProvince(safetyStock.getProvince());</span><br><span class="line">        safetyStockMessage.setCategoryName(safetyStock.getCategoryName());</span><br><span class="line">        safetyStockMessage.setUpdateTime(new Date());</span><br><span class="line">        safetyStockMessage.setUpdateBy(getLoginUser(request));</span><br><span class="line">        return safetyStockMessage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码看起来非常工整，命名也很规范，大家觉得这样的代码优雅吗？这样的代码属于纯体力劳动。如果使用原型模式，可以帮助我们解决这样的问题。</p>
<p>原型模式（Prototype Pattern）是指原型实例指定创建对象的种类，并且通过拷贝这样原型创建新的对象。</p>
<p>原型模式主要适用于以下场景：</p>
<p>1、类初始化消耗的资源较多；</p>
<p>2、new产生的一个对象需要非常繁琐的过程（数据准备、访问权限等）；</p>
<p>3、构造函数比较复杂；</p>
<p>4、循环体中生产大量对象。</p>
<p>原型模型的类结构图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/21/17067d2c6f3719e9?w=912&h=299&f=png&s=164629" alt=""></p>
<h1 id="二、简单克隆"><a href="#二、简单克隆" class="headerlink" title="二、简单克隆"></a>二、简单克隆</h1><p>一个标准的原型模式代码，应该是这样的设计的。先创建原型Prototype接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Prototype &#123;</span><br><span class="line">    Prototype clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建具体需要克隆的对象ConcretePrototype：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class ConcretePrototype implements Prototype &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private List&lt;String&gt; hobbies;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; getHobbies() &#123;</span><br><span class="line">        return hobbies;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHobbies(List&lt;String&gt; hobbies) &#123;</span><br><span class="line">        this.hobbies &#x3D; hobbies;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ConcretePrototype clone() &#123;</span><br><span class="line">        ConcretePrototype concretePrototype &#x3D; new ConcretePrototype();</span><br><span class="line">        concretePrototype.setName(this.name);</span><br><span class="line">        concretePrototype.setAge(this.age);</span><br><span class="line">        concretePrototype.setHobbies(this.hobbies);</span><br><span class="line">        return concretePrototype;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建Client对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    private Prototype prototype;</span><br><span class="line"></span><br><span class="line">    public Client(Prototype prototype) &#123;</span><br><span class="line">        this.prototype &#x3D; prototype;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Prototype startClone(Prototype concretePrototype) &#123;</span><br><span class="line">        return (Prototype)concretePrototype.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个具体的需要克隆的对象</span><br><span class="line">        ConcretePrototype concretePrototype &#x3D; new ConcretePrototype();</span><br><span class="line">        &#x2F;&#x2F;填充属性，准备测试</span><br><span class="line">        concretePrototype.setName(&quot;Kevin&quot;);</span><br><span class="line">        concretePrototype.setAge(18);</span><br><span class="line">        List&lt;String&gt; hobbies &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        concretePrototype.setHobbies(hobbies);</span><br><span class="line">        System.out.println(concretePrototype);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建Client对象，准备进行克隆</span><br><span class="line">        Client client &#x3D; new Client(concretePrototype);</span><br><span class="line">        ConcretePrototype concretePrototypeClone &#x3D; (ConcretePrototype)</span><br><span class="line">                client.startClone(concretePrototype);</span><br><span class="line">        System.out.println(concretePrototypeClone);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;克隆对象中的引用类型地址值是：&quot; +</span><br><span class="line">                concretePrototypeClone.getHobbies());</span><br><span class="line">        System.out.println(&quot;原对象中的引用类型地址值是：&quot; +</span><br><span class="line">                concretePrototype.getHobbies());</span><br><span class="line">        System.out.println(&quot;对象地址比较：&quot; + (concretePrototypeClone.getHobbies() &#x3D;&#x3D;</span><br><span class="line">                concretePrototype.getHobbies()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/21/1706804761bd93d1?w=640&h=223&f=png&s=29218" alt=""></p>
<p>从测试结果看出hobbies的引用地址是相同的，意味着不是复制值，而复制的是引用的地址。如果我们修改任何一个对象的属性值，concretePrototype和concretePrototypeClone的hobbies的值都会改变。这就是我们常说的浅克隆。只是完整复制了值类型数据，没有复制引用对象。换言之，所有的引用对象还是指向原来的对象，显然不是我们想要的结果。</p>
<p>下面我们继续改造代码，使用深度克隆。</p>
<h1 id="三、深度克隆"><a href="#三、深度克隆" class="headerlink" title="三、深度克隆"></a>三、深度克隆</h1><p>我们来换一个场景，大家都知道齐天大圣孙悟空。首先它是一只猴子，有着七十二般变化，把一根毫毛放在嘴里一吹就变出千万个泼猴，手里还拿着金箍棒，金箍棒可变大变小。这就是我们耳熟能详的原型模式的经典体现。</p>
<p>创建原型猴子 Monkey 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Monkey &#123;</span><br><span class="line"></span><br><span class="line">    public int height;</span><br><span class="line">    public int weight;</span><br><span class="line">    public Date birthday;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建引用对象金箍棒GoldenCudgel类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class GoldenCudgel implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    public float h &#x3D; 100f;</span><br><span class="line"></span><br><span class="line">    public float d &#x3D; 10f;</span><br><span class="line"></span><br><span class="line">    public void changeBig() &#123;</span><br><span class="line">        this.d *&#x3D; 2;</span><br><span class="line">        this.h *&#x3D; 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void changeSmall() &#123;</span><br><span class="line">        this.d &#x2F;&#x3D; 2;</span><br><span class="line">        this.h &#x2F;&#x3D; 2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建具体的对象齐天大圣孙悟空MonkeyKing类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class MonkeyKing extends Monkey implements Cloneable, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    public GoldenCudgel goldenCudgel;</span><br><span class="line"></span><br><span class="line">    public MonkeyKing() &#123;</span><br><span class="line">        this.birthday &#x3D; new Date();</span><br><span class="line">        this.goldenCudgel &#x3D; new GoldenCudgel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() &#123;</span><br><span class="line">        return this.deepClone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 深克隆</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected Object deepClone()  &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);</span><br><span class="line">            oos.writeObject(this);</span><br><span class="line"></span><br><span class="line">            ByteArrayInputStream bis &#x3D; new ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">            ObjectInputStream ois &#x3D; new ObjectInputStream(bis);</span><br><span class="line"></span><br><span class="line">            MonkeyKing copy &#x3D; (MonkeyKing) ois.readObject();</span><br><span class="line">            copy.birthday &#x3D; new Date();</span><br><span class="line">            return copy;</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 浅克隆</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public MonkeyKing shallowClone(MonkeyKing target) &#123;</span><br><span class="line">        MonkeyKing monkeyKing &#x3D; new MonkeyKing();</span><br><span class="line">        monkeyKing.height &#x3D; target.height;</span><br><span class="line">        monkeyKing.weight &#x3D; target.weight;</span><br><span class="line"></span><br><span class="line">        monkeyKing.goldenCudgel &#x3D; target.goldenCudgel;</span><br><span class="line">        monkeyKing.birthday &#x3D; new Date();</span><br><span class="line"></span><br><span class="line">        return monkeyKing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        MonkeyKing monkeyKing &#x3D; new MonkeyKing();</span><br><span class="line"></span><br><span class="line">        MonkeyKing clone &#x3D; (MonkeyKing)monkeyKing.clone();</span><br><span class="line">        System.out.println(&quot;深克隆：&quot; + (monkeyKing.goldenCudgel &#x3D;&#x3D; clone.goldenCudgel));</span><br><span class="line"></span><br><span class="line">        MonkeyKing shallow &#x3D; new MonkeyKing();</span><br><span class="line">        MonkeyKing newMonkeyKing &#x3D; shallow.shallowClone(shallow);</span><br><span class="line">        System.out.println(&quot;浅克隆&quot; + (shallow.goldenCudgel &#x3D;  newMonkeyKing.goldenCudgel));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/22/1706cb7b5846bd38?w=214&h=103&f=png&s=4529" alt=""></p>
<ul>
<li>克隆破坏单例模式</li>
</ul>
<p>如果我们克隆的目标是单例模式创建的对象，那么意味着深克隆会破坏单例模式。如何防止克隆破坏单例，禁止深克隆便可。我们在单例的类中不实现Cloneable接口，在重写clone()方法中返回单例对象即可，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">    return INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>Cloneable 源码分析</li>
</ul>
<p>先看我们常用的 ArrayList 就实现了 Cloneable 接口，来看代码clone()方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Object clone() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ArrayList&lt;?&gt; v &#x3D; (ArrayList&lt;?&gt;) super.clone();</span><br><span class="line">            v.elementData &#x3D; Arrays.copyOf(elementData, size);</span><br><span class="line">            v.modCount &#x3D; 0;</span><br><span class="line">            return v;</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; this shouldn&#39;t happen, since we are Cloneable</span><br><span class="line">            throw new InternalError(e);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/02/22/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%8F%AA%E6%98%AF%E5%8D%95%E7%BA%AF%E5%90%AC%E8%AF%B4%E8%BF%87%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="ck7lialug00096xra2p0sg5ty" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，经典高频面试的单例模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/21/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E7%BB%8F%E5%85%B8%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-02-21T07:58:17.000Z" itemprop="datePublished">2020-02-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/21/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E7%BB%8F%E5%85%B8%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，经典高频面试的单例模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、单例模式应用场景"><a href="#一、单例模式应用场景" class="headerlink" title="一、单例模式应用场景"></a>一、单例模式应用场景</h1><p>单例模式（Single Pattern）是指<strong>确保一个类在任何情况下绝对只是一个实例，并提供一个全局的访问点。</strong> 单例模式在现实生活中的应用也很广泛。例如国家总统、公司CEO、部门经理等。在java标准中，ServletContext、ServletContextConfig等；在Spring框架中ApplicationCotext；数据库对应的连接池也都是单例形势的。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/20/170613d3f9e4fcf0?w=720&h=405&f=png&s=385065" alt=""></p>
<h1 id="二、单例模式分类"><a href="#二、单例模式分类" class="headerlink" title="二、单例模式分类"></a>二、单例模式分类</h1><h2 id="2-1-饿汉式单例"><a href="#2-1-饿汉式单例" class="headerlink" title="2.1 饿汉式单例"></a>2.1 饿汉式单例</h2><p><strong>饿汉式单例是在类加载的时候就立即初始化了，并且创建了单例对象。绝对的线程安全，在线程还没出现以前就实例化了，不可能存在访问安全问题。</strong></p>
<p>优点：没有加任何的锁，执行效率高，在用户体验上，比懒汉式更好。<br>缺点：类加载的时候就初始化了，不管用与不用都占空间，浪费了内存，有可能占着茅坑不拉屎。</p>
<p><strong>Spring中的IOC容器ApplicationContext</strong>本身就是典型的饿汉式单例。案例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class HungrySingleton &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 先静态后动态</span><br><span class="line">     * 先属性后方法</span><br><span class="line">     * 先上后下</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static final HungrySingleton hungrySingleton &#x3D; new HungrySingleton();</span><br><span class="line"></span><br><span class="line">    private HungrySingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static HungrySingleton getInstance() &#123;</span><br><span class="line">        return hungrySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种写法，是利用静态代码块机制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class HungrySingleton &#123;</span><br><span class="line">    </span><br><span class="line">    private static final HungrySingleton hungrySingleton;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        hungrySingleton &#x3D; new HungrySingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private HungrySingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private HungrySingleton getInstance() &#123;</span><br><span class="line">        return hungrySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种写法都很简单，也很容易理解。<strong>饿汉式使用在单例对象较少的情况下。</strong> 下面来看下性能更优的写法。</p>
<h2 id="2-2-懒汉式单例"><a href="#2-2-懒汉式单例" class="headerlink" title="2.2 懒汉式单例"></a>2.2 懒汉式单例</h2><p>懒汉式单例是指被外部调用的时候才会进行加载。示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 懒汉式单例</span><br><span class="line">     * 在外部需要使用的时候才进行实例化</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private LazySingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static LazySingleton lazySingleton &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public static LazySingleton getInstance() &#123;</span><br><span class="line">        if(lazySingleton &#x3D;&#x3D; null) &#123;</span><br><span class="line">            lazySingleton &#x3D; new LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return lazySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写一个线程类ExectorThread：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ExectorThread implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        LazySingleton lazySingleton &#x3D; LazySingleton.getInstance();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + lazySingleton);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;--------begin-------&quot;);</span><br><span class="line">        Thread t1 &#x3D; new Thread(new ExectorThread());</span><br><span class="line">        Thread t2 &#x3D; new Thread(new ExectorThread());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println(&quot;--------end---------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看main方法多次运行的结果发现：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/20/170619047ed1b1de?w=349&h=82&f=png&s=7164" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/2/20/17061910bb8a9a1e?w=346&h=85&f=png&s=7161" alt=""></p>
<p>有一定几率会出现创建两个不同结果的情况，意味着上门的单例创建代码存在线程安全隐患。我们通过对代码进行debug调试，发现通过不断切换线程，并观测其内存状态，发现在线程环境下LazySingleton被实例化了两次。有时候我们得到的运行结果可能是相同的两个对象，实际上是被后面的执行线程给覆盖了，看到了一个假象，线程安全隐患依然存在。这样我们需要在线程安全的环境下运行懒汉单例代码。给getIntance()方法加上<strong>Synchronized</strong>关键字，使这个方法变成线程同步方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 懒汉式单例</span><br><span class="line">     * 在外部需要使用的时候才进行实例化</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private LazySingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static LazySingleton lazySingleton &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public synchronized static LazySingleton getInstance() &#123;</span><br><span class="line">        if(lazySingleton &#x3D;&#x3D; null) &#123;</span><br><span class="line">            lazySingleton &#x3D; new LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return lazySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加<strong>synchronized</strong>关键字使用锁，在线程数量比较多的情况下，如果CPU分配压力上升，会导致大批线程出现阻塞，从而导致程序运行性能大幅度下降。那么，有木有一种更好的方式，既兼顾线程的安全性又提升程序性能呢？答案是肯定的。我们会使用<strong>双重检查锁</strong>的单例模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class LazyDoubleCheckSingletion &#123;</span><br><span class="line"></span><br><span class="line">    private volatile static LazyDoubleCheckSingletion lazy &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private LazyDoubleCheckSingletion() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static LazyDoubleCheckSingletion getInstance() &#123;</span><br><span class="line">        if(lazy &#x3D;&#x3D; null) &#123;</span><br><span class="line">            synchronized(LazyDoubleCheckSingletion.class) &#123;</span><br><span class="line">                if(lazy &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    lazy &#x3D; new LazyDoubleCheckSingletion();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return lazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当第一个线程调用 getInstance()方法时，第二个线程也可以调用getInstance()。当第一个线程执行到 synchronized 时会上锁，第二个线程就会变成 MONITOR状态，出现阻塞。此时，阻塞并不是基于整个 LazySingleton 类的阻塞，而是在 getInstance()方法内部阻塞，只要逻辑不是太复杂，对于调用者而言感知不到。</p>
<p>但是，用到 synchronized关键字，总归是要上锁，对程序性能还是存在一定影响的。难道就真的没有更好的方案吗？当然是有的。我们可以从类初始化角度来考虑，看下面的代码，采用静态内部类的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class LazyInnerClassSingleton &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 这种形式兼顾饿汉式的内存浪费，也兼顾 synchronized 性能问题</span><br><span class="line">     * 完美地屏蔽了这两个缺点</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;如果没使用的话，内部类是不加载的</span><br><span class="line">    private LazyInnerClassSingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 每一个关键字都不是多余的</span><br><span class="line">     * static 是为了使单例的空间共享</span><br><span class="line">     * 保证这个方法不会被重写，重载</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final LazyInnerClassSingleton getInstance() &#123;</span><br><span class="line">        &#x2F;&#x2F;在返回结果以前，一定会先加载内部类</span><br><span class="line">        return LazyHolder.LAZY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;默认不加载</span><br><span class="line">    private static class LazyHolder&#123;</span><br><span class="line">        private static final LazyInnerClassSingleton LAZY &#x3D;</span><br><span class="line">                new LazyInnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种形式兼顾饿汉式的内存浪费，也兼顾synchronized性能问题。内部类一定是要在方法调用之前初始化，巧妙地避免了线程安全问题。</p>
<ul>
<li>反射破坏单例</li>
</ul>
<p>上面一些介绍单例模式的构造方法除了加上private以外，没有做任何处理。如果使用反射来调用其构造方法，然后再调用getInstance()方法，应该就会有两个不同的实例。还是以LazyInnerClassSingleton为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Class&lt;?&gt; clazz &#x3D; LazyInnerClassSingleton.class;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;通过反射机制拿到私有的构造方法</span><br><span class="line">            Constructor c &#x3D; clazz.getDeclaredConstructor(null);</span><br><span class="line">            &#x2F;&#x2F;强制访问</span><br><span class="line">            c.setAccessible(true);</span><br><span class="line">            &#x2F;&#x2F;&#x2F;&#x2F;暴力初始化</span><br><span class="line">            Object o1 &#x3D; c.newInstance();</span><br><span class="line">            &#x2F;&#x2F;调用了两次构造方法，相当于 new 了两次</span><br><span class="line">            Object o2 &#x3D; c.newInstance();</span><br><span class="line"></span><br><span class="line">            System.out.println(o1 &#x3D;&#x3D; o2);</span><br><span class="line"></span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果是：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/20/17061e9caa179a11?w=322&h=91&f=png&s=4243" alt=""></p>
<p>运行结果很显然是创建了两个不同的实例。现在我们对其构造方法做一些限制，一旦出现重复创建实例，则直接抛出异常。来看优化后的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * 这种形式兼顾饿汉式的内存浪费，也兼顾 synchronized 性能问题</span><br><span class="line">   * 完美地屏蔽了这两个缺点</span><br><span class="line">   *&#x2F;</span><br><span class="line">  &#x2F;&#x2F;如果没使用的话，内部类是不加载的</span><br><span class="line">  private LazyInnerClassSingleton() &#123;</span><br><span class="line">      if(LazyHolder.LAZY !&#x3D; null) &#123;</span><br><span class="line">          throw new RuntimeException(&quot;Multiple instances are not allowed to be created!&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 每一个关键字都不是多余的</span><br><span class="line">   * static 是为了使单例的空间共享</span><br><span class="line">   * 保证这个方法不会被重写，重载</span><br><span class="line">   * @return</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public static final LazyInnerClassSingleton getInstance() &#123;</span><br><span class="line">      &#x2F;&#x2F;在返回结果以前，一定会先加载内部类</span><br><span class="line">      return LazyHolder.LAZY;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;默认不加载</span><br><span class="line">  private static class LazyHolder&#123;</span><br><span class="line">      private static final LazyInnerClassSingleton LAZY &#x3D;</span><br><span class="line">              new LazyInnerClassSingleton();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>再次运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/20/17061edd8dce3459?w=1213&h=238&f=png&s=38316" alt=""></p>
<p><strong>至此，史上最牛 B 的单例写法便大功告成。</strong></p>
<ul>
<li>序列化破坏单例</li>
</ul>
<p>当我们将一个单例对象创建好后，有时候需要将对象序列化后写入到磁盘，下次使用的时候再从磁盘中读取到对象，反序列化为内存对象。反序列化后的对象会重新分配内存，即重新创建。<strong>那么如果序列化的目标的对象为单例对象，就违背了单例模式的初衷，相当于破坏了单例</strong>，来看一下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class SerializeSingleton implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    public static final SerializeSingleton INSTANCE &#x3D; new SerializeSingleton();</span><br><span class="line"></span><br><span class="line">    private SerializeSingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static SerializeSingleton getInstance() &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        SerializeSingleton s1 &#x3D; null;</span><br><span class="line">        SerializeSingleton s2 &#x3D; SerializeSingleton.getInstance();</span><br><span class="line"></span><br><span class="line">        FileOutputStream fos &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            fos &#x3D; new FileOutputStream(&quot;SerializeSingleton.obj&quot;);</span><br><span class="line">            ObjectOutputStream oos &#x3D; new ObjectOutputStream(fos);</span><br><span class="line">            oos.writeObject(s2);</span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line"></span><br><span class="line">            FileInputStream fis &#x3D; new FileInputStream(&quot;SerializeSingleton.obj&quot;);</span><br><span class="line">            ObjectInputStream ois &#x3D; new ObjectInputStream(fis);</span><br><span class="line">            s1 &#x3D; (SerializeSingleton)ois.readObject();</span><br><span class="line">            ois.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(s1);</span><br><span class="line">            System.out.println(s2);</span><br><span class="line">            System.out.println(s1 &#x3D;&#x3D; s2);</span><br><span class="line"></span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行main方法结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/21/170668beaa38b178?w=676&h=142&f=png&s=14015" alt=""></p>
<p>运行结果可以看出反序列化后的对象和手动创建的对象不一致，实例化了两次，违背了单例的设计初衷。那么，<strong>如何保证序列化的情况下也能够实现单例呢？</strong> 其实很简单，只需要增加<strong>readResolve()</strong> 方法即可。来看一下优化后的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class SerializeSingleton implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    public static final SerializeSingleton INSTANCE &#x3D; new SerializeSingleton();</span><br><span class="line"></span><br><span class="line">    private SerializeSingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static SerializeSingleton getInstance() &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private Object readResolve() &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/21/170668a01cca79d7?w=670&h=139&f=png&s=13181" alt=""></p>
<p>为什么要这么写呢？我们来一起看下JDK的源码实现吧，进入ObjectInputStream类的readObject()方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public final Object readObject()</span><br><span class="line">        throws IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        if (enableOverride) &#123;</span><br><span class="line">            return readObjectOverride();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; if nested read, passHandle contains handle of enclosing object</span><br><span class="line">        int outerHandle &#x3D; passHandle;</span><br><span class="line">        try &#123;</span><br><span class="line">            Object obj &#x3D; readObject0(false);</span><br><span class="line">            handles.markDependency(outerHandle, passHandle);</span><br><span class="line">            ClassNotFoundException ex &#x3D; handles.lookupException(passHandle);</span><br><span class="line">            if (ex !&#x3D; null) &#123;</span><br><span class="line">                throw ex;</span><br><span class="line">            &#125;</span><br><span class="line">            if (depth &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                vlist.doCallbacks();</span><br><span class="line">            &#125;</span><br><span class="line">            return obj;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            passHandle &#x3D; outerHandle;</span><br><span class="line">            if (closed &amp;&amp; depth &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现在readObject()方法中又调用了我们重写的readObject0()方法。进入readObject0()方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">private Object readObject0(boolean unshared) throws IOException &#123;</span><br><span class="line">        boolean oldMode &#x3D; bin.getBlockDataMode();</span><br><span class="line">        if (oldMode) &#123;</span><br><span class="line">            int remain &#x3D; bin.currentBlockRemaining();</span><br><span class="line">            if (remain &gt; 0) &#123;</span><br><span class="line">                throw new OptionalDataException(remain);</span><br><span class="line">            &#125; else if (defaultDataEnd) &#123;</span><br><span class="line">                &#x2F;*</span><br><span class="line">                 * Fix for 4360508: stream is currently at the end of a field</span><br><span class="line">                 * value block written via default serialization; since there</span><br><span class="line">                 * is no terminating TC_ENDBLOCKDATA tag, simulate</span><br><span class="line">                 * end-of-custom-data behavior explicitly.</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                throw new OptionalDataException(true);</span><br><span class="line">            &#125;</span><br><span class="line">            bin.setBlockDataMode(false);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        byte tc;</span><br><span class="line">        while ((tc &#x3D; bin.peekByte()) &#x3D;&#x3D; TC_RESET) &#123;</span><br><span class="line">            bin.readByte();</span><br><span class="line">            handleReset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        depth++;</span><br><span class="line">        totalObjectRefs++;</span><br><span class="line">        try &#123;</span><br><span class="line">            switch (tc) &#123;</span><br><span class="line">                case TC_NULL:</span><br><span class="line">                    return readNull();</span><br><span class="line"></span><br><span class="line">                case TC_REFERENCE:</span><br><span class="line">                    return readHandle(unshared);</span><br><span class="line"></span><br><span class="line">                case TC_CLASS:</span><br><span class="line">                    return readClass(unshared);</span><br><span class="line"></span><br><span class="line">                case TC_CLASSDESC:</span><br><span class="line">                case TC_PROXYCLASSDESC:</span><br><span class="line">                    return readClassDesc(unshared);</span><br><span class="line"></span><br><span class="line">                case TC_STRING:</span><br><span class="line">                case TC_LONGSTRING:</span><br><span class="line">                    return checkResolve(readString(unshared));</span><br><span class="line"></span><br><span class="line">                case TC_ARRAY:</span><br><span class="line">                    return checkResolve(readArray(unshared));</span><br><span class="line"></span><br><span class="line">                case TC_ENUM:</span><br><span class="line">                    return checkResolve(readEnum(unshared));</span><br><span class="line"></span><br><span class="line">                case TC_OBJECT:</span><br><span class="line">                    return checkResolve(readOrdinaryObject(unshared));</span><br><span class="line"></span><br><span class="line">                case TC_EXCEPTION:</span><br><span class="line">                    IOException ex &#x3D; readFatalException();</span><br><span class="line">                    throw new WriteAbortedException(&quot;writing aborted&quot;, ex);</span><br><span class="line"></span><br><span class="line">                case TC_BLOCKDATA:</span><br><span class="line">                case TC_BLOCKDATALONG:</span><br><span class="line">                    if (oldMode) &#123;</span><br><span class="line">                        bin.setBlockDataMode(true);</span><br><span class="line">                        bin.peek();             &#x2F;&#x2F; force header read</span><br><span class="line">                        throw new OptionalDataException(</span><br><span class="line">                            bin.currentBlockRemaining());</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        throw new StreamCorruptedException(</span><br><span class="line">                            &quot;unexpected block data&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                case TC_ENDBLOCKDATA:</span><br><span class="line">                    if (oldMode) &#123;</span><br><span class="line">                        throw new OptionalDataException(true);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        throw new StreamCorruptedException(</span><br><span class="line">                            &quot;unexpected end of block data&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                default:</span><br><span class="line">                    throw new StreamCorruptedException(</span><br><span class="line">                        String.format(&quot;invalid type code: %02X&quot;, tc));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            depth--;</span><br><span class="line">            bin.setBlockDataMode(oldMode);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在源码中看到了TC_OBJECT中判断，调用了readOrdinaryObject()方法，继续看源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">private Object readOrdinaryObject(boolean unshared)</span><br><span class="line">        throws IOException</span><br><span class="line">    &#123;</span><br><span class="line">        if (bin.readByte() !&#x3D; TC_OBJECT) &#123;</span><br><span class="line">            throw new InternalError();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ObjectStreamClass desc &#x3D; readClassDesc(false);</span><br><span class="line">        desc.checkDeserialize();</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; cl &#x3D; desc.forClass();</span><br><span class="line">        if (cl &#x3D;&#x3D; String.class || cl &#x3D;&#x3D; Class.class</span><br><span class="line">                || cl &#x3D;&#x3D; ObjectStreamClass.class) &#123;</span><br><span class="line">            throw new InvalidClassException(&quot;invalid class descriptor&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object obj;</span><br><span class="line">        try &#123;</span><br><span class="line">            obj &#x3D; desc.isInstantiable() ? desc.newInstance() : null;</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            throw (IOException) new InvalidClassException(</span><br><span class="line">                desc.forClass().getName(),</span><br><span class="line">                &quot;unable to create instance&quot;).initCause(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        passHandle &#x3D; handles.assign(unshared ? unsharedMarker : obj);</span><br><span class="line">        ClassNotFoundException resolveEx &#x3D; desc.getResolveException();</span><br><span class="line">        if (resolveEx !&#x3D; null) &#123;</span><br><span class="line">            handles.markException(passHandle, resolveEx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (desc.isExternalizable()) &#123;</span><br><span class="line">            readExternalData((Externalizable) obj, desc);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            readSerialData(obj, desc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handles.finish(passHandle);</span><br><span class="line"></span><br><span class="line">        if (obj !&#x3D; null &amp;&amp;</span><br><span class="line">            handles.lookupException(passHandle) &#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">            desc.hasReadResolveMethod())</span><br><span class="line">        &#123;</span><br><span class="line">            Object rep &#x3D; desc.invokeReadResolve(obj);</span><br><span class="line">            if (unshared &amp;&amp; rep.getClass().isArray()) &#123;</span><br><span class="line">                rep &#x3D; cloneArray(rep);</span><br><span class="line">            &#125;</span><br><span class="line">            if (rep !&#x3D; obj) &#123;</span><br><span class="line">                &#x2F;&#x2F; Filter the replacement object</span><br><span class="line">                if (rep !&#x3D; null) &#123;</span><br><span class="line">                    if (rep.getClass().isArray()) &#123;</span><br><span class="line">                        filterCheck(rep.getClass(), Array.getLength(rep));</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        filterCheck(rep.getClass(), -1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                handles.setObject(passHandle, obj &#x3D; rep);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现调用了 ObjectStreamClass 的 isInstantiable()方法，而isInstantiable()里面的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">boolean isInstantiable() &#123;</span><br><span class="line">        requireInitialized();</span><br><span class="line">        return (cons !&#x3D; null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码看起来很简单，就是判断了以下构造方法是否为空，构造方法不为空就返回true。这样意味着，只要有无参构造方法就会实例化。</p>
<p>这个时候，其实还是没找到为什么加上readResolve()方法就避免了单例被破坏的真正原因。再回到ObjectInputStream的readOrdinaryObject()方法继续往下看：</p>
<p>判断无参构造方法是否存在之后，又调用了hasReadResolveMethod()方法，来看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">boolean hasReadResolveMethod() &#123;</span><br><span class="line">        requireInitialized();</span><br><span class="line">        return (readResolveMethod !&#x3D; null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑非常简单，就是判断 readResolveMethod 是否为空，不为空就返回 true。那么<br>readResolveMethod 是在哪里赋值的呢？通过全局查找找到了赋值代码在私有方法<br>ObjectStreamClass()方法中给 readResolveMethod 进行赋值，来看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readResolveMethod &#x3D; getInheritableMethod(</span><br><span class="line">                        cl, &quot;readResolve&quot;, null, Object.class);</span><br></pre></td></tr></table></figure>

<p>上面的逻辑其实就是通过反射找到一个无参的 readResolve()方法，并且保存下来。现在再回到 ObjectInputStream 的 readOrdinaryObject() 方法继续往下看，如果readResolve()存在则调用 invokeReadResolve()方法，来看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Object invokeReadResolve(Object obj)</span><br><span class="line">        throws IOException, UnsupportedOperationException</span><br><span class="line">    &#123;</span><br><span class="line">        requireInitialized();</span><br><span class="line">        if (readResolveMethod !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                return readResolveMethod.invoke(obj, (Object[]) null);</span><br><span class="line">            &#125; catch (InvocationTargetException ex) &#123;</span><br><span class="line">                Throwable th &#x3D; ex.getTargetException();</span><br><span class="line">                if (th instanceof ObjectStreamException) &#123;</span><br><span class="line">                    throw (ObjectStreamException) th;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throwMiscException(th);</span><br><span class="line">                    throw new InternalError(th);  &#x2F;&#x2F; never reached</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IllegalAccessException ex) &#123;</span><br><span class="line">                &#x2F;&#x2F; should not occur, as access checks have been suppressed</span><br><span class="line">                throw new InternalError(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在invokeReadResolve()方法中用反射调用了readResolveMethod方法。<br>通过 JDK 源码分析我们可以看出，虽然，增加readResolve()方法返回实例，解决了单例被破坏的问题。但是，我们通过分析源码以及调试，我们可以看到实际上实例化了两次，只不过新创建的对象没有被返回而已。那如果，创建对象的动作发生频率增大，就意味着内存分配开销也就随之增大，难道真的就没办法从根本上解决问题吗？下面我们来注册式单例也许能帮助到你。</p>
<h2 id="2-3-注册式单例"><a href="#2-3-注册式单例" class="headerlink" title="2.3 注册式单例"></a>2.3 注册式单例</h2><p>注册式单例又称登记式单例，就是将每一个实例都登记到一个地方，使用唯一标识获取实例。注册的方式有两种：一种为容器缓存，一种为枚举登记。先来看下枚举式单例的写法，创建EnumSingleton类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public enum EnumSingleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    private Object data;</span><br><span class="line"></span><br><span class="line">    public Object getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        this.data &#x3D; data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static EnumSingleton getInstance() &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试main方法；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            EnumSingleton instance1 &#x3D; null;</span><br><span class="line">            EnumSingleton instance2 &#x3D; EnumSingleton.getInstance();</span><br><span class="line">            instance2.setData(new Object());</span><br><span class="line">            FileOutputStream fos &#x3D; new FileOutputStream(&quot;EnumSingleton.obj&quot;);</span><br><span class="line">            ObjectOutputStream oos &#x3D; new ObjectOutputStream(fos);</span><br><span class="line">            oos.writeObject(instance2);</span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line">            FileInputStream fis &#x3D; new FileInputStream(&quot;EnumSingleton.obj&quot;);</span><br><span class="line">            ObjectInputStream ois &#x3D; new ObjectInputStream(fis);</span><br><span class="line">            instance1 &#x3D; (EnumSingleton) ois.readObject();</span><br><span class="line">            ois.close();</span><br><span class="line">            System.out.println(instance1.getData());</span><br><span class="line">            System.out.println(instance2.getData());</span><br><span class="line">            System.out.println(instance1.getData() &#x3D;&#x3D; instance2.getData());</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果是：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/20/17062cae761681fd?w=358&h=160&f=png&s=8735" alt=""></p>
<p>没有做任何的处理，我们发现运行的结果和我们预期的一样。那么枚举式单例如此神奇，它的神秘之处体现在哪呢？下面我们就通过分析源码来揭开它的神秘面纱。<br>我们使用jad反编译工具（<a href="https://varaneckas.com/jad/）" target="_blank" rel="noopener">https://varaneckas.com/jad/）</a>      生成的EnumSingleton.jad文件，打开这个文件发现这一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static</span><br><span class="line">&#123;</span><br><span class="line">    INSTANCE &#x3D; new EnumSingleton(&quot;INSTANCE&quot;, 0);</span><br><span class="line">    $VALUES &#x3D; (new EnumSingleton[] &#123;</span><br><span class="line">    INSTANCE</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现<strong>枚举单例在静态模块中就给INSTANCE进行了赋值，是饿汉式单例的实现。</strong> 我们回想序列化能否破坏枚举式单例呢？再回到之前的源码ObjectInputStream的readObject0()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private Object readObject0(boolean unshared) throws IOException &#123;</span><br><span class="line">...</span><br><span class="line">    case TC_ENUM:</span><br><span class="line">        return checkResolve(readEnum(unshared));</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们看到在 readObject0()中调用了 readEnum()方法，来看readEnum()中代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private Enum&lt;?&gt; readEnum(boolean unshared) throws IOException &#123;</span><br><span class="line">        if (bin.readByte() !&#x3D; TC_ENUM) &#123;</span><br><span class="line">            throw new InternalError();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ObjectStreamClass desc &#x3D; readClassDesc(false);</span><br><span class="line">        if (!desc.isEnum()) &#123;</span><br><span class="line">            throw new InvalidClassException(&quot;non-enum class: &quot; + desc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int enumHandle &#x3D; handles.assign(unshared ? unsharedMarker : null);</span><br><span class="line">        ClassNotFoundException resolveEx &#x3D; desc.getResolveException();</span><br><span class="line">        if (resolveEx !&#x3D; null) &#123;</span><br><span class="line">            handles.markException(enumHandle, resolveEx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String name &#x3D; readString(false);</span><br><span class="line">        Enum&lt;?&gt; result &#x3D; null;</span><br><span class="line">        Class&lt;?&gt; cl &#x3D; desc.forClass();</span><br><span class="line">        if (cl !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                Enum&lt;?&gt; en &#x3D; Enum.valueOf((Class)cl, name);</span><br><span class="line">                result &#x3D; en;</span><br><span class="line">            &#125; catch (IllegalArgumentException ex) &#123;</span><br><span class="line">                throw (IOException) new InvalidObjectException(</span><br><span class="line">                    &quot;enum constant &quot; + name + &quot; does not exist in &quot; +</span><br><span class="line">                    cl).initCause(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!unshared) &#123;</span><br><span class="line">                handles.setObject(enumHandle, result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handles.finish(enumHandle);</span><br><span class="line">        passHandle &#x3D; enumHandle;</span><br><span class="line">        return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>发现枚举类型其实是通过类名和class对象找到一个唯一的枚举对象。</strong> 因此，枚举对象不可能被加载器加载多次。那么反射能破坏枚举式单例吗？来看一下测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class clazz &#x3D; EnumSingleton.class;</span><br><span class="line">            Constructor c &#x3D; clazz.getDeclaredConstructor();</span><br><span class="line">            c.newInstance();</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/21/17065f63d5f340c8?w=1027&h=181&f=png&s=32397" alt=""></p>
<p>报的是 java.lang.NoSuchMethodException 异常，意思是没找到无参的构造方法。我们打开 java.lang.Enum 的源码代码，查看它的构造方法，只有一个 protected的构造方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected Enum(String name, int ordinal) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.ordinal &#x3D; ordinal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那我们再做这样一个测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class clazz &#x3D; EnumSingleton.class;</span><br><span class="line">            Constructor c &#x3D; clazz.getDeclaredConstructor(String.class, int.class);</span><br><span class="line">            c.setAccessible(true);</span><br><span class="line">            EnumSingleton enumSingleton &#x3D; (EnumSingleton)c.newInstance(&quot;Kevin&quot;, 123);</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果是：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/21/17066033cb7d990b?w=1615&h=94&f=png&s=19094" alt=""></p>
<p>这时错误已经非常明显了，告诉我们 Cannot reflectively create enum objects，<strong>不能用反射来创建枚举类型</strong>。还是看下JDK源码，看下Constructor类的newInstance()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public T newInstance(Object ... initargs)</span><br><span class="line">        throws InstantiationException, IllegalAccessException,</span><br><span class="line">               IllegalArgumentException, InvocationTargetException</span><br><span class="line">    &#123;</span><br><span class="line">        if (!override) &#123;</span><br><span class="line">            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">                Class&lt;?&gt; caller &#x3D; Reflection.getCallerClass();</span><br><span class="line">                checkAccess(caller, clazz, null, modifiers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((clazz.getModifiers() &amp; Modifier.ENUM) !&#x3D; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;);</span><br><span class="line">        ConstructorAccessor ca &#x3D; constructorAccessor;   &#x2F;&#x2F; read volatile</span><br><span class="line">        if (ca &#x3D;&#x3D; null) &#123;</span><br><span class="line">            ca &#x3D; acquireConstructorAccessor();</span><br><span class="line">        &#125;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        T inst &#x3D; (T) ca.newInstance(initargs);</span><br><span class="line">        return inst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在newInstance()方法中做了强制性的判断，如果修饰符Modifier.ENUM枚举类型，直接抛出异常。到此为止，我们应该非常清晰明了了。</p>
<p>枚举类型单例也是《Effective Java》书中非常推荐的一种单例的实现写法。在 JDK 枚举的语法特殊性，以及反射也为枚举保驾护航，让枚举式单例成为一种比较优雅的实现。</p>
<p>注册式单例还有另外一种写法，容器缓存的写法，创建ContainerSingleton类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ContainerSingleton &#123;</span><br><span class="line"></span><br><span class="line">    private ContainerSingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static Map&lt;String, Object&gt; ioc &#x3D; new ConcurrentHashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    public static Object getBean(String className) &#123;</span><br><span class="line">        synchronized (ioc) &#123;</span><br><span class="line">            if(!ioc.containsKey(className)) &#123;</span><br><span class="line">                Object object &#x3D; null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    object &#x3D; Class.forName(className).newInstance();</span><br><span class="line">                    ioc.put(className, object);</span><br><span class="line">                &#125; catch (InstantiationException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                return object;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                return ioc.get(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>容器式写法适用于创建实例非常多的情况，便于管理。但是，是非线程安全的。到此，注册式单例介绍完毕。</p>
<p>来看看 <strong>Spring 中的容器式单例</strong> 的实现代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory implements AutowireCapableBeanFactory &#123;</span><br><span class="line">    &#x2F;** Cache of unfinished FactoryBean instances: FactoryBean name --&gt; BeanWrapper *&#x2F;</span><br><span class="line">    private final Map&lt;String, BeanWrapper&gt; factoryBeanInstanceCache &#x3D; new ConcurrentHashMap&lt;&gt;(16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-ThreadLocal-线程单例"><a href="#2-4-ThreadLocal-线程单例" class="headerlink" title="2.4 ThreadLocal 线程单例"></a>2.4 ThreadLocal 线程单例</h2><p><strong>ThreadLocal不能保证其创建的对象是全局唯一的，但是能保证在单个线程中是唯一的，天生的线程安全。</strong> 下面来看下示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocalSingleton &#123;</span><br><span class="line"></span><br><span class="line">    private static final ThreadLocal&lt;ThreadLocalSingleton&gt; instance &#x3D; new</span><br><span class="line">            ThreadLocal&lt;ThreadLocalSingleton&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                protected ThreadLocalSingleton initialValue() &#123;</span><br><span class="line">                    return new ThreadLocalSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">    private ThreadLocalSingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static ThreadLocalSingleton getInstance() &#123;</span><br><span class="line">        return instance.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写一下测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;begin&quot;);</span><br><span class="line">        System.out.println(ThreadLocalSingleton.getInstance());</span><br><span class="line">        System.out.println(ThreadLocalSingleton.getInstance());</span><br><span class="line">        System.out.println(ThreadLocalSingleton.getInstance());</span><br><span class="line">        System.out.println(ThreadLocalSingleton.getInstance());</span><br><span class="line">        System.out.println(ThreadLocalSingleton.getInstance());</span><br><span class="line"></span><br><span class="line">        Thread t1 &#x3D; new Thread(new ExectorThread());</span><br><span class="line">        Thread t2 &#x3D; new Thread(new ExectorThread());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/21/170668670edc458f?w=700&h=409&f=png&s=53862" alt=""></p>
<p>在主线程 main 中无论调用多少次，获取到的实例都是同一个，都在两个子线程中分别获取到了不同的实例。那么ThreadLocal是如果实现这样的效果的呢？我们知道上面的<strong>单例模式为了达到线程安全的目的，给方法上锁，以时间换空间。</strong> ThreadLocal将所有的对象全部放在ThreadLocalMap中，为每个线程都提供一个对象，实际上是以空间换时间来实现线程间隔离的。</p>
<h1 id="三、单例模式总结"><a href="#三、单例模式总结" class="headerlink" title="三、单例模式总结"></a>三、单例模式总结</h1><p>单例模式可以保证内存里只有一个实例，减少了内存开销；可以避免对资源的多重占用。单例模式看起来非常简单，实现起来其实也非常简单。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/02/21/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E7%BB%8F%E5%85%B8%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="ck7lialw6000g6xra6mjh1ukv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，经典框架都在用的工厂模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/21/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E7%BB%8F%E5%85%B8%E6%A1%86%E6%9E%B6%E9%83%BD%E5%9C%A8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-02-21T07:55:01.000Z" itemprop="datePublished">2020-02-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/21/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E7%BB%8F%E5%85%B8%E6%A1%86%E6%9E%B6%E9%83%BD%E5%9C%A8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，经典框架都在用的工厂模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、经典框架都在用设计模式解决问题"><a href="#一、经典框架都在用设计模式解决问题" class="headerlink" title="一、经典框架都在用设计模式解决问题"></a>一、经典框架都在用设计模式解决问题</h1><p>Spring就是一个把设计模式用的淋漓尽致的经典框架，其实从类的名称就能够看出来，我们来一一列举一下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/19/1705c4fe88d41ff7?w=946&h=476&f=png&s=21565" alt=""></p>
<p><strong>特别需要说明的是，设计模式从来都不是单个设计模式独立使用的。</strong> 在通常情况下，经常是多个设计模式混合使用，<strong>你中有我，我中有你</strong>。所有的设计模式讲解都会围绕Spring的IOC、AOP、JDBC、MVC来进行展开。设计模式根据设计类型进行分类如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/19/1705c5a0b678e0f8?w=721&h=433&f=png&s=47142" alt=""></p>
<h1 id="二、工厂模式详解"><a href="#二、工厂模式详解" class="headerlink" title="二、工厂模式详解"></a>二、工厂模式详解</h1><h2 id="2-1-工厂模式的由来"><a href="#2-1-工厂模式的由来" class="headerlink" title="2.1 工厂模式的由来"></a>2.1 工厂模式的由来</h2><p>在我们的现实生活当中，原始社会自给自足（没有工厂）、农耕社会的小作坊（简单工厂，民间酒坊）、工业革命流水线（工厂方法，自产自销）、现代产业链工厂（抽象工厂，富士康）</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/19/1705c649df25e7dd?w=1000&h=562&f=png&s=915663" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/2/19/1705c65b429988c0?w=900&h=600&f=png&s=699085" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/2/19/1705c66e7a3c0afb?w=475&h=261&f=png&s=155298" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/2/19/1705c6777f3ecf54?w=640&h=345&f=png&s=503072" alt=""></p>
<p>从现实生活联想到我们项目中的代码同样也是由简而繁一步一步迭代而来的，但是对于调用者确是越来越简单化。</p>
<h2 id="2-2-简单工厂模式（Simple-Factory-Pattern）"><a href="#2-2-简单工厂模式（Simple-Factory-Pattern）" class="headerlink" title="2.2 简单工厂模式（Simple Factory Pattern）"></a>2.2 简单工厂模式（Simple Factory Pattern）</h2><p>简单工厂模式是指由一个工厂对象决定创建出哪一种产品的实例，但它不属于GOF，23设计模式。</p>
<p>参考资料维基百科地址：<a href="https://en.wikipedia.org/wiki/Design_Patterns#Patterns_by_Type" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Design_Patterns#Patterns_by_Type</a></p>
<p>简单工厂模式适用于工厂类负责创建的对象较少的场景，且客户端只需要传入工厂类的参数，对于如何创建对象的逻辑不需要关系。</p>
<p>接下来我们来举例，以高中学校课程为例。语文、数学、英语等多门学科。我们可以定义一个课程标准ICourse接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface ICourse &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 学习课程</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void study();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个语文课的实现ChineseCourse类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ChineseCourse implements ICourse &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void study() &#123;</span><br><span class="line">        System.out.println(&quot;学习语文课&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ICourse course &#x3D; new ChineseCourse();</span><br><span class="line">        course.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看上面的main方法中，应用层的代码需要依赖ChineseCourse，如果业务扩展，会继续增加MathCourse甚至更多，这样的话客户端的依赖会越来越臃肿的。所以我们需要对创建代码的细节进行隐藏，我们使用简单工厂模式对代码进行优化。先添加MathCourse类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MathCourse implements ICourse &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void study() &#123;</span><br><span class="line">        System.out.println(&quot;学习数学课&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建CourseFactory工厂类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class CourseFactory &#123;</span><br><span class="line">    public ICourse create(String name) &#123;</span><br><span class="line">        if(&quot;chinese&quot;.equals(name)) &#123;</span><br><span class="line">            return new ChineseCourse();</span><br><span class="line">        &#125;else if(&quot;math&quot;.equals(name)) &#123;</span><br><span class="line">            return new MathCourse();</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mian方法调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">        CourseFactory courseFactory &#x3D; new CourseFactory();</span><br><span class="line">        courseFactory.create(&quot;chinese&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用是简单了，但是我们的业务继续扩展，需要增加英文课，那么工厂中的create()方法要根据增加的业务每次都修改代码逻辑，不符合开闭原则。因此，我们还需要对简单工厂进行优化，利用反射技术：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class CourseFactory &#123;</span><br><span class="line"></span><br><span class="line">    public ICourse create(String className) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if(!(null &#x3D;&#x3D; className || &quot;&quot;.equals(className))) &#123;</span><br><span class="line">                    return (ICourse) Class.forName(className).newInstance();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InstantiationException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CourseFactory courseFactory &#x3D; new CourseFactory();</span><br><span class="line">        ICourse course &#x3D; courseFactory.create(&quot;com.sfp.ChineseCourse&quot;);</span><br><span class="line">        course.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化之后，课程不断增加不需要修改CourseFactory中的代码了。但是，方法参数是字符串，可控性有待提高，而且还需进行强制转换。再次修改代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class CourseFactory &#123;</span><br><span class="line"></span><br><span class="line">    public ICourse create(Class&lt;? extends ICourse&gt; clazz) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if(null !&#x3D; clazz) &#123;</span><br><span class="line">                return clazz.newInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CourseFactory courseFactory &#x3D; new CourseFactory();</span><br><span class="line">        ICourse course &#x3D; courseFactory.create(ChineseCourse.class);</span><br><span class="line">        course.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单工厂模式的例子无处不在，现在我们来看JDK当中的类使用简单工厂模式的例子，例如Calendar类，其中Calendar.getInstance()方法，我们查看源码具体的实现步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">private static Calendar createCalendar(TimeZone zone,</span><br><span class="line">                                           Locale aLocale)</span><br><span class="line">    &#123;</span><br><span class="line">        CalendarProvider provider &#x3D;</span><br><span class="line">            LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)</span><br><span class="line">                                 .getCalendarProvider();</span><br><span class="line">        if (provider !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                return provider.getInstance(zone, aLocale);</span><br><span class="line">            &#125; catch (IllegalArgumentException iae) &#123;</span><br><span class="line">                &#x2F;&#x2F; fall back to the default instantiation</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Calendar cal &#x3D; null;</span><br><span class="line"></span><br><span class="line">        if (aLocale.hasExtensions()) &#123;</span><br><span class="line">            String caltype &#x3D; aLocale.getUnicodeLocaleType(&quot;ca&quot;);</span><br><span class="line">            if (caltype !&#x3D; null) &#123;</span><br><span class="line">                switch (caltype) &#123;</span><br><span class="line">                case &quot;buddhist&quot;:</span><br><span class="line">                cal &#x3D; new BuddhistCalendar(zone, aLocale);</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;japanese&quot;:</span><br><span class="line">                    cal &#x3D; new JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;gregory&quot;:</span><br><span class="line">                    cal &#x3D; new GregorianCalendar(zone, aLocale);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (cal &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; If no known calendar type is explicitly specified,</span><br><span class="line">            &#x2F;&#x2F; perform the traditional way to create a Calendar:</span><br><span class="line">            &#x2F;&#x2F; create a BuddhistCalendar for th_TH locale,</span><br><span class="line">            &#x2F;&#x2F; a JapaneseImperialCalendar for ja_JP_JP locale, or</span><br><span class="line">            &#x2F;&#x2F; a GregorianCalendar for any other locales.</span><br><span class="line">            &#x2F;&#x2F; NOTE: The language, country and variant strings are interned.</span><br><span class="line">            if (aLocale.getLanguage() &#x3D;&#x3D; &quot;th&quot; &amp;&amp; aLocale.getCountry() &#x3D;&#x3D; &quot;TH&quot;) &#123;</span><br><span class="line">                cal &#x3D; new BuddhistCalendar(zone, aLocale);</span><br><span class="line">            &#125; else if (aLocale.getVariant() &#x3D;&#x3D; &quot;JP&quot; &amp;&amp; aLocale.getLanguage() &#x3D;&#x3D; &quot;ja&quot;</span><br><span class="line">                       &amp;&amp; aLocale.getCountry() &#x3D;&#x3D; &quot;JP&quot;) &#123;</span><br><span class="line">                cal &#x3D; new JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cal &#x3D; new GregorianCalendar(zone, aLocale);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cal;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>还有一个大家经常使用的logback，我们可以看到LoggerFactory中有多个重载的方法getLogger():</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Logger getLogger(String name) &#123;</span><br><span class="line">    ILoggerFactory iLoggerFactory &#x3D; getILoggerFactory();</span><br><span class="line">    return iLoggerFactory.getLogger(name);</span><br><span class="line">&#125;</span><br><span class="line">public static Logger getLogger(Class clazz) &#123;</span><br><span class="line">    return getLogger(clazz.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单工厂的缺点：工厂的职责相对过重，不易于扩展过于复杂的代码结构。</p>
<h2 id="2-3-工厂方法模式（Factory-Method-Pattern）"><a href="#2-3-工厂方法模式（Factory-Method-Pattern）" class="headerlink" title="2.3 工厂方法模式（Factory Method Pattern）"></a>2.3 工厂方法模式（Factory Method Pattern）</h2><p>工厂方法模式是指<strong>定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。</strong> 在工厂方法模式中只关心所需产品对应的工厂，无心关注创建细节，而加入新的产品符合开闭原则。</p>
<p>工厂方式模式主要解决产品扩展的问题，根据单一职责原则将职能进行拆分，专人干专事。语文课由语文工厂创建，数据课由数学工厂创建，对工厂本身做一个抽象。示例代码如下：</p>
<p>创建ICourseFactory接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface ICourseFacotry &#123;</span><br><span class="line"></span><br><span class="line">    ICourse create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再分别创建子工厂，ChineseCourseFactory类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ChineseCourseFactory implements ICourseFacotry &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ICourse create() &#123;</span><br><span class="line">        return new ChineseCourse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MathCourseFactory类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MathCourseFactory implements ICourseFacotry &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ICourse create() &#123;</span><br><span class="line">        return new MathCourse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">     ICourseFacotry chineseCourseFactory &#x3D; new ChineseCourseFactory();</span><br><span class="line">     ICourse chineseCourse &#x3D; chineseCourseFactory.create();</span><br><span class="line">     chineseCourse.study();</span><br><span class="line">     </span><br><span class="line">     ICourseFacotry mathCourseFactory &#x3D; new MathCourseFactory();</span><br><span class="line">     ICourse mathCourse &#x3D; mathCourseFactory.create();</span><br><span class="line">     mathCourse.study();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-抽象工厂模式（Abstract-Factory-Pattern）"><a href="#2-4-抽象工厂模式（Abstract-Factory-Pattern）" class="headerlink" title="2.4 抽象工厂模式（Abstract Factory Pattern）"></a>2.4 抽象工厂模式（Abstract Factory Pattern）</h2><p>抽象工厂模式是指<strong>提供一个创建一系列相关或相互依赖对象的接口，无需指定它们具体的类。</strong> 客户端（应用层）不依赖于产品实例如何被创建、实现等细节，强调的是一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复的代码。需要提供一个产品库的类，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</p>
<p>我们还是以课程的例子为例，现在是新冠状病毒疫情的时期，高中学生只能在家利用互联网进行在线直播上课，每个课程不仅要提供课程的录播视频，而且还要提供老师的课堂笔记。相当于现在的业务变更为同一个课程不单纯是课程信息，同时要包括录播视频、课堂笔记等才是一个完整的课程。在产品等级中增加两个产品接口Ivideo录播视频和INote课堂笔记。</p>
<p>Ivideo接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IVideo &#123;</span><br><span class="line"></span><br><span class="line">    void record();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>INote接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface INote &#123;</span><br><span class="line"></span><br><span class="line">    void edit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建抽象工厂类CourseFactory类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface CourseFactory &#123;</span><br><span class="line"></span><br><span class="line">    IVideo createVideo();</span><br><span class="line"></span><br><span class="line">    INote createNote();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建语文课产品族，语文课视频的ChineseVideo类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ChineseVideo implements IVideo &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void record() &#123;</span><br><span class="line">        System.out.println(&quot;录制语文课视频！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建语文课课堂笔记的ChineseNote类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ChineseNote implements INote &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void edit() &#123;</span><br><span class="line">        System.out.println(&quot;编写语文课笔记！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建语文课产品族的具体工厂类ChineseCourseFactory：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ChineseCourseFactory implements CourseFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public IVideo createVideo() &#123;</span><br><span class="line">        return new ChineseVideo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public INote createNote() &#123;</span><br><span class="line">        return new ChineseNote();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再创建数学产品，Math视频MathVideo类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MathVideo implements IVideo &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void record() &#123;</span><br><span class="line">        System.out.println(&quot;录制数学课视频！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建数学课堂笔记的MathNote类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MathNote implements INote &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void edit() &#123;</span><br><span class="line">        System.out.println(&quot;编写数学课笔记！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建数学课产品族的具体工厂类MathCourseFactory：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class MathCourseFactory implements CourseFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public IVideo createVideo() &#123;</span><br><span class="line">        return new MathVideo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public INote createNote() &#123;</span><br><span class="line">        return new MathNote();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MathCourseFactory mathCourseFactory &#x3D; new MathCourseFactory();</span><br><span class="line">        mathCourseFactory.createNote().edit();</span><br><span class="line">        mathCourseFactory.createVideo().record();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的案例代码完整的描述了两个产品族语文课程和数学课程，也描述了两个产品等级的视频和课堂笔记。抽象工厂非常完美清晰地描述了这一层复杂的关系。如果我们再升级扩展产品等级，将课堂作业也加入到课程中，我们的代码需要从抽象工厂，到具体的工厂都要进行调整，很显然不符合开闭原则。所以抽象工厂也是有缺点的：</p>
<p>1、规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口。</p>
<p>2、增加了系统的抽象性和理解难度。</p>
<h1 id="三、工厂模式总结"><a href="#三、工厂模式总结" class="headerlink" title="三、工厂模式总结"></a>三、工厂模式总结</h1><p><img src="https://user-gold-cdn.xitu.io/2020/2/20/17061184a4c31ec2?w=1465&h=535&f=png&s=108016" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/02/21/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E7%BB%8F%E5%85%B8%E6%A1%86%E6%9E%B6%E9%83%BD%E5%9C%A8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="ck7lialvb000c6xra3uk5gpph" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，软件架构设计的七大原则精选案例" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/19/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%E7%B2%BE%E9%80%89%E6%A1%88%E4%BE%8B/" class="article-date">
  <time datetime="2020-02-19T06:43:44.000Z" itemprop="datePublished">2020-02-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/19/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%E7%B2%BE%E9%80%89%E6%A1%88%E4%BE%8B/">架构师内功心法，软件架构设计的七大原则精选案例</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、软件架构设计的七大原则简介"><a href="#一、软件架构设计的七大原则简介" class="headerlink" title="一、软件架构设计的七大原则简介"></a>一、软件架构设计的七大原则简介</h1><p><img src="https://user-gold-cdn.xitu.io/2020/2/17/17052b314ab91c9f?w=1018&h=812&f=png&s=43050" alt=""></p>
<h2 id="1-1-开闭原则（Open-Closed-Principle，OCP）"><a href="#1-1-开闭原则（Open-Closed-Principle，OCP）" class="headerlink" title="1.1 开闭原则（Open-Closed Principle，OCP）"></a>1.1 开闭原则（Open-Closed Principle，OCP）</h2><p>开闭原则是一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。所谓的开闭也是对扩展和修改两个行为的一个原则。强调是用抽象扩展架构，用实现扩展细节。可以提高软件系统的可复用性及可维护性。开闭原则，是面向对象设计中最基础的设计原则。它指导我们如何建立稳定灵活的系统，例如：<strong>版本更新，我们尽可能不修改代码，但是可以增加新功能。</strong></p>
<p>在现实生活中也有很多开闭原则的例子，比如，很多互联网公司都实行弹性的工作时间，规定每天工作8小时。意思就是说，对于工作日每天工作8小时这个规定是关闭的，但是你什么时候来，什么时候走是开放的。早来早走，晚来晚走。</p>
<p>实现开闭原则的核心思想就是面向抽象编程，以某新华书店的图书为例，首先创建一个课程接口类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class IBook &#123;</span><br><span class="line">    Integer getId();</span><br><span class="line">    String getName();</span><br><span class="line">    Double getPrice();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来创建一个计算机图书的类ComputerBook：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class ComputerBook implements IBook &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    protected Double price;</span><br><span class="line">    public ComputerBook(Integer id, String name, Double price) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.price &#x3D; price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return this.id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Double getPrice() &#123;</span><br><span class="line">        return this.price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们要给计算机类的图书做活动，价格优惠。如果修改ComputerBook类的getPrice()方法，则会存在一定的风险，可能会影响其它地方的调用结果。我们如何在不修改原有代码的前提下，实现价格优惠这个功能呢？现在，我们再写一个处理优惠逻辑的类，ComputerDiscountBook类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ComputerDiscountBook extends ComputerBook &#123;</span><br><span class="line">    public ComputerDiscountBook(Integer id, String name, Double price) &#123;</span><br><span class="line">        super(id, name, price);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Double getOriginPrice() &#123;</span><br><span class="line">        return super.price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Double getPrice() &#123;</span><br><span class="line">        return super.price * 0.8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/2/17/170533730e78204e?w=667&h=742&f=png&s=45090" alt=""></p>
<h2 id="1-2-依赖倒置原则（Dependence-Inversion-Principle，DIP）"><a href="#1-2-依赖倒置原则（Dependence-Inversion-Principle，DIP）" class="headerlink" title="1.2 依赖倒置原则（Dependence Inversion Principle，DIP）"></a>1.2 依赖倒置原则（Dependence Inversion Principle，DIP）</h2><p>依赖倒置原则是指设计代码结构时，高层模块不应该依赖底层模块，二者都应该依赖其抽象。抽象不应该依赖细节；细节应该依赖抽象。通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，并能够降低修改程序所造成的风险。</p>
<p>还是以课程为例，创建一个类Kevin：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Kevin &#123;</span><br><span class="line"></span><br><span class="line">    public void readComputerBook() &#123;</span><br><span class="line">        System.out.println(&quot;Kevin正在阅读电脑书籍&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void readScienceBook() &#123;</span><br><span class="line">        System.out.println(&quot;Kevin正在阅读科学书籍&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Kevin kevin &#x3D; new Kevin();</span><br><span class="line">        kevin.readComputerBook();</span><br><span class="line">        kevin.readScienceBook();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kevin正在阅读电脑书籍和科学书籍。大家知道电脑书籍的种类很多，现在人工智能AI这么火热，Kevin想学习关于人工智能方面的电脑书籍。这个时候，业务需要扩展，我们需要从底层到调用层一次修改代码来满足业务要求。在Kevin中增加readAIBook（）的方法，在调用层也要追加调用。这样一来，系统发布的时候，实际上不是很稳定。如何优化我们的代码，创建一个书籍的抽象IBook接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IBook &#123;</span><br><span class="line"></span><br><span class="line">    void read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后写ComputerBook类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ComputerBook implements IBook &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void read() &#123;</span><br><span class="line">        System.out.println(&quot;Kevin正在阅读电脑书籍&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再写ScienceBook类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ScienceBook implements IBook &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void read() &#123;</span><br><span class="line">        System.out.printf(&quot;Kevin正在阅读科学书籍&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改Kevin类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Kevin &#123;</span><br><span class="line"></span><br><span class="line">    public void read(IBook book) &#123;</span><br><span class="line">        book.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Kevin kevin &#x3D; new Kevin();</span><br><span class="line">        kevin.read(new ComputerBook());</span><br><span class="line">        kevin.read(new ScienceBook());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看main方法调用，无论Kevin想读哪些类的新书，只需要创建一个类，通过传参的方式告诉Kevin，而不需要修改底层代码来实现。这种实现方式叫做依赖注入。注入的方式有构造器注入和setter注入两种方式。</p>
<p>构造器注入实现方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Kevin &#123;</span><br><span class="line"></span><br><span class="line">    public IBook book;</span><br><span class="line"></span><br><span class="line">    public Kevin(IBook book) &#123;</span><br><span class="line">        this.book &#x3D; book;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void read() &#123;</span><br><span class="line">        book.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Kevin kevin &#x3D; new Kevin(new ComputerBook());</span><br><span class="line">        kevin.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据构造器注入，在调用时，每次都需要创建实例。如果Kevin是全局单例的话，则只能选择Setter方式来注入，继续修改Kevin类的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Kevin &#123;</span><br><span class="line"></span><br><span class="line">    public IBook book;</span><br><span class="line"></span><br><span class="line">    public void setBook(IBook book) &#123;</span><br><span class="line">        this.book &#x3D; book;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void read() &#123;</span><br><span class="line">        book.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Kevin kevin &#x3D; new Kevin();</span><br><span class="line">        kevin.setBook(new ComputerBook());</span><br><span class="line">        kevin.read();</span><br><span class="line"></span><br><span class="line">        kevin.setBook(new ScienceBook());</span><br><span class="line">        kevin.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>以抽象为基准比以细节为基准搭建起来的代码架构要稳定得多，因此拿到需求任务后，要面向接口编程，先设计顶层再琢磨细节来设计代码结构。</strong></p>
<h2 id="1-3-单一职责原则（Simple-Responsibility-Principle，SRP）"><a href="#1-3-单一职责原则（Simple-Responsibility-Principle，SRP）" class="headerlink" title="1.3 单一职责原则（Simple Responsibility Principle，SRP）"></a>1.3 单一职责原则（Simple Responsibility Principle，SRP）</h2><p>单一职责原则是值不要存在多于一个导致类变更的原因。假设我们有一个类要负责两个职责，一旦发生需求变更，修改其中一个职责的逻辑代码，有可能会导致另一个职责的功能发生故障。这样一来，这个类存在两个导致类变更的原因。怎么来解决这个问题呢？就需要给两个职责分别用两个类来实现，进行解耦。后期需求维护相互不受影响。这样的设计，可以降低类的复杂度，提高类的可读性，提高系统的可维护性，降低变更引起的风险。总体来说就是一个<strong>class/interface/mothod</strong>只负责一项职责。<br>这里用在线直播课程的案例来举例，课程有在线直播课和录播课。直播课不能快进和后退，录播课程可以任意的反复观看，功能职责不一样。创建一个Course类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Course &#123;</span><br><span class="line"></span><br><span class="line">    public static final String COURSE_NAME &#x3D; &quot;直播课&quot;;</span><br><span class="line"></span><br><span class="line">    public void study(String courseName) &#123;</span><br><span class="line">        if(COURSE_NAME.equals(courseName)) &#123;</span><br><span class="line">            System.out.println(courseName + &quot;不能快进和快退&quot;);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            System.out.println(courseName + &quot;可以反复观看&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Course course &#x3D; new Course();</span><br><span class="line">        course.study(&quot;直播课&quot;);</span><br><span class="line">        course.study(&quot;录播课&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码看，Course类承担了两种逻辑。现在需要对课程进行加密，那么直播课和录播课的加密逻辑是不一样的，必须要修改代码。而修改代码逻辑必然会相互影响并且容易造成风险。我们对职责进行解耦，分别创建LiveCourse和ReplayCourse两个类：</p>
<p>LiveCourse类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class LiveCourse &#123;</span><br><span class="line"></span><br><span class="line">    public void study(String courseName) &#123;</span><br><span class="line">        System.out.println(courseName + &quot;不能快进和快退&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReplayCourse类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ReplayCourse &#123;</span><br><span class="line"></span><br><span class="line">    public void study(String courseName) &#123;</span><br><span class="line">        System.out.println(courseName + &quot;可以反复观看&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">     LiveCourse liveCourse &#x3D; new LiveCourse();</span><br><span class="line">     liveCourse.study(&quot;直播课&quot;);</span><br><span class="line">     ReplayCourse replayCourse &#x3D; new ReplayCourse();</span><br><span class="line">     replayCourse.study(&quot;录播课&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随着业务的发展，课程也要做权限。没有付费的vip会员可以获取课程基本信息，已经付费的vip会员可以获得视频流，即获得视频观看权限。对于控制课程层面上至少有两个职责。我们可以把展示职责和管理职责分离出来，实现同一个抽象依赖。设计一个顶层接口，创建ICourse接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public interface ICourse &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获得课程信息</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    String getCourseName();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获得视频流</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    byte[] getCourseVideo();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 学习课程</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void studyCourse();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 退款</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void refundCourse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以把这个接口拆成两个接口，创建一个接口ICourseInfo和ICourseManager：</p>
<p>接口ICourseInfo：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface ICourseInfo &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获得课程信息</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    String getCourseName();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获得视频流</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    byte[] getCourseVideo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口ICourseManager：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface ICourseManager &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 学习课程</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void studyCourse();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 退款</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void refundCourse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来看下方法层面的单一职责的代码设计。有时候我们为了偷懒，通常会把方法写成下面这样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void mofifyUserInfo(String userName, String address) &#123;</span><br><span class="line">    userName &#x3D; &quot;Kevin&quot;;</span><br><span class="line">    address &#x3D; &quot;Beijing&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可能写成这样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void modifyUserInfo(String userName, String... fields) &#123;</span><br><span class="line">    userName &#x3D; &quot;Kevin&quot;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void modifyUserInfo(String userName, String address, boolean bool) &#123;</span><br><span class="line">    if(bool) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    userName &#x3D; &quot;Kevin&quot;;</span><br><span class="line">    address &#x3D; &quot;Beijing&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然上面的modifyUserInfo()方法中承担了多个职责，既可以修改userName，也可以修改address，甚至更多的值，明显不符合单一职责。这样我们需要对代码进行修改，把这个方法拆分成两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void modifyUserName(String userName) &#123;</span><br><span class="line">    userName &#x3D; &quot;Kevin&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void modifyAddress(String address) &#123;</span><br><span class="line">    address &#x3D; &quot;Beijing&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改之后的代码看起来简单，且维护起来更加容易。但是，<strong>我们在实际开发项目过程中，项目直接会相互依赖，组合、聚和这些关系，还有项目的规模，周期，技术人员的水平，对进度的把控，很多类都不符合单一职责。但是，我们在编码的过程中尽量做到单一职责，这样对我们项目的后期维护是有很大的帮助的。</strong></p>
<h2 id="1-4-接口隔离原则-（Interface-Segregation-Principle，ISP）"><a href="#1-4-接口隔离原则-（Interface-Segregation-Principle，ISP）" class="headerlink" title="1.4 接口隔离原则 （Interface Segregation Principle，ISP）"></a>1.4 接口隔离原则 （Interface Segregation Principle，ISP）</h2><p>接口隔离原则是指用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口。这个原则指导我们在设计接口的时候应该注意以下几点：</p>
<p>1、一个类对一类的依赖应该建立在最小的接口之上；</p>
<p>2、建立单一接口，不要建立庞大臃肿的接口；</p>
<p>3、尽量细化接口，接口中的方法尽量少（不是越少越好，要适度）。</p>
<p>接口隔离原则符合我们常说的<strong>高内聚低耦合</strong>的设计思想，从而使得类具有很好的可读性、可扩展性以及可维护性。在设计接口的时候，要多花时间去思考，要考虑业务模型，包括以后有可能发生变更的地方还要做一些预判。所以对于抽象，对于业务模型的理解是非常重要的。下面举例来看一个动物行为的抽象接口：</p>
<p>IAnimal接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface IAnimal &#123;</span><br><span class="line">    void eat();</span><br><span class="line">    void fly();</span><br><span class="line">    void swim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Bird 类实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Bird implements IAnimal &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void fly() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void swim() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dog 类实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Dog implements IAnimal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void fly() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void swim() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，Bird 的 swim()方法可能只能空着，Dog 的fly()方法显然不可能的。这时候，我们针对不同动物行为来设计不同的接口，分别设计 IEatAnimal，IFlyAnimal 和ISwimAnimal 接口，来看代码：</p>
<p>IEatAnimal接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IEatAnimal &#123;</span><br><span class="line">    void eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IFlyAnimal接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IFlyAnimal &#123;</span><br><span class="line">    void fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ISwimAnimal接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ISwimAnimal &#123;</span><br><span class="line">    void swim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dog 只实现 IEatAnimal 和 ISwimAnimal 接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Dog implements IEatAnimal, ISwimAnimal &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void swim() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-迪米特法则（Law-of-Demeter-LoD）"><a href="#1-5-迪米特法则（Law-of-Demeter-LoD）" class="headerlink" title="1.5 迪米特法则（Law of Demeter, LoD）"></a>1.5 迪米特法则（Law of Demeter, LoD）</h2><p>迪米特法则是指一个对象应该对其他对象保持最少的了解，又叫最少知道原则（Least Knowledge Principle， LKP），尽量降低类与类之间的耦合。<strong>主要强调只和朋友说话，不和陌生人说话。出现在成员变量、方法输入、输出参数中的类都可以称之为成员朋友类，而出现在方法体内部的类不属于朋友类。</strong></p>
<p>现在来设计一个权限系统，老板需要查看目前发布到线上的课程数量。这个老板找到项目负责人去进行统计，项目负责人再把统计结果告诉老板。来看一下代码示例：</p>
<p>Course类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class Course &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TeamLeader类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class TeamLeader &#123;</span><br><span class="line">    public void checkNumberOfCourses(List&lt;Course&gt; courseList)&#123;</span><br><span class="line">        System.out.println(&quot;目前已发布的课程数量是：&quot;+courseList.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Boss类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Boss &#123;</span><br><span class="line"></span><br><span class="line">    public void commandCheckNumber(TeamLeader teamLeader)&#123;</span><br><span class="line">        &#x2F;&#x2F;模拟 Boss 一页一页往下翻页，TeamLeader 实时统计</span><br><span class="line">        List&lt;Course&gt; courseList &#x3D; new ArrayList&lt;Course&gt;();</span><br><span class="line">        for (int i&#x3D; 0; i &lt; 10 ;i ++)&#123;</span><br><span class="line">            courseList.add(new Course());</span><br><span class="line">        &#125;</span><br><span class="line">        teamLeader.checkNumberOfCourses(courseList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Boss boss &#x3D; new Boss();</span><br><span class="line">        TeamLeader teamLeader &#x3D; new TeamLeader();</span><br><span class="line">        boss.commandCheckNumber(teamLeader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码根据迪米特原则，老板Boss只想要结果，不需要跟Course产生直接交流。而课程负责人统计要引用Course对象。Boss和Course并不是朋友，我们需要修改代码：</p>
<p>TeamLeader类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class TeamLeader &#123;</span><br><span class="line"></span><br><span class="line">    public void checkNumberOfCourses()&#123;</span><br><span class="line">        List&lt;Course&gt; courseList &#x3D; new ArrayList&lt;Course&gt;();</span><br><span class="line">        for(int i &#x3D; 0 ;i &lt; 10;i++)&#123;</span><br><span class="line">            courseList.add(new Course());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;目前已发布的课程数量是：&quot;+courseList.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Boss类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Boss &#123;</span><br><span class="line"></span><br><span class="line">    public void commandCheckNumber(TeamLeader teamLeader)&#123;</span><br><span class="line">        teamLeader.checkNumberOfCourses();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Boss boss &#x3D; new Boss();</span><br><span class="line">        TeamLeader teamLeader &#x3D; new TeamLeader();</span><br><span class="line">        boss.commandCheckNumber(teamLeader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>得到的：学习软件设计原则，千万不能形成强迫症。碰到业务复杂的场景，我们需要随机应变。</strong></p>
<h2 id="1-6-里氏替换原则（Liskov-Substitution-Principle，LSP）"><a href="#1-6-里氏替换原则（Liskov-Substitution-Principle，LSP）" class="headerlink" title="1.6 里氏替换原则（Liskov Substitution Principle，LSP）"></a>1.6 里氏替换原则（Liskov Substitution Principle，LSP）</h2><p>里氏替换原则是指如果对每一个类型T1的对象o1,都有类型为T2的对象o2,使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。</p>
<p>定义看上去还是比较抽象，可以理解为<strong>如果适应一个父类的话，那一定是适用于子类，所有的引用父类的地方必须能透明的使用子类的对象，子类对象能够替换父类对象，而程序逻辑不变。</strong> 总结一下：</p>
<p>引申含义：子类可以扩展父类的功能，但不能改变父类原有的功能。</p>
<p>1、子类可以实现父类的抽象方法，但不能覆盖父类的抽象方法；</p>
<p>2、子类中可以增加自己特有的方法；</p>
<p>3、当子类的方法覆盖父类的方法时，方法的前置条件（即方法的输入/入参）要比父类方法的输入参数更宽松；</p>
<p>4、当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的输出/返回值）要比父类更严格或者相等。</p>
<p>我们在开闭原则的代码案例中在获取折后时覆盖了父类的getPrice()方法，增加了一个获取优惠价格后的方法getOriginPrice(),显然就违背了里氏替换原则。接下来我们不覆盖getPrice()方法，增加getDiscountBook()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ComputerDiscountBook extends ComputerBook &#123;</span><br><span class="line">    public ComputerDiscountBook(Integer id, String name, Double price) &#123;</span><br><span class="line">        super(id, name, price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Double getDiscountBook() &#123;</span><br><span class="line">        return super.getPrice() * 0.8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用里氏替换原则有以下几个优点：</p>
<p>1、约束继承泛滥，开闭原则的一种体现；</p>
<p>2、加强程序的健壮性，同时变更时可以做到很好的兼容性，提高程序的维护性、扩展性。降低需求变更时引入的风险。</p>
<p>现在用正方形、矩形和四边形来说明里氏替换原则，我们都知道正方形是一个特殊的长方形，创建一个长方形父类Rectangle：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Rectangle &#123;</span><br><span class="line"></span><br><span class="line">    private long width;</span><br><span class="line"></span><br><span class="line">    private long height;</span><br><span class="line"></span><br><span class="line">    public long getWidth() &#123;</span><br><span class="line">        return width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setWidth(long width) &#123;</span><br><span class="line">        this.width &#x3D; width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getHeight() &#123;</span><br><span class="line">        return height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHeight(long height) &#123;</span><br><span class="line">        this.height &#x3D; height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建正方形Square类继承Rectangle长方形类，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Square extends Rectangle &#123;</span><br><span class="line"></span><br><span class="line">    private long length;</span><br><span class="line">    public long getLength() &#123;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setLength(long length) &#123;</span><br><span class="line">        this.length &#x3D; length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public long getWidth() &#123;</span><br><span class="line">        return getLength();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public long getHeight() &#123;</span><br><span class="line">        return getLength();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void setHeight(long height) &#123;</span><br><span class="line">        setLength(height);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void setWidth(long width) &#123;</span><br><span class="line">        setLength(width);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在测试类中创建 resize()方法，根据逻辑长方形的宽应该大于等于高，我们让高一直自增，知道高等于宽变成正方形：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void resize(Rectangle rectangle)&#123;</span><br><span class="line">        while (rectangle.getWidth() &gt;&#x3D; rectangle.getHeight())&#123;</span><br><span class="line">            rectangle.setHeight(rectangle.getHeight() + 1);</span><br><span class="line">            System.out.println(&quot;width:&quot;+rectangle.getWidth() + &quot;,height:&quot;+rectangle.getHeight());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;resize 方法结束&quot; +</span><br><span class="line">                &quot;\nwidth:&quot;+rectangle.getWidth() + &quot;,height:&quot;+rectangle.getHeight());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">        Rectangle rectangle &#x3D; new Rectangle();</span><br><span class="line">        rectangle.setWidth(20);</span><br><span class="line">        rectangle.setHeight(10);</span><br><span class="line">        resize(rectangle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/18/17058a6cffb9fefd?w=502&h=589&f=png&s=35867" alt=""></p>
<p>修改代码把长方形Rectangle替换成它的子类正方形Square：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Square square &#x3D; new Square();</span><br><span class="line">        square.setLength(10);</span><br><span class="line">        resize(square);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候我们运行的时候就出现了死循环，违背了里氏替换原则，将父类替换为子类后，程序运行结果没有达到预期。因此，我们的代码设计是存在一定风险的。里氏替换原则只存在父类与子类之间，约束继承泛滥。再来创建一个基于长方形与正方形共同抽象的四边形Quadrangle接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Quadrangle &#123;</span><br><span class="line">    </span><br><span class="line">    long getWidth();</span><br><span class="line">    </span><br><span class="line">    long getHeight();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改长方形 Rectangle 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Rectangle implements Quadrangle &#123;</span><br><span class="line"></span><br><span class="line">    private long height;</span><br><span class="line">    private long width;</span><br><span class="line">    @Override</span><br><span class="line">    public long getWidth() &#123;</span><br><span class="line">        return width;</span><br><span class="line">    &#125;</span><br><span class="line">    public long getHeight() &#123;</span><br><span class="line">        return height;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setHeight(long height) &#123;</span><br><span class="line">        this.height &#x3D; height;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setWidth(long width) &#123;</span><br><span class="line">        this.width &#x3D; width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改正方形类 Square 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Square implements Quadrangle &#123;</span><br><span class="line"></span><br><span class="line">    private long length;</span><br><span class="line">    public long getLength() &#123;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setLength(long length) &#123;</span><br><span class="line">        this.length &#x3D; length;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public long getWidth() &#123;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public long getHeight() &#123;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，如果我们把 resize()方法的参数换成四边形 Quadrangle类，方法内部就会报错。因为正方形 Square 已经没有了 setWidth()和 setHeight()方法了。因此，为了约束继承泛滥，resize()的方法参数只能用 Rectangle 长方形。</p>
<h2 id="1-7-合成复用原则-（Composite-Aggregate-Reuse-Principle，CARP）"><a href="#1-7-合成复用原则-（Composite-Aggregate-Reuse-Principle，CARP）" class="headerlink" title="1.7 合成复用原则 （Composite/Aggregate Reuse Principle，CARP）"></a>1.7 合成复用原则 （Composite/Aggregate Reuse Principle，CARP）</h2><p>合成复用原则是指尽量使用对象组合/聚和，而不是用继承关系达到对象复用的目的。这样可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其它类造成的影响也较少。</p>
<p><strong>继承又叫做白箱复用，相当于把所有的实现细节暴露给子类。组合/聚和也成为黑箱复用，对类以外的对象是无法获取到实现细节的。</strong> 需要根据具体的业务场景来设计代码，其实也要遵循OOP模型。这里以数据库操作为例，先创建DBConnection类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class DBConnection &#123;</span><br><span class="line"></span><br><span class="line">    public String getConnection()&#123;</span><br><span class="line">        return &quot;MySQL 数据库连接&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 ProductDao 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ProductDao &#123;</span><br><span class="line"></span><br><span class="line">    private DBConnection dbConnection;</span><br><span class="line">    public void setDbConnection(DBConnection dbConnection) &#123;</span><br><span class="line">        this.dbConnection &#x3D; dbConnection;</span><br><span class="line">    &#125;</span><br><span class="line">    public void addProduct()&#123;</span><br><span class="line">        String conn &#x3D; dbConnection.getConnection();</span><br><span class="line">        System.out.println(&quot;使用&quot;+conn+&quot;增加产品&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是非常典型的合成复用原则的应用场景。但是DBConnection还不是一种抽象，不便于系统扩展。目前系统只支持Mysql数据库连接，假设业务发生变化，数据库操作层要支持Oralce数据库。当然，可以在DBConnection中增加对Oracle数据库支持的方法。但是违背了开闭原则。我们可以不修改Dao的代码，将DBConnection改为abstract，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class DBConnection &#123;</span><br><span class="line">    public abstract String getConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，将 MySQL 的逻辑抽离：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MySqlConnection extends DBConnection &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getConnection() &#123;</span><br><span class="line">        return &quot;MySQL 数据库连接&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再创建 Oracle 支持的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class OracleConnection extends DBConnection &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getConnection() &#123;</span><br><span class="line">        return &quot;Oracle 数据库连接&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、-设计原则总结"><a href="#二、-设计原则总结" class="headerlink" title="二、 设计原则总结"></a>二、 设计原则总结</h1><p>学习设计原则，学习设计模式的基础。在实际开发过程中，并不是所有的代码都要遵循设计原则。我们需要考虑人力、时间、成本、质量，不是刻意的追求完美，要在适当的场景下遵循设计原则，体现的是一种平衡的取舍，帮助我们设计出更加优美的代码结构。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/02/19/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%E7%B2%BE%E9%80%89%E6%A1%88%E4%BE%8B/" data-id="ck7lialvh000f6xractl88c9b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/03/10/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E4%BD%9C%E4%B8%BA%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%9A%84%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，作为树形结构系统架构的组合模式详解</a>
          </li>
        
          <li>
            <a href="/2020/03/08/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1%E6%9D%A5%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，使用共享对象来提高性能的享元模式详解</a>
          </li>
        
          <li>
            <a href="/2020/03/08/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%A4%96%E7%95%8C%E8%AE%BF%E9%97%AE%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%E5%94%AF%E4%B8%80%E9%80%9A%E9%81%93%E7%9A%84%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，外界访问系统内部唯一通道的门面模式详解</a>
          </li>
        
          <li>
            <a href="/2020/03/01/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E6%B3%A8%E9%87%8D%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F%E7%9A%84%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，注重方法调用顺序的建造者模式详解</a>
          </li>
        
          <li>
            <a href="/2020/02/25/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%B1%9E%E4%BA%8E%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，属于游戏设计模式的策略模式详解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Kevin Shaw<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>