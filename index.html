<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>来一杯咖啡</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="互联网Java体系平台架构，分布式系统，中间件技术等">
<meta property="og:type" content="website">
<meta property="og:title" content="来一杯咖啡">
<meta property="og:url" content="https://xkjava.github.io/index.html">
<meta property="og:site_name" content="来一杯咖啡">
<meta property="og:description" content="互联网Java体系平台架构，分布式系统，中间件技术等">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Kevin Shaw">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="Netty">
<meta property="article:tag" content="Kafka...">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="来一杯咖啡" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">来一杯咖啡</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">互联网技术无边界，学习与交流</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://xkjava.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-架构师内功心法，外界访问系统内部唯一通道的门面模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/08/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%A4%96%E7%95%8C%E8%AE%BF%E9%97%AE%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%E5%94%AF%E4%B8%80%E9%80%9A%E9%81%93%E7%9A%84%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-03-08T03:27:32.000Z" itemprop="datePublished">2020-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/08/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%A4%96%E7%95%8C%E8%AE%BF%E9%97%AE%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%E5%94%AF%E4%B8%80%E9%80%9A%E9%81%93%E7%9A%84%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，外界访问系统内部唯一通道的门面模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、门面模式的应用场景"><a href="#一、门面模式的应用场景" class="headerlink" title="一、门面模式的应用场景"></a>一、门面模式的应用场景</h1><p>门面模式（Facade Pattern）又叫外观模式，提供了一个统一的接口，用来访问子系统中的一群接口。主要特征是定义了一个高层接口，让子系统更容易使用。在我们的日常工作中，都在有意无意大量使用门面模式，但凡只要高层模块需要调度多个子系统，我们都会封装一个新类，提供精简接口，让高层模块很容易的间接调用这些子系统的功能。尤其是现阶段各种第三方API，各种开源类库，很大概率都会使用门面模式。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/7/170b41dceb2532a0?w=522&h=369&f=png&s=80554" alt=""></p>
<p>门面模式适用于以下几种场景：</p>
<ul>
<li>子系统越来越复杂，增加门面模式提供简单接口；</li>
<li>构建多层系统结构，利用门面对象作为每层的入口，简化层间调用。</li>
</ul>
<p>门面模式主要有2种角色：</p>
<ul>
<li>外观角色（Facade）：也成为门面角色，系统对外的统一接口；</li>
<li>子系统角色（SubSystem）：可以有一个或者多个子系统角色。</li>
</ul>
<h2 id="1-1-门面模式的通用写法"><a href="#1-1-门面模式的通用写法" class="headerlink" title="1.1 门面模式的通用写法"></a>1.1 门面模式的通用写法</h2><p>下面是门面模式的通用代码，首先分别创建 3 个子系统的业务逻辑 SubSystemA、SubSystemB、SubSystemC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class SubSystemA &#123;</span><br><span class="line">    public void doA() &#123;</span><br><span class="line">        System.out.println(&quot;doing A stuff&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SubSystemB &#123;</span><br><span class="line">    public void doB() &#123;</span><br><span class="line">        System.out.println(&quot;doing B stuff&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SubSystemC &#123;</span><br><span class="line">    public void doC() &#123;</span><br><span class="line">        System.out.println(&quot;doing C stuff&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，创建外观角色 Facade 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Facade &#123;</span><br><span class="line">    private SubSystemA a &#x3D; new SubSystemA();</span><br><span class="line">    private SubSystemB b &#x3D; new SubSystemB();</span><br><span class="line">    private SubSystemC c &#x3D; new SubSystemC();</span><br><span class="line">    &#x2F;&#x2F; 对外接口</span><br><span class="line">    public void doA() &#123;</span><br><span class="line">        this.a.doA();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 对外接口</span><br><span class="line">    public void doB() &#123;</span><br><span class="line">        this.b.doB();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 对外接口</span><br><span class="line">    public void doC() &#123;</span><br><span class="line">        this.c.doC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">    Facade facade &#x3D; new Facade();</span><br><span class="line">    facade.doA();</span><br><span class="line">    facade.doB();</span><br><span class="line">    facade.doC();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、门面模式在源码中的体现"><a href="#二、门面模式在源码中的体现" class="headerlink" title="二、门面模式在源码中的体现"></a>二、门面模式在源码中的体现</h1><h2 id="2-1-Spring-JDBC中的JdbcUtils"><a href="#2-1-Spring-JDBC中的JdbcUtils" class="headerlink" title="2.1 Spring JDBC中的JdbcUtils"></a>2.1 Spring JDBC中的JdbcUtils</h2><p>JdbcUtils封装了和JDBC 相关的所有操作，它一个代码片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public abstract class JdbcUtils &#123;</span><br><span class="line">    public static final int TYPE_UNKNOWN &#x3D; -2147483648;</span><br><span class="line">    private static final Log logger &#x3D; LogFactory.getLog(JdbcUtils.class);</span><br><span class="line">    public JdbcUtils() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void closeConnection(Connection con) &#123;</span><br><span class="line">    if(con !&#x3D; null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            con.close();</span><br><span class="line">        &#125; catch (SQLException var2) &#123;</span><br><span class="line">            logger.debug(&quot;Could not close JDBC Connection&quot;, var2);</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            logger.debug(&quot;Unexpected exception on closing JDBC Connection&quot;, var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void closeStatement(Statement stmt) &#123;</span><br><span class="line">        if(stmt !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; catch (SQLException var2) &#123;</span><br><span class="line">                logger.trace(&quot;Could not close JDBC Statement&quot;, var2);</span><br><span class="line">            &#125; catch (Throwable var3) &#123;</span><br><span class="line">                logger.trace(&quot;Unexpected exception on closing JDBC Statement&quot;, var3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void closeResultSet(ResultSet rs) &#123;</span><br><span class="line">        if(rs !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; catch (SQLException var2) &#123;</span><br><span class="line">                logger.trace(&quot;Could not close JDBC ResultSet&quot;, var2);</span><br><span class="line">            &#125; catch (Throwable var3) &#123;</span><br><span class="line">                logger.trace(&quot;Unexpected exception on closing JDBC ResultSet&quot;, var3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-Tomcat-的源码中的RequestFacade-类"><a href="#2-2-Tomcat-的源码中的RequestFacade-类" class="headerlink" title="2.2  Tomcat 的源码中的RequestFacade 类"></a>2.2  Tomcat 的源码中的RequestFacade 类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class RequestFacade implements HttpServletRequest &#123;</span><br><span class="line">...</span><br><span class="line">    @Override</span><br><span class="line">    public String getContentType() &#123;</span><br><span class="line">        if (request &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(</span><br><span class="line">                sm.getString(&quot;requestFacade.nullRequest&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        return request.getContentType();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public ServletInputStream getInputStream() throws IOException &#123;</span><br><span class="line">        if (request &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(</span><br><span class="line">                sm.getString(&quot;requestFacade.nullRequest&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        return request.getInputStream();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String getParameter(String name) &#123;</span><br><span class="line">        if (request &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(</span><br><span class="line">                sm.getString(&quot;requestFacade.nullRequest&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        if (Globals.IS_SECURITY_ENABLED)&#123;</span><br><span class="line">            return AccessController.doPrivileged(</span><br><span class="line">            new GetParameterPrivilegedAction(name));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return request.getParameter(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看名字就知道它用了门面模式。它封装了非常多的request的操作，也整合了很多 servlet-api 以外的一些内容，给用户使用提供了很大便捷。同样，Tomcat 对 Response 和 Session 当也封装了<strong>ResponseFacade</strong> 和 <strong>StandardSessionFacade</strong> 类，感兴趣的小伙伴可以去深入了解一下。</p>
<h1 id="三、门面模式的优缺点"><a href="#三、门面模式的优缺点" class="headerlink" title="三、门面模式的优缺点"></a>三、门面模式的优缺点</h1><p>优点：</p>
<ul>
<li>简化了调用过程，无需深入了解子系统，以防给子系统带来风险；</li>
<li>减少系统依赖、松散耦合；</li>
<li>更好地划分访问层次，提高了安全性；</li>
<li>遵循迪米特法则，即最少知道原则。</li>
</ul>
<p>缺点：</p>
<ul>
<li>当增加子系统和扩展子系统行为时，可能容易带来未知风险；</li>
<li>不符合开闭原则；</li>
<li>某些情况下可能违背单一职责原则。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/03/08/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%A4%96%E7%95%8C%E8%AE%BF%E9%97%AE%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%E5%94%AF%E4%B8%80%E9%80%9A%E9%81%93%E7%9A%84%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="ck7ih9d6v00011orae0qze5hh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，注重方法调用顺序的建造者模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/01/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E6%B3%A8%E9%87%8D%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F%E7%9A%84%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-03-01T07:51:27.000Z" itemprop="datePublished">2020-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/01/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E6%B3%A8%E9%87%8D%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F%E7%9A%84%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，注重方法调用顺序的建造者模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、建造者模式的定义"><a href="#一、建造者模式的定义" class="headerlink" title="一、建造者模式的定义"></a>一、建造者模式的定义</h1><p>大家平时都去过肯德基用餐，那里不变的是炸鸡、汉堡、薯条、可乐等，这些都是一直都有的，不变的，而其它组合是经常变化的，从而生成不同的“套餐”罢了。而建造模式（Builder Pattern）是将一个复杂的对象的构建过程与它的表示分离，使得同样的构建过程构建不同的表示。使用建造者模式对于用户而言只需要关注指定需要建造的类型就可以获得对象，而不需要了解建造的过程以及细节。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/1/170950ed1508a094?w=750&h=423&f=png&s=768819" alt=""></p>
<p>建造者模式适用于创建对象需要很多步骤，但是步骤的顺序不是固定不变的。先看一下建造者模式的类图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/1/17094b9a96e4f1ee?w=456&h=405&f=png&s=150230" alt=""></p>
<p>建造者模式中的四个重要角色：</p>
<ul>
<li>产品（Product）：要创建的产品类对象</li>
<li>抽象建造者（Builder）：规范产品对象的各个组成部分的建造</li>
<li>建造者（Concrete Builder）：具体化对象的各个组成部分的创建</li>
<li>调用者（Director）：负责保证对象各部分完整创建或按某种顺序创建</li>
</ul>
<h1 id="二、建造者模式的应用场景"><a href="#二、建造者模式的应用场景" class="headerlink" title="二、建造者模式的应用场景"></a>二、建造者模式的应用场景</h1><p>建造者模式适用于一个具有较多的零件的复杂产品的创建过程，由于需求的变化，组成这个复杂产品的各个零件经常猛烈变化，但是它们的组合方式却相对稳定。</p>
<p>建造者模式适用于以下几种场景：</p>
<ul>
<li>相同的方法，不同的执行顺序，产生的结果也不同</li>
<li>多个部件或零件，装配到一个对象中，产生的结果不同</li>
<li>产品类复杂，或者产品类中调用顺序不同产生不同的作用</li>
<li>初始化对象特别复杂，参数多，而且很多参数都有默认值</li>
</ul>
<h2 id="2-1-建造者模式的基本写法"><a href="#2-1-建造者模式的基本写法" class="headerlink" title="2.1 建造者模式的基本写法"></a>2.1 建造者模式的基本写法</h2><p>我们以公司的技术培训为例，一个完整的技术培训需要由发布培训通知、制作培训PPT、组织员工培训、现场（远程）培训、提交培训问卷等步骤。下面我们用建造模式的代码来简单实现这类场景，首先创建一个技术培训的 TechnicalTraining 产品类  ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class TechnicalTraining &#123;</span><br><span class="line"></span><br><span class="line">    private String notice;</span><br><span class="line">    private String ppt;</span><br><span class="line">    private String training;</span><br><span class="line">    private String questionnaire;</span><br><span class="line"></span><br><span class="line">    public String getNotice() &#123;</span><br><span class="line">        return notice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNotice(String notice) &#123;</span><br><span class="line">        this.notice &#x3D; notice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPpt() &#123;</span><br><span class="line">        return ppt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPpt(String ppt) &#123;</span><br><span class="line">        this.ppt &#x3D; ppt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getTraining() &#123;</span><br><span class="line">        return training;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTraining(String training) &#123;</span><br><span class="line">        this.training &#x3D; training;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getQuestionnaire() &#123;</span><br><span class="line">        return questionnaire;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setQuestionnaire(String questionnaire) &#123;</span><br><span class="line">        this.questionnaire &#x3D; questionnaire;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;TechnicalTraining&#123;&quot; +</span><br><span class="line">                &quot;notice&#x3D;&#39;&quot; + notice + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, ppt&#x3D;&#39;&quot; + ppt + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, training&#x3D;&#39;&quot; + training + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, questionnaire&#x3D;&#39;&quot; + questionnaire + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着创建建造者 TrainingBuilder 类，将复杂的构造过程封装起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class TrainingBuilder &#123;</span><br><span class="line"></span><br><span class="line">    private TechnicalTraining technicalTraining &#x3D; new TechnicalTraining();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发布培训通知</span><br><span class="line">     * @param notice</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void PostNotice(String notice) &#123;</span><br><span class="line">        technicalTraining.setNotice(notice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 制作培训PPT</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void createPPT(String ppt) &#123;</span><br><span class="line">        technicalTraining.setPpt(ppt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 组织员工培训</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void organizeTraining(String training) &#123;</span><br><span class="line">        technicalTraining.setTraining(training);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 提交培训问卷</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void sumitQuestionnaire(String questionnaire) &#123;</span><br><span class="line">        technicalTraining.setQuestionnaire(questionnaire);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     public TechnicalTraining build() &#123;</span><br><span class="line">        return technicalTraining;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试main方法：</p>
<p>public static void main(String[] args) {</p>
<pre><code>TrainingBuilder builder = new TrainingBuilder();
builder.PostNotice(&quot;发布培训通知&quot;);
builder.createPPT(&quot;创建ppt&quot;);
builder.organizeTraining(&quot;组织员工培训&quot;);
builder.sumitQuestionnaire(&quot;提交培训问卷&quot;);
System.out.println(builder.build());</code></pre><p>}</p>
<p>最后来看一下类图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/1/17094dea480736e2?w=868&h=586&f=png&s=60246" alt=""></p>
<h2 id="2-2-建造者模式的链式写法"><a href="#2-2-建造者模式的链式写法" class="headerlink" title="2.2 建造者模式的链式写法"></a>2.2 建造者模式的链式写法</h2><p>在平时的应用中，建造者模式通常是采用链式编程的方式构造对象，下面我们来改造上面的案例代码，将TechnicalTraining变成TrainingBuilder的内部类，将构造步骤添加进去，每完成一个步骤，都返回 this：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">public class TrainingBuilder &#123;</span><br><span class="line"></span><br><span class="line">    public class TechnicalTraining &#123;</span><br><span class="line"></span><br><span class="line">        private String notice;</span><br><span class="line">        private String ppt;</span><br><span class="line">        private String training;</span><br><span class="line">        private String questionnaire;</span><br><span class="line"></span><br><span class="line">        public String getNotice() &#123;</span><br><span class="line">            return notice;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setNotice(String notice) &#123;</span><br><span class="line">            this.notice &#x3D; notice;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getPpt() &#123;</span><br><span class="line">            return ppt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setPpt(String ppt) &#123;</span><br><span class="line">            this.ppt &#x3D; ppt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getTraining() &#123;</span><br><span class="line">            return training;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setTraining(String training) &#123;</span><br><span class="line">            this.training &#x3D; training;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getQuestionnaire() &#123;</span><br><span class="line">            return questionnaire;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setQuestionnaire(String questionnaire) &#123;</span><br><span class="line">            this.questionnaire &#x3D; questionnaire;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private TechnicalTraining technicalTraining &#x3D; new TechnicalTraining();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发布培训通知</span><br><span class="line">     * @param notice</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public TrainingBuilder PostNotice(String notice) &#123;</span><br><span class="line">        technicalTraining.setNotice(notice);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 制作培训PPT</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public TrainingBuilder createPPT(String ppt) &#123;</span><br><span class="line">        technicalTraining.setPpt(ppt);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 组织员工培训</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public TrainingBuilder organizeTraining(String training) &#123;</span><br><span class="line">        technicalTraining.setTraining(training);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 提交培训问卷</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public TrainingBuilder sumitQuestionnaire(String questionnaire) &#123;</span><br><span class="line">        technicalTraining.setQuestionnaire(questionnaire);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TechnicalTraining build() &#123;</span><br><span class="line">        return this.technicalTraining;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    TrainingBuilder builder &#x3D; new TrainingBuilder();</span><br><span class="line">    builder.PostNotice(&quot;发布培训通知&quot;)</span><br><span class="line">    .createPPT(&quot;创建ppt&quot;)</span><br><span class="line">    .organizeTraining(&quot;组织员工培训&quot;)</span><br><span class="line">    .sumitQuestionnaire(&quot;提交培训问卷&quot;);</span><br><span class="line">    System.out.println(builder.build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后再来看下类图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/1/17094e9be66020c5?w=574&h=589&f=png&s=42023" alt=""></p>
<h1 id="三、建造者模式在源码中的体现"><a href="#三、建造者模式在源码中的体现" class="headerlink" title="三、建造者模式在源码中的体现"></a>三、建造者模式在源码中的体现</h1><h2 id="3-1-StringBuilder类"><a href="#3-1-StringBuilder类" class="headerlink" title="3.1 StringBuilder类"></a>3.1 StringBuilder类</h2><p>使用StringBuilder类，我们常用的有append()、toString()方法，我们来看下append()方法的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public StringBuilder(CharSequence seq) &#123;</span><br><span class="line">    this(seq.length() + 16);</span><br><span class="line">    append(seq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public StringBuilder append(Object obj) &#123;</span><br><span class="line">    return append(String.valueOf(obj));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public StringBuilder append(String str) &#123;</span><br><span class="line">    super.append(str);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-Spring中的BeanDefinitionBuilder类"><a href="#3-2-Spring中的BeanDefinitionBuilder类" class="headerlink" title="3.2 Spring中的BeanDefinitionBuilder类"></a>3.2 Spring中的BeanDefinitionBuilder类</h2><p>比如 BeanDefinitionBuilder 通过调用 getBeanDefinition()方法获得一个 BeanDefinition 对象，比如下面的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private BeanDefinitionBuilder(AbstractBeanDefinition beanDefinition) &#123;</span><br><span class="line">    this.beanDefinition &#x3D; beanDefinition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public AbstractBeanDefinition getRawBeanDefinition() &#123;</span><br><span class="line">    return this.beanDefinition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public AbstractBeanDefinition getBeanDefinition() &#123;</span><br><span class="line">    this.beanDefinition.validate();</span><br><span class="line">    return this.beanDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、建造者模式的优缺点"><a href="#四、建造者模式的优缺点" class="headerlink" title="四、建造者模式的优缺点"></a>四、建造者模式的优缺点</h1><p>建造者模式的优点：</p>
<ul>
<li><p>封装性好，创建和使用分离；</p>
</li>
<li><p>扩展性好，建造类之间独立、一定程度上解耦。</p>
</li>
</ul>
<p>建造者模式的缺点：</p>
<ul>
<li><p>产生多余的 Builder 对象；</p>
</li>
<li><p>产品内部发生变化，建造者都要修改，成本较大。</p>
</li>
</ul>
<h1 id="建造者模式和工厂模式的区别"><a href="#建造者模式和工厂模式的区别" class="headerlink" title="建造者模式和工厂模式的区别"></a>建造者模式和工厂模式的区别</h1><p>通过前面的学习，我们已经了解建造者模式，那么它和工厂模式有什么区别呢？<br>1、建造者模式更加注重方法的调用顺序，工厂模式注重于创建对象。</p>
<p>2、创建对象的力度不同，建造者模式创建复杂的对象，由各种复杂的部件组成，工厂模式创建出来的都一样。</p>
<p>3、关注重点不一样，工厂模式模式只需要把对象创建出来就可以了，而建造者模式中不仅要创建出这个对象，还要知道这个对象由哪些部件组成。</p>
<p>4、建造者模式根据建造过程中的顺序不一样，最终的对象部件组成也不一样。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/03/01/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E6%B3%A8%E9%87%8D%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F%E7%9A%84%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="ck7ih9d7u00091oraem9t2kym" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，属于游戏设计模式的策略模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/25/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%B1%9E%E4%BA%8E%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-02-25T09:03:29.000Z" itemprop="datePublished">2020-02-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/25/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%B1%9E%E4%BA%8E%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，属于游戏设计模式的策略模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、策略模式的应用场景"><a href="#一、策略模式的应用场景" class="headerlink" title="一、策略模式的应用场景"></a>一、策略模式的应用场景</h1><p>策略模式（Strategy Pattern）是指定义了算法家族、分别封装起来，让它们之间可以相互替换，此模式让算法的变化不会影响到使用算法的用户。</p>
<h2 id="1-1-应用场景"><a href="#1-1-应用场景" class="headerlink" title="1.1 应用场景"></a>1.1 应用场景</h2><ul>
<li>假如系统中有很多类，而他们的区别仅仅在于他们的行为不同。</li>
</ul>
<ul>
<li>一个系统需要动态地在几种算法中选择一种。</li>
</ul>
<h2 id="1-2-实现餐饮行业选择支付方式的业务场景"><a href="#1-2-实现餐饮行业选择支付方式的业务场景" class="headerlink" title="1.2 实现餐饮行业选择支付方式的业务场景"></a>1.2 实现餐饮行业选择支付方式的业务场景</h2><p>我们在外面去吃饭的时候，不同的饭店经常会有优惠活动，优惠策略也有很多很多，比如优惠券折扣、返现促销、拼团下单等等。我们来用程序模拟这样的业务场景，首先创建一个促销策略的接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IPromotionStrategy &#123;</span><br><span class="line"></span><br><span class="line">    void doPromotion();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后分别创建优惠券抵扣策略 CouponStrategy 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class CouponStrategy implements IPromotionStrategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doPromotion() &#123;</span><br><span class="line">        System.out.println(&quot;领取的优惠券在指定时间到店消费，订单的价格直接减优惠券面额抵扣！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返现促销策略 CashBackStrategy 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class CashBackStrategy implements IPromotionStrategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doPromotion() &#123;</span><br><span class="line">        System.out.println(&quot;返现促销，返回的金额转到支付账号！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拼团优惠策略 GroupBuyStrategy 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class GroupBuyStrategy implements IPromotionStrategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doPromotion() &#123;</span><br><span class="line">        System.out.println(&quot;拼团，满5人成团，全团享受团购价！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无优惠策略 EmptyStrategy 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class EmptyStrategy implements IPromotionStrategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doPromotion() &#123;</span><br><span class="line">        System.out.println(&quot;无促销活动！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建促销活动方案 PromotionActivity 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class PromotionActivity &#123;</span><br><span class="line"></span><br><span class="line">    private IPromotionStrategy promotionStrategy;</span><br><span class="line"></span><br><span class="line">    public PromotionActivity(IPromotionStrategy promotionStrategy) &#123;</span><br><span class="line">        this.promotionStrategy &#x3D; promotionStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        promotionStrategy.doPromotion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    PromotionActivity activity_618 &#x3D; new PromotionActivity(new CouponStrategy());</span><br><span class="line">    PromotionActivity activity_1212 &#x3D; new PromotionActivity(new CashBackStrategy());</span><br><span class="line">    activity_618.execute();</span><br><span class="line">    activity_1212.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，上面的这段测试代码放到实际的业务场景并不实用，因为餐饮门店做活动的时候是要根据不同需求对促销策略进行动态选择的，并不会一次性执行多种优惠。所以代码会这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">    PromotionActivity promotionActivity &#x3D; null;</span><br><span class="line">    String promotionKey &#x3D; &quot;COUPON&quot;;</span><br><span class="line">    if(promotionKey.equals(&quot;COUPON&quot;))&#123;</span><br><span class="line">        promotionActivity &#x3D; new PromotionActivity(new CouponStrategy());</span><br><span class="line">    &#125;else if(promotionKey.equals(&quot;CASHBACK&quot;))&#123;</span><br><span class="line">        promotionActivity &#x3D; new PromotionActivity(new CashBackStrategy());</span><br><span class="line">    &#125;&#x2F;&#x2F;......</span><br><span class="line">    promotionActivity.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样改造之后，满足了业务需求，客户可根据自己的需求选择不同的优惠策略了。但是，经过一段时间的业务积累，我们的促销活动会越来越多。于是，我们的程序猿小哥哥就忙不赢了，每次上活动之前都要通宵改代码，而且要做重复测试，判断逻辑可能也变得越来越复杂。这时候，我们是不需要思考代码是不是应该重构了？</p>
<p>其实我们可以结合工厂模式和单例模式来进行优化改造。创建PromotionActivityFactory：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class PromotionActivityFactory &#123;</span><br><span class="line"></span><br><span class="line">    public interface PromotionKey &#123;</span><br><span class="line">        String COUPON &#x3D; &quot;COUPON&quot;;</span><br><span class="line">        String CASHBACK &#x3D; &quot;CASHBACK&quot;;</span><br><span class="line">        String GROUPBUY &#x3D; &quot;GROUPBUY&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Map&lt;String, IPromotionStrategy&gt; PROMOTION_STRATEGY_MAP &#x3D;</span><br><span class="line">            new HashMap&lt;&gt;();</span><br><span class="line">    static &#123;</span><br><span class="line">        PROMOTION_STRATEGY_MAP.put(PromotionKey.COUPON, new CouponStrategy());</span><br><span class="line">        PROMOTION_STRATEGY_MAP.put(PromotionKey.CASHBACK, new CashBackStrategy());</span><br><span class="line">        PROMOTION_STRATEGY_MAP.put(PromotionKey.GROUPBUY, new GroupBuyStrategy());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final IPromotionStrategy NO_PROMOTION &#x3D; new EmptyStrategy();</span><br><span class="line"></span><br><span class="line">    private PromotionActivityFactory() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static IPromotionStrategy getPromotionStrategy(String promotionKey) &#123;</span><br><span class="line">        IPromotionStrategy promotionStrategy &#x3D; PROMOTION_STRATEGY_MAP.get(promotionKey);</span><br><span class="line">        return promotionStrategy &#x3D;&#x3D; null ? NO_PROMOTION : promotionStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String promotionKey &#x3D; &quot;COUPON&quot;;</span><br><span class="line">    PromotionActivity promotionActivity &#x3D;  new PromotionActivity(PromotionActivityFactory.getPromotionStrategy(promotionKey));</span><br><span class="line">    promotionActivity.execute();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改代码之后维护工作应该轻松了很多，每次上新活动，不会影响原来的代码逻辑。来看一下完整的类图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/25/1707b0d517cdd627?w=1246&h=490&f=png&s=43282" alt=""></p>
<p>为了加深大家对策略模式的理解，结合实际生活场景再举一个例子。大家都用过移动支付进行付款，比较流行的支付方式有支付宝、微信、银联等。一个场景的支付场景就是在支付的时候提示会选择支付方式，如果用户没有进行选择，那么系统会使用默认的支付方式进行结算。</p>
<p>创建抽象类Payment：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Payment &#123;</span><br><span class="line"></span><br><span class="line">    public abstract String getType();</span><br><span class="line"></span><br><span class="line">    public PayState pay(String id, double amount) &#123;</span><br><span class="line">        if(queryBalance(id) &lt; amount) &#123;</span><br><span class="line">            return new PayState(500,&quot;支付失败&quot;,&quot;余额不足&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return new PayState(200,&quot;支付成功&quot;,&quot;支付金额：&quot; + amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract double queryBalance(String id);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别创建具体的支付方式，支付宝 AliPay 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class AliPay extends Payment &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return &quot;支付宝&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public double queryBalance(String id) &#123;</span><br><span class="line">        return 1000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>微信支付 WechatPay 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class WechatPay extends Payment &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return &quot;微信支付&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public double queryBalance(String id) &#123;</span><br><span class="line">        return 512;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>银联云闪付支付 UnionPay 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class UnionPay extends Payment &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return &quot;云闪付&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public double queryBalance(String id) &#123;</span><br><span class="line">        return 380;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建支付状态的包装类 PayState:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class PayState &#123;</span><br><span class="line"></span><br><span class="line">    private int code;</span><br><span class="line">    private Object data;</span><br><span class="line">    private String msg;</span><br><span class="line"></span><br><span class="line">    public PayState(int code, Object data, String msg) &#123;</span><br><span class="line">        this.code &#x3D; code;</span><br><span class="line">        this.data &#x3D; data;</span><br><span class="line">        this.msg &#x3D; msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;PayState&#123;&quot; +</span><br><span class="line">                &quot;code&#x3D;&quot; + code +</span><br><span class="line">                &quot;, data&#x3D;&quot; + data +</span><br><span class="line">                &quot;, msg&#x3D;&#39;&quot; + msg + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建支付策略管理工厂类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class PayStrategyFactory &#123;</span><br><span class="line"></span><br><span class="line">    public interface PayKey &#123;</span><br><span class="line">        String DEFAULTPAY &#x3D; &quot;ALIPAY&quot;;</span><br><span class="line">        String ALIPAY &#x3D; &quot;ALIPAY&quot;;</span><br><span class="line">        String WECHATPAY &#x3D; &quot;WECHATPAY&quot;;</span><br><span class="line">        String UNIONPAY &#x3D; &quot;UNIONPAY&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final Map&lt;String, Payment&gt; PAYMENT_MAP &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    static  &#123;</span><br><span class="line">        PAYMENT_MAP.put(PayKey.ALIPAY, new AliPay());</span><br><span class="line">        PAYMENT_MAP.put(PayKey.WECHATPAY, new WechatPay());</span><br><span class="line">        PAYMENT_MAP.put(PayKey.UNIONPAY, new UnionPay());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Payment getPayment(String payKey) &#123;</span><br><span class="line">        if(!PAYMENT_MAP.containsKey(payKey))&#123;</span><br><span class="line">            return PAYMENT_MAP.get(PayKey.DEFAULTPAY);</span><br><span class="line">        &#125;</span><br><span class="line">        return PAYMENT_MAP.get(payKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建订单 Order 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Order &#123;</span><br><span class="line"></span><br><span class="line">    private String id;</span><br><span class="line">    private String orderId;</span><br><span class="line">    private double amount;</span><br><span class="line"></span><br><span class="line">    public Order(String id, String orderId, double amount) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.orderId &#x3D; orderId;</span><br><span class="line">        this.amount &#x3D; amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PayState pay()&#123;</span><br><span class="line">        return pay(PayStrategyFactory.PayKey.DEFAULTPAY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PayState pay(String payKey)&#123;</span><br><span class="line">        Payment payment &#x3D; PayStrategyFactory.PAYMENT_MAP.get(payKey);</span><br><span class="line">        System.out.println(&quot;欢迎使用&quot; + payment.getType());</span><br><span class="line">        System.out.println(&quot;本次交易金额为：&quot; + amount + &quot;，开始扣款...&quot;);</span><br><span class="line">        return payment.pay(id,amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    Order order &#x3D; new Order(&quot;1&quot;, &quot;20200225000001&quot;, 120.98);</span><br><span class="line"></span><br><span class="line">    System.out.println(order.pay(PayStrategyFactory.PayKey.ALIPAY));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/25/1707b50d93119f88?w=742&h=214&f=png&s=22506" alt=""></p>
<p>最后来看一下类图结构：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/25/1707b54365747dac?w=1066&h=769&f=png&s=67982" alt=""></p>
<h1 id="二、源码中的策略模式"><a href="#二、源码中的策略模式" class="headerlink" title="二、源码中的策略模式"></a>二、源码中的策略模式</h1><h2 id="2-1-Compartor接口"><a href="#2-1-Compartor接口" class="headerlink" title="2.1 Compartor接口"></a>2.1 Compartor接口</h2><p>Compartor接口中的compare()方法就是一个策略模式的抽象实现。</p>
<p>int compare(T o1, T o2);</p>
<p>Comparator 接口下面有非常多的实现类，我们经常会把 Comparator 作为参数传入作为排序策略，例如 Arrays 类的 parallelSort 方法等：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/25/1707b643e817639c?w=1645&h=496&f=png&s=70716" alt=""></p>
<p>还有 TreeMap 的构造方法:</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/25/1707b6689c6d7218?w=1162&h=259&f=png&s=36243" alt=""></p>
<h2 id="2-2-Spring中的策略模式"><a href="#2-2-Spring中的策略模式" class="headerlink" title="2.2 Spring中的策略模式"></a>2.2 Spring中的策略模式</h2><h2 id="2-2-1-Resouce类"><a href="#2-2-1-Resouce类" class="headerlink" title="2.2.1 Resouce类"></a>2.2.1 Resouce类</h2><p>我们来看Resource类的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.core.io;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.URI;</span><br><span class="line">import java.net.URL;</span><br><span class="line">import java.nio.channels.Channels;</span><br><span class="line">import java.nio.channels.ReadableByteChannel;</span><br><span class="line">import org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line">public interface Resource extends InputStreamSource &#123;</span><br><span class="line">    boolean exists();</span><br><span class="line"></span><br><span class="line">    default boolean isReadable() &#123;</span><br><span class="line">        return this.exists();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default boolean isOpen() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default boolean isFile() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    URL getURL() throws IOException;</span><br><span class="line"></span><br><span class="line">    URI getURI() throws IOException;</span><br><span class="line"></span><br><span class="line">    File getFile() throws IOException;</span><br><span class="line"></span><br><span class="line">    default ReadableByteChannel readableChannel() throws IOException &#123;</span><br><span class="line">        return Channels.newChannel(this.getInputStream());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    long contentLength() throws IOException;</span><br><span class="line"></span><br><span class="line">    long lastModified() throws IOException;</span><br><span class="line"></span><br><span class="line">    Resource createRelative(String var1) throws IOException;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    String getFilename();</span><br><span class="line"></span><br><span class="line">    String getDescription();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们虽然没有直接使用 Resource 类，但是我们经常使用它的子类，例如：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/25/1707b7cc055b952d?w=1885&h=568&f=png&s=186061" alt=""></p>
<p>Spring 的初始化也采用了策略模式，不同的类型的类采用不<br>同的初始化策略。首先有一个 <strong>InstantiationStrategy</strong> 接口，我们来看一下源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface InstantiationStrategy &#123;</span><br><span class="line">    Object instantiate(RootBeanDefinition var1, @Nullable String var2, BeanFactory var3) throws BeansException;</span><br><span class="line"></span><br><span class="line">    Object instantiate(RootBeanDefinition var1, @Nullable String var2, BeanFactory var3, Constructor&lt;?&gt; var4, Object... var5) throws BeansException;</span><br><span class="line"></span><br><span class="line">    Object instantiate(RootBeanDefinition var1, @Nullable String var2, BeanFactory var3, @Nullable Object var4, Method var5, Object... var6) throws BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顶层的策略抽象非常简单，但是它下面有两种策略 <strong>SimpleInstantiationStrategy</strong> 和<strong>CglibSubclassingInstantiationStrategy</strong>，我们看一下类图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/25/1707b81615f908ef?w=1057&h=724&f=png&s=80916" alt=""><br>打开类图我们还发现 CglibSubclassingInstantiationStrategy 策略类还继承了<br>SimpleInstantiationStrategy类，说明在实际应用中多种策略之间还可以继承使用。</p>
<h1 id="三、策略模式的优缺点"><a href="#三、策略模式的优缺点" class="headerlink" title="三、策略模式的优缺点"></a>三、策略模式的优缺点</h1><p>优点：</p>
<ul>
<li>策略模式符合开闭原则；</li>
</ul>
<ul>
<li>避免使用多重条件转移语句，如 if…else…语句、switch 语句；</li>
</ul>
<ul>
<li>使用策略模式可以提高算法的保密性和安全性。</li>
</ul>
<p>缺点：</p>
<ul>
<li>客户端必须知道所有的策略，并且自行决定使用哪一个策略类；</li>
</ul>
<ul>
<li>代码中会产生非常多策略类，增加维护难度。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/02/25/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%B1%9E%E4%BA%8E%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="ck7ih9d7t00081ora3v9u8rrb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，干过中介干过快递的代理模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/25/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%B9%B2%E8%BF%87%E4%B8%AD%E4%BB%8B%E5%B9%B2%E8%BF%87%E5%BF%AB%E9%80%92%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-02-25T09:01:55.000Z" itemprop="datePublished">2020-02-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/25/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%B9%B2%E8%BF%87%E4%B8%AD%E4%BB%8B%E5%B9%B2%E8%BF%87%E5%BF%AB%E9%80%92%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，干过中介干过快递的代理模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、代理模式的应用场景"><a href="#一、代理模式的应用场景" class="headerlink" title="一、代理模式的应用场景"></a>一、代理模式的应用场景</h1><p>在我们的生活中，经常会见到这样的场景，如：租售房中介、婚介、经纪人、快递等，这些都是代理模式的现实生活体现。代理模式（Proxy Pattern）是指为其它对象提供一种代理，以控制对这个对象的访问。代理对象在客户端和目标对象中间起到了中介的作用，使用代理模式主要有两个目的：<strong>一是保护目标对象，二是增强目标对象。</strong> </p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/23/17070809577156fb?w=1712&h=1080&f=png&s=3560244" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/23/1707081485369be2?w=1280&h=853&f=png&s=1671129" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/23/1707082136eaba87?w=650&h=487&f=png&s=547465" alt=""></p>
<p>代理模式的类图结构：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/23/170702e8a82b99b5?w=451&h=379&f=png&s=126867" alt=""></p>
<p>Subject是顶层设计的接口，RealSubject是真实的对象，Proxy是代理对象，代理对象持有真实对象的引用，客户端Client调用代理对象的方法，同时也调用真实对象的方法，在代理对象前后增加一些处理。我们一想到代理模式，就会理解为<strong>代码增强</strong>，其实就是在原本的代码逻辑前后增加一些逻辑，而使得调用者无感知。代理模式分为静态代理和动态代理。</p>
<h1 id="二、代理模式的分类"><a href="#二、代理模式的分类" class="headerlink" title="二、代理模式的分类"></a>二、代理模式的分类</h1><h2 id="2-1-静态代理"><a href="#2-1-静态代理" class="headerlink" title="2.1 静态代理"></a>2.1 静态代理</h2><p>我们直接来举例说明静态代理，青年男女到了适婚的年龄，如果没有对象，周围的亲戚朋友总是张罗着要给某某某介绍对象，这个介绍对象相亲的过程，就是一种我们人人都有份的代理。来看代码实现：</p>
<p>顶层接口设计Person类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Person &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 寻找伴侣</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void lookForMate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>女儿要求找对象，实现Person接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Daughter implements Person &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void lookForMate() &#123;</span><br><span class="line">        System.out.println(&quot;女儿要求：高大英俊且有钱！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>母亲要帮闺女相亲，实现Mother类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Mother &#123;</span><br><span class="line"></span><br><span class="line">    private Daughter daughter;</span><br><span class="line">    &#x2F;&#x2F;如何扩展呢</span><br><span class="line">    public Mother(Daughter daughter) &#123;</span><br><span class="line">        this.daughter &#x3D; daughter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;目标对象的引用daughter拿到，可以调用</span><br><span class="line">    public void lookForMate() &#123;</span><br><span class="line">        System.out.println(&quot;母亲物色女儿的对象&quot;);</span><br><span class="line">        daughter.lookForMate();</span><br><span class="line">        System.out.println(&quot;双方同意交往并确立关系&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;只能帮女儿找对象，不能帮表妹、不能帮陌生人</span><br><span class="line">    Mother mother &#x3D; new Mother(new Daughter());</span><br><span class="line">    mother.lookForMate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/23/170709c04b74144d?w=475&h=229&f=png&s=16047" alt=""></p>
<p>上面的这个例子是生活中的例子，我们用代码实现了生活中的代理模式。再来一个具体的实际业务场景的例子吧。我们经常会对数据库进行分库分表，分库分表后用Java代码来操作，就需要配置多个数据源，通过设置数据源路由来动态动态切换数据源。<br>创建订单实体类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 订单实体类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Order &#123;</span><br><span class="line"></span><br><span class="line">    private String id;</span><br><span class="line"></span><br><span class="line">    private Object orderInfo;</span><br><span class="line"></span><br><span class="line">    private Long createTime;</span><br><span class="line"></span><br><span class="line">    public String getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(String id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getOrderInfo() &#123;</span><br><span class="line">        return orderInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOrderInfo(Object orderInfo) &#123;</span><br><span class="line">        this.orderInfo &#x3D; orderInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Long getCreateTime() &#123;</span><br><span class="line">        return createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCreateTime(Long createTime) &#123;</span><br><span class="line">        this.createTime &#x3D; createTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建OrderDao持久层操作类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class OrderDao &#123;</span><br><span class="line">    public int insert(Order order) &#123;</span><br><span class="line">        System.out.println(&quot;创建order对象成功!&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 IOrderService 接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IOrderService &#123;</span><br><span class="line">    int createOrder(Order order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 OrderService 实现类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class OrderService implements IOrderService &#123;</span><br><span class="line"></span><br><span class="line">    private OrderDao orderDao;</span><br><span class="line"></span><br><span class="line">    public OrderService(OrderDao orderDao) &#123;</span><br><span class="line">        orderDao &#x3D; new OrderDao();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int createOrder(Order order) &#123;</span><br><span class="line">        System.out.println(&quot;OrderService调用OrderDao创建订单&quot;);</span><br><span class="line">        return orderDao.insert(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来使用静态代理，完成订单创建时间自动按年份进行分库，通过使用代理对象来完成接下来的代码。创建数据源路由对象，使用ThreadLocal单例实现，DynamicDataSourceEntity：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicDataSourceEntity &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 默认数据源</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final String DEFAULT_DATA_SOURCE &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private static final ThreadLocal&lt;String&gt; local &#x3D; new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private DynamicDataSourceEntity() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取当前正在使用的数据源</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String get() &#123;</span><br><span class="line">        return local.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 设置已知名字的数据源</span><br><span class="line">     * @param dataSource</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void set(String dataSource) &#123;</span><br><span class="line">        local.set(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 还原当前切面的数据源</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void restore() &#123;</span><br><span class="line">        local.set(DEFAULT_DATA_SOURCE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 根据年份动态设置数据源</span><br><span class="line">     * @param year</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void set(int year) &#123;</span><br><span class="line">        local.set(&quot;DB_&quot; + year);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 清空数据源</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void remove() &#123;</span><br><span class="line">        local.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建切换数据源代理OrderServiceStaticProxy：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class OrderServiceStaticProxy implements IOrderService &#123;</span><br><span class="line"></span><br><span class="line">    private SimpleDateFormat yearFormat &#x3D; new SimpleDateFormat(&quot;yyyy&quot;);</span><br><span class="line"></span><br><span class="line">    private IOrderService orderService;</span><br><span class="line"></span><br><span class="line">    public OrderServiceStaticProxy(IOrderService orderService) &#123;</span><br><span class="line">        this.orderService &#x3D; orderService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int createOrder(Order order) &#123;</span><br><span class="line">        before();</span><br><span class="line">        Long time &#x3D; order.getCreateTime();</span><br><span class="line">        Integer dbRouter &#x3D; Integer.valueOf(yearFormat.format(new Date(time)));</span><br><span class="line">        System.out.println(&quot;静态代理类自动分配到【DB_&quot; + dbRouter + &quot;】数据源处理数据。&quot;);</span><br><span class="line">        DynamicDataSourceEntity.set(dbRouter);</span><br><span class="line">        orderService.createOrder(order);</span><br><span class="line">        after();</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void before()&#123;</span><br><span class="line">        System.out.println(&quot;代理方法执行开始了......&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private void after()&#123;</span><br><span class="line">        System.out.println(&quot;代理方法执行结束了......&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main方法的代码：</p>
<p> public static void main(String[] args) throws ParseException {</p>
<pre><code>Order order = new Order();
order.setId(&quot;010101001&quot;);
//Date today = new Date();
//order.setCreateTime(today.getTime());

SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd&quot;);
Date date = sdf.parse(&quot;2019/02/01&quot;);
order.setCreateTime(date.getTime());


IOrderService orderService = new OrderServiceStaticProxy(new OrderService());
orderService.createOrder(order);</code></pre><p>}</p>
<p>运行结果是：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/23/17070e2f728d86b3?w=610&h=346&f=png&s=26911" alt=""></p>
<p>符合我们的预期效果。现在我们再来回顾一下类图，看是不是和我们最先画的类结构一致：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/23/17070e41a9eadcfb?w=1197&h=476&f=png&s=346255" alt=""></p>
<h2 id="2-2-动态代理"><a href="#2-2-动态代理" class="headerlink" title="2.2 动态代理"></a>2.2 动态代理</h2><p>动态代理和静态代理的思路基本是一致的，只不过动态代理的功能更加强大，随着业务的扩展适应性更强。前面说到的母亲替闺女找对象的例子，如果找对象的业务发展为一个行业，那么就是婚姻中介了。来升级代码的实现过程，以满足帮助更多的单身人士找对象的需求。下面使用JDK的方式实现婚姻介绍所。</p>
<h2 id="2-2-1-JDK实现方式"><a href="#2-2-1-JDK实现方式" class="headerlink" title="2.2.1 JDK实现方式"></a>2.2.1 JDK实现方式</h2><p>创建婚姻介绍JDKMarriage类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class JDKMarriage implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    private Object target;</span><br><span class="line"></span><br><span class="line">    public Object getInstance(Object target) &#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz &#x3D; target.getClass();</span><br><span class="line">        return Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        before();</span><br><span class="line">        Object object &#x3D; method.invoke(this.target, args);</span><br><span class="line">        after();</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void before()&#123;</span><br><span class="line">        System.out.println(&quot;我是婚姻介绍所：要给你找对象，现在已经拿到你的需求&quot;);</span><br><span class="line">        System.out.println(&quot;开始物色&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private void after()&#123;</span><br><span class="line">        System.out.println(&quot;如果合适的话，就准备办事&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建单身客户Customer类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Customer implements Person &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void lookForMate() &#123;</span><br><span class="line">        System.out.println(&quot;高富帅&quot;);</span><br><span class="line">        System.out.println(&quot;身高180cm&quot;);</span><br><span class="line">        System.out.println(&quot;有房有车&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试main方法代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    JDKMarriage marriage &#x3D; new JDKMarriage();</span><br><span class="line"></span><br><span class="line">    Person person &#x3D; (Person) marriage.getInstance(new Customer());</span><br><span class="line">    person.lookForMate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/23/170712617edfebb2?w=670&h=364&f=png&s=25490" alt=""></p>
<p>上面的动态代理案例通过实现InvocationHandler接口来完成的，在前面的数据源路由业务，也要用动态代理来实现一下，我们来看下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class OrderServiceDynamicProxy implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    private SimpleDateFormat yearFormat &#x3D; new SimpleDateFormat(&quot;yyyy&quot;);</span><br><span class="line"></span><br><span class="line">    public Object target;</span><br><span class="line"></span><br><span class="line">    public Object getInstance(Object target) &#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">        Class&lt;?&gt; clazz &#x3D; target.getClass();</span><br><span class="line">        return Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        before(args[0]);</span><br><span class="line">        Object object &#x3D; method.invoke(target, args);</span><br><span class="line">        after();</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void before(Object target) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;代理方法执行开始了......&quot;);</span><br><span class="line">            Long time &#x3D; (Long)target.getClass().getMethod(&quot;getCreateTime&quot;).invoke(target);</span><br><span class="line">            Integer dbRouter &#x3D; Integer.valueOf(yearFormat.format(new Date(time)));</span><br><span class="line">            System.out.println(&quot;动态代理类自动分配到【DB_&quot; + dbRouter + &quot;】数据源处理数据&quot;);</span><br><span class="line">            DynamicDataSourceEntity.set(dbRouter);</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void after() &#123;</span><br><span class="line">        System.out.println(&quot;代理方法执行结束了......&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试main方法代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws ParseException &#123;</span><br><span class="line">        Order order &#x3D; new Order();</span><br><span class="line">        order.setId(&quot;010101001&quot;);</span><br><span class="line">&#x2F;&#x2F;        Date today &#x3D; new Date();</span><br><span class="line">&#x2F;&#x2F;        order.setCreateTime(today.getTime());</span><br><span class="line"></span><br><span class="line">        SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy&#x2F;MM&#x2F;dd&quot;);</span><br><span class="line">        Date date &#x3D; sdf.parse(&quot;2019&#x2F;02&#x2F;01&quot;);</span><br><span class="line">        order.setCreateTime(date.getTime());</span><br><span class="line"></span><br><span class="line">        IOrderService orderService &#x3D; (IOrderService) new OrderServiceDynamicProxy().getInstance(new OrderService());</span><br><span class="line">        orderService.createOrder(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/23/170715f8efe2d262?w=553&h=298&f=png&s=25414" alt=""></p>
<p>依然可以达到想要的运行效果。但是，动态代理实现之后，我们不仅能实现 Order 的数据源动态路由，还可以实现其他任何类的数据源路由。</p>
<h2 id="2-2-2-CGLib代理调用API及原理分析"><a href="#2-2-2-CGLib代理调用API及原理分析" class="headerlink" title="2.2.2 CGLib代理调用API及原理分析"></a>2.2.2 CGLib代理调用API及原理分析</h2><p>pom依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;cglib&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;cglib&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;3.3.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>还是以婚姻介绍所为例，创建CglibMarriage类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class CglibMarriage implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    public Object getInstance(Class&lt;?&gt; clazz) throws Exception &#123;</span><br><span class="line">        Enhancer enhancer &#x3D; new Enhancer();</span><br><span class="line">        &#x2F;&#x2F;要把哪个类设置成为生成的新类的父类</span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        enhancer.setCallback(this);</span><br><span class="line"></span><br><span class="line">        return enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object o, Method method, Object[] objects,</span><br><span class="line">                            MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        before();</span><br><span class="line">        Object obj &#x3D; methodProxy.invokeSuper(o, objects);</span><br><span class="line">        after();</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void before()&#123;</span><br><span class="line">        System.out.println(&quot;我是婚姻介绍所：要给你找对象，现在已经拿到你的需求&quot;);</span><br><span class="line">        System.out.println(&quot;开始物色&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private void after()&#123;</span><br><span class="line">        System.out.println(&quot;如果合适的话，就准备办事&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着创建单身客户类Customer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Customer &#123;</span><br><span class="line">    </span><br><span class="line">    public void lookForMate() &#123;</span><br><span class="line">        System.out.println(&quot;高富帅&quot;);</span><br><span class="line">        System.out.println(&quot;身高180cm&quot;);</span><br><span class="line">        System.out.println(&quot;有房有车&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>CGLib代理的目标对象不需要实现任何接口，它是通过动态继承目标对象实现动态代理的。</strong> 来看测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Customer customer &#x3D; (Customer)new CglibMarriage().getInstance(Customer.class);</span><br><span class="line">            customer.lookForMate();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CGLib代理执行代理对象的方法效率之所以比JDK的高，是因为CGLib采用了FastClass机制，FastClass的原理是：为代理类和被代理类各生成一个class，这个class会为代理类或被代理类的方法分配一个index(int类型)，这个index当作入参，FastClass就可以直接定位要调用的方法直接进行调用，这样省去了反射调用，所以调用效率比JDK动态代理通过反射调用高。</strong></p>
<h2 id="2-2-3-CGLib和JDK动态代理对比"><a href="#2-2-3-CGLib和JDK动态代理对比" class="headerlink" title="2.2.3 CGLib和JDK动态代理对比"></a>2.2.3 CGLib和JDK动态代理对比</h2><p>1、JDK动态代理实现了被代理对象的接口，CGLib代理继承了被代理对象。</p>
<p>2、JDK和CGLib都在运行期间生成字节码，JDK动态代理直接生成class字节码，CGLib代理通过asm框架生成class字节码，CGLib代理实现更复杂，生成代理类比JDK动态代理效率低。</p>
<p>3、JDK动态代理调用代理方法是通过反射机制调用的，CGLib代理是通过FastClass机制直接调用方法的，CGLib代理的执行效率高。</p>
<h1 id="三、Spring与代理模式"><a href="#三、Spring与代理模式" class="headerlink" title="三、Spring与代理模式"></a>三、Spring与代理模式</h1><h2 id="3-1-代理模式在Spring源码中的应用"><a href="#3-1-代理模式在Spring源码中的应用" class="headerlink" title="3.1 代理模式在Spring源码中的应用"></a>3.1 代理模式在Spring源码中的应用</h2><p>先看 <strong>ProxyFactoryBean</strong>  核心的方法就是 <strong>getObject()</strong> 方法，我们来看一下源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">public Object getObject() throws BeansException &#123;</span><br><span class="line">    this.initializeAdvisorChain();</span><br><span class="line">    if (this.isSingleton()) &#123;</span><br><span class="line">        return this.getSingletonInstance();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (this.targetName &#x3D;&#x3D; null) &#123;</span><br><span class="line">            this.logger.info(&quot;Using non-singleton proxies with singleton targets is often undesirable. Enable prototype proxies by setting the &#39;targetName&#39; property.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return this.newPrototypeInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 getObject()方法中，主要调用 <strong>getSingletonInstance()</strong> 和<strong>newPrototypeInstance()</strong> ；<br>在 Spring 的配置中，如果不做任何设置，那么 Spring 代理生成的 Bean 都是单例对象。如果修改 scope则每次创建一个新的原型对象。newPrototypeInstance()里面的逻辑比较复杂，我们后面的课程再做深入研究，这里我们先做简单的了解。</p>
<h2 id="3-2-Spring-中的代理选择原则"><a href="#3-2-Spring-中的代理选择原则" class="headerlink" title="3.2 Spring 中的代理选择原则"></a>3.2 Spring 中的代理选择原则</h2><p>Spring 利用动态代理实现 AOP 有两个非常重要的类，一个是 <strong>JdkDynamicAopProxy</strong> 类和 <strong>CglibAopProxy</strong> 类，来看一下类图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/24/17075edc2fd9e1a9?w=1195&h=469&f=png&s=29406" alt=""></p>
<ul>
<li>当 Bean 有实现接口时，Spring 就会用 JDK 的动态代理；</li>
</ul>
<ul>
<li>当 Bean 没有实现接口时，Spring 选择 CGLib。</li>
</ul>
<h1 id="三、-静态代理和动态的本质区别"><a href="#三、-静态代理和动态的本质区别" class="headerlink" title="三、 静态代理和动态的本质区别"></a>三、 静态代理和动态的本质区别</h1><p>1、静态代理只能通过手动完成代理操作，如果被代理类增加新的方法，代理类需要同步新增，违背开闭原则。</p>
<p>2、动态代理采用在运行时动态生成代码的方式，取消了对被代理类的扩展限制，遵循开闭原则。</p>
<p>3、若动态代理要对目标类的增强逻辑扩展，结合策略模式，只需要新增策略类便可完成，无需修改代理类的代码。</p>
<h1 id="四、代理模式的优缺点"><a href="#四、代理模式的优缺点" class="headerlink" title="四、代理模式的优缺点"></a>四、代理模式的优缺点</h1><p>使用代理模式具有以下几个优点：</p>
<ul>
<li>代理模式能将代理对象与真实被调用的目标对象分离；</li>
</ul>
<ul>
<li>一定程度上降低了系统的耦合度，扩展性好；</li>
</ul>
<ul>
<li>可以起到保护目标对象的作用；</li>
</ul>
<ul>
<li>可以对目标对象的功能增强。</li>
</ul>
<p>当然，代理模式也是有缺点的：</p>
<ul>
<li>代理模式会造成系统设计中类的数量增加；</li>
</ul>
<ul>
<li>在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢；</li>
</ul>
<ul>
<li>增加了系统的复杂度。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/02/25/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%B9%B2%E8%BF%87%E4%B8%AD%E4%BB%8B%E5%B9%B2%E8%BF%87%E5%BF%AB%E9%80%92%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="ck7ih9d7y000c1ora292n2dwi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，只是单纯听说过的原型模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/22/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%8F%AA%E6%98%AF%E5%8D%95%E7%BA%AF%E5%90%AC%E8%AF%B4%E8%BF%87%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-02-22T13:12:08.000Z" itemprop="datePublished">2020-02-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/22/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%8F%AA%E6%98%AF%E5%8D%95%E7%BA%AF%E5%90%AC%E8%AF%B4%E8%BF%87%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，只是单纯听说过的原型模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、原型模式的应用场景"><a href="#一、原型模式的应用场景" class="headerlink" title="一、原型模式的应用场景"></a>一、原型模式的应用场景</h1><p>你一定遇到过这样的代码场景，有大量的getter、setter赋值的场景。例如这样的代码片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private SafetyStockMessage createKafkaMessage(SafetyStock safetyStock, HttpServletRequest request) &#123;</span><br><span class="line">        SafetyStockMessage safetyStockMessage &#x3D; new SafetyStockMessage();</span><br><span class="line">        safetyStockMessage.setId(safetyStock.getId());</span><br><span class="line">        safetyStockMessage.setProvinceCode(safetyStock.getProvinceCode());</span><br><span class="line">        safetyStockMessage.setRequestId(CodeConstants.REQUEST_ID);</span><br><span class="line">        safetyStockMessage.setRequestIp(CodeConstants.REQUEST_IP);</span><br><span class="line">        safetyStockMessage.setSerial(IdMakerUtil.make32Id());</span><br><span class="line">        safetyStockMessage.setStockMax(safetyStock.getStockMax());</span><br><span class="line">        safetyStockMessage.setStockMin(safetyStock.getStockMin());</span><br><span class="line">        safetyStockMessage.setProvince(safetyStock.getProvince());</span><br><span class="line">        safetyStockMessage.setCategoryName(safetyStock.getCategoryName());</span><br><span class="line">        safetyStockMessage.setUpdateTime(new Date());</span><br><span class="line">        safetyStockMessage.setUpdateBy(getLoginUser(request));</span><br><span class="line">        return safetyStockMessage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码看起来非常工整，命名也很规范，大家觉得这样的代码优雅吗？这样的代码属于纯体力劳动。如果使用原型模式，可以帮助我们解决这样的问题。</p>
<p>原型模式（Prototype Pattern）是指原型实例指定创建对象的种类，并且通过拷贝这样原型创建新的对象。</p>
<p>原型模式主要适用于以下场景：</p>
<p>1、类初始化消耗的资源较多；</p>
<p>2、new产生的一个对象需要非常繁琐的过程（数据准备、访问权限等）；</p>
<p>3、构造函数比较复杂；</p>
<p>4、循环体中生产大量对象。</p>
<p>原型模型的类结构图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/21/17067d2c6f3719e9?w=912&h=299&f=png&s=164629" alt=""></p>
<h1 id="二、简单克隆"><a href="#二、简单克隆" class="headerlink" title="二、简单克隆"></a>二、简单克隆</h1><p>一个标准的原型模式代码，应该是这样的设计的。先创建原型Prototype接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Prototype &#123;</span><br><span class="line">    Prototype clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建具体需要克隆的对象ConcretePrototype：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class ConcretePrototype implements Prototype &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private List&lt;String&gt; hobbies;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; getHobbies() &#123;</span><br><span class="line">        return hobbies;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHobbies(List&lt;String&gt; hobbies) &#123;</span><br><span class="line">        this.hobbies &#x3D; hobbies;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ConcretePrototype clone() &#123;</span><br><span class="line">        ConcretePrototype concretePrototype &#x3D; new ConcretePrototype();</span><br><span class="line">        concretePrototype.setName(this.name);</span><br><span class="line">        concretePrototype.setAge(this.age);</span><br><span class="line">        concretePrototype.setHobbies(this.hobbies);</span><br><span class="line">        return concretePrototype;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建Client对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    private Prototype prototype;</span><br><span class="line"></span><br><span class="line">    public Client(Prototype prototype) &#123;</span><br><span class="line">        this.prototype &#x3D; prototype;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Prototype startClone(Prototype concretePrototype) &#123;</span><br><span class="line">        return (Prototype)concretePrototype.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个具体的需要克隆的对象</span><br><span class="line">        ConcretePrototype concretePrototype &#x3D; new ConcretePrototype();</span><br><span class="line">        &#x2F;&#x2F;填充属性，准备测试</span><br><span class="line">        concretePrototype.setName(&quot;Kevin&quot;);</span><br><span class="line">        concretePrototype.setAge(18);</span><br><span class="line">        List&lt;String&gt; hobbies &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        concretePrototype.setHobbies(hobbies);</span><br><span class="line">        System.out.println(concretePrototype);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建Client对象，准备进行克隆</span><br><span class="line">        Client client &#x3D; new Client(concretePrototype);</span><br><span class="line">        ConcretePrototype concretePrototypeClone &#x3D; (ConcretePrototype)</span><br><span class="line">                client.startClone(concretePrototype);</span><br><span class="line">        System.out.println(concretePrototypeClone);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;克隆对象中的引用类型地址值是：&quot; +</span><br><span class="line">                concretePrototypeClone.getHobbies());</span><br><span class="line">        System.out.println(&quot;原对象中的引用类型地址值是：&quot; +</span><br><span class="line">                concretePrototype.getHobbies());</span><br><span class="line">        System.out.println(&quot;对象地址比较：&quot; + (concretePrototypeClone.getHobbies() &#x3D;&#x3D;</span><br><span class="line">                concretePrototype.getHobbies()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/21/1706804761bd93d1?w=640&h=223&f=png&s=29218" alt=""></p>
<p>从测试结果看出hobbies的引用地址是相同的，意味着不是复制值，而复制的是引用的地址。如果我们修改任何一个对象的属性值，concretePrototype和concretePrototypeClone的hobbies的值都会改变。这就是我们常说的浅克隆。只是完整复制了值类型数据，没有复制引用对象。换言之，所有的引用对象还是指向原来的对象，显然不是我们想要的结果。</p>
<p>下面我们继续改造代码，使用深度克隆。</p>
<h1 id="三、深度克隆"><a href="#三、深度克隆" class="headerlink" title="三、深度克隆"></a>三、深度克隆</h1><p>我们来换一个场景，大家都知道齐天大圣孙悟空。首先它是一只猴子，有着七十二般变化，把一根毫毛放在嘴里一吹就变出千万个泼猴，手里还拿着金箍棒，金箍棒可变大变小。这就是我们耳熟能详的原型模式的经典体现。</p>
<p>创建原型猴子 Monkey 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Monkey &#123;</span><br><span class="line"></span><br><span class="line">    public int height;</span><br><span class="line">    public int weight;</span><br><span class="line">    public Date birthday;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建引用对象金箍棒GoldenCudgel类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class GoldenCudgel implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    public float h &#x3D; 100f;</span><br><span class="line"></span><br><span class="line">    public float d &#x3D; 10f;</span><br><span class="line"></span><br><span class="line">    public void changeBig() &#123;</span><br><span class="line">        this.d *&#x3D; 2;</span><br><span class="line">        this.h *&#x3D; 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void changeSmall() &#123;</span><br><span class="line">        this.d &#x2F;&#x3D; 2;</span><br><span class="line">        this.h &#x2F;&#x3D; 2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建具体的对象齐天大圣孙悟空MonkeyKing类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class MonkeyKing extends Monkey implements Cloneable, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    public GoldenCudgel goldenCudgel;</span><br><span class="line"></span><br><span class="line">    public MonkeyKing() &#123;</span><br><span class="line">        this.birthday &#x3D; new Date();</span><br><span class="line">        this.goldenCudgel &#x3D; new GoldenCudgel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() &#123;</span><br><span class="line">        return this.deepClone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 深克隆</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected Object deepClone()  &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);</span><br><span class="line">            oos.writeObject(this);</span><br><span class="line"></span><br><span class="line">            ByteArrayInputStream bis &#x3D; new ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">            ObjectInputStream ois &#x3D; new ObjectInputStream(bis);</span><br><span class="line"></span><br><span class="line">            MonkeyKing copy &#x3D; (MonkeyKing) ois.readObject();</span><br><span class="line">            copy.birthday &#x3D; new Date();</span><br><span class="line">            return copy;</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 浅克隆</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public MonkeyKing shallowClone(MonkeyKing target) &#123;</span><br><span class="line">        MonkeyKing monkeyKing &#x3D; new MonkeyKing();</span><br><span class="line">        monkeyKing.height &#x3D; target.height;</span><br><span class="line">        monkeyKing.weight &#x3D; target.weight;</span><br><span class="line"></span><br><span class="line">        monkeyKing.goldenCudgel &#x3D; target.goldenCudgel;</span><br><span class="line">        monkeyKing.birthday &#x3D; new Date();</span><br><span class="line"></span><br><span class="line">        return monkeyKing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        MonkeyKing monkeyKing &#x3D; new MonkeyKing();</span><br><span class="line"></span><br><span class="line">        MonkeyKing clone &#x3D; (MonkeyKing)monkeyKing.clone();</span><br><span class="line">        System.out.println(&quot;深克隆：&quot; + (monkeyKing.goldenCudgel &#x3D;&#x3D; clone.goldenCudgel));</span><br><span class="line"></span><br><span class="line">        MonkeyKing shallow &#x3D; new MonkeyKing();</span><br><span class="line">        MonkeyKing newMonkeyKing &#x3D; shallow.shallowClone(shallow);</span><br><span class="line">        System.out.println(&quot;浅克隆&quot; + (shallow.goldenCudgel &#x3D;  newMonkeyKing.goldenCudgel));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/22/1706cb7b5846bd38?w=214&h=103&f=png&s=4529" alt=""></p>
<ul>
<li>克隆破坏单例模式</li>
</ul>
<p>如果我们克隆的目标是单例模式创建的对象，那么意味着深克隆会破坏单例模式。如何防止克隆破坏单例，禁止深克隆便可。我们在单例的类中不实现Cloneable接口，在重写clone()方法中返回单例对象即可，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">    return INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>Cloneable 源码分析</li>
</ul>
<p>先看我们常用的 ArrayList 就实现了 Cloneable 接口，来看代码clone()方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Object clone() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ArrayList&lt;?&gt; v &#x3D; (ArrayList&lt;?&gt;) super.clone();</span><br><span class="line">            v.elementData &#x3D; Arrays.copyOf(elementData, size);</span><br><span class="line">            v.modCount &#x3D; 0;</span><br><span class="line">            return v;</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; this shouldn&#39;t happen, since we are Cloneable</span><br><span class="line">            throw new InternalError(e);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/02/22/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%8F%AA%E6%98%AF%E5%8D%95%E7%BA%AF%E5%90%AC%E8%AF%B4%E8%BF%87%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="ck7ih9d7s00071ora6k4i9s4b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，经典高频面试的单例模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/21/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E7%BB%8F%E5%85%B8%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-02-21T07:58:17.000Z" itemprop="datePublished">2020-02-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/21/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E7%BB%8F%E5%85%B8%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，经典高频面试的单例模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、单例模式应用场景"><a href="#一、单例模式应用场景" class="headerlink" title="一、单例模式应用场景"></a>一、单例模式应用场景</h1><p>单例模式（Single Pattern）是指<strong>确保一个类在任何情况下绝对只是一个实例，并提供一个全局的访问点。</strong> 单例模式在现实生活中的应用也很广泛。例如国家总统、公司CEO、部门经理等。在java标准中，ServletContext、ServletContextConfig等；在Spring框架中ApplicationCotext；数据库对应的连接池也都是单例形势的。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/20/170613d3f9e4fcf0?w=720&h=405&f=png&s=385065" alt=""></p>
<h1 id="二、单例模式分类"><a href="#二、单例模式分类" class="headerlink" title="二、单例模式分类"></a>二、单例模式分类</h1><h2 id="2-1-饿汉式单例"><a href="#2-1-饿汉式单例" class="headerlink" title="2.1 饿汉式单例"></a>2.1 饿汉式单例</h2><p><strong>饿汉式单例是在类加载的时候就立即初始化了，并且创建了单例对象。绝对的线程安全，在线程还没出现以前就实例化了，不可能存在访问安全问题。</strong></p>
<p>优点：没有加任何的锁，执行效率高，在用户体验上，比懒汉式更好。<br>缺点：类加载的时候就初始化了，不管用与不用都占空间，浪费了内存，有可能占着茅坑不拉屎。</p>
<p><strong>Spring中的IOC容器ApplicationContext</strong>本身就是典型的饿汉式单例。案例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class HungrySingleton &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 先静态后动态</span><br><span class="line">     * 先属性后方法</span><br><span class="line">     * 先上后下</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static final HungrySingleton hungrySingleton &#x3D; new HungrySingleton();</span><br><span class="line"></span><br><span class="line">    private HungrySingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static HungrySingleton getInstance() &#123;</span><br><span class="line">        return hungrySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种写法，是利用静态代码块机制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class HungrySingleton &#123;</span><br><span class="line">    </span><br><span class="line">    private static final HungrySingleton hungrySingleton;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        hungrySingleton &#x3D; new HungrySingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private HungrySingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private HungrySingleton getInstance() &#123;</span><br><span class="line">        return hungrySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种写法都很简单，也很容易理解。<strong>饿汉式使用在单例对象较少的情况下。</strong> 下面来看下性能更优的写法。</p>
<h2 id="2-2-懒汉式单例"><a href="#2-2-懒汉式单例" class="headerlink" title="2.2 懒汉式单例"></a>2.2 懒汉式单例</h2><p>懒汉式单例是指被外部调用的时候才会进行加载。示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 懒汉式单例</span><br><span class="line">     * 在外部需要使用的时候才进行实例化</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private LazySingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static LazySingleton lazySingleton &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public static LazySingleton getInstance() &#123;</span><br><span class="line">        if(lazySingleton &#x3D;&#x3D; null) &#123;</span><br><span class="line">            lazySingleton &#x3D; new LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return lazySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写一个线程类ExectorThread：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ExectorThread implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        LazySingleton lazySingleton &#x3D; LazySingleton.getInstance();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + lazySingleton);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;--------begin-------&quot;);</span><br><span class="line">        Thread t1 &#x3D; new Thread(new ExectorThread());</span><br><span class="line">        Thread t2 &#x3D; new Thread(new ExectorThread());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println(&quot;--------end---------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看main方法多次运行的结果发现：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/20/170619047ed1b1de?w=349&h=82&f=png&s=7164" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/2/20/17061910bb8a9a1e?w=346&h=85&f=png&s=7161" alt=""></p>
<p>有一定几率会出现创建两个不同结果的情况，意味着上门的单例创建代码存在线程安全隐患。我们通过对代码进行debug调试，发现通过不断切换线程，并观测其内存状态，发现在线程环境下LazySingleton被实例化了两次。有时候我们得到的运行结果可能是相同的两个对象，实际上是被后面的执行线程给覆盖了，看到了一个假象，线程安全隐患依然存在。这样我们需要在线程安全的环境下运行懒汉单例代码。给getIntance()方法加上<strong>Synchronized</strong>关键字，使这个方法变成线程同步方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 懒汉式单例</span><br><span class="line">     * 在外部需要使用的时候才进行实例化</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private LazySingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static LazySingleton lazySingleton &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public synchronized static LazySingleton getInstance() &#123;</span><br><span class="line">        if(lazySingleton &#x3D;&#x3D; null) &#123;</span><br><span class="line">            lazySingleton &#x3D; new LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return lazySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加<strong>synchronized</strong>关键字使用锁，在线程数量比较多的情况下，如果CPU分配压力上升，会导致大批线程出现阻塞，从而导致程序运行性能大幅度下降。那么，有木有一种更好的方式，既兼顾线程的安全性又提升程序性能呢？答案是肯定的。我们会使用<strong>双重检查锁</strong>的单例模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class LazyDoubleCheckSingletion &#123;</span><br><span class="line"></span><br><span class="line">    private volatile static LazyDoubleCheckSingletion lazy &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private LazyDoubleCheckSingletion() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static LazyDoubleCheckSingletion getInstance() &#123;</span><br><span class="line">        if(lazy &#x3D;&#x3D; null) &#123;</span><br><span class="line">            synchronized(LazyDoubleCheckSingletion.class) &#123;</span><br><span class="line">                if(lazy &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    lazy &#x3D; new LazyDoubleCheckSingletion();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return lazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当第一个线程调用 getInstance()方法时，第二个线程也可以调用getInstance()。当第一个线程执行到 synchronized 时会上锁，第二个线程就会变成 MONITOR状态，出现阻塞。此时，阻塞并不是基于整个 LazySingleton 类的阻塞，而是在 getInstance()方法内部阻塞，只要逻辑不是太复杂，对于调用者而言感知不到。</p>
<p>但是，用到 synchronized关键字，总归是要上锁，对程序性能还是存在一定影响的。难道就真的没有更好的方案吗？当然是有的。我们可以从类初始化角度来考虑，看下面的代码，采用静态内部类的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class LazyInnerClassSingleton &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 这种形式兼顾饿汉式的内存浪费，也兼顾 synchronized 性能问题</span><br><span class="line">     * 完美地屏蔽了这两个缺点</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;如果没使用的话，内部类是不加载的</span><br><span class="line">    private LazyInnerClassSingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 每一个关键字都不是多余的</span><br><span class="line">     * static 是为了使单例的空间共享</span><br><span class="line">     * 保证这个方法不会被重写，重载</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static final LazyInnerClassSingleton getInstance() &#123;</span><br><span class="line">        &#x2F;&#x2F;在返回结果以前，一定会先加载内部类</span><br><span class="line">        return LazyHolder.LAZY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;默认不加载</span><br><span class="line">    private static class LazyHolder&#123;</span><br><span class="line">        private static final LazyInnerClassSingleton LAZY &#x3D;</span><br><span class="line">                new LazyInnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种形式兼顾饿汉式的内存浪费，也兼顾synchronized性能问题。内部类一定是要在方法调用之前初始化，巧妙地避免了线程安全问题。</p>
<ul>
<li>反射破坏单例</li>
</ul>
<p>上面一些介绍单例模式的构造方法除了加上private以外，没有做任何处理。如果使用反射来调用其构造方法，然后再调用getInstance()方法，应该就会有两个不同的实例。还是以LazyInnerClassSingleton为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Class&lt;?&gt; clazz &#x3D; LazyInnerClassSingleton.class;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;通过反射机制拿到私有的构造方法</span><br><span class="line">            Constructor c &#x3D; clazz.getDeclaredConstructor(null);</span><br><span class="line">            &#x2F;&#x2F;强制访问</span><br><span class="line">            c.setAccessible(true);</span><br><span class="line">            &#x2F;&#x2F;&#x2F;&#x2F;暴力初始化</span><br><span class="line">            Object o1 &#x3D; c.newInstance();</span><br><span class="line">            &#x2F;&#x2F;调用了两次构造方法，相当于 new 了两次</span><br><span class="line">            Object o2 &#x3D; c.newInstance();</span><br><span class="line"></span><br><span class="line">            System.out.println(o1 &#x3D;&#x3D; o2);</span><br><span class="line"></span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果是：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/20/17061e9caa179a11?w=322&h=91&f=png&s=4243" alt=""></p>
<p>运行结果很显然是创建了两个不同的实例。现在我们对其构造方法做一些限制，一旦出现重复创建实例，则直接抛出异常。来看优化后的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * 这种形式兼顾饿汉式的内存浪费，也兼顾 synchronized 性能问题</span><br><span class="line">   * 完美地屏蔽了这两个缺点</span><br><span class="line">   *&#x2F;</span><br><span class="line">  &#x2F;&#x2F;如果没使用的话，内部类是不加载的</span><br><span class="line">  private LazyInnerClassSingleton() &#123;</span><br><span class="line">      if(LazyHolder.LAZY !&#x3D; null) &#123;</span><br><span class="line">          throw new RuntimeException(&quot;Multiple instances are not allowed to be created!&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 每一个关键字都不是多余的</span><br><span class="line">   * static 是为了使单例的空间共享</span><br><span class="line">   * 保证这个方法不会被重写，重载</span><br><span class="line">   * @return</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public static final LazyInnerClassSingleton getInstance() &#123;</span><br><span class="line">      &#x2F;&#x2F;在返回结果以前，一定会先加载内部类</span><br><span class="line">      return LazyHolder.LAZY;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;默认不加载</span><br><span class="line">  private static class LazyHolder&#123;</span><br><span class="line">      private static final LazyInnerClassSingleton LAZY &#x3D;</span><br><span class="line">              new LazyInnerClassSingleton();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>再次运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/20/17061edd8dce3459?w=1213&h=238&f=png&s=38316" alt=""></p>
<p><strong>至此，史上最牛 B 的单例写法便大功告成。</strong></p>
<ul>
<li>序列化破坏单例</li>
</ul>
<p>当我们将一个单例对象创建好后，有时候需要将对象序列化后写入到磁盘，下次使用的时候再从磁盘中读取到对象，反序列化为内存对象。反序列化后的对象会重新分配内存，即重新创建。<strong>那么如果序列化的目标的对象为单例对象，就违背了单例模式的初衷，相当于破坏了单例</strong>，来看一下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class SerializeSingleton implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    public static final SerializeSingleton INSTANCE &#x3D; new SerializeSingleton();</span><br><span class="line"></span><br><span class="line">    private SerializeSingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static SerializeSingleton getInstance() &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        SerializeSingleton s1 &#x3D; null;</span><br><span class="line">        SerializeSingleton s2 &#x3D; SerializeSingleton.getInstance();</span><br><span class="line"></span><br><span class="line">        FileOutputStream fos &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            fos &#x3D; new FileOutputStream(&quot;SerializeSingleton.obj&quot;);</span><br><span class="line">            ObjectOutputStream oos &#x3D; new ObjectOutputStream(fos);</span><br><span class="line">            oos.writeObject(s2);</span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line"></span><br><span class="line">            FileInputStream fis &#x3D; new FileInputStream(&quot;SerializeSingleton.obj&quot;);</span><br><span class="line">            ObjectInputStream ois &#x3D; new ObjectInputStream(fis);</span><br><span class="line">            s1 &#x3D; (SerializeSingleton)ois.readObject();</span><br><span class="line">            ois.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(s1);</span><br><span class="line">            System.out.println(s2);</span><br><span class="line">            System.out.println(s1 &#x3D;&#x3D; s2);</span><br><span class="line"></span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行main方法结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/21/170668beaa38b178?w=676&h=142&f=png&s=14015" alt=""></p>
<p>运行结果可以看出反序列化后的对象和手动创建的对象不一致，实例化了两次，违背了单例的设计初衷。那么，<strong>如何保证序列化的情况下也能够实现单例呢？</strong> 其实很简单，只需要增加<strong>readResolve()</strong> 方法即可。来看一下优化后的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class SerializeSingleton implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    public static final SerializeSingleton INSTANCE &#x3D; new SerializeSingleton();</span><br><span class="line"></span><br><span class="line">    private SerializeSingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static SerializeSingleton getInstance() &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private Object readResolve() &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/21/170668a01cca79d7?w=670&h=139&f=png&s=13181" alt=""></p>
<p>为什么要这么写呢？我们来一起看下JDK的源码实现吧，进入ObjectInputStream类的readObject()方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public final Object readObject()</span><br><span class="line">        throws IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        if (enableOverride) &#123;</span><br><span class="line">            return readObjectOverride();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; if nested read, passHandle contains handle of enclosing object</span><br><span class="line">        int outerHandle &#x3D; passHandle;</span><br><span class="line">        try &#123;</span><br><span class="line">            Object obj &#x3D; readObject0(false);</span><br><span class="line">            handles.markDependency(outerHandle, passHandle);</span><br><span class="line">            ClassNotFoundException ex &#x3D; handles.lookupException(passHandle);</span><br><span class="line">            if (ex !&#x3D; null) &#123;</span><br><span class="line">                throw ex;</span><br><span class="line">            &#125;</span><br><span class="line">            if (depth &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                vlist.doCallbacks();</span><br><span class="line">            &#125;</span><br><span class="line">            return obj;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            passHandle &#x3D; outerHandle;</span><br><span class="line">            if (closed &amp;&amp; depth &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现在readObject()方法中又调用了我们重写的readObject0()方法。进入readObject0()方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">private Object readObject0(boolean unshared) throws IOException &#123;</span><br><span class="line">        boolean oldMode &#x3D; bin.getBlockDataMode();</span><br><span class="line">        if (oldMode) &#123;</span><br><span class="line">            int remain &#x3D; bin.currentBlockRemaining();</span><br><span class="line">            if (remain &gt; 0) &#123;</span><br><span class="line">                throw new OptionalDataException(remain);</span><br><span class="line">            &#125; else if (defaultDataEnd) &#123;</span><br><span class="line">                &#x2F;*</span><br><span class="line">                 * Fix for 4360508: stream is currently at the end of a field</span><br><span class="line">                 * value block written via default serialization; since there</span><br><span class="line">                 * is no terminating TC_ENDBLOCKDATA tag, simulate</span><br><span class="line">                 * end-of-custom-data behavior explicitly.</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                throw new OptionalDataException(true);</span><br><span class="line">            &#125;</span><br><span class="line">            bin.setBlockDataMode(false);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        byte tc;</span><br><span class="line">        while ((tc &#x3D; bin.peekByte()) &#x3D;&#x3D; TC_RESET) &#123;</span><br><span class="line">            bin.readByte();</span><br><span class="line">            handleReset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        depth++;</span><br><span class="line">        totalObjectRefs++;</span><br><span class="line">        try &#123;</span><br><span class="line">            switch (tc) &#123;</span><br><span class="line">                case TC_NULL:</span><br><span class="line">                    return readNull();</span><br><span class="line"></span><br><span class="line">                case TC_REFERENCE:</span><br><span class="line">                    return readHandle(unshared);</span><br><span class="line"></span><br><span class="line">                case TC_CLASS:</span><br><span class="line">                    return readClass(unshared);</span><br><span class="line"></span><br><span class="line">                case TC_CLASSDESC:</span><br><span class="line">                case TC_PROXYCLASSDESC:</span><br><span class="line">                    return readClassDesc(unshared);</span><br><span class="line"></span><br><span class="line">                case TC_STRING:</span><br><span class="line">                case TC_LONGSTRING:</span><br><span class="line">                    return checkResolve(readString(unshared));</span><br><span class="line"></span><br><span class="line">                case TC_ARRAY:</span><br><span class="line">                    return checkResolve(readArray(unshared));</span><br><span class="line"></span><br><span class="line">                case TC_ENUM:</span><br><span class="line">                    return checkResolve(readEnum(unshared));</span><br><span class="line"></span><br><span class="line">                case TC_OBJECT:</span><br><span class="line">                    return checkResolve(readOrdinaryObject(unshared));</span><br><span class="line"></span><br><span class="line">                case TC_EXCEPTION:</span><br><span class="line">                    IOException ex &#x3D; readFatalException();</span><br><span class="line">                    throw new WriteAbortedException(&quot;writing aborted&quot;, ex);</span><br><span class="line"></span><br><span class="line">                case TC_BLOCKDATA:</span><br><span class="line">                case TC_BLOCKDATALONG:</span><br><span class="line">                    if (oldMode) &#123;</span><br><span class="line">                        bin.setBlockDataMode(true);</span><br><span class="line">                        bin.peek();             &#x2F;&#x2F; force header read</span><br><span class="line">                        throw new OptionalDataException(</span><br><span class="line">                            bin.currentBlockRemaining());</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        throw new StreamCorruptedException(</span><br><span class="line">                            &quot;unexpected block data&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                case TC_ENDBLOCKDATA:</span><br><span class="line">                    if (oldMode) &#123;</span><br><span class="line">                        throw new OptionalDataException(true);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        throw new StreamCorruptedException(</span><br><span class="line">                            &quot;unexpected end of block data&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                default:</span><br><span class="line">                    throw new StreamCorruptedException(</span><br><span class="line">                        String.format(&quot;invalid type code: %02X&quot;, tc));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            depth--;</span><br><span class="line">            bin.setBlockDataMode(oldMode);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在源码中看到了TC_OBJECT中判断，调用了readOrdinaryObject()方法，继续看源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">private Object readOrdinaryObject(boolean unshared)</span><br><span class="line">        throws IOException</span><br><span class="line">    &#123;</span><br><span class="line">        if (bin.readByte() !&#x3D; TC_OBJECT) &#123;</span><br><span class="line">            throw new InternalError();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ObjectStreamClass desc &#x3D; readClassDesc(false);</span><br><span class="line">        desc.checkDeserialize();</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; cl &#x3D; desc.forClass();</span><br><span class="line">        if (cl &#x3D;&#x3D; String.class || cl &#x3D;&#x3D; Class.class</span><br><span class="line">                || cl &#x3D;&#x3D; ObjectStreamClass.class) &#123;</span><br><span class="line">            throw new InvalidClassException(&quot;invalid class descriptor&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object obj;</span><br><span class="line">        try &#123;</span><br><span class="line">            obj &#x3D; desc.isInstantiable() ? desc.newInstance() : null;</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            throw (IOException) new InvalidClassException(</span><br><span class="line">                desc.forClass().getName(),</span><br><span class="line">                &quot;unable to create instance&quot;).initCause(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        passHandle &#x3D; handles.assign(unshared ? unsharedMarker : obj);</span><br><span class="line">        ClassNotFoundException resolveEx &#x3D; desc.getResolveException();</span><br><span class="line">        if (resolveEx !&#x3D; null) &#123;</span><br><span class="line">            handles.markException(passHandle, resolveEx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (desc.isExternalizable()) &#123;</span><br><span class="line">            readExternalData((Externalizable) obj, desc);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            readSerialData(obj, desc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handles.finish(passHandle);</span><br><span class="line"></span><br><span class="line">        if (obj !&#x3D; null &amp;&amp;</span><br><span class="line">            handles.lookupException(passHandle) &#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">            desc.hasReadResolveMethod())</span><br><span class="line">        &#123;</span><br><span class="line">            Object rep &#x3D; desc.invokeReadResolve(obj);</span><br><span class="line">            if (unshared &amp;&amp; rep.getClass().isArray()) &#123;</span><br><span class="line">                rep &#x3D; cloneArray(rep);</span><br><span class="line">            &#125;</span><br><span class="line">            if (rep !&#x3D; obj) &#123;</span><br><span class="line">                &#x2F;&#x2F; Filter the replacement object</span><br><span class="line">                if (rep !&#x3D; null) &#123;</span><br><span class="line">                    if (rep.getClass().isArray()) &#123;</span><br><span class="line">                        filterCheck(rep.getClass(), Array.getLength(rep));</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        filterCheck(rep.getClass(), -1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                handles.setObject(passHandle, obj &#x3D; rep);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现调用了 ObjectStreamClass 的 isInstantiable()方法，而isInstantiable()里面的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">boolean isInstantiable() &#123;</span><br><span class="line">        requireInitialized();</span><br><span class="line">        return (cons !&#x3D; null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码看起来很简单，就是判断了以下构造方法是否为空，构造方法不为空就返回true。这样意味着，只要有无参构造方法就会实例化。</p>
<p>这个时候，其实还是没找到为什么加上readResolve()方法就避免了单例被破坏的真正原因。再回到ObjectInputStream的readOrdinaryObject()方法继续往下看：</p>
<p>判断无参构造方法是否存在之后，又调用了hasReadResolveMethod()方法，来看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">boolean hasReadResolveMethod() &#123;</span><br><span class="line">        requireInitialized();</span><br><span class="line">        return (readResolveMethod !&#x3D; null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑非常简单，就是判断 readResolveMethod 是否为空，不为空就返回 true。那么<br>readResolveMethod 是在哪里赋值的呢？通过全局查找找到了赋值代码在私有方法<br>ObjectStreamClass()方法中给 readResolveMethod 进行赋值，来看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readResolveMethod &#x3D; getInheritableMethod(</span><br><span class="line">                        cl, &quot;readResolve&quot;, null, Object.class);</span><br></pre></td></tr></table></figure>

<p>上面的逻辑其实就是通过反射找到一个无参的 readResolve()方法，并且保存下来。现在再回到 ObjectInputStream 的 readOrdinaryObject() 方法继续往下看，如果readResolve()存在则调用 invokeReadResolve()方法，来看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Object invokeReadResolve(Object obj)</span><br><span class="line">        throws IOException, UnsupportedOperationException</span><br><span class="line">    &#123;</span><br><span class="line">        requireInitialized();</span><br><span class="line">        if (readResolveMethod !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                return readResolveMethod.invoke(obj, (Object[]) null);</span><br><span class="line">            &#125; catch (InvocationTargetException ex) &#123;</span><br><span class="line">                Throwable th &#x3D; ex.getTargetException();</span><br><span class="line">                if (th instanceof ObjectStreamException) &#123;</span><br><span class="line">                    throw (ObjectStreamException) th;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throwMiscException(th);</span><br><span class="line">                    throw new InternalError(th);  &#x2F;&#x2F; never reached</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IllegalAccessException ex) &#123;</span><br><span class="line">                &#x2F;&#x2F; should not occur, as access checks have been suppressed</span><br><span class="line">                throw new InternalError(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在invokeReadResolve()方法中用反射调用了readResolveMethod方法。<br>通过 JDK 源码分析我们可以看出，虽然，增加readResolve()方法返回实例，解决了单例被破坏的问题。但是，我们通过分析源码以及调试，我们可以看到实际上实例化了两次，只不过新创建的对象没有被返回而已。那如果，创建对象的动作发生频率增大，就意味着内存分配开销也就随之增大，难道真的就没办法从根本上解决问题吗？下面我们来注册式单例也许能帮助到你。</p>
<h2 id="2-3-注册式单例"><a href="#2-3-注册式单例" class="headerlink" title="2.3 注册式单例"></a>2.3 注册式单例</h2><p>注册式单例又称登记式单例，就是将每一个实例都登记到一个地方，使用唯一标识获取实例。注册的方式有两种：一种为容器缓存，一种为枚举登记。先来看下枚举式单例的写法，创建EnumSingleton类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public enum EnumSingleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    private Object data;</span><br><span class="line"></span><br><span class="line">    public Object getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        this.data &#x3D; data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static EnumSingleton getInstance() &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试main方法；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            EnumSingleton instance1 &#x3D; null;</span><br><span class="line">            EnumSingleton instance2 &#x3D; EnumSingleton.getInstance();</span><br><span class="line">            instance2.setData(new Object());</span><br><span class="line">            FileOutputStream fos &#x3D; new FileOutputStream(&quot;EnumSingleton.obj&quot;);</span><br><span class="line">            ObjectOutputStream oos &#x3D; new ObjectOutputStream(fos);</span><br><span class="line">            oos.writeObject(instance2);</span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line">            FileInputStream fis &#x3D; new FileInputStream(&quot;EnumSingleton.obj&quot;);</span><br><span class="line">            ObjectInputStream ois &#x3D; new ObjectInputStream(fis);</span><br><span class="line">            instance1 &#x3D; (EnumSingleton) ois.readObject();</span><br><span class="line">            ois.close();</span><br><span class="line">            System.out.println(instance1.getData());</span><br><span class="line">            System.out.println(instance2.getData());</span><br><span class="line">            System.out.println(instance1.getData() &#x3D;&#x3D; instance2.getData());</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果是：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/20/17062cae761681fd?w=358&h=160&f=png&s=8735" alt=""></p>
<p>没有做任何的处理，我们发现运行的结果和我们预期的一样。那么枚举式单例如此神奇，它的神秘之处体现在哪呢？下面我们就通过分析源码来揭开它的神秘面纱。<br>我们使用jad反编译工具（<a href="https://varaneckas.com/jad/）" target="_blank" rel="noopener">https://varaneckas.com/jad/）</a>      生成的EnumSingleton.jad文件，打开这个文件发现这一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static</span><br><span class="line">&#123;</span><br><span class="line">    INSTANCE &#x3D; new EnumSingleton(&quot;INSTANCE&quot;, 0);</span><br><span class="line">    $VALUES &#x3D; (new EnumSingleton[] &#123;</span><br><span class="line">    INSTANCE</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现<strong>枚举单例在静态模块中就给INSTANCE进行了赋值，是饿汉式单例的实现。</strong> 我们回想序列化能否破坏枚举式单例呢？再回到之前的源码ObjectInputStream的readObject0()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private Object readObject0(boolean unshared) throws IOException &#123;</span><br><span class="line">...</span><br><span class="line">    case TC_ENUM:</span><br><span class="line">        return checkResolve(readEnum(unshared));</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们看到在 readObject0()中调用了 readEnum()方法，来看readEnum()中代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private Enum&lt;?&gt; readEnum(boolean unshared) throws IOException &#123;</span><br><span class="line">        if (bin.readByte() !&#x3D; TC_ENUM) &#123;</span><br><span class="line">            throw new InternalError();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ObjectStreamClass desc &#x3D; readClassDesc(false);</span><br><span class="line">        if (!desc.isEnum()) &#123;</span><br><span class="line">            throw new InvalidClassException(&quot;non-enum class: &quot; + desc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int enumHandle &#x3D; handles.assign(unshared ? unsharedMarker : null);</span><br><span class="line">        ClassNotFoundException resolveEx &#x3D; desc.getResolveException();</span><br><span class="line">        if (resolveEx !&#x3D; null) &#123;</span><br><span class="line">            handles.markException(enumHandle, resolveEx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String name &#x3D; readString(false);</span><br><span class="line">        Enum&lt;?&gt; result &#x3D; null;</span><br><span class="line">        Class&lt;?&gt; cl &#x3D; desc.forClass();</span><br><span class="line">        if (cl !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                Enum&lt;?&gt; en &#x3D; Enum.valueOf((Class)cl, name);</span><br><span class="line">                result &#x3D; en;</span><br><span class="line">            &#125; catch (IllegalArgumentException ex) &#123;</span><br><span class="line">                throw (IOException) new InvalidObjectException(</span><br><span class="line">                    &quot;enum constant &quot; + name + &quot; does not exist in &quot; +</span><br><span class="line">                    cl).initCause(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!unshared) &#123;</span><br><span class="line">                handles.setObject(enumHandle, result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handles.finish(enumHandle);</span><br><span class="line">        passHandle &#x3D; enumHandle;</span><br><span class="line">        return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>发现枚举类型其实是通过类名和class对象找到一个唯一的枚举对象。</strong> 因此，枚举对象不可能被加载器加载多次。那么反射能破坏枚举式单例吗？来看一下测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class clazz &#x3D; EnumSingleton.class;</span><br><span class="line">            Constructor c &#x3D; clazz.getDeclaredConstructor();</span><br><span class="line">            c.newInstance();</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/21/17065f63d5f340c8?w=1027&h=181&f=png&s=32397" alt=""></p>
<p>报的是 java.lang.NoSuchMethodException 异常，意思是没找到无参的构造方法。我们打开 java.lang.Enum 的源码代码，查看它的构造方法，只有一个 protected的构造方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected Enum(String name, int ordinal) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.ordinal &#x3D; ordinal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那我们再做这样一个测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class clazz &#x3D; EnumSingleton.class;</span><br><span class="line">            Constructor c &#x3D; clazz.getDeclaredConstructor(String.class, int.class);</span><br><span class="line">            c.setAccessible(true);</span><br><span class="line">            EnumSingleton enumSingleton &#x3D; (EnumSingleton)c.newInstance(&quot;Kevin&quot;, 123);</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果是：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/21/17066033cb7d990b?w=1615&h=94&f=png&s=19094" alt=""></p>
<p>这时错误已经非常明显了，告诉我们 Cannot reflectively create enum objects，<strong>不能用反射来创建枚举类型</strong>。还是看下JDK源码，看下Constructor类的newInstance()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public T newInstance(Object ... initargs)</span><br><span class="line">        throws InstantiationException, IllegalAccessException,</span><br><span class="line">               IllegalArgumentException, InvocationTargetException</span><br><span class="line">    &#123;</span><br><span class="line">        if (!override) &#123;</span><br><span class="line">            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">                Class&lt;?&gt; caller &#x3D; Reflection.getCallerClass();</span><br><span class="line">                checkAccess(caller, clazz, null, modifiers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((clazz.getModifiers() &amp; Modifier.ENUM) !&#x3D; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;);</span><br><span class="line">        ConstructorAccessor ca &#x3D; constructorAccessor;   &#x2F;&#x2F; read volatile</span><br><span class="line">        if (ca &#x3D;&#x3D; null) &#123;</span><br><span class="line">            ca &#x3D; acquireConstructorAccessor();</span><br><span class="line">        &#125;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        T inst &#x3D; (T) ca.newInstance(initargs);</span><br><span class="line">        return inst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在newInstance()方法中做了强制性的判断，如果修饰符Modifier.ENUM枚举类型，直接抛出异常。到此为止，我们应该非常清晰明了了。</p>
<p>枚举类型单例也是《Effective Java》书中非常推荐的一种单例的实现写法。在 JDK 枚举的语法特殊性，以及反射也为枚举保驾护航，让枚举式单例成为一种比较优雅的实现。</p>
<p>注册式单例还有另外一种写法，容器缓存的写法，创建ContainerSingleton类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ContainerSingleton &#123;</span><br><span class="line"></span><br><span class="line">    private ContainerSingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static Map&lt;String, Object&gt; ioc &#x3D; new ConcurrentHashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    public static Object getBean(String className) &#123;</span><br><span class="line">        synchronized (ioc) &#123;</span><br><span class="line">            if(!ioc.containsKey(className)) &#123;</span><br><span class="line">                Object object &#x3D; null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    object &#x3D; Class.forName(className).newInstance();</span><br><span class="line">                    ioc.put(className, object);</span><br><span class="line">                &#125; catch (InstantiationException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                return object;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                return ioc.get(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>容器式写法适用于创建实例非常多的情况，便于管理。但是，是非线程安全的。到此，注册式单例介绍完毕。</p>
<p>来看看 <strong>Spring 中的容器式单例</strong> 的实现代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory implements AutowireCapableBeanFactory &#123;</span><br><span class="line">    &#x2F;** Cache of unfinished FactoryBean instances: FactoryBean name --&gt; BeanWrapper *&#x2F;</span><br><span class="line">    private final Map&lt;String, BeanWrapper&gt; factoryBeanInstanceCache &#x3D; new ConcurrentHashMap&lt;&gt;(16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-ThreadLocal-线程单例"><a href="#2-4-ThreadLocal-线程单例" class="headerlink" title="2.4 ThreadLocal 线程单例"></a>2.4 ThreadLocal 线程单例</h2><p><strong>ThreadLocal不能保证其创建的对象是全局唯一的，但是能保证在单个线程中是唯一的，天生的线程安全。</strong> 下面来看下示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocalSingleton &#123;</span><br><span class="line"></span><br><span class="line">    private static final ThreadLocal&lt;ThreadLocalSingleton&gt; instance &#x3D; new</span><br><span class="line">            ThreadLocal&lt;ThreadLocalSingleton&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                protected ThreadLocalSingleton initialValue() &#123;</span><br><span class="line">                    return new ThreadLocalSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">    private ThreadLocalSingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static ThreadLocalSingleton getInstance() &#123;</span><br><span class="line">        return instance.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写一下测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;begin&quot;);</span><br><span class="line">        System.out.println(ThreadLocalSingleton.getInstance());</span><br><span class="line">        System.out.println(ThreadLocalSingleton.getInstance());</span><br><span class="line">        System.out.println(ThreadLocalSingleton.getInstance());</span><br><span class="line">        System.out.println(ThreadLocalSingleton.getInstance());</span><br><span class="line">        System.out.println(ThreadLocalSingleton.getInstance());</span><br><span class="line"></span><br><span class="line">        Thread t1 &#x3D; new Thread(new ExectorThread());</span><br><span class="line">        Thread t2 &#x3D; new Thread(new ExectorThread());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/21/170668670edc458f?w=700&h=409&f=png&s=53862" alt=""></p>
<p>在主线程 main 中无论调用多少次，获取到的实例都是同一个，都在两个子线程中分别获取到了不同的实例。那么ThreadLocal是如果实现这样的效果的呢？我们知道上面的<strong>单例模式为了达到线程安全的目的，给方法上锁，以时间换空间。</strong> ThreadLocal将所有的对象全部放在ThreadLocalMap中，为每个线程都提供一个对象，实际上是以空间换时间来实现线程间隔离的。</p>
<h1 id="三、单例模式总结"><a href="#三、单例模式总结" class="headerlink" title="三、单例模式总结"></a>三、单例模式总结</h1><p>单例模式可以保证内存里只有一个实例，减少了内存开销；可以避免对资源的多重占用。单例模式看起来非常简单，实现起来其实也非常简单。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/02/21/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E7%BB%8F%E5%85%B8%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="ck7ih9d86000e1ora19936z0l" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，经典框架都在用的工厂模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/21/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E7%BB%8F%E5%85%B8%E6%A1%86%E6%9E%B6%E9%83%BD%E5%9C%A8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-02-21T07:55:01.000Z" itemprop="datePublished">2020-02-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/21/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E7%BB%8F%E5%85%B8%E6%A1%86%E6%9E%B6%E9%83%BD%E5%9C%A8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，经典框架都在用的工厂模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、经典框架都在用设计模式解决问题"><a href="#一、经典框架都在用设计模式解决问题" class="headerlink" title="一、经典框架都在用设计模式解决问题"></a>一、经典框架都在用设计模式解决问题</h1><p>Spring就是一个把设计模式用的淋漓尽致的经典框架，其实从类的名称就能够看出来，我们来一一列举一下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/19/1705c4fe88d41ff7?w=946&h=476&f=png&s=21565" alt=""></p>
<p><strong>特别需要说明的是，设计模式从来都不是单个设计模式独立使用的。</strong> 在通常情况下，经常是多个设计模式混合使用，<strong>你中有我，我中有你</strong>。所有的设计模式讲解都会围绕Spring的IOC、AOP、JDBC、MVC来进行展开。设计模式根据设计类型进行分类如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/19/1705c5a0b678e0f8?w=721&h=433&f=png&s=47142" alt=""></p>
<h1 id="二、工厂模式详解"><a href="#二、工厂模式详解" class="headerlink" title="二、工厂模式详解"></a>二、工厂模式详解</h1><h2 id="2-1-工厂模式的由来"><a href="#2-1-工厂模式的由来" class="headerlink" title="2.1 工厂模式的由来"></a>2.1 工厂模式的由来</h2><p>在我们的现实生活当中，原始社会自给自足（没有工厂）、农耕社会的小作坊（简单工厂，民间酒坊）、工业革命流水线（工厂方法，自产自销）、现代产业链工厂（抽象工厂，富士康）</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/19/1705c649df25e7dd?w=1000&h=562&f=png&s=915663" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/2/19/1705c65b429988c0?w=900&h=600&f=png&s=699085" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/2/19/1705c66e7a3c0afb?w=475&h=261&f=png&s=155298" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/2/19/1705c6777f3ecf54?w=640&h=345&f=png&s=503072" alt=""></p>
<p>从现实生活联想到我们项目中的代码同样也是由简而繁一步一步迭代而来的，但是对于调用者确是越来越简单化。</p>
<h2 id="2-2-简单工厂模式（Simple-Factory-Pattern）"><a href="#2-2-简单工厂模式（Simple-Factory-Pattern）" class="headerlink" title="2.2 简单工厂模式（Simple Factory Pattern）"></a>2.2 简单工厂模式（Simple Factory Pattern）</h2><p>简单工厂模式是指由一个工厂对象决定创建出哪一种产品的实例，但它不属于GOF，23设计模式。</p>
<p>参考资料维基百科地址：<a href="https://en.wikipedia.org/wiki/Design_Patterns#Patterns_by_Type" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Design_Patterns#Patterns_by_Type</a></p>
<p>简单工厂模式适用于工厂类负责创建的对象较少的场景，且客户端只需要传入工厂类的参数，对于如何创建对象的逻辑不需要关系。</p>
<p>接下来我们来举例，以高中学校课程为例。语文、数学、英语等多门学科。我们可以定义一个课程标准ICourse接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface ICourse &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 学习课程</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void study();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个语文课的实现ChineseCourse类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ChineseCourse implements ICourse &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void study() &#123;</span><br><span class="line">        System.out.println(&quot;学习语文课&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ICourse course &#x3D; new ChineseCourse();</span><br><span class="line">        course.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看上面的main方法中，应用层的代码需要依赖ChineseCourse，如果业务扩展，会继续增加MathCourse甚至更多，这样的话客户端的依赖会越来越臃肿的。所以我们需要对创建代码的细节进行隐藏，我们使用简单工厂模式对代码进行优化。先添加MathCourse类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MathCourse implements ICourse &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void study() &#123;</span><br><span class="line">        System.out.println(&quot;学习数学课&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建CourseFactory工厂类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class CourseFactory &#123;</span><br><span class="line">    public ICourse create(String name) &#123;</span><br><span class="line">        if(&quot;chinese&quot;.equals(name)) &#123;</span><br><span class="line">            return new ChineseCourse();</span><br><span class="line">        &#125;else if(&quot;math&quot;.equals(name)) &#123;</span><br><span class="line">            return new MathCourse();</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mian方法调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">        CourseFactory courseFactory &#x3D; new CourseFactory();</span><br><span class="line">        courseFactory.create(&quot;chinese&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用是简单了，但是我们的业务继续扩展，需要增加英文课，那么工厂中的create()方法要根据增加的业务每次都修改代码逻辑，不符合开闭原则。因此，我们还需要对简单工厂进行优化，利用反射技术：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class CourseFactory &#123;</span><br><span class="line"></span><br><span class="line">    public ICourse create(String className) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if(!(null &#x3D;&#x3D; className || &quot;&quot;.equals(className))) &#123;</span><br><span class="line">                    return (ICourse) Class.forName(className).newInstance();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InstantiationException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CourseFactory courseFactory &#x3D; new CourseFactory();</span><br><span class="line">        ICourse course &#x3D; courseFactory.create(&quot;com.sfp.ChineseCourse&quot;);</span><br><span class="line">        course.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化之后，课程不断增加不需要修改CourseFactory中的代码了。但是，方法参数是字符串，可控性有待提高，而且还需进行强制转换。再次修改代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class CourseFactory &#123;</span><br><span class="line"></span><br><span class="line">    public ICourse create(Class&lt;? extends ICourse&gt; clazz) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if(null !&#x3D; clazz) &#123;</span><br><span class="line">                return clazz.newInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CourseFactory courseFactory &#x3D; new CourseFactory();</span><br><span class="line">        ICourse course &#x3D; courseFactory.create(ChineseCourse.class);</span><br><span class="line">        course.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单工厂模式的例子无处不在，现在我们来看JDK当中的类使用简单工厂模式的例子，例如Calendar类，其中Calendar.getInstance()方法，我们查看源码具体的实现步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">private static Calendar createCalendar(TimeZone zone,</span><br><span class="line">                                           Locale aLocale)</span><br><span class="line">    &#123;</span><br><span class="line">        CalendarProvider provider &#x3D;</span><br><span class="line">            LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)</span><br><span class="line">                                 .getCalendarProvider();</span><br><span class="line">        if (provider !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                return provider.getInstance(zone, aLocale);</span><br><span class="line">            &#125; catch (IllegalArgumentException iae) &#123;</span><br><span class="line">                &#x2F;&#x2F; fall back to the default instantiation</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Calendar cal &#x3D; null;</span><br><span class="line"></span><br><span class="line">        if (aLocale.hasExtensions()) &#123;</span><br><span class="line">            String caltype &#x3D; aLocale.getUnicodeLocaleType(&quot;ca&quot;);</span><br><span class="line">            if (caltype !&#x3D; null) &#123;</span><br><span class="line">                switch (caltype) &#123;</span><br><span class="line">                case &quot;buddhist&quot;:</span><br><span class="line">                cal &#x3D; new BuddhistCalendar(zone, aLocale);</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;japanese&quot;:</span><br><span class="line">                    cal &#x3D; new JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;gregory&quot;:</span><br><span class="line">                    cal &#x3D; new GregorianCalendar(zone, aLocale);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (cal &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; If no known calendar type is explicitly specified,</span><br><span class="line">            &#x2F;&#x2F; perform the traditional way to create a Calendar:</span><br><span class="line">            &#x2F;&#x2F; create a BuddhistCalendar for th_TH locale,</span><br><span class="line">            &#x2F;&#x2F; a JapaneseImperialCalendar for ja_JP_JP locale, or</span><br><span class="line">            &#x2F;&#x2F; a GregorianCalendar for any other locales.</span><br><span class="line">            &#x2F;&#x2F; NOTE: The language, country and variant strings are interned.</span><br><span class="line">            if (aLocale.getLanguage() &#x3D;&#x3D; &quot;th&quot; &amp;&amp; aLocale.getCountry() &#x3D;&#x3D; &quot;TH&quot;) &#123;</span><br><span class="line">                cal &#x3D; new BuddhistCalendar(zone, aLocale);</span><br><span class="line">            &#125; else if (aLocale.getVariant() &#x3D;&#x3D; &quot;JP&quot; &amp;&amp; aLocale.getLanguage() &#x3D;&#x3D; &quot;ja&quot;</span><br><span class="line">                       &amp;&amp; aLocale.getCountry() &#x3D;&#x3D; &quot;JP&quot;) &#123;</span><br><span class="line">                cal &#x3D; new JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cal &#x3D; new GregorianCalendar(zone, aLocale);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cal;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>还有一个大家经常使用的logback，我们可以看到LoggerFactory中有多个重载的方法getLogger():</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Logger getLogger(String name) &#123;</span><br><span class="line">    ILoggerFactory iLoggerFactory &#x3D; getILoggerFactory();</span><br><span class="line">    return iLoggerFactory.getLogger(name);</span><br><span class="line">&#125;</span><br><span class="line">public static Logger getLogger(Class clazz) &#123;</span><br><span class="line">    return getLogger(clazz.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单工厂的缺点：工厂的职责相对过重，不易于扩展过于复杂的代码结构。</p>
<h2 id="2-3-工厂方法模式（Factory-Method-Pattern）"><a href="#2-3-工厂方法模式（Factory-Method-Pattern）" class="headerlink" title="2.3 工厂方法模式（Factory Method Pattern）"></a>2.3 工厂方法模式（Factory Method Pattern）</h2><p>工厂方法模式是指<strong>定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。</strong> 在工厂方法模式中只关心所需产品对应的工厂，无心关注创建细节，而加入新的产品符合开闭原则。</p>
<p>工厂方式模式主要解决产品扩展的问题，根据单一职责原则将职能进行拆分，专人干专事。语文课由语文工厂创建，数据课由数学工厂创建，对工厂本身做一个抽象。示例代码如下：</p>
<p>创建ICourseFactory接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface ICourseFacotry &#123;</span><br><span class="line"></span><br><span class="line">    ICourse create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再分别创建子工厂，ChineseCourseFactory类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ChineseCourseFactory implements ICourseFacotry &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ICourse create() &#123;</span><br><span class="line">        return new ChineseCourse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MathCourseFactory类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MathCourseFactory implements ICourseFacotry &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ICourse create() &#123;</span><br><span class="line">        return new MathCourse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">     ICourseFacotry chineseCourseFactory &#x3D; new ChineseCourseFactory();</span><br><span class="line">     ICourse chineseCourse &#x3D; chineseCourseFactory.create();</span><br><span class="line">     chineseCourse.study();</span><br><span class="line">     </span><br><span class="line">     ICourseFacotry mathCourseFactory &#x3D; new MathCourseFactory();</span><br><span class="line">     ICourse mathCourse &#x3D; mathCourseFactory.create();</span><br><span class="line">     mathCourse.study();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-抽象工厂模式（Abstract-Factory-Pattern）"><a href="#2-4-抽象工厂模式（Abstract-Factory-Pattern）" class="headerlink" title="2.4 抽象工厂模式（Abstract Factory Pattern）"></a>2.4 抽象工厂模式（Abstract Factory Pattern）</h2><p>抽象工厂模式是指<strong>提供一个创建一系列相关或相互依赖对象的接口，无需指定它们具体的类。</strong> 客户端（应用层）不依赖于产品实例如何被创建、实现等细节，强调的是一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复的代码。需要提供一个产品库的类，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</p>
<p>我们还是以课程的例子为例，现在是新冠状病毒疫情的时期，高中学生只能在家利用互联网进行在线直播上课，每个课程不仅要提供课程的录播视频，而且还要提供老师的课堂笔记。相当于现在的业务变更为同一个课程不单纯是课程信息，同时要包括录播视频、课堂笔记等才是一个完整的课程。在产品等级中增加两个产品接口Ivideo录播视频和INote课堂笔记。</p>
<p>Ivideo接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IVideo &#123;</span><br><span class="line"></span><br><span class="line">    void record();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>INote接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface INote &#123;</span><br><span class="line"></span><br><span class="line">    void edit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建抽象工厂类CourseFactory类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface CourseFactory &#123;</span><br><span class="line"></span><br><span class="line">    IVideo createVideo();</span><br><span class="line"></span><br><span class="line">    INote createNote();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建语文课产品族，语文课视频的ChineseVideo类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ChineseVideo implements IVideo &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void record() &#123;</span><br><span class="line">        System.out.println(&quot;录制语文课视频！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建语文课课堂笔记的ChineseNote类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ChineseNote implements INote &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void edit() &#123;</span><br><span class="line">        System.out.println(&quot;编写语文课笔记！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建语文课产品族的具体工厂类ChineseCourseFactory：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ChineseCourseFactory implements CourseFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public IVideo createVideo() &#123;</span><br><span class="line">        return new ChineseVideo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public INote createNote() &#123;</span><br><span class="line">        return new ChineseNote();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再创建数学产品，Math视频MathVideo类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MathVideo implements IVideo &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void record() &#123;</span><br><span class="line">        System.out.println(&quot;录制数学课视频！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建数学课堂笔记的MathNote类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MathNote implements INote &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void edit() &#123;</span><br><span class="line">        System.out.println(&quot;编写数学课笔记！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建数学课产品族的具体工厂类MathCourseFactory：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class MathCourseFactory implements CourseFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public IVideo createVideo() &#123;</span><br><span class="line">        return new MathVideo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public INote createNote() &#123;</span><br><span class="line">        return new MathNote();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MathCourseFactory mathCourseFactory &#x3D; new MathCourseFactory();</span><br><span class="line">        mathCourseFactory.createNote().edit();</span><br><span class="line">        mathCourseFactory.createVideo().record();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的案例代码完整的描述了两个产品族语文课程和数学课程，也描述了两个产品等级的视频和课堂笔记。抽象工厂非常完美清晰地描述了这一层复杂的关系。如果我们再升级扩展产品等级，将课堂作业也加入到课程中，我们的代码需要从抽象工厂，到具体的工厂都要进行调整，很显然不符合开闭原则。所以抽象工厂也是有缺点的：</p>
<p>1、规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口。</p>
<p>2、增加了系统的抽象性和理解难度。</p>
<h1 id="三、工厂模式总结"><a href="#三、工厂模式总结" class="headerlink" title="三、工厂模式总结"></a>三、工厂模式总结</h1><p><img src="https://user-gold-cdn.xitu.io/2020/2/20/17061184a4c31ec2?w=1465&h=535&f=png&s=108016" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/02/21/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E7%BB%8F%E5%85%B8%E6%A1%86%E6%9E%B6%E9%83%BD%E5%9C%A8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="ck7ih9d7v000a1ora44hp1r5j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，软件架构设计的七大原则精选案例" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/19/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%E7%B2%BE%E9%80%89%E6%A1%88%E4%BE%8B/" class="article-date">
  <time datetime="2020-02-19T06:43:44.000Z" itemprop="datePublished">2020-02-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/19/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%E7%B2%BE%E9%80%89%E6%A1%88%E4%BE%8B/">架构师内功心法，软件架构设计的七大原则精选案例</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、软件架构设计的七大原则简介"><a href="#一、软件架构设计的七大原则简介" class="headerlink" title="一、软件架构设计的七大原则简介"></a>一、软件架构设计的七大原则简介</h1><p><img src="https://user-gold-cdn.xitu.io/2020/2/17/17052b314ab91c9f?w=1018&h=812&f=png&s=43050" alt=""></p>
<h2 id="1-1-开闭原则（Open-Closed-Principle，OCP）"><a href="#1-1-开闭原则（Open-Closed-Principle，OCP）" class="headerlink" title="1.1 开闭原则（Open-Closed Principle，OCP）"></a>1.1 开闭原则（Open-Closed Principle，OCP）</h2><p>开闭原则是一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。所谓的开闭也是对扩展和修改两个行为的一个原则。强调是用抽象扩展架构，用实现扩展细节。可以提高软件系统的可复用性及可维护性。开闭原则，是面向对象设计中最基础的设计原则。它指导我们如何建立稳定灵活的系统，例如：<strong>版本更新，我们尽可能不修改代码，但是可以增加新功能。</strong></p>
<p>在现实生活中也有很多开闭原则的例子，比如，很多互联网公司都实行弹性的工作时间，规定每天工作8小时。意思就是说，对于工作日每天工作8小时这个规定是关闭的，但是你什么时候来，什么时候走是开放的。早来早走，晚来晚走。</p>
<p>实现开闭原则的核心思想就是面向抽象编程，以某新华书店的图书为例，首先创建一个课程接口类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class IBook &#123;</span><br><span class="line">    Integer getId();</span><br><span class="line">    String getName();</span><br><span class="line">    Double getPrice();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来创建一个计算机图书的类ComputerBook：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class ComputerBook implements IBook &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    protected Double price;</span><br><span class="line">    public ComputerBook(Integer id, String name, Double price) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.price &#x3D; price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return this.id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Double getPrice() &#123;</span><br><span class="line">        return this.price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们要给计算机类的图书做活动，价格优惠。如果修改ComputerBook类的getPrice()方法，则会存在一定的风险，可能会影响其它地方的调用结果。我们如何在不修改原有代码的前提下，实现价格优惠这个功能呢？现在，我们再写一个处理优惠逻辑的类，ComputerDiscountBook类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ComputerDiscountBook extends ComputerBook &#123;</span><br><span class="line">    public ComputerDiscountBook(Integer id, String name, Double price) &#123;</span><br><span class="line">        super(id, name, price);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Double getOriginPrice() &#123;</span><br><span class="line">        return super.price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Double getPrice() &#123;</span><br><span class="line">        return super.price * 0.8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/2/17/170533730e78204e?w=667&h=742&f=png&s=45090" alt=""></p>
<h2 id="1-2-依赖倒置原则（Dependence-Inversion-Principle，DIP）"><a href="#1-2-依赖倒置原则（Dependence-Inversion-Principle，DIP）" class="headerlink" title="1.2 依赖倒置原则（Dependence Inversion Principle，DIP）"></a>1.2 依赖倒置原则（Dependence Inversion Principle，DIP）</h2><p>依赖倒置原则是指设计代码结构时，高层模块不应该依赖底层模块，二者都应该依赖其抽象。抽象不应该依赖细节；细节应该依赖抽象。通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，并能够降低修改程序所造成的风险。</p>
<p>还是以课程为例，创建一个类Kevin：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Kevin &#123;</span><br><span class="line"></span><br><span class="line">    public void readComputerBook() &#123;</span><br><span class="line">        System.out.println(&quot;Kevin正在阅读电脑书籍&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void readScienceBook() &#123;</span><br><span class="line">        System.out.println(&quot;Kevin正在阅读科学书籍&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Kevin kevin &#x3D; new Kevin();</span><br><span class="line">        kevin.readComputerBook();</span><br><span class="line">        kevin.readScienceBook();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kevin正在阅读电脑书籍和科学书籍。大家知道电脑书籍的种类很多，现在人工智能AI这么火热，Kevin想学习关于人工智能方面的电脑书籍。这个时候，业务需要扩展，我们需要从底层到调用层一次修改代码来满足业务要求。在Kevin中增加readAIBook（）的方法，在调用层也要追加调用。这样一来，系统发布的时候，实际上不是很稳定。如何优化我们的代码，创建一个书籍的抽象IBook接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IBook &#123;</span><br><span class="line"></span><br><span class="line">    void read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后写ComputerBook类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ComputerBook implements IBook &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void read() &#123;</span><br><span class="line">        System.out.println(&quot;Kevin正在阅读电脑书籍&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再写ScienceBook类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ScienceBook implements IBook &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void read() &#123;</span><br><span class="line">        System.out.printf(&quot;Kevin正在阅读科学书籍&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改Kevin类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Kevin &#123;</span><br><span class="line"></span><br><span class="line">    public void read(IBook book) &#123;</span><br><span class="line">        book.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Kevin kevin &#x3D; new Kevin();</span><br><span class="line">        kevin.read(new ComputerBook());</span><br><span class="line">        kevin.read(new ScienceBook());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看main方法调用，无论Kevin想读哪些类的新书，只需要创建一个类，通过传参的方式告诉Kevin，而不需要修改底层代码来实现。这种实现方式叫做依赖注入。注入的方式有构造器注入和setter注入两种方式。</p>
<p>构造器注入实现方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Kevin &#123;</span><br><span class="line"></span><br><span class="line">    public IBook book;</span><br><span class="line"></span><br><span class="line">    public Kevin(IBook book) &#123;</span><br><span class="line">        this.book &#x3D; book;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void read() &#123;</span><br><span class="line">        book.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Kevin kevin &#x3D; new Kevin(new ComputerBook());</span><br><span class="line">        kevin.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据构造器注入，在调用时，每次都需要创建实例。如果Kevin是全局单例的话，则只能选择Setter方式来注入，继续修改Kevin类的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Kevin &#123;</span><br><span class="line"></span><br><span class="line">    public IBook book;</span><br><span class="line"></span><br><span class="line">    public void setBook(IBook book) &#123;</span><br><span class="line">        this.book &#x3D; book;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void read() &#123;</span><br><span class="line">        book.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Kevin kevin &#x3D; new Kevin();</span><br><span class="line">        kevin.setBook(new ComputerBook());</span><br><span class="line">        kevin.read();</span><br><span class="line"></span><br><span class="line">        kevin.setBook(new ScienceBook());</span><br><span class="line">        kevin.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>以抽象为基准比以细节为基准搭建起来的代码架构要稳定得多，因此拿到需求任务后，要面向接口编程，先设计顶层再琢磨细节来设计代码结构。</strong></p>
<h2 id="1-3-单一职责原则（Simple-Responsibility-Principle，SRP）"><a href="#1-3-单一职责原则（Simple-Responsibility-Principle，SRP）" class="headerlink" title="1.3 单一职责原则（Simple Responsibility Principle，SRP）"></a>1.3 单一职责原则（Simple Responsibility Principle，SRP）</h2><p>单一职责原则是值不要存在多于一个导致类变更的原因。假设我们有一个类要负责两个职责，一旦发生需求变更，修改其中一个职责的逻辑代码，有可能会导致另一个职责的功能发生故障。这样一来，这个类存在两个导致类变更的原因。怎么来解决这个问题呢？就需要给两个职责分别用两个类来实现，进行解耦。后期需求维护相互不受影响。这样的设计，可以降低类的复杂度，提高类的可读性，提高系统的可维护性，降低变更引起的风险。总体来说就是一个<strong>class/interface/mothod</strong>只负责一项职责。<br>这里用在线直播课程的案例来举例，课程有在线直播课和录播课。直播课不能快进和后退，录播课程可以任意的反复观看，功能职责不一样。创建一个Course类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Course &#123;</span><br><span class="line"></span><br><span class="line">    public static final String COURSE_NAME &#x3D; &quot;直播课&quot;;</span><br><span class="line"></span><br><span class="line">    public void study(String courseName) &#123;</span><br><span class="line">        if(COURSE_NAME.equals(courseName)) &#123;</span><br><span class="line">            System.out.println(courseName + &quot;不能快进和快退&quot;);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            System.out.println(courseName + &quot;可以反复观看&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Course course &#x3D; new Course();</span><br><span class="line">        course.study(&quot;直播课&quot;);</span><br><span class="line">        course.study(&quot;录播课&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码看，Course类承担了两种逻辑。现在需要对课程进行加密，那么直播课和录播课的加密逻辑是不一样的，必须要修改代码。而修改代码逻辑必然会相互影响并且容易造成风险。我们对职责进行解耦，分别创建LiveCourse和ReplayCourse两个类：</p>
<p>LiveCourse类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class LiveCourse &#123;</span><br><span class="line"></span><br><span class="line">    public void study(String courseName) &#123;</span><br><span class="line">        System.out.println(courseName + &quot;不能快进和快退&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReplayCourse类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ReplayCourse &#123;</span><br><span class="line"></span><br><span class="line">    public void study(String courseName) &#123;</span><br><span class="line">        System.out.println(courseName + &quot;可以反复观看&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">     LiveCourse liveCourse &#x3D; new LiveCourse();</span><br><span class="line">     liveCourse.study(&quot;直播课&quot;);</span><br><span class="line">     ReplayCourse replayCourse &#x3D; new ReplayCourse();</span><br><span class="line">     replayCourse.study(&quot;录播课&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随着业务的发展，课程也要做权限。没有付费的vip会员可以获取课程基本信息，已经付费的vip会员可以获得视频流，即获得视频观看权限。对于控制课程层面上至少有两个职责。我们可以把展示职责和管理职责分离出来，实现同一个抽象依赖。设计一个顶层接口，创建ICourse接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public interface ICourse &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获得课程信息</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    String getCourseName();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获得视频流</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    byte[] getCourseVideo();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 学习课程</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void studyCourse();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 退款</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void refundCourse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以把这个接口拆成两个接口，创建一个接口ICourseInfo和ICourseManager：</p>
<p>接口ICourseInfo：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface ICourseInfo &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获得课程信息</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    String getCourseName();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获得视频流</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    byte[] getCourseVideo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口ICourseManager：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface ICourseManager &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 学习课程</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void studyCourse();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 退款</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void refundCourse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来看下方法层面的单一职责的代码设计。有时候我们为了偷懒，通常会把方法写成下面这样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void mofifyUserInfo(String userName, String address) &#123;</span><br><span class="line">    userName &#x3D; &quot;Kevin&quot;;</span><br><span class="line">    address &#x3D; &quot;Beijing&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可能写成这样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void modifyUserInfo(String userName, String... fields) &#123;</span><br><span class="line">    userName &#x3D; &quot;Kevin&quot;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void modifyUserInfo(String userName, String address, boolean bool) &#123;</span><br><span class="line">    if(bool) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    userName &#x3D; &quot;Kevin&quot;;</span><br><span class="line">    address &#x3D; &quot;Beijing&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然上面的modifyUserInfo()方法中承担了多个职责，既可以修改userName，也可以修改address，甚至更多的值，明显不符合单一职责。这样我们需要对代码进行修改，把这个方法拆分成两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void modifyUserName(String userName) &#123;</span><br><span class="line">    userName &#x3D; &quot;Kevin&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void modifyAddress(String address) &#123;</span><br><span class="line">    address &#x3D; &quot;Beijing&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改之后的代码看起来简单，且维护起来更加容易。但是，<strong>我们在实际开发项目过程中，项目直接会相互依赖，组合、聚和这些关系，还有项目的规模，周期，技术人员的水平，对进度的把控，很多类都不符合单一职责。但是，我们在编码的过程中尽量做到单一职责，这样对我们项目的后期维护是有很大的帮助的。</strong></p>
<h2 id="1-4-接口隔离原则-（Interface-Segregation-Principle，ISP）"><a href="#1-4-接口隔离原则-（Interface-Segregation-Principle，ISP）" class="headerlink" title="1.4 接口隔离原则 （Interface Segregation Principle，ISP）"></a>1.4 接口隔离原则 （Interface Segregation Principle，ISP）</h2><p>接口隔离原则是指用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口。这个原则指导我们在设计接口的时候应该注意以下几点：</p>
<p>1、一个类对一类的依赖应该建立在最小的接口之上；</p>
<p>2、建立单一接口，不要建立庞大臃肿的接口；</p>
<p>3、尽量细化接口，接口中的方法尽量少（不是越少越好，要适度）。</p>
<p>接口隔离原则符合我们常说的<strong>高内聚低耦合</strong>的设计思想，从而使得类具有很好的可读性、可扩展性以及可维护性。在设计接口的时候，要多花时间去思考，要考虑业务模型，包括以后有可能发生变更的地方还要做一些预判。所以对于抽象，对于业务模型的理解是非常重要的。下面举例来看一个动物行为的抽象接口：</p>
<p>IAnimal接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface IAnimal &#123;</span><br><span class="line">    void eat();</span><br><span class="line">    void fly();</span><br><span class="line">    void swim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Bird 类实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Bird implements IAnimal &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void fly() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void swim() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dog 类实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Dog implements IAnimal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void fly() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void swim() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，Bird 的 swim()方法可能只能空着，Dog 的fly()方法显然不可能的。这时候，我们针对不同动物行为来设计不同的接口，分别设计 IEatAnimal，IFlyAnimal 和ISwimAnimal 接口，来看代码：</p>
<p>IEatAnimal接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IEatAnimal &#123;</span><br><span class="line">    void eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IFlyAnimal接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IFlyAnimal &#123;</span><br><span class="line">    void fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ISwimAnimal接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ISwimAnimal &#123;</span><br><span class="line">    void swim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dog 只实现 IEatAnimal 和 ISwimAnimal 接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Dog implements IEatAnimal, ISwimAnimal &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void swim() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-迪米特法则（Law-of-Demeter-LoD）"><a href="#1-5-迪米特法则（Law-of-Demeter-LoD）" class="headerlink" title="1.5 迪米特法则（Law of Demeter, LoD）"></a>1.5 迪米特法则（Law of Demeter, LoD）</h2><p>迪米特法则是指一个对象应该对其他对象保持最少的了解，又叫最少知道原则（Least Knowledge Principle， LKP），尽量降低类与类之间的耦合。<strong>主要强调只和朋友说话，不和陌生人说话。出现在成员变量、方法输入、输出参数中的类都可以称之为成员朋友类，而出现在方法体内部的类不属于朋友类。</strong></p>
<p>现在来设计一个权限系统，老板需要查看目前发布到线上的课程数量。这个老板找到项目负责人去进行统计，项目负责人再把统计结果告诉老板。来看一下代码示例：</p>
<p>Course类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class Course &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TeamLeader类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class TeamLeader &#123;</span><br><span class="line">    public void checkNumberOfCourses(List&lt;Course&gt; courseList)&#123;</span><br><span class="line">        System.out.println(&quot;目前已发布的课程数量是：&quot;+courseList.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Boss类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Boss &#123;</span><br><span class="line"></span><br><span class="line">    public void commandCheckNumber(TeamLeader teamLeader)&#123;</span><br><span class="line">        &#x2F;&#x2F;模拟 Boss 一页一页往下翻页，TeamLeader 实时统计</span><br><span class="line">        List&lt;Course&gt; courseList &#x3D; new ArrayList&lt;Course&gt;();</span><br><span class="line">        for (int i&#x3D; 0; i &lt; 10 ;i ++)&#123;</span><br><span class="line">            courseList.add(new Course());</span><br><span class="line">        &#125;</span><br><span class="line">        teamLeader.checkNumberOfCourses(courseList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Boss boss &#x3D; new Boss();</span><br><span class="line">        TeamLeader teamLeader &#x3D; new TeamLeader();</span><br><span class="line">        boss.commandCheckNumber(teamLeader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码根据迪米特原则，老板Boss只想要结果，不需要跟Course产生直接交流。而课程负责人统计要引用Course对象。Boss和Course并不是朋友，我们需要修改代码：</p>
<p>TeamLeader类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class TeamLeader &#123;</span><br><span class="line"></span><br><span class="line">    public void checkNumberOfCourses()&#123;</span><br><span class="line">        List&lt;Course&gt; courseList &#x3D; new ArrayList&lt;Course&gt;();</span><br><span class="line">        for(int i &#x3D; 0 ;i &lt; 10;i++)&#123;</span><br><span class="line">            courseList.add(new Course());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;目前已发布的课程数量是：&quot;+courseList.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Boss类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Boss &#123;</span><br><span class="line"></span><br><span class="line">    public void commandCheckNumber(TeamLeader teamLeader)&#123;</span><br><span class="line">        teamLeader.checkNumberOfCourses();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Boss boss &#x3D; new Boss();</span><br><span class="line">        TeamLeader teamLeader &#x3D; new TeamLeader();</span><br><span class="line">        boss.commandCheckNumber(teamLeader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>得到的：学习软件设计原则，千万不能形成强迫症。碰到业务复杂的场景，我们需要随机应变。</strong></p>
<h2 id="1-6-里氏替换原则（Liskov-Substitution-Principle，LSP）"><a href="#1-6-里氏替换原则（Liskov-Substitution-Principle，LSP）" class="headerlink" title="1.6 里氏替换原则（Liskov Substitution Principle，LSP）"></a>1.6 里氏替换原则（Liskov Substitution Principle，LSP）</h2><p>里氏替换原则是指如果对每一个类型T1的对象o1,都有类型为T2的对象o2,使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。</p>
<p>定义看上去还是比较抽象，可以理解为<strong>如果适应一个父类的话，那一定是适用于子类，所有的引用父类的地方必须能透明的使用子类的对象，子类对象能够替换父类对象，而程序逻辑不变。</strong> 总结一下：</p>
<p>引申含义：子类可以扩展父类的功能，但不能改变父类原有的功能。</p>
<p>1、子类可以实现父类的抽象方法，但不能覆盖父类的抽象方法；</p>
<p>2、子类中可以增加自己特有的方法；</p>
<p>3、当子类的方法覆盖父类的方法时，方法的前置条件（即方法的输入/入参）要比父类方法的输入参数更宽松；</p>
<p>4、当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的输出/返回值）要比父类更严格或者相等。</p>
<p>我们在开闭原则的代码案例中在获取折后时覆盖了父类的getPrice()方法，增加了一个获取优惠价格后的方法getOriginPrice(),显然就违背了里氏替换原则。接下来我们不覆盖getPrice()方法，增加getDiscountBook()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ComputerDiscountBook extends ComputerBook &#123;</span><br><span class="line">    public ComputerDiscountBook(Integer id, String name, Double price) &#123;</span><br><span class="line">        super(id, name, price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Double getDiscountBook() &#123;</span><br><span class="line">        return super.getPrice() * 0.8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用里氏替换原则有以下几个优点：</p>
<p>1、约束继承泛滥，开闭原则的一种体现；</p>
<p>2、加强程序的健壮性，同时变更时可以做到很好的兼容性，提高程序的维护性、扩展性。降低需求变更时引入的风险。</p>
<p>现在用正方形、矩形和四边形来说明里氏替换原则，我们都知道正方形是一个特殊的长方形，创建一个长方形父类Rectangle：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Rectangle &#123;</span><br><span class="line"></span><br><span class="line">    private long width;</span><br><span class="line"></span><br><span class="line">    private long height;</span><br><span class="line"></span><br><span class="line">    public long getWidth() &#123;</span><br><span class="line">        return width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setWidth(long width) &#123;</span><br><span class="line">        this.width &#x3D; width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getHeight() &#123;</span><br><span class="line">        return height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHeight(long height) &#123;</span><br><span class="line">        this.height &#x3D; height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建正方形Square类继承Rectangle长方形类，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Square extends Rectangle &#123;</span><br><span class="line"></span><br><span class="line">    private long length;</span><br><span class="line">    public long getLength() &#123;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setLength(long length) &#123;</span><br><span class="line">        this.length &#x3D; length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public long getWidth() &#123;</span><br><span class="line">        return getLength();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public long getHeight() &#123;</span><br><span class="line">        return getLength();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void setHeight(long height) &#123;</span><br><span class="line">        setLength(height);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void setWidth(long width) &#123;</span><br><span class="line">        setLength(width);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在测试类中创建 resize()方法，根据逻辑长方形的宽应该大于等于高，我们让高一直自增，知道高等于宽变成正方形：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void resize(Rectangle rectangle)&#123;</span><br><span class="line">        while (rectangle.getWidth() &gt;&#x3D; rectangle.getHeight())&#123;</span><br><span class="line">            rectangle.setHeight(rectangle.getHeight() + 1);</span><br><span class="line">            System.out.println(&quot;width:&quot;+rectangle.getWidth() + &quot;,height:&quot;+rectangle.getHeight());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;resize 方法结束&quot; +</span><br><span class="line">                &quot;\nwidth:&quot;+rectangle.getWidth() + &quot;,height:&quot;+rectangle.getHeight());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">        Rectangle rectangle &#x3D; new Rectangle();</span><br><span class="line">        rectangle.setWidth(20);</span><br><span class="line">        rectangle.setHeight(10);</span><br><span class="line">        resize(rectangle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/18/17058a6cffb9fefd?w=502&h=589&f=png&s=35867" alt=""></p>
<p>修改代码把长方形Rectangle替换成它的子类正方形Square：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Square square &#x3D; new Square();</span><br><span class="line">        square.setLength(10);</span><br><span class="line">        resize(square);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候我们运行的时候就出现了死循环，违背了里氏替换原则，将父类替换为子类后，程序运行结果没有达到预期。因此，我们的代码设计是存在一定风险的。里氏替换原则只存在父类与子类之间，约束继承泛滥。再来创建一个基于长方形与正方形共同抽象的四边形Quadrangle接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Quadrangle &#123;</span><br><span class="line">    </span><br><span class="line">    long getWidth();</span><br><span class="line">    </span><br><span class="line">    long getHeight();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改长方形 Rectangle 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Rectangle implements Quadrangle &#123;</span><br><span class="line"></span><br><span class="line">    private long height;</span><br><span class="line">    private long width;</span><br><span class="line">    @Override</span><br><span class="line">    public long getWidth() &#123;</span><br><span class="line">        return width;</span><br><span class="line">    &#125;</span><br><span class="line">    public long getHeight() &#123;</span><br><span class="line">        return height;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setHeight(long height) &#123;</span><br><span class="line">        this.height &#x3D; height;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setWidth(long width) &#123;</span><br><span class="line">        this.width &#x3D; width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改正方形类 Square 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Square implements Quadrangle &#123;</span><br><span class="line"></span><br><span class="line">    private long length;</span><br><span class="line">    public long getLength() &#123;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setLength(long length) &#123;</span><br><span class="line">        this.length &#x3D; length;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public long getWidth() &#123;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public long getHeight() &#123;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，如果我们把 resize()方法的参数换成四边形 Quadrangle类，方法内部就会报错。因为正方形 Square 已经没有了 setWidth()和 setHeight()方法了。因此，为了约束继承泛滥，resize()的方法参数只能用 Rectangle 长方形。</p>
<h2 id="1-7-合成复用原则-（Composite-Aggregate-Reuse-Principle，CARP）"><a href="#1-7-合成复用原则-（Composite-Aggregate-Reuse-Principle，CARP）" class="headerlink" title="1.7 合成复用原则 （Composite/Aggregate Reuse Principle，CARP）"></a>1.7 合成复用原则 （Composite/Aggregate Reuse Principle，CARP）</h2><p>合成复用原则是指尽量使用对象组合/聚和，而不是用继承关系达到对象复用的目的。这样可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其它类造成的影响也较少。</p>
<p><strong>继承又叫做白箱复用，相当于把所有的实现细节暴露给子类。组合/聚和也成为黑箱复用，对类以外的对象是无法获取到实现细节的。</strong> 需要根据具体的业务场景来设计代码，其实也要遵循OOP模型。这里以数据库操作为例，先创建DBConnection类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class DBConnection &#123;</span><br><span class="line"></span><br><span class="line">    public String getConnection()&#123;</span><br><span class="line">        return &quot;MySQL 数据库连接&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 ProductDao 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ProductDao &#123;</span><br><span class="line"></span><br><span class="line">    private DBConnection dbConnection;</span><br><span class="line">    public void setDbConnection(DBConnection dbConnection) &#123;</span><br><span class="line">        this.dbConnection &#x3D; dbConnection;</span><br><span class="line">    &#125;</span><br><span class="line">    public void addProduct()&#123;</span><br><span class="line">        String conn &#x3D; dbConnection.getConnection();</span><br><span class="line">        System.out.println(&quot;使用&quot;+conn+&quot;增加产品&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是非常典型的合成复用原则的应用场景。但是DBConnection还不是一种抽象，不便于系统扩展。目前系统只支持Mysql数据库连接，假设业务发生变化，数据库操作层要支持Oralce数据库。当然，可以在DBConnection中增加对Oracle数据库支持的方法。但是违背了开闭原则。我们可以不修改Dao的代码，将DBConnection改为abstract，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class DBConnection &#123;</span><br><span class="line">    public abstract String getConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，将 MySQL 的逻辑抽离：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MySqlConnection extends DBConnection &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getConnection() &#123;</span><br><span class="line">        return &quot;MySQL 数据库连接&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再创建 Oracle 支持的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class OracleConnection extends DBConnection &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getConnection() &#123;</span><br><span class="line">        return &quot;Oracle 数据库连接&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、-设计原则总结"><a href="#二、-设计原则总结" class="headerlink" title="二、 设计原则总结"></a>二、 设计原则总结</h1><p>学习设计原则，学习设计模式的基础。在实际开发过程中，并不是所有的代码都要遵循设计原则。我们需要考虑人力、时间、成本、质量，不是刻意的追求完美，要在适当的场景下遵循设计原则，体现的是一种平衡的取舍，帮助我们设计出更加优美的代码结构。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/02/19/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%E7%B2%BE%E9%80%89%E6%A1%88%E4%BE%8B/" data-id="ck7ih9d81000d1orab9zadybr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-如何优雅的学习JVM，终结篇（六）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/17/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AD%A6%E4%B9%A0JVM%EF%BC%8C%E7%BB%88%E7%BB%93%E7%AF%87%EF%BC%88%E5%85%AD%EF%BC%89/" class="article-date">
  <time datetime="2020-02-17T07:30:08.000Z" itemprop="datePublished">2020-02-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/17/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AD%A6%E4%B9%A0JVM%EF%BC%8C%E7%BB%88%E7%BB%93%E7%AF%87%EF%BC%88%E5%85%AD%EF%BC%89/">如何优雅的学习JVM，终结篇（六）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、如何计算一个对象占用的内存大小？"><a href="#一、如何计算一个对象占用的内存大小？" class="headerlink" title="一、如何计算一个对象占用的内存大小？"></a>一、如何计算一个对象占用的内存大小？</h1><p>我们在编写代码的过程中会创建大量的对象，有没有考虑到底某个对象占用了多少内存呢？</p>
<p>在C/C++中，我们可以通过sizeof()函数来计算一个变量或者类型所占用的大小，然而在Java中并没有这样的系统调用，那么在Java中如何实现类似的计算对象占用的内存大小呢？Java对象的内存结构，我们在前面的章节也进行了学习，它包括<strong>对象头（标记位、对象指针）、实例数据、对齐填充</strong>。那么我们只要按照顺序计算出各个区域所占用的内存并求和就可以了。其实仔细想想肯定没有这么简单，其中还有很多细节问题需要考虑。</p>
<ul>
<li>对象头</li>
</ul>
<p>在不开启JVM对象头压缩的情况下：</p>
<p><strong>32位</strong> JRE中一个对象头大小是<strong>8个字节</strong>（4 + 4）</p>
<p><strong>64位</strong> JRE中则是<strong>16个字节</strong>（8 + 8）</p>
<ul>
<li>实例数据</li>
</ul>
<p>成员变量主要包括两种：基本类型和引用类型，非静态成员变量所占用的数据。在确定JRE运行环境中，基本类型和引用类型占用的内存大小都是确定的，因此需要简单通过反射做个加法似乎就可以了。但是实际情况不是你想的这样简单，让我们来写代码测试一下吧。</p>
<p>通过jol工具可以查看到一个对象的实际内存布局，我们使用OpenJDK，提供了JOL包，<strong>官网：</strong> <a href="http://openjdk.java.net/projects/code-tools/jol/" target="_blank" rel="noopener">http://openjdk.java.net/projects/code-tools/jol/</a></p>
<p>POM依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jol&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jol-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.8&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>


<p>创建一个如下示例代码的测试类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line">public class Pojo &#123;</span><br><span class="line">    public int a;</span><br><span class="line">    public String b;</span><br><span class="line">    public int c;</span><br><span class="line">    public boolean d;</span><br><span class="line">    private long e; &#x2F;&#x2F; e设置为私有的，后面讲解为什么</span><br><span class="line">    public Object f;</span><br><span class="line">    Pojo() &#123; e &#x3D; 1024L;&#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Pojo pojo &#x3D; new Pojo();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(pojo).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 jol 工具查看其内存布局如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> OFFSET  SIZE               TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4                    (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4                    (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4                    (object header)                           05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315)</span><br><span class="line">     12     4                int Pojo.a                                    0</span><br><span class="line">     16     8               long Pojo.e                                    1024</span><br><span class="line">     24     4                int Pojo.c                                    0</span><br><span class="line">     28     1            boolean Pojo.d                                    false</span><br><span class="line">     29     3                    (alignment&#x2F;padding gap)                  </span><br><span class="line">     32     4   java.lang.String Pojo.b                                    null</span><br><span class="line">     36     4   java.lang.Object Pojo.f                                    null</span><br><span class="line">Instance size: 40 bytes</span><br><span class="line">Space losses: 3 bytes internal + 0 bytes external &#x3D; 3 bytes total</span><br></pre></td></tr></table></figure>

<p>由此可以看出对象头所占用的大小为12字节。从这个内存布局表上不难看出，成员变量在实际分配内存时，并不是按照声明的顺序来储存的，此外在变量d之后，还出现了一块用于对齐内存的padding gap，这说明计算对象实际数据所占用的内存大小时，并不是简单的求和就可以的。</p>
<p>在上面的内存布局表中，可以看到OFFSET一列，这就是对应变量的偏移地址，如同C++中的指针，其实就是告诉了CPU要从什么位置取出对应的数据。举个例子，假设 Pojo 类的一个对象pojo存放在以 0x0010 开始的内存空间中，我们需要获取它的成员变量 b ，由于其偏移地址是 32（转换成十六进制为20），占用大小是 4 ，那么实际储存变量b的内存空间就是 0 x0030 ~ 0x0033 ，根据这个 CPU 就可以很容易地获取到变量了。</p>
<p>实际上在反射中，正式通过这样的方式来获取指定属性的值，具体实际上则需要借助强大的Unsafe工具。Unsafe可以实现系统底层不可思议的操作（比如修改变量的可见性，分配和回收堆外内存等），不过正因为其功能的强大性，随意使用有可能引发程序崩溃，所以官方不建议在除系统之外（如反射等）以外的场景使用，使用Unsafe如何通过变量偏移地址来获取一个变量。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testUnsafe() throws Exception &#123;</span><br><span class="line">        Class&lt;?&gt; unsafeClass &#x3D; null;</span><br><span class="line">        Unsafe unsafe &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            unsafeClass &#x3D; Class.forName(&quot;sun.misc.Unsafe&quot;);</span><br><span class="line">            final Field unsafeField &#x3D; unsafeClass.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">            unsafeField.setAccessible(true);</span><br><span class="line">            unsafe &#x3D; (Unsafe) unsafeField.get(null);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Pojo pojo &#x3D; new Pojo();&#x2F;&#x2F;上面案例的测试实体类</span><br><span class="line">        Field field &#x3D; Pojo.class.getDeclaredField(&quot;e&quot;);</span><br><span class="line">        long offset &#x3D; unsafe.objectFieldOffset(field);</span><br><span class="line">        if(offset &gt; 0L) &#123;</span><br><span class="line">            long eVal &#x3D; unsafe.getLong(pojo, offset);</span><br><span class="line">            System.out.println(eVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果打印：<strong>1024</strong></p>
<p>出于安全起见，一般情况下在正常的代码中是无法直接获取 Unsafe的实例的，这里我们通过反射的方式hack了一把来拿到 unsafe实例。接着通过调用 <strong>objectFieldOffset</strong> 方法获取到成员变量 e的地址偏移为 16（和 jol 中的结果一致），最终我们通过 <strong>getLong()</strong> 方法，传入e 的地址偏移量，便获取到了 e 的值。可以看到尽管 Pojo 类中 e是一个私有属性，通过这种方法依然是可以获取到它的值的</p>
<p>有了调用Unsafe的objectFieldOffset，我们可以通过代码精确的计算一个对象在内存中所占用的空间大小了，递归遍历对象中所有的引用并计算他们指向的实际对象的浅内存占用，最终求和即可。考虑到会有大量重复的类出现，我们可以使用一个数组来缓存已经计算过浅内存占用的class，避免重复计算。</p>
<p>如果引用指向了数组或者集合类型，那么只需要计算其基本元素的大小，然后乘以数组长度/集合大小即可。</p>
<p>具体实现代码在此不过多赘述，可以直接参考源代码（ from Apache luence ，入口方法为 sizeOf ( Object )）。</p>
<p>源代码：<br><a href="https://github.com/MarkLux/Java-Memory-Monitor/blob/master/src/main/java/cn/marklux/memory/RamUsageEstimator.java" target="_blank" rel="noopener">https://github.com/MarkLux/Java-Memory-Monitor/blob/master/src/main/java/cn/marklux/memory/RamUsageEstimator.java</a></p>
<p>需要注意的是，<strong>这种计算对象内存的方法并不是毫无代价的，由于使用了递归、反射和缓存，在性能和空间上都会有一定的消耗。</strong></p>
<h1 id="二、性能优化经验总结"><a href="#二、性能优化经验总结" class="headerlink" title="二、性能优化经验总结"></a>二、性能优化经验总结</h1><h2 id="2-1-性能优化的背景"><a href="#2-1-性能优化的背景" class="headerlink" title="2.1 性能优化的背景"></a>2.1 性能优化的背景</h2><p>大家平时一定遇到过这样的问题：单机的线程池队列爆满，使用集群扩容增加集群；系统内存占用高，高峰时段OOM，重启就分分钟解决了等一系列的问题。如果临时性的补救措施只能是给应用埋雷，同时只能解决部分问题，治标不治本。</p>
<p>添加硬件资源并不一定能够解决系统的性能问题，反而有时候会造成资源的浪费，得不偿失。因此对系统进行合理的性能优化，可以在系统稳定性、成本核算获得很大的收益。</p>
<p>假设现在我们的系统已经出现了性能问题，需要准备开始进行优化工作，那么在这个优化过程中，潜在的痛点有哪些呢？</p>
<p><strong>1、对性能优化的流程不是很清晰。</strong> 最终需要解决的问题其实是一个浅层次的性能瓶颈，真实的问题的根源并不能触达。</p>
<p><strong>2、对性能瓶颈点的分析思路不是很清晰。</strong> 网路、CPU、内存等这么多的性能指标，到底该关注什么，应该从哪一块开始入手呢？</p>
<p><strong>3、对性能优化的工具不是很了解。</strong> 遇到问题后，不清楚使用哪个工具，不知道通过工具得到的指标代表着什么。</p>
<h2 id="2-2-性能优化的流程"><a href="#2-2-性能优化的流程" class="headerlink" title="2.2 性能优化的流程"></a>2.2 性能优化的流程</h2><p><strong>1、准备阶段：</strong> 通过性能测试，了解系统的概况、瓶颈的大概方向，明确优化目标；</p>
<p><strong>2、分析阶段：</strong> 通过各种工具或手段，初步定为性能瓶颈点；</p>
<p><strong>3、调优阶段：</strong> 根据定位到的瓶颈点，进行系统性能调优。</p>
<p><strong>4、测试阶段：</strong> 让调优后的系统进行性能测试，与准备阶段的各项指标进行对比，观察其是否属于预期，如果瓶颈点没有消除或者性能指标不符合预期，则重复2和3步骤。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/15/1704814cc768f998?w=748&h=967&f=png&s=46807" alt=""></p>
<ul>
<li><p>准备阶段详解：</p>
<p>  <strong>对性能问题进行粗略评估，</strong> 比如线上应用日志级别不合理，可能会在大流量的时候导致CPU和磁盘的负载过高，这种情况需要调整日志级别；</p>
<p>  <strong>了解应用的总体架构，</strong> 应用依赖的外部接口和本身核心接口有哪些，使用了哪些框架和组件，哪些接口，模块的使用率较高，上下游的数据链路是怎么样的；</p>
<p>  <strong>了解应用对应的服务器信息，</strong> 服务器所在的集群信息、服务器的CPU、内存等信息，安装的操作系统Linux版本信息，服务器是容器还是虚拟机，所在的宿主机混部（把集群混合起来，将不同类型的任务调度到相同的物理资源上，通过调度，资源隔离等控制手段 , 在保障 SLO（服务等级目标） 的基础上，充分使用资源能力，极大降低成本）后是否当前应用有影响等。</p>
<p>  a、通过压测工具或者压测平台（如果公司有的话），对应用进行压力测试，获取当前应用的宏观指标。也可以结合当前的实际业务和过往的监控数据，去统计一些核心业务指标，比如午高峰的服务TPS。</p>
</li>
</ul>
<pre><code>* 响应时间


* 吞吐量


* TPS


* QPS


* 消费速率（对于使用MQ的中间件）


b、可以Linux基准测试工具，得到文件系统、磁盘I/O、网络等性能报告，还有GC、Web服务器、网卡流量等信息。


* jmeter


* ab


* loadrunnerwrk


* wrk</code></pre><ul>
<li><p>测试阶段详解：</p>
<p>  <strong>性能瓶颈点通常呈现2/8分布，</strong> 即80%的性能问题通常是由20%的性能瓶颈点导致的，2/8原则也以为着并不是所有的性能问题都值得去优化；</p>
<p>  <strong>不要过度追求应用的单机性能，</strong> 如果单机表现良好，则应该从架构的角度去思考；比如过滤追求CPU的性能而忽略了内存方面的瓶颈；</p>
<p>  <strong>整个应用的优化，应与线上系统隔离</strong>， 新的代码上线应该有降级方案。</p>
</li>
</ul>
<h2 id="2-3-工具箱"><a href="#2-3-工具箱" class="headerlink" title="2.3 工具箱"></a>2.3 工具箱</h2><p>工欲善其事必先利其器，我们该如何选择合适的工具呢？先来看看Linux性能工具图吧。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/15/17048d7bd472a3b7?w=3000&h=2100&f=png&s=941208" alt=""></p>
<p>上面的这张图非常经典，是做性能优化时候非常好的参考资料，但是事实上，我们在实际运用的时候，会发现可能并不合适。所以需要给出一张更为实用的图，该图从系统层、应用层（含组件层）的角度，列举我们在分析性能问题需要关注的各项指标，这些点是最有可能出现性能瓶颈的地方。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/15/1704919977f1208e?w=1246&h=1850&f=png&s=109125" alt=""></p>
<p>下面针对不同层次的核心性能指标做如下分析，同时也会介绍如何初步根据这些指标，判断系统或者应用是否存在性能瓶颈点。</p>
<h2 id="2-3-1-网络"><a href="#2-3-1-网络" class="headerlink" title="2.3.1 网络"></a>2.3.1 网络</h2><p>这里说的网络指的是应用层的网络，通常指的是：</p>
<ul>
<li>网络带宽：表示链路的最大传输速率；</li>
<li>网络吞吐：表示单位时间内成功传输的数据量大小；</li>
<li>网络延时：表示从网络从请求发出后直到收到远端响应，所需要的时间；</li>
<li>网络连接数和错误数。</li>
</ul>
<p>应用层的网络瓶颈有如下几类：</p>
<ul>
<li>网络出现分区；</li>
<li>集群或机器所在的机房的网络带宽饱和，影响应用的<strong>TPS/QPS</strong>的提升；</li>
<li>网络吞吐出现异常，如接口存在大量的数据传输，造成贷款占用过高；</li>
<li>网络连接出现异常或错误。</li>
</ul>
<p>带宽和网络吞吐两个指标，一般会关注整个应用的，并通过监控系统可以直接得到，如一段时间内出现了明显的指标上升，说明存在网络瓶颈。对于单机，可以使用<strong>sar命令</strong>得到网络接口，进程的网络吞吐。</p>
<p>使用<strong>ping</strong>或<strong>hping3</strong>可以得到是否出现网络分区、网络具体时延。整个应用链路的时延，可以通过中间件埋点后输出的trace日志得到链路上各个环节的时延信息。</p>
<p>使用<strong>netstat、ss</strong>和<strong>sar</strong>可以获取网络连接数或网络错误数。系统可以支撑的网络连接数是有限的，一是会占用<strong>文件描述符</strong>，二是会占用<strong>缓存</strong>。</p>
<h2 id="2-3-2-磁盘和文件"><a href="#2-3-2-磁盘和文件" class="headerlink" title="2.3.2 磁盘和文件"></a>2.3.2 磁盘和文件</h2><p>磁盘以及文件系统主要关注的指标有，常用命令有iostat（用于真个系统）和pidstat（用于具体的I/O进程）：</p>
<ul>
<li>磁盘I/O利用率：是指磁盘处理I/O的时间百分比；</li>
<li>磁盘吞吐量：是指每秒的I/O请求大小，单位为KB；</li>
<li>I/O响应时间：是指I/O请求从发出到收到响应的间隔，包含在队列中等待的时间和处理时间；</li>
<li>IOPS（Input/Output Per Second）：每秒I/O请求数；</li>
<li>I/O等待队列大小：是指平均I/O队列长度，队列长度越短越好。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zea13o0oyywo7z5hawlz ~]# iostat -dx</span><br><span class="line">Linux 3.10.0-693.2.2.el7.x86_64 (iz2zea13o0oyywo7z5hawlz) 	02&#x2F;16&#x2F;2020 	_x86_64_	(1 CPU)</span><br><span class="line"></span><br><span class="line">Device:         rrqm&#x2F;s   wrqm&#x2F;s     r&#x2F;s     w&#x2F;s    rkB&#x2F;s    wkB&#x2F;s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">vda               0.00     0.11    0.01    0.29     0.23     2.61    18.68     0.00    5.97    4.32    6.03   0.16   0.00</span><br></pre></td></tr></table></figure>

<p><strong>%util：</strong> 磁盘的I/O利用率，同CPU利用率一样，这个值也可能超过100%（存在并行I/O）；</p>
<p><strong>rKB/s、wKB/s：</strong> 每秒从磁盘读取和写入的数据量，即吞吐量，单位为KB；</p>
<p><strong>r_await、w_await：</strong> 读和写请求处理的响应时间；</p>
<p><strong>r/s、w/s：</strong> 每秒发送给磁盘的读请求数和写请求数；</p>
<p><strong>svctm：</strong> 该指标废弃，表示处理I/O所需的平均时间；</p>
<p><strong>pidstat</strong> 的输出大部分和 <strong>iostat</strong> 类似，区别在于它可以实时查看每个进程的 I/O 情况。</p>
<p><strong>如何判断磁盘的指标出现了异常？</strong></p>
<p>1、当 <strong>%util</strong> （磁盘利用率）长时间超过<strong>80%</strong>，或者响应时间过大（<strong>SSD，从0.0x毫秒到1.x毫秒不等，机械硬盘一般为5毫秒到10毫秒</strong>），通常意味着磁盘I/O存在性能瓶颈。</p>
<p>2、如果 <strong>%util</strong> 很大，而rKB/s和wKB/s很小，一般因为存在较多的磁盘随机读写，<strong>最好把随机读写优化成顺序读写</strong>，可以通过<strong>strace</strong>或<strong>blktrace</strong>观察I/O是否连续判断是否是顺序读写行为，<strong>随机读写应该关注IOPS指标，顺序读写可以关注吞吐量指标。</strong></p>
<p>3、如果<strong>avgqu-sz</strong> 比较大，说明有很多I/O<strong>在请求队列中等待</strong>。如果单块磁盘的队列长度持续<strong>超过2</strong>，一般认为该磁盘存在I/O性能问题。</p>
<h2 id="2-3-3-CPU和线程"><a href="#2-3-3-CPU和线程" class="headerlink" title="2.3.3 CPU和线程"></a>2.3.3 CPU和线程</h2><p>CPU关注的指标主要有以下几个。常用的命令有top、ps、uptime、vmstat、pidstat等。</p>
<ul>
<li>CPU利用率（CPU Utilization）</li>
<li>CPU平均负载（Load Average）</li>
<li>上下文切换次数（Context Switch）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">top - 14:58:36 up 18 days,  1:31,  1 user,  load average: 0.00, 0.01, 0.05</span><br><span class="line">Tasks:  63 total,   1 running,  62 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.3 us,  0.3 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  1883420 total,   109840 free,   187712 used,  1585868 buff&#x2F;cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.  1494900 avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                              </span><br><span class="line"> 1008 root      10 -10  132300  14672   9420 S  1.0  0.8 210:54.23 AliYunDun                                                            </span><br><span class="line">    1 root      20   0   43264   3708   2500 S  0.0  0.2   0:12.20 systemd</span><br></pre></td></tr></table></figure>
<p>第一行显示内容：当前时间、系统运行时间以及正在登录的用户数。<strong>load average</strong>后的三个数字，依次表示过去1分钟、5分钟、15分钟的平均负载。<strong>CPU的平均负载和CPU的使用率没有直接的关系</strong>。</p>
<p>第三行显示内容：表示CPU利用率，计算公式：<strong>CPU利用率 = 1 - CPU空闲时间/CPU总的时间。</strong> 注：top工具显示的CPU利用率是把所有的CPU核的数值加起来，即<strong>8核CPU的利用率最大可以达到800%</strong>，可以用（<strong>htop命令代替top进行查看</strong>）。</p>
<p>查看<strong>CPU上下文切换次数</strong>可以用<strong>vmstat</strong>命令进行查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zea13o0oyywo7z5hawlz ~]# vmstat</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 2  0      0 109592 141200 1445092    0    0     0     3   12   22  0  0 99  0  0</span><br></pre></td></tr></table></figure>

<p>上面的 <strong>cs（Context Swtich）</strong> 就是每秒上下文切换次数，过多的上下文切换次数，会把CPU时间消耗<strong>在寄存器、内核栈以及虚拟内存等</strong>数据保存和恢复上，从而缩短进程真正的运行时间，导致系统的整体性能大幅下降。</p>
<p><strong>us、sy分别是用户态和内核态的CPU利用率。</strong></p>
<p><strong>vmstat</strong>给出的是系统总体的上下文切换情况，想要查看每个进程的上下文切换详情，需要使用<strong>pidstat</strong>命令，<strong>该命令还可以查看某个进程用户态和内核态的CPU利用率。</strong></p>
<p><strong>CPU相关指标异常的分析思路是什么呢？</strong></p>
<p><strong>1、CPU利用率：</strong> 观察某段时间系统或者应用进程的CPU利用率一直很高（<strong>单个超过80%</strong>），可以多次使用jstack命令dump应用线程栈查看热点线程代码。</p>
<p><strong>2、CPU平均负载：</strong> <strong>平均负载高与CPU数量70%</strong>，意味着系统存在瓶颈，通过监控系统检测平均负载的变化趋势，更容易定位问题，有时候加载大文件的时候，也会导致平均负载瞬时升高。<strong>如果1分钟/5分钟/15分钟的三个值相差不是很大，则说明系统负载很平稳，如果这三个值逐渐降低，说明负载在逐渐升高</strong>，需要重点关注。</p>
<p><strong>3、CPU上下文切换次数：</strong> 这个指标取决于系统本身的CPU性能，以及当前应用的工作情况。<strong>如果系统或者应用的上下文切换次数出现数量级的增长的时候，则说明有很大概率存在性能问题，如果是非自愿的上下文切换次数大幅度上升，说明有太多的线程竞争CPU。</strong></p>
<p><strong>这三个指标是密切相关的，如频繁的CPU上下文切换，可能会导致平均负载升高。</strong></p>
<p><strong>关于线程，可关注的异常有：</strong></p>
<ul>
<li><strong>线程的总数是否过多。</strong> 线程过多，就会在CPU上频繁的进行上下文切换，同时线程过多也会消耗内存，线程的总数大小和应用本身和机器配置相关。</li>
<li><strong>线程的状态是否异常。</strong> 观察<strong>WAITING/BLOCKED</strong> 状态线程是否过多（线程数量设置过多或锁竞争剧烈），综合应用内部锁使用的情况进行进一步分析。</li>
<li><strong>结合CPU利用率，观察是否存在大量消耗CPU的线程。</strong></li>
</ul>
<h2 id="2-3-4-内存和堆"><a href="#2-3-4-内存和堆" class="headerlink" title="2.3.4 内存和堆"></a>2.3.4 内存和堆</h2><p>和内存相关的指标主要有以下几个，常用命令是<strong>top、free、vmstat、pidstat</strong>以及JDK自带的一些工具。</p>
<ul>
<li>系统内存使用情况，包括剩余内存、已用内存、可用内存、缓存/缓冲区；</li>
<li>进程（包含Java进程）的虚拟内存、常驻内存、共享内存；</li>
<li>进程的缺页异常数、包含主缺页异常和次缺页异常；</li>
<li>Swap换入和换出的内存大小、Swap参数配置；</li>
<li>JVM堆的分配、JVM启动参数；</li>
<li>JVM堆的回收、GC情况。</li>
</ul>
<p>使用free查看系统内存使用情况和Swap分区使用情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zea13o0oyywo7z5hawlz ~]# free -h</span><br><span class="line">              total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:           1.8G        182M        106M        364K        1.5G        1.4G</span><br><span class="line">Swap:            0B          0B          0B</span><br></pre></td></tr></table></figure>
<p>Swap：把一个本地文件或者一块磁盘的空间作为内存来使用，包括换入和换出两个过程。<strong>Swap分区的升高一般和磁盘的使用强相关，具体分析，需要结合缓存的使用情况，swappiness阈值以及匿名页和文件页的活跃情况综合分析。</strong></p>
<p>buff/cache：缓存和缓冲区大小。<strong>缓存（cache）：</strong> 从磁盘读取的文件或者向磁盘写文件的临时存储数据，面向文件。<strong>使用cachestat可以查看真个系统缓存的读写命中情况，使用cachetop可以观察每个进程缓存的读写命中情况。</strong> <strong>缓冲区（buff）：</strong> 写入磁盘数据或者从磁盘直接读取的数据的临时存储，面向块设备。<strong>free 命令的输出中，这两个指标是加在一起的，使用 vmstat 命令可以区分缓存和缓冲区，还可以看到 Swap 分区换入和换出的内存大小。</strong></p>
<p><strong>性能优化中常见的内存问题有哪些呢？</strong></p>
<p>1、系统剩余内存/可用内存不足（某个进程占用太多、系统本身内存不足），内存溢出；</p>
<p>2、内存回收异常：内存泄漏（进程在一段时间内内存使用持续走高），GC频率异常；</p>
<p>3、缓存使用过大（大文件读取或写入）、缓存命中率不高；</p>
<p>4、缺页异常过多（频繁的I/O读）；</p>
<p>5、Swap分区使用异常（使用过大）。</p>
<p><strong>内存相关指标异常后，分析的思路是怎么样的？</strong></p>
<p>1、使用free发现缓存/缓冲区占用不大，排序缓存/缓冲区对内存的影响；</p>
<p>2、使用vmstat或者sar观察一下各个进程内存使用变化的趋势，发现某个进程的内存使用持续走高；</p>
<p>3、Java应用，使用jmap/VisualVM/heap dump等分析工具观察对象内存的分配，或者通过jstat观察GC后应用的内存变化；</p>
<p>4、结合业务场景，定位内存泄漏/GC参数配置不合理/业务代码异常等。</p>
<h2 id="2-4-使用总结"><a href="#2-4-使用总结" class="headerlink" title="2.4 使用总结"></a>2.4 使用总结</h2><p>有一些工具频繁出现，总结如下：</p>
<ul>
<li><p>CPU：top、vmstat、pidstat、sar、perf、jstack、jstat；</p>
</li>
<li><p>内存：top、free、vmstat、cachetop、cachestat、sar、jmap；</p>
</li>
<li><p>磁盘：top、iostat、vmstat、pidstat、du/df；</p>
</li>
<li><p>网络：netstat、sar、dstat、tcpdump；</p>
</li>
<li><p>应用：profiler、dump。</p>
</li>
</ul>
<h1 id="三、-性能优化思路总结"><a href="#三、-性能优化思路总结" class="headerlink" title="三、 性能优化思路总结"></a>三、 性能优化思路总结</h1><p><img src="https://user-gold-cdn.xitu.io/2020/2/17/17051e88cc4fdb78?w=1967&h=4959&f=png&s=2143045" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/02/17/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AD%A6%E4%B9%A0JVM%EF%BC%8C%E7%BB%88%E7%BB%93%E7%AF%87%EF%BC%88%E5%85%AD%EF%BC%89/" data-id="ck7ih9d7x000b1ora0mq218zp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-如何优雅的学习JVM，综合篇（五）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/13/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AD%A6%E4%B9%A0JVM%EF%BC%8C%E7%BB%BC%E5%90%88%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89/" class="article-date">
  <time datetime="2020-02-13T13:30:03.000Z" itemprop="datePublished">2020-02-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/13/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AD%A6%E4%B9%A0JVM%EF%BC%8C%E7%BB%BC%E5%90%88%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89/">如何优雅的学习JVM，综合篇（五）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、重新认识JVM"><a href="#一、重新认识JVM" class="headerlink" title="一、重新认识JVM"></a>一、重新认识JVM</h1><p>在之前的我们画过一张图，是从class文件到类装载器，再到运行时数据区的过程。今天把这张图进行升级，画一张完整的JVM大体的物理结构图。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/13/1703d58ce61dfd9e?w=1041&h=697&f=png&s=62727" alt=""></p>
<h1 id="二、-GC优化"><a href="#二、-GC优化" class="headerlink" title="二、 GC优化"></a>二、 GC优化</h1><p>内存被使用了之后，难免会有不够用或者达到设定值的时候，就需要对内存空间进行垃圾回收。</p>
<h2 id="2-1-垃圾收集发生的时间"><a href="#2-1-垃圾收集发生的时间" class="headerlink" title="2.1 垃圾收集发生的时间"></a>2.1 垃圾收集发生的时间</h2><p>GC由JVM自动完成的，根据JVM系统环境而定的，所以时机是不确定的。当然，我们也可以进行手动垃圾回收，比如调用System.gc()方法通知JVM进行一次垃圾回收，但是具体什么时刻运行也无法控制。也就是System.gc()只是通知要回收，什么时候回收由JVM自行决定。但是不建议手动进行垃圾回收，因为消耗的资源比较大。</p>
<p><strong>一般以下几种情况会进行垃圾回收</strong></p>
<ul>
<li>当Eden区或者S区不够用</li>
<li>老年代空间不够用</li>
<li>方法区看空间不够用</li>
<li>System.gc()</li>
</ul>
<h2 id="2-2-项目环境准备"><a href="#2-2-项目环境准备" class="headerlink" title="2.2 项目环境准备"></a>2.2 项目环境准备</h2><p>此次案例我们使用SpringBoot来创建项目，然后配置对应的参数。</p>
<h2 id="2-3-GC日志文件"><a href="#2-3-GC日志文件" class="headerlink" title="2.3 GC日志文件"></a>2.3 GC日志文件</h2><p><img src="https://user-gold-cdn.xitu.io/2020/2/13/1703d8a38b0e96c9?w=1174&h=633&f=png&s=59828" alt=""></p>
<p>要分析日志的信息，首先得拿到GC日志文件才行，所以得配置一下启动参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -Xloggc:gc.log</span><br></pre></td></tr></table></figure>

<p>然后启动项目</p>
<p>可以看到默认使用的是<strong>ParallelGC</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/13/1703d9807b8b571c?w=1594&h=193&f=png&s=98461" alt=""></p>
<p>1、ParallelGC日志</p>
<ul>
<li>吞吐量优先，日志分析</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-02-13T16:01:45.974+0800: 3.592: [GC (Allocation Failure) [PSYoungGen: 65536K【Young区回收前】-&gt;8294K【Young区回收后】(76288K【Young区总大小】)] 65536K【整个堆回收前】-&gt;8310K【整个堆回收后】(251392K【整个堆总大小】), 0.0253276 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.03 secs]</span><br></pre></td></tr></table></figure>

<p><strong>如果回收的差值有出入，则说明这部分空间是Old区释放出来的</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/13/1703da02d79da864?w=1609&h=520&f=png&s=258949" alt=""></p>
<p>2、CMS GC日志</p>
<ul>
<li>停顿时间优先</li>
</ul>
<p><code>参数设置：-XX:+UseConcMarkSweepGC -Xloggc:cms-gc.log</code></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/13/1703da8b88f3d7ed?w=1627&h=868&f=png&s=466196" alt=""></p>
<p>3、G1 GC日志</p>
<ul>
<li>停顿时间优先</li>
</ul>
<p><code>参数设置：-XX:+UseG1GC -Xloggc:g1-gc.log</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC  # 使用了G1垃圾收集器</span><br><span class="line"></span><br><span class="line">#什么时候发生的GC，相对的时间刻，GC发生的区域young，总共花费的时间，0.00444s</span><br><span class="line"></span><br><span class="line">2020-02-13T16:31:01.099+0800: 2.230: [GC pause (G1 Evacuation Pause) (young), 0.0044422 secs]</span><br><span class="line"></span><br><span class="line">#多少个垃圾回收线程，并行的时间</span><br><span class="line"></span><br><span class="line">[Parallel Time: 3.4 ms, GC Workers: 4]</span><br><span class="line"></span><br><span class="line">#GC线程开始相对于上面的0.2230的时间刻</span><br><span class="line">[GC Worker Start (ms): Min: 2230.2, Avg: 2230.2, Max: 2230.3, Diff: 0.1]</span><br><span class="line"></span><br><span class="line">#每个工作线程扫描根的时间</span><br><span class="line"></span><br><span class="line">[Ext Root Scanning (ms): Min: 0.5, Avg: 0.7, Max: 1.0, Diff: 0.5, Sum: 2.9]</span><br><span class="line"></span><br><span class="line">#每个线程更新记忆集所花费的时间</span><br><span class="line"></span><br><span class="line">[Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br></pre></td></tr></table></figure>

<p><strong>理解G1日志格式：</strong> <a href="https://blogs.oracle.com/poonam/understanding-g1-gc-logs" target="_blank" rel="noopener">https://blogs.oracle.com/poonam/understanding-g1-gc-logs</a></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/13/1703db30649ae319?w=1603&h=865&f=png&s=321487" alt=""></p>
<h2 id="2-4-GC日志文件分析工具"><a href="#2-4-GC日志文件分析工具" class="headerlink" title="2.4 GC日志文件分析工具"></a>2.4 GC日志文件分析工具</h2><p>1、gceasy</p>
<p><strong>官网：</strong> <a href="https://gceasy.io/" target="_blank" rel="noopener">https://gceasy.io/</a></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/13/1703db93c64d20e3?w=1759&h=751&f=png&s=197662" alt=""></p>
<p>可以比较不同的垃圾收集器的<strong>吞吐量</strong>和<strong>停顿时间</strong>，比如打开cms-gc.log和g1-gc.log</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/13/1703dc210eea9809?w=1840&h=739&f=png&s=121378" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/13/1703dc2f9be32a4a?w=1750&h=508&f=png&s=64580" alt=""></p>
<p>2、GCViewer</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/13/1703dd0c62e0f1fe?w=1924&h=1036&f=png&s=133027" alt=""></p>
<h2 id="2-5-G1调优与最佳指南"><a href="#2-5-G1调优与最佳指南" class="headerlink" title="2.5 G1调优与最佳指南"></a>2.5 G1调优与最佳指南</h2><p>是否选用G1垃圾收集器的判断依据，<strong>官网：</strong> <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/G1.html#use_cases" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/G1.html#use_cases</a></p>
<ul>
<li>50%以上的堆被存活对象占用</li>
<li>对象分配和晋升的速度变化非常大</li>
<li>垃圾回收时间比较长</li>
</ul>
<p><strong>思考：使用G1 GC增加堆使用率</strong><br><a href="https://blogs.oracle.com/poonam/increased-heap-usage-with-g1-gc" target="_blank" rel="noopener">https://blogs.oracle.com/poonam/increased-heap-usage-with-g1-gc</a></p>
<p>1、使用G1GC垃圾收集器: -XX:+UseG1GC</p>
<p>修改配置参数，获取到gc日志，使用GCViewer分析吞吐量和响应时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Throughput    Min Pause    Max Pause   Avg Pause    GC count</span><br><span class="line">99.16%         0.00016s     0.0137s    0.00559s     12</span><br></pre></td></tr></table></figure>
<p>2、调整内存大小再获取gc日志分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize&#x3D;100M</span><br><span class="line">-Xms300M</span><br><span class="line">-Xmx300M</span><br></pre></td></tr></table></figure>
<p>比如设置堆内存的大小，获取到gc日志，使用GCViewer分析吞吐量和响应时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Throughput    Min Pause    Max Pause   Avg Pause    GC count</span><br><span class="line">98.89%        0.00021s     0.01531s    0.00538s      12</span><br></pre></td></tr></table></figure>

<p>3、调整最大停顿时间</p>
<p><code>-XX:MaxGCPauseMillis=20  设置最大GC停顿时间指标</code></p>
<p>比如设置最大停顿时间，获取到gc日志，使用GCViewer分析吞吐量和响应时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Throughput    Min Pause    Max Pause   Avg Pause    GC count</span><br><span class="line">98.96%        0.00015s     0.01737s    0.00574s     12</span><br></pre></td></tr></table></figure>
<p>4、启动并发GC时堆内存占用百分比</p>
<p><code>-XX:InitiatingHeapOccupancyPercent=45</code></p>
<p>G1用它来触发并发GC周期,基于整个堆的使用率,而不只是某一代内存的<br>使用比例。值为 0 则表示“一直执行GC循环)’. 默认值为 45 (例如, 全部的 45% 或者使用了45%).</p>
<p>比如设置该百分比参数，获取到gc日志，使用GCViewer分析吞吐量和响应时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Throughput    Min Pause    Max Pause   Avg Pause    GC count</span><br><span class="line">  98.11%      0.00406s     0.00532s    0.00469s     12</span><br></pre></td></tr></table></figure>
<p><strong>最佳指南</strong></p>
<p><strong>官网建议：</strong> <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#recommendations" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#recommendations</a></p>
<p>1、<strong>不要手动设置新生代和老年代的大小，只要设置整个堆的大小</strong></p>
<p>G1收集器在运行过程中，会自己调整新生代和老年代大小，其实是通过adapt代的大小调整对象晋升的速度和年龄，从而到达为收集器设置的暂停时间目标，如果是手动设置了大小就意味着放弃了G1的自动调优</p>
<p>2、<strong>不断调优暂停时间目标</strong></p>
<p>一般情况下这个时间值设置到100ms或者200ms都是可以的（不同情况会不一样），但是如果设置成50ms就太不合理了。暂停时间设置的太短，就会出现G1 GC跟不上垃圾生产的速度，最终退化成Full GC。所以对这个参数的调优是一个持续的过程，逐步调整到最佳状态。暂停时间只是一个目标，并不是总能得到满足。</p>
<p>3、<strong>使用-XX:ConcGCThreads=n来增加标记线程的数量</strong></p>
<p>IHOP如果阀值设置过高，可能会遇到转移失败的风险，比如对象进行转移时空间不足。如果阀值设置过低，就会使标记周期运行过于频繁，并且有可能混合收集期回收不到空间。IHOP值如果设置合理，但是在并发周期时间过长时，可以尝试增加并发线程数，调高ConcGCThreads。</p>
<p>4、<strong>MixedGC调优</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:InitiatingHeapOccupancyPercent</span><br><span class="line">-XX:G1MixedGCLiveThresholdPercent</span><br><span class="line">-XX:G1MixedGCCountTarger</span><br><span class="line">-XX:G1OldCSetRegionThresholdPercent</span><br></pre></td></tr></table></figure>

<p>5、适当增加堆内存大小</p>
<h1 id="三、高并发场景案例分析"><a href="#三、高并发场景案例分析" class="headerlink" title="三、高并发场景案例分析"></a>三、高并发场景案例分析</h1><p><img src="https://user-gold-cdn.xitu.io/2020/2/13/1703e8f4a591c5ad?w=1299&h=904&f=png&s=75088" alt=""></p>
<h1 id="四、JVM性能优化指南"><a href="#四、JVM性能优化指南" class="headerlink" title="四、JVM性能优化指南"></a>四、JVM性能优化指南</h1><p><img src="https://user-gold-cdn.xitu.io/2020/2/13/1703ea8f325397ab?w=1041&h=838&f=png&s=48953" alt=""></p>
<h1 id="五、常见问题的思考与解决"><a href="#五、常见问题的思考与解决" class="headerlink" title="五、常见问题的思考与解决"></a>五、常见问题的思考与解决</h1><h2 id="5-1-内存泄漏与内存溢出的区别"><a href="#5-1-内存泄漏与内存溢出的区别" class="headerlink" title="5.1 内存泄漏与内存溢出的区别"></a>5.1 内存泄漏与内存溢出的区别</h2><p>内存泄漏：对象无法得到及时的回收，持续占用内存空间，从而造成内存空间的浪费。</p>
<p>内存溢出：内存泄漏到一定的程度就会导致内存溢出，但是内存溢出也有可能是大对象导致的。</p>
<h2 id="5-2-young-gc会有stw吗？"><a href="#5-2-young-gc会有stw吗？" class="headerlink" title="5.2 young gc会有stw吗？"></a>5.2 young gc会有stw吗？</h2><p>不管什么 GC，都会有 stop-the-world，只是发生时间的长短。</p>
<h2 id="5-3-major-gc和full-gc的区别"><a href="#5-3-major-gc和full-gc的区别" class="headerlink" title="5.3 major gc和full gc的区别"></a>5.3 major gc和full gc的区别</h2><p>major gc指的是老年代的gc，而full gc等于young+old+metaspace的gc。</p>
<h2 id="5-4-G1与CMS的区别是什么"><a href="#5-4-G1与CMS的区别是什么" class="headerlink" title="5.4 G1与CMS的区别是什么"></a>5.4 G1与CMS的区别是什么</h2><p>CMS 用于老年代的回收，而 G1 用于新生代和老年代的回收。<br>G1 使用了 Region 方式对堆内存进行了划分，且基于标记整理算法实现，整体减少了垃圾碎片的产生。</p>
<h2 id="5-5-什么是直接内存"><a href="#5-5-什么是直接内存" class="headerlink" title="5.5 什么是直接内存"></a>5.5 什么是直接内存</h2><p>直接内存是在java堆外的、直接向系统申请的内存空间。通常访问直接内存的速度会优于Java堆。因此出于性能的考<br>虑，读写频繁的场合可能会考虑使用直接内存。</p>
<h2 id="5-6不可达的对象一定要被回收吗？"><a href="#5-6不可达的对象一定要被回收吗？" class="headerlink" title="5.6不可达的对象一定要被回收吗？"></a>5.6不可达的对象一定要被回收吗？</h2><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p>
<h2 id="5-7-方法区中的无用类回收"><a href="#5-7-方法区中的无用类回收" class="headerlink" title="5.7 方法区中的无用类回收"></a>5.7 方法区中的无用类回收</h2><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 “无用的类” ：</p>
<p>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</p>
<p>加载该类的 ClassLoader 已经被回收。</p>
<p>该类对应的 java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p>
<h2 id="5-8-不同的引用"><a href="#5-8-不同的引用" class="headerlink" title="5.8 不同的引用"></a>5.8 不同的引用</h2><p>JDK1.2以后，Java对引用进行了扩充：强引用、软引用、弱引用和虚引用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/02/13/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AD%A6%E4%B9%A0JVM%EF%BC%8C%E7%BB%BC%E5%90%88%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89/" data-id="ck7ih9d7r00051oradvn9g0dd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/03/08/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%A4%96%E7%95%8C%E8%AE%BF%E9%97%AE%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%E5%94%AF%E4%B8%80%E9%80%9A%E9%81%93%E7%9A%84%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，外界访问系统内部唯一通道的门面模式详解</a>
          </li>
        
          <li>
            <a href="/2020/03/01/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E6%B3%A8%E9%87%8D%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F%E7%9A%84%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，注重方法调用顺序的建造者模式详解</a>
          </li>
        
          <li>
            <a href="/2020/02/25/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%B1%9E%E4%BA%8E%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，属于游戏设计模式的策略模式详解</a>
          </li>
        
          <li>
            <a href="/2020/02/25/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%B9%B2%E8%BF%87%E4%B8%AD%E4%BB%8B%E5%B9%B2%E8%BF%87%E5%BF%AB%E9%80%92%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，干过中介干过快递的代理模式详解</a>
          </li>
        
          <li>
            <a href="/2020/02/22/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%8F%AA%E6%98%AF%E5%8D%95%E7%BA%AF%E5%90%AC%E8%AF%B4%E8%BF%87%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，只是单纯听说过的原型模式详解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Kevin Shaw<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>