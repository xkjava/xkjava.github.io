<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>来一杯咖啡</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="互联网Java体系平台架构，分布式系统，中间件技术等">
<meta property="og:type" content="website">
<meta property="og:title" content="来一杯咖啡">
<meta property="og:url" content="https://xkjava.github.io/index.html">
<meta property="og:site_name" content="来一杯咖啡">
<meta property="og:description" content="互联网Java体系平台架构，分布式系统，中间件技术等">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Kevin Shaw">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="Netty">
<meta property="article:tag" content="Kafka...">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="来一杯咖啡" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">来一杯咖啡</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">互联网技术无边界，学习与交流</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://xkjava.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-数据治理的王者Apache-Atlas如何构建自己的API" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/25/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E7%9A%84%E7%8E%8B%E8%80%85Apache-Atlas%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84API/" class="article-date">
  <time datetime="2020-08-25T02:44:06.000Z" itemprop="datePublished">2020-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/25/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E7%9A%84%E7%8E%8B%E8%80%85Apache-Atlas%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84API/">数据治理的王者Apache-Atlas如何构建自己的API</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Apache Atlas是一个优秀的服务治理组件，用于企业Hadoop集群上的数据治理和元数据管理的数据治理工具。接下来我们将讨论构建自己的Java API，这些Java API可使用Apache atlas客户端与Apache Atlas交互以在其中创建新的实体和类型。</p>
<h1 id="一、Atlas客户端Maven依赖关系"><a href="#一、Atlas客户端Maven依赖关系" class="headerlink" title="一、Atlas客户端Maven依赖关系"></a>一、Atlas客户端Maven依赖关系</h1><p>以下依赖项可用于pom.xml文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.atlas&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;atlas-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.7-incubating&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.atlas&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;atlas-typesystem&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.7-incubating&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.atlas&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;atlas-notification&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.7-incubating&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.atlas&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;atlas-repository&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.7-incubating&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h1 id="二、设置atlas-application-properties"><a href="#二、设置atlas-application-properties" class="headerlink" title="二、设置atlas-application.properties"></a>二、设置atlas-application.properties</h1><p>Apache Atlas客户端使用atlas-application属性在我们的API和Apache Atlas服务器之间建立连接。这些属性应放置在resources/atlas-application.properties中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#########  Security Properties  #########</span><br><span class="line"></span><br><span class="line"># SSL config</span><br><span class="line">atlas.enableTLS&#x3D;false</span><br><span class="line"></span><br><span class="line">#########  Server Properties  #########</span><br><span class="line">atlas.rest.address&#x3D;http:&#x2F;&#x2F;192.168.5.95:21000</span><br><span class="line"></span><br><span class="line">atlas.hook.demo.kafka.retries&#x3D;1</span><br><span class="line">atlas.kafka.zookeeper.connect&#x3D;192.168.5.93:2181,192.168.5.94:2181,192.168.5.95:2181</span><br><span class="line">atlas.kafka.bootstrap.servers&#x3D;192.168.5.93:9092,192.168.5.94:9092,192.168.5.95:9092</span><br><span class="line">atlas.kafka.zookeeper.session.timeout.ms&#x3D;4000</span><br><span class="line">atlas.kafka.zookeeper.connection.timeout.ms&#x3D;2000</span><br><span class="line">atlas.kafka.zookeeper.sync.time.ms&#x3D;20</span><br><span class="line">atlas.kafka.auto.commit.interval.ms&#x3D;1000</span><br><span class="line">atlas.kafka.hook.group.id&#x3D;atlas</span><br></pre></td></tr></table></figure>
<h1 id="三、创建与Atlas服务器的连接"><a href="#三、创建与Atlas服务器的连接" class="headerlink" title="三、创建与Atlas服务器的连接"></a>三、创建与Atlas服务器的连接</h1><p>要与Apache atlas Server，baseUrl和用户名创建连接，必须在AtlasClient构造函数中传递密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final AtlasClient atlasClient &#x3D; new AtlasClient</span><br><span class="line">            (new String[]&#123;&quot;http:&#x2F;&#x2F;192.168.5.95:21000&quot;&#125;,</span><br><span class="line">                    new String[]&#123;&quot;admin&quot;,</span><br><span class="line">                            &quot;admin&quot;&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="四、关于Type相关的测试类"><a href="#四、关于Type相关的测试类" class="headerlink" title="四、关于Type相关的测试类"></a>四、关于Type相关的测试类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">public class AtlasTypesTest &#123;</span><br><span class="line"></span><br><span class="line">    final AtlasClient atlasClient &#x3D; new AtlasClient</span><br><span class="line">            (new String[]&#123;&quot;http:&#x2F;&#x2F;192.168.5.95:21000&quot;&#125;,</span><br><span class="line">                    new String[]&#123;&quot;admin&quot;,</span><br><span class="line">                            &quot;admin&quot;&#125;);</span><br><span class="line"></span><br><span class="line">    static final String DATABASE_TYPE &#x3D; &quot;DB_Sync&quot;;</span><br><span class="line">    static final String COLUMN_TYPE &#x3D; &quot;Column_Sync&quot;;</span><br><span class="line">    static final String TABLE_TYPE &#x3D; &quot;Table_Sync&quot;;</span><br><span class="line">    static final String VIEW_TYPE &#x3D; &quot;View_Sync&quot;;</span><br><span class="line">    public static final String DB_ATTRIBUTE &#x3D; &quot;db&quot;;</span><br><span class="line">    static final String STORAGE_DESC_TYPE &#x3D; &quot;StorageDesc&quot;;</span><br><span class="line">    public static final String COLUMNS_ATTRIBUTE &#x3D; &quot;columns&quot;;</span><br><span class="line">    public static final String INPUT_TABLES_ATTRIBUTE &#x3D; &quot;inputTables&quot;;</span><br><span class="line">    private static final String[] TYPES &#x3D;</span><br><span class="line">            &#123;DATABASE_TYPE, TABLE_TYPE, STORAGE_DESC_TYPE, COLUMN_TYPE, VIEW_TYPE, &quot;JdbcAccess&quot;,</span><br><span class="line">                    &quot;ETL&quot;, &quot;Metric&quot;, &quot;PII&quot;, &quot;Fact&quot;, &quot;Dimension&quot;, &quot;Log Data&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 组织定义types</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    TypesDef createTypeDefinitions() &#123;</span><br><span class="line">        HierarchicalTypeDefinition&lt;ClassType&gt; dbClsDef &#x3D; TypesUtil</span><br><span class="line">                .createClassTypeDef(DATABASE_TYPE, DATABASE_TYPE, null,</span><br><span class="line">                        TypesUtil.createUniqueRequiredAttrDef(&quot;name&quot;, DataTypes.STRING_TYPE),</span><br><span class="line">                        attrDef(&quot;description&quot;, DataTypes.STRING_TYPE.getName()), attrDef(&quot;locationUri&quot;, DataTypes.STRING_TYPE.getName()),</span><br><span class="line">                        attrDef(&quot;owner&quot;, DataTypes.STRING_TYPE.getName()), attrDef(&quot;createTime&quot;, DataTypes.LONG_TYPE.getName()));</span><br><span class="line"></span><br><span class="line">        HierarchicalTypeDefinition&lt;ClassType&gt; columnClsDef &#x3D; TypesUtil</span><br><span class="line">                .createClassTypeDef(COLUMN_TYPE, COLUMN_TYPE, null, attrDef(&quot;name&quot;, DataTypes.STRING_TYPE.getName()),</span><br><span class="line">                        attrDef(&quot;dataType&quot;, DataTypes.STRING_TYPE.getName()), attrDef(&quot;comment&quot;, DataTypes.STRING_TYPE.getName()));</span><br><span class="line"></span><br><span class="line">        HierarchicalTypeDefinition&lt;ClassType&gt; tblClsDef &#x3D; TypesUtil</span><br><span class="line">                .createClassTypeDef(TABLE_TYPE, TABLE_TYPE, ImmutableSet.of(&quot;DataSet&quot;),</span><br><span class="line">                        new AttributeDefinition(DB_ATTRIBUTE, DATABASE_TYPE, Multiplicity.REQUIRED, false, null),</span><br><span class="line">                        new AttributeDefinition(&quot;sd&quot;, STORAGE_DESC_TYPE, Multiplicity.REQUIRED, true, null),</span><br><span class="line">                        attrDef(&quot;owner&quot;, DataTypes.STRING_TYPE.getName()), attrDef(&quot;createTime&quot;, DataTypes.LONG_TYPE.getName()),</span><br><span class="line">                        attrDef(&quot;lastAccessTime&quot;, DataTypes.LONG_TYPE.getName()), attrDef(&quot;retention&quot;, DataTypes.LONG_TYPE.getName()),</span><br><span class="line">                        attrDef(&quot;viewOriginalText&quot;, DataTypes.STRING_TYPE.getName()),</span><br><span class="line">                        attrDef(&quot;viewExpandedText&quot;, DataTypes.STRING_TYPE.getName()), attrDef(&quot;tableType&quot;, DataTypes.STRING_TYPE.getName()),</span><br><span class="line">                        attrDef(&quot;temporary&quot;, DataTypes.BOOLEAN_TYPE.getName()),</span><br><span class="line">                        new AttributeDefinition(COLUMNS_ATTRIBUTE, DataTypes.arrayTypeName(COLUMN_TYPE),</span><br><span class="line">                                Multiplicity.COLLECTION, true, null));</span><br><span class="line"></span><br><span class="line">        HierarchicalTypeDefinition&lt;ClassType&gt; viewClsDef &#x3D; TypesUtil</span><br><span class="line">                .createClassTypeDef(VIEW_TYPE, VIEW_TYPE, ImmutableSet.of(&quot;DataSet&quot;),</span><br><span class="line">                        new AttributeDefinition(&quot;db&quot;, DATABASE_TYPE, Multiplicity.REQUIRED, false, null),</span><br><span class="line">                        new AttributeDefinition(&quot;inputTables&quot;, DataTypes.arrayTypeName(TABLE_TYPE),</span><br><span class="line">                                Multiplicity.COLLECTION, false, null));</span><br><span class="line"></span><br><span class="line">        return TypesUtil.getTypesDef(ImmutableList.&lt;EnumTypeDefinition&gt;of(), ImmutableList.&lt;StructTypeDefinition&gt;of(),</span><br><span class="line">                ImmutableList.of(),</span><br><span class="line">                ImmutableList.of(dbClsDef, columnClsDef, tblClsDef, viewClsDef));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void createTypes() throws Exception &#123;</span><br><span class="line">        TypesDef typesDef &#x3D; createTypeDefinitions();</span><br><span class="line">        String typesAsJSON &#x3D;  TypesSerialization.toJson(typesDef);</span><br><span class="line">        System.out.println(&quot;typesAsJSON &#x3D; &quot; + typesAsJSON);</span><br><span class="line">        atlasClient.createType(typesAsJSON);</span><br><span class="line">        verifyTypesCreated();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void verifyTypesCreated() throws Exception &#123;</span><br><span class="line">        List&lt;String&gt; types &#x3D; atlasClient.listTypes();</span><br><span class="line">        for (String type : TYPES) &#123;</span><br><span class="line">            assert types.contains(type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AttributeDefinition attrDef(String name, String dT) &#123;</span><br><span class="line">        return attrDef(name, dT, Multiplicity.OPTIONAL, false, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AttributeDefinition attrDef(String name, String dT, Multiplicity m, boolean isComposite,</span><br><span class="line">                                String reverseAttributeName) &#123;</span><br><span class="line">        return new AttributeDefinition(name, dT, m, isComposite, reverseAttributeName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void createNewTypes() throws Exception &#123;</span><br><span class="line">        createTypes();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、关于Entities相关的测试类"><a href="#五、关于Entities相关的测试类" class="headerlink" title="五、关于Entities相关的测试类"></a>五、关于Entities相关的测试类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">public class AtlasEntitiesTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    final AtlasClient atlasClient &#x3D; new AtlasClient</span><br><span class="line">            (new String[]&#123;&quot;http:&#x2F;&#x2F;192.168.5.95:21000&quot;&#125;,</span><br><span class="line">                    new String[]&#123;&quot;admin&quot;,</span><br><span class="line">                            &quot;admin&quot;&#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 创建实例并返创建的Id对象</span><br><span class="line">     * @param referenceable</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Id createInstance(Referenceable referenceable) throws Exception &#123;</span><br><span class="line">        String typeName &#x3D; referenceable.getTypeName();</span><br><span class="line">        String entityJSON &#x3D; InstanceSerialization.toJson(referenceable, true);</span><br><span class="line">        System.out.println(&quot;Submitting new entity&#x3D; &quot; + entityJSON);</span><br><span class="line">        List&lt;String&gt; guids &#x3D; atlasClient.createEntity(entityJSON);</span><br><span class="line">        System.out.println(&quot;created instance for type &quot; + typeName + &quot;, guid: &quot; + guids);</span><br><span class="line">        return new Id(guids.get(guids.size() - 1), referenceable.getId().getVersion(),</span><br><span class="line">                referenceable.getTypeName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 创建数据库实例并返创建的数据库Id对象</span><br><span class="line">     * @param name</span><br><span class="line">     * @param description</span><br><span class="line">     * @param owner</span><br><span class="line">     * @param locationUri</span><br><span class="line">     * @param traitNames</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Id database(String name, String description, String owner, String locationUri, String... traitNames)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        Referenceable referenceable &#x3D; new Referenceable(DATABASE_TYPE, traitNames);</span><br><span class="line">        referenceable.set(&quot;name&quot;, name);</span><br><span class="line">        referenceable.set(&quot;description&quot;, description);</span><br><span class="line">        referenceable.set(&quot;owner&quot;, owner);</span><br><span class="line">        referenceable.set(&quot;locationUri&quot;, locationUri);</span><br><span class="line">        referenceable.set(&quot;createTime&quot;, System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        return createInstance(referenceable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 创建列的实例并返创建的列的实例对象</span><br><span class="line">     * @param name</span><br><span class="line">     * @param dataType</span><br><span class="line">     * @param comment</span><br><span class="line">     * @param traitNames</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Referenceable column(String name, String dataType, String comment, String... traitNames) throws Exception &#123;</span><br><span class="line">        Referenceable referenceable &#x3D; new Referenceable(COLUMN_TYPE, traitNames);</span><br><span class="line">        referenceable.set(&quot;name&quot;, name);</span><br><span class="line">        referenceable.set(&quot;dataType&quot;, dataType);</span><br><span class="line">        referenceable.set(&quot;comment&quot;, comment);</span><br><span class="line"></span><br><span class="line">        return referenceable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 创建表的实例并返创建的表的Id对象</span><br><span class="line">     * @param name</span><br><span class="line">     * @param description</span><br><span class="line">     * @param dbId</span><br><span class="line">     * @param sd</span><br><span class="line">     * @param owner</span><br><span class="line">     * @param tableType</span><br><span class="line">     * @param columns</span><br><span class="line">     * @param traitNames</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Id table(String name, String description, Id dbId, Referenceable sd, String owner, String tableType,</span><br><span class="line">             List&lt;Referenceable&gt; columns, String... traitNames) throws Exception &#123;</span><br><span class="line">        Referenceable referenceable &#x3D; new Referenceable(TABLE_TYPE, traitNames);</span><br><span class="line">        referenceable.set(&quot;name&quot;, name);</span><br><span class="line">        referenceable.set(AtlasClient.REFERENCEABLE_ATTRIBUTE_NAME, name);</span><br><span class="line">        referenceable.set(&quot;description&quot;, description);</span><br><span class="line">        referenceable.set(&quot;owner&quot;, owner);</span><br><span class="line">        referenceable.set(&quot;tableType&quot;, tableType);</span><br><span class="line">        referenceable.set(&quot;createTime&quot;, System.currentTimeMillis());</span><br><span class="line">        referenceable.set(&quot;lastAccessTime&quot;, System.currentTimeMillis());</span><br><span class="line">        referenceable.set(&quot;retention&quot;, System.currentTimeMillis());</span><br><span class="line">        referenceable.set(&quot;db&quot;, dbId);</span><br><span class="line">        referenceable.set(&quot;sd&quot;, sd);</span><br><span class="line">        referenceable.set(&quot;columns&quot;, columns);</span><br><span class="line"></span><br><span class="line">        return createInstance(referenceable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 创建视图的实例并返创建的视图的Id对象</span><br><span class="line">     * @param name</span><br><span class="line">     * @param dbId</span><br><span class="line">     * @param inputTables</span><br><span class="line">     * @param traitNames</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Id view(String name, Id dbId, List&lt;Id&gt; inputTables, String... traitNames) throws Exception &#123;</span><br><span class="line">        Referenceable referenceable &#x3D; new Referenceable(VIEW_TYPE, traitNames);</span><br><span class="line">        referenceable.set(&quot;name&quot;, name);</span><br><span class="line">        referenceable.set(AtlasClient.REFERENCEABLE_ATTRIBUTE_NAME, name);</span><br><span class="line">        referenceable.set(&quot;db&quot;, dbId);</span><br><span class="line"></span><br><span class="line">        referenceable.set(INPUT_TABLES_ATTRIBUTE, inputTables);</span><br><span class="line"></span><br><span class="line">        return createInstance(referenceable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 原始存储描述符</span><br><span class="line">     * @param location</span><br><span class="line">     * @param inputFormat</span><br><span class="line">     * @param outputFormat</span><br><span class="line">     * @param compressed</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Referenceable storageDescriptor(String location, String inputFormat, String outputFormat, boolean compressed)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        Referenceable referenceable &#x3D; new Referenceable(STORAGE_DESC_TYPE);</span><br><span class="line">        referenceable.set(&quot;location&quot;, location);</span><br><span class="line">        referenceable.set(&quot;inputFormat&quot;, inputFormat);</span><br><span class="line">        referenceable.set(&quot;outputFormat&quot;, outputFormat);</span><br><span class="line">        referenceable.set(&quot;compressed&quot;, compressed);</span><br><span class="line"></span><br><span class="line">        return referenceable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void createEntities() throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;创建数据库实例</span><br><span class="line">        Id syncDB &#x3D; database(&quot;sy_sync&quot;, &quot;Sync Database&quot;, &quot;root&quot;, &quot;&quot;);</span><br><span class="line">        &#x2F;&#x2F;存储描述符</span><br><span class="line">        Referenceable sd &#x3D;</span><br><span class="line">                storageDescriptor(&quot;&quot;, &quot;TextInputFormat&quot;, &quot;TextOutputFormat&quot;,</span><br><span class="line">                        true);</span><br><span class="line">        &#x2F;&#x2F;创建列实例</span><br><span class="line">        &#x2F;&#x2F;1、数据源</span><br><span class="line">        List&lt;Referenceable&gt; databaseColumns &#x3D; ImmutableList</span><br><span class="line">                .of(column(&quot;id&quot;, &quot;long&quot;, &quot;id&quot;),</span><br><span class="line">                        column(&quot;name&quot;, &quot;string&quot;, &quot;name&quot;),</span><br><span class="line">                        column(&quot;type&quot;, &quot;string&quot;, &quot;type&quot;),</span><br><span class="line">                        column(&quot;url&quot;, &quot;string&quot;, &quot;url&quot;),</span><br><span class="line">                        column(&quot;database_name&quot;, &quot;string&quot;, &quot;database name&quot;),</span><br><span class="line">                        column(&quot;username&quot;, &quot;string&quot;, &quot;username&quot;),</span><br><span class="line">                        column(&quot;password&quot;,&quot;string&quot;,&quot;password&quot;),</span><br><span class="line">                        column(&quot;description&quot;, &quot;string&quot;, &quot;description&quot;),</span><br><span class="line">                        column(&quot;create_time&quot;, &quot;string&quot;, &quot;create time&quot;),</span><br><span class="line">                        column(&quot;update_time&quot;, &quot;string&quot;, &quot;update time&quot;),</span><br><span class="line">                        column(&quot;create_id&quot;, &quot;long&quot;, &quot;user id&quot;),</span><br><span class="line">                        column(&quot;update_id&quot;, &quot;long&quot;, &quot;user id&quot;));</span><br><span class="line">        &#x2F;&#x2F;2、同步文件夹</span><br><span class="line">        List&lt;Referenceable&gt; syncFolderColumns &#x3D; ImmutableList</span><br><span class="line">                .of(column(&quot;id&quot;, &quot;long&quot;, &quot;id&quot;),</span><br><span class="line">                        column(&quot;name&quot;, &quot;string&quot;, &quot;name&quot;),</span><br><span class="line">                        column(&quot;description&quot;, &quot;string&quot;, &quot;description&quot;),</span><br><span class="line">                        column(&quot;create_time&quot;, &quot;string&quot;, &quot;create time&quot;),</span><br><span class="line">                        column(&quot;update_time&quot;, &quot;string&quot;, &quot;update time&quot;),</span><br><span class="line">                        column(&quot;create_id&quot;, &quot;long&quot;, &quot;user id&quot;),</span><br><span class="line">                        column(&quot;update_id&quot;, &quot;long&quot;, &quot;user id&quot;));</span><br><span class="line">        &#x2F;&#x2F;创建表实例</span><br><span class="line">        Id database &#x3D; table(&quot;datasource&quot;, &quot;database table&quot;, syncDB, sd, &quot;root&quot;, &quot;External&quot;, databaseColumns);</span><br><span class="line">        Id syncFolder &#x3D; table(&quot;folder&quot;, &quot;sync folder table&quot;, syncDB, sd, &quot;root&quot;, &quot;External&quot;, syncFolderColumns);</span><br><span class="line">        &#x2F;&#x2F;创建视图实例</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void getEntity() throws AtlasServiceException &#123;</span><br><span class="line">        Referenceable referenceable &#x3D; atlasClient.getEntity(&quot;1406ddd0-5d51-41d4-b174-859bd4f34a5b&quot;);</span><br><span class="line">        System.out.println(InstanceSerialization.toJson(referenceable, true));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/08/25/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E7%9A%84%E7%8E%8B%E8%80%85Apache-Atlas%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84API/" data-id="cke9cjzd3000ef5ra5b9qgkgv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CountDownLatch、Semaphore、CyclicBarrier、Condition源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/26/CountDownLatch%E3%80%81Semaphore%E3%80%81CyclicBarrier%E3%80%81Condition%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2020-07-26T11:27:44.000Z" itemprop="datePublished">2020-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/26/CountDownLatch%E3%80%81Semaphore%E3%80%81CyclicBarrier%E3%80%81Condition%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">CountDownLatch、Semaphore、CyclicBarrier、Condition源码分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、CountDownLatch"><a href="#一、CountDownLatch" class="headerlink" title="一、CountDownLatch"></a>一、CountDownLatch</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>它是一个同步辅助类，允许一个或多个线程等待，直到在其他线程中执行的一组操作完成。一个倒数计算的概念。<br>初始化给定一定的整数参数值，然后通过countDown()来实现倒数功能，在这个整数倒数到 0 之前，调用了 await() 方法的程序都必须要等待，当到达0后， 释放所有等待线程。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/26/17389d7755916958?w=1843&h=607&f=png&s=70631" alt=""></p>
<h2 id="1-2-源码分析"><a href="#1-2-源码分析" class="headerlink" title="1.2 源码分析"></a>1.2 源码分析</h2><p>对于 CountDownLatch，我们仅仅需要关心两个方法，一个是 <strong>countDown</strong>() 方法，另一个是 <strong>await</strong>() 方法。</p>
<h2 id="1-2-1-countDown"><a href="#1-2-1-countDown" class="headerlink" title="1.2.1 countDown()"></a>1.2.1 countDown()</h2><p>CountDownLatch有一个同步内部类<strong>Sync</strong>：<br>它使用AQS状态表示计数，实现同步控制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Synchronization control For CountDownLatch.</span><br><span class="line">     * Uses AQS state to represent count.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static final class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        private static final long serialVersionUID &#x3D; 4982264981922014374L;</span><br><span class="line"></span><br><span class="line">        Sync(int count) &#123;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int getCount() &#123;</span><br><span class="line">            return getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">            return (getState() &#x3D;&#x3D; 0) ? 1 : -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">            &#x2F;&#x2F; Decrement count; signal when transition to zero</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                int c &#x3D; getState();</span><br><span class="line">                if (c &#x3D;&#x3D; 0)</span><br><span class="line">                    return false;</span><br><span class="line">                int nextc &#x3D; c-1;</span><br><span class="line">                if (compareAndSetState(c, nextc))</span><br><span class="line">                    return nextc &#x3D;&#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>countDown方法调用Sync中releaseShared()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void countDown() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的线程由于调用了await()方法阻塞了，只能等到countDown()使得state=0的时候才会被全部唤醒。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    &#x2F;&#x2F; Decrement count; signal when transition to zero</span><br><span class="line">    &#x2F;&#x2F;使用自旋的方式实现state-1</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; getState();</span><br><span class="line">        if (c &#x3D;&#x3D; 0)</span><br><span class="line">            return false;</span><br><span class="line">        int nextc &#x3D; c-1;</span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line">            return nextc &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当state递减为0的时候，tryReleaseShared才返回true；否则只是返回state-1的值；<br>如果state=0，调用<strong>doReleaseShared</strong>()方法，唤醒等待的线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h !&#x3D; tail) &#123;</span><br><span class="line">            int ws &#x3D; h.waitStatus;</span><br><span class="line">            if (ws &#x3D;&#x3D; Node.SIGNAL) &#123;</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            &#x2F;&#x2F; loop to recheck cases</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;PROPAGATE的节点状态，表示处于共享模式，会对线程的唤醒进行传播</span><br><span class="line">            else if (ws &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                &#x2F;&#x2F; loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果前面唤醒的线程占领了head，那么再进行循环，通过头节点检查是否改变了，如果改变了就继续循环</span><br><span class="line">        if (h &#x3D;&#x3D; head)                   &#x2F;&#x2F; loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在线程被唤醒的执行顺序中：</p>
<ul>
<li><strong>h == head</strong> 表示头节点还没有被使用；</li>
<li><strong>unparkSuccessor(h)</strong> 表示唤醒的线程；</li>
<li><strong>h != head</strong> 表示头节点被刚刚唤醒的线程占用。</li>
</ul>
<h2 id="1-2-2-await"><a href="#1-2-2-await" class="headerlink" title="1.2.2 await()"></a>1.2.2 await()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void await() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<strong>state&lt;0</strong>，那么当前线程需要加入到共享锁队列中，执行<strong>doAcquireSharedInterruptibly</strong>()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireSharedInterruptibly(int arg)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    &#x2F;&#x2F;SHARED为共享模式，创建一个共享模式的节点到队列中</span><br><span class="line">    final Node node &#x3D; addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            if (p &#x3D;&#x3D; head) &#123;</span><br><span class="line">                &#x2F;&#x2F;尝试获取锁</span><br><span class="line">                int r &#x3D; tryAcquireShared(arg);</span><br><span class="line">                &#x2F;&#x2F;获得了锁并且state!&#x3D;0，下面的代码则不会执行</span><br><span class="line">                if (r &gt;&#x3D; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F;把唤醒的节点，设置成head节点</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                    failed &#x3D; false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把唤醒的节点，设置成head节点，当第一个线程被唤醒后，并设置为head节点，依次会唤醒第二个线程……</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">    Node h &#x3D; head; &#x2F;&#x2F; Record old head for check below</span><br><span class="line">    setHead(node);</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * Try to signal next queued node if:</span><br><span class="line">     *   Propagation was indicated by caller,</span><br><span class="line">     *     or was recorded (as h.waitStatus either before</span><br><span class="line">     *     or after setHead) by a previous operation</span><br><span class="line">     *     (note: this uses sign-check of waitStatus because</span><br><span class="line">     *      PROPAGATE status may transition to SIGNAL.)</span><br><span class="line">     * and</span><br><span class="line">     *   The next node is waiting in shared mode,</span><br><span class="line">     *     or we don&#39;t know, because it appears null</span><br><span class="line">     *</span><br><span class="line">     * The conservatism in both of these checks may cause</span><br><span class="line">     * unnecessary wake-ups, but only when there are multiple</span><br><span class="line">     * racing acquires&#x2F;releases, so most need signals now or soon</span><br><span class="line">     * anyway.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    if (propagate &gt; 0 || h &#x3D;&#x3D; null || h.waitStatus &lt; 0 ||</span><br><span class="line">        (h &#x3D; head) &#x3D;&#x3D; null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">        Node s &#x3D; node.next;</span><br><span class="line">        if (s &#x3D;&#x3D; null || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="https://user-gold-cdn.xitu.io/2020/7/26/1738a21abbf083e6?w=971&h=322&f=png&s=38421" alt=""></p>
<h1 id="二、Semaphore"><a href="#二、Semaphore" class="headerlink" title="二、Semaphore"></a>二、Semaphore</h1><h2 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h2><p>从单词的意思理解为信号灯，它可以控制同时访问程序的线程个数，比如停车场总共有100个车位，那么这时一下子来了150辆车需要停放在此停车场，必须要等到停车场有空余的位置才能让停满剩下的车进入此停车场。使用场景可用于限流。<br><img src="https://user-gold-cdn.xitu.io/2020/7/26/1738a47754e9bdbb?w=1795&h=712&f=png&s=87894" alt=""></p>
<p>两个重要的方法，acquire()获取一个许可，release()释放一个许可。</p>
<h2 id="2-2-源码分析"><a href="#2-2-源码分析" class="headerlink" title="2.2 源码分析"></a>2.2 源码分析</h2><h2 id="2-2-1-FairSync-公平策略"><a href="#2-2-1-FairSync-公平策略" class="headerlink" title="2.2.1 FairSync 公平策略"></a>2.2.1 FairSync 公平策略</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 2014338818796000944L;</span><br><span class="line"></span><br><span class="line">    FairSync(int permits) &#123;</span><br><span class="line">        super(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            &#x2F;&#x2F;判断是否有线程在排队，然后再进行CAS操作</span><br><span class="line">            if (hasQueuedPredecessors())</span><br><span class="line">                return -1;</span><br><span class="line">            int available &#x3D; getState();</span><br><span class="line">            int remaining &#x3D; available - acquires;</span><br><span class="line">            if (remaining &lt; 0 ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                return remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-2-2-NonFairSync-非公平策略"><a href="#2-2-2-NonFairSync-非公平策略" class="headerlink" title="2.2.2 NonFairSync 非公平策略"></a>2.2.2 NonFairSync 非公平策略</h2><p>公平与非公平策略只是多了个<strong>hasQueuedPredecessors</strong>()判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; -2694183684443567898L;</span><br><span class="line"></span><br><span class="line">    NonfairSync(int permits) &#123;</span><br><span class="line">        super(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">        return nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>nonfairTryAcquireShared</strong>()方法源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final int nonfairTryAcquireShared(int acquires) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int available &#x3D; getState();</span><br><span class="line">        int remaining &#x3D; available - acquires;</span><br><span class="line">        if (remaining &lt; 0 ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            return remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其它源码和 <strong>CountDownLatch</strong> 的是完全一样，都是基于共享锁的实现的。</p>
<h1 id="三、CyclicBarrier"><a href="#三、CyclicBarrier" class="headerlink" title="三、CyclicBarrier"></a>三、CyclicBarrier</h1><h2 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h2><p>从单词组成的意思理解为<strong>循环屏障</strong>。所谓屏障就是一个同步点，当一组线程到达这个同步点的时候被阻塞了，只有最后一个线程到达这个同步点的时候，屏障（也就是同步点）的大门才会打开，所有被拦截在大门之外的线程才会进入大门而继续工作。可以适用的场景于所有的子线程完成任务后，再执行主线程。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/26/1738a80a234bb06d?w=715&h=799&f=png&s=118926" alt=""></p>
<h2 id="3-2-源码分析"><a href="#3-2-源码分析" class="headerlink" title="3.2 源码分析"></a>3.2 源码分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public CyclicBarrier(int parties, Runnable barrierAction) &#123;</span><br><span class="line">    if (parties &lt;&#x3D; 0) throw new IllegalArgumentException();</span><br><span class="line">    this.parties &#x3D; parties;</span><br><span class="line">    this.count &#x3D; parties;</span><br><span class="line">    this.barrierCommand &#x3D; barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造方法参数parties，表示参与线程的个数；<br>每一个线程调用await()方法后，parties递减1，穿过屏障的大门（栅栏）后重置。<br>第二个参数barrierAction为Runnable实例，由最后一个到达的线程进行执行，如果没有需要执行的，设置为null。</p>
<h1 id="四、Condition"><a href="#四、Condition" class="headerlink" title="四、Condition"></a>四、Condition</h1><h2 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h2><p>它是一个用来多线程的协调通信的工具类，当某个线程阻塞等待某个条件时，当满足条件才会被唤醒。</p>
<h2 id="4-2-源码分析"><a href="#4-2-源码分析" class="headerlink" title="4.2 源码分析"></a>4.2 源码分析</h2><p>两个重要方法，await()和signal()。</p>
<h2 id="4-2-1-await"><a href="#4-2-1-await" class="headerlink" title="4.2.1 await()"></a>4.2.1 await()</h2><p>调用此方法会使得线程进入等待队列并释放锁，线程的状态变成等待状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">    &#x2F;&#x2F;允许线程中断</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    &#x2F;&#x2F;创建一个状态为condition的节点，采用链表的形式存放数据</span><br><span class="line">    Node node &#x3D; addConditionWaiter();</span><br><span class="line">    &#x2F;&#x2F;释放当前的锁，得到锁的状态，释放等待队列中的一个线程</span><br><span class="line">    int savedState &#x3D; fullyRelease(node);</span><br><span class="line">    int interruptMode &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F;判断当前节点是或否在队列上</span><br><span class="line">    while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        &#x2F;&#x2F;挂起当前线程</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        if ((interruptMode &#x3D; checkInterruptWhileWaiting(node)) !&#x3D; 0)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;acquireQueued为false就拿到了锁</span><br><span class="line">    &#x2F;&#x2F;interruptMode !&#x3D; THROW_IE表示这个线程没有成功将 node 入队,但 signal 执行了 enq 方法让其入队了</span><br><span class="line">    if (acquireQueued(node, savedState) &amp;&amp; interruptMode !&#x3D; THROW_IE)</span><br><span class="line">        &#x2F;&#x2F;将这个变量设置成 REINTERRUPT</span><br><span class="line">        interruptMode &#x3D; REINTERRUPT;</span><br><span class="line">    &#x2F;&#x2F;如果node节点的下一个等待者不为空，则开始进行清理，清理condition节点 </span><br><span class="line">    if (node.nextWaiter !&#x3D; null) &#x2F;&#x2F; clean up if cancelled</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    &#x2F;&#x2F;如果线程中断了，需要抛出异常    </span><br><span class="line">    if (interruptMode !&#x3D; 0)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>addConditionWaiter()源码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private Node addConditionWaiter() &#123;</span><br><span class="line">    Node t &#x3D; lastWaiter;</span><br><span class="line">    &#x2F;&#x2F; If lastWaiter is cancelled, clean out.</span><br><span class="line">    &#x2F;&#x2F;如果lastWaiter不等于空并且waitStatus不为condition，把这个节点从链表中移除</span><br><span class="line">    if (t !&#x3D; null &amp;&amp; t.waitStatus !&#x3D; Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t &#x3D; lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;创建一个状态为condition的单向列表</span><br><span class="line">    Node node &#x3D; new Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    if (t &#x3D;&#x3D; null)</span><br><span class="line">        firstWaiter &#x3D; node;</span><br><span class="line">    else</span><br><span class="line">        t.nextWaiter &#x3D; node;</span><br><span class="line">    lastWaiter &#x3D; node;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>fullyRelease()方法源码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final int fullyRelease(Node node) &#123;</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;获得重入的次数</span><br><span class="line">        int savedState &#x3D; getState();</span><br><span class="line">        &#x2F;&#x2F;释放并唤醒同步队列中的线程</span><br><span class="line">        if (release(savedState)) &#123;</span><br><span class="line">            failed &#x3D; false;</span><br><span class="line">            return savedState;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            node.waitStatus &#x3D; Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>isOnSyncQueue()方法源码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final boolean isOnSyncQueue(Node node) &#123;</span><br><span class="line">    &#x2F;&#x2F;判断当前节点是否在队列中，false表示不在，true表示在</span><br><span class="line">    if (node.waitStatus &#x3D;&#x3D; Node.CONDITION || node.prev &#x3D;&#x3D; null)</span><br><span class="line">        return false;</span><br><span class="line">    if (node.next !&#x3D; null) &#x2F;&#x2F; If has successor, it must be on queue</span><br><span class="line">        return true;</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * node.prev can be non-null, but not yet on queue because</span><br><span class="line">     * the CAS to place it on queue can fail. So we have to</span><br><span class="line">     * traverse from tail to make sure it actually made it.  It</span><br><span class="line">     * will always be near the tail in calls to this method, and</span><br><span class="line">     * unless the CAS failed (which is unlikely), it will be</span><br><span class="line">     * there, so we hardly ever traverse much.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;从tail节点往前扫描AQS队列，如果发现AQS队列中的节点与当前节点相等，则说明节点一定存在与队列中</span><br><span class="line">    return findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-2-signal"><a href="#4-2-2-signal" class="headerlink" title="4.2.2 signal()"></a>4.2.2 signal()</h2><p>调用此方法，将会唤醒在AQS队列中的节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final void signal() &#123;</span><br><span class="line">    &#x2F;&#x2F;判断当前线程是否获得了锁</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    &#x2F;&#x2F;AQS队列的第一个节点</span><br><span class="line">    Node first &#x3D; firstWaiter;</span><br><span class="line">    if (first !&#x3D; null)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>doSignal()方法的源码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void doSignal(Node first) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F;从condition队列中移除first节点</span><br><span class="line">        if ( (firstWaiter &#x3D; first.nextWaiter) &#x3D;&#x3D; null)</span><br><span class="line">            lastWaiter &#x3D; null;</span><br><span class="line">        first.nextWaiter &#x3D; null;</span><br><span class="line">    &#125; while (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first &#x3D; firstWaiter) !&#x3D; null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>transferForSignal()方法的源码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">final boolean transferForSignal(Node node) &#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * If cannot change waitStatus, the node has been cancelled.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;更新节点状态为0</span><br><span class="line">    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * Splice onto queue and try to set waitStatus of predecessor to</span><br><span class="line">     * indicate that thread is (probably) waiting. If cancelled or</span><br><span class="line">     * attempt to set waitStatus fails, wake up to resync (in which</span><br><span class="line">     * case the waitStatus can be transiently and harmlessly wrong).</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;调用 enq，把当前节点添加到AQS队列。并且返回返回按当前节点的上一个节点，也就是原tail 节点</span><br><span class="line">    Node p &#x3D; enq(node);</span><br><span class="line">    int ws &#x3D; p.waitStatus;</span><br><span class="line">    &#x2F;&#x2F;如果上一个节点被取消了，尝试设置上一节点状态为SIGNAL</span><br><span class="line">    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        &#x2F;&#x2F;唤醒节点上的线程</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>阻塞：await()方法中，在线程释放锁资源之后，如果节点不在AQS等待队列，则阻塞当前线程，如果在等待队列，则自旋等待尝试获取锁；</li>
<li>释放：signal()后，节点会从condition队列移动到AQS等待队列，则进入正常锁的获取流程。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/07/26/CountDownLatch%E3%80%81Semaphore%E3%80%81CyclicBarrier%E3%80%81Condition%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" data-id="cke9cjzcj0005f5racy4ra32s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-微服务核心重新认识SpringBoot，掌握核心特性及设计思想" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86SpringBoot%EF%BC%8C%E6%8E%8C%E6%8F%A1%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/" class="article-date">
  <time datetime="2020-07-05T10:14:48.000Z" itemprop="datePublished">2020-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86SpringBoot%EF%BC%8C%E6%8E%8C%E6%8F%A1%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/">微服务核心重新认识SpringBoot，掌握核心特性及设计思想</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”.</p>
<p>We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need minimal Spring configuration.</p>
<p>这是Spring官网对SpringBoot的定义和评价。</p>
<h1 id="一、SpringBoot的前世今生"><a href="#一、SpringBoot的前世今生" class="headerlink" title="一、SpringBoot的前世今生"></a>一、SpringBoot的前世今生</h1><p>对于Spring框架而言，我们接触的比较多的是Spring framework中的SpringMVC、IOC、AOP、DI等。而这些框架在使用过程中需要进行大量的配置文件的编写，或者需要进行很多繁琐的配置才能完成项目的初始化搭建工作。Spring可以说它是万能胶，这样一点没错。下面我们来使用SpringMVC去构建一个Web项目，看看其步骤有多么的繁琐吧。</p>
<ul>
<li>1、创建一个项目结构（maven/gradle）</li>
<li>2、spring的依赖，spring mvc 、servlet api的依赖</li>
<li>3、web.xml， DispatcherServlet</li>
<li>4、启动一个Spring mVC的配置，Dispatcher-servlet.xml</li>
<li>5、创建一个Controller 发布一个http请求</li>
<li>6、发布到jsp/servlet容器</li>
</ul>
<h2 id="1-1-SpringBoot的产生过程"><a href="#1-1-SpringBoot的产生过程" class="headerlink" title="1.1 SpringBoot的产生过程"></a>1.1 SpringBoot的产生过程</h2><p><strong>2012年10月份</strong>，一个叫Mike Youngstrom(扬斯特罗姆)在Spring Jira中创建了一个功能请求，要求在Spring Framework中支持无容器Web应用程序体系结构，他谈到了在主容器引导 spring 容器<br>内配置 Web 容器服务。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/173191a9a190ecac?w=1861&h=943&f=png&s=247267" alt=""></p>
<p>SpringBoot刚出生的时候，引起了很多开源社区的关注，并且也有个人和企业开始尝试使用SpringBoot。 <strong>其实直到2016年</strong>，SpringBoot才真正在国内被使用起来。</p>
<h2 id="1-2-到底什么是SpringBoot"><a href="#1-2-到底什么是SpringBoot" class="headerlink" title="1.2 到底什么是SpringBoot"></a>1.2 到底什么是SpringBoot</h2><p>SpringBoot 框架是为了能够帮助使用Spring框架的开发者快速高效的构建一个基于Spirng框架以及Spring生态体系的应用解决方案。它是对“<strong>约定优于配置</strong>”这个理念下的一个最佳实践。因此它是一个服务于框架的框架，服务的范围是简化配置文件。</p>
<p><strong>什么才是约定优于配置呢？</strong></p>
<ul>
<li><p>只要依赖的spring-boot-starter-web的jar，就会自动内置一个tomcat容器(替换)<br>项目结构</p>
</li>
<li><p>默认提供了配置文件application.properties/yml</p>
</li>
<li><p>starter启动依赖 - 如果是一个webstarter ，默认认为你是去构建一个spring mvc的应用. </p>
</li>
<li><p>EnableAutoConfiguration 默认对于依赖的 starter 进行自动装载</p>
</li>
</ul>
<h1 id="二、SpringBoot与微服务"><a href="#二、SpringBoot与微服务" class="headerlink" title="二、SpringBoot与微服务"></a>二、SpringBoot与微服务</h1><p>那为什么Spring Cloud会采用Spring Boot来作为基础框架呢？原因很简单</p>
<ol>
<li>Spring Cloud它是关注服务治理领域的解决方案，而服务治理是依托于服务架构之上，所以它仍然需要一个承载框架；</li>
<li>Spring Boot 可以简单认为它是一套快速配置Spring应用的脚手架，它可以快速开发单个微服务，所以Spring Cloud的版本和Spring Boot版本的兼容性有很大关联。</li>
</ol>
<h1 id="三、Spring注解驱动的发展过程"><a href="#三、Spring注解驱动的发展过程" class="headerlink" title="三、Spring注解驱动的发展过程"></a>三、Spring注解驱动的发展过程</h1><h2 id="3-1-Spring-1-x"><a href="#3-1-Spring-1-x" class="headerlink" title="3.1 Spring 1.x"></a>3.1 Spring 1.x</h2><p>在SpringFramework1.x时代，其中在1.2.0是这个时代的分水岭，当时Java5刚刚发布，业界正兴起了使用Annotation的技术风，SpringFramework自然也提供了支持，比如当时已经支持了@Transactional等注解，但是这个时候，XML配置方式还是唯一选择。</p>
<h2 id="3-2-Spring-2-x"><a href="#3-2-Spring-2-x" class="headerlink" title="3.2 Spring 2.x"></a>3.2 Spring 2.x</h2><p>Spring Framework2.x时代，2.0版本在Annotation中添加了@Required、@Repository以及AOP相关的@Aspect等注解，同时也提升了XML配置能力，也就是可扩展的XML，比如Dubbo这样的开源框架就是基于SpringXML的扩展来完美的集成Spring，从而降低了Dubbo使用的门槛。</p>
<p>在2.x时代，2.5版本也是这个时代的分水岭， 它引入了一些很核心的Annotation</p>
<ul>
<li>@Autowired 依赖注入</li>
<li>@Qualifier 依赖查找</li>
<li>@Component、@Service 组件声明</li>
<li>@Controller、@RequestMappring等spring mvc的注解</li>
</ul>
<p>尽管Spring 2.x时代提供了不少的注解，但是仍然没有脱离XML配置驱动，比如context:annotation-config context:componet-scan,前者的职责是注册Annotation处理器，后者是负责扫描classpath下指定包路径下被Spring模式注解标注的类，将他们注册成为Spring Bean</p>
<ul>
<li>@Required</li>
<li>@Repository（Dao）</li>
<li>@Aspect</li>
</ul>
<p>spring 2.5</p>
<ul>
<li>@Component (组件)</li>
<li>@Service service（服务接口）</li>
<li>@Controller（控制器）</li>
<li>@RequetsMapping（请求映射器）</li>
</ul>
<h2 id="3-3-Spring-3-x"><a href="#3-3-Spring-3-x" class="headerlink" title="3.3 Spring 3.x"></a>3.3 Spring 3.x</h2><p>Spring Framework3.0是一个里程碑式的时代，他的功能特性开始出现了非常大的扩展，比如全面拥抱Java5、以及Spring Annotation。更重要的是，它提供了配置类注解@Configuration，它出现的首要任务就是取代XML配置方式。</p>
<p><strong>实现无配置化的方式实现Bean的装配。</strong></p>
<ul>
<li>@Configuraion （去xml化）</li>
</ul>
<p>把Bean的对象如何以便捷的方式加载到Spring IOC容器中</p>
<ul>
<li>ComponentScan（扫描@Service、@Controller、@Repository）</li>
<li>Import（把多个容器配置合并在一个配置中）</li>
</ul>
<p><strong>Enable模块驱动</strong><br>在Spring 3.1中，提供了很多以@Enable开头的注解，比如：</p>
<ul>
<li>@EnableWebMvc（引入MVC框架在Spring应用中需要用到的所有的Bean）</li>
<li>@EnableScheduling（开启任务计划）</li>
<li>@EnableAutoConfiguration</li>
<li>@Bean（来声明一个bean）</li>
</ul>
<h2 id="3-4-Spring-4-x"><a href="#3-4-Spring-4-x" class="headerlink" title="3.4 Spring 4.x"></a>3.4 Spring 4.x</h2><p>@Conditional（选择性的对加载的bean进行条件过滤）</p>
<h2 id="3-5-Spring-5-x"><a href="#3-5-Spring-5-x" class="headerlink" title="3.5 Spring 5.x"></a>3.5 Spring 5.x</h2><h1 id="四、SpringBoot的特性"><a href="#四、SpringBoot的特性" class="headerlink" title="四、SpringBoot的特性"></a>四、SpringBoot的特性</h1><p>首先分析特性的时候，我们不妨从SrpingBootApplication的注解入手，看看它做了什么，首先打开注解的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(excludeFilters &#x3D; &#123;</span><br><span class="line">		@Filter(type &#x3D; FilterType.CUSTOM, classes &#x3D; TypeExcludeFilter.class),</span><br><span class="line">		@Filter(type &#x3D; FilterType.CUSTOM,</span><br><span class="line">				classes &#x3D; AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line">public @interface SpringBootApplication &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SpringBootApplication 本质上是由 3 个注解组成，分别是：</p>
<ul>
<li>@Configuration;</li>
<li>@EnableAutoConfiguration;</li>
<li>@ComponentScan。</li>
<li>可以直接用这三个注解也可以启动SpringBoot应用，只是每次配置三个注解比较繁琐，所以直接用一个复合注解更方便些。后面会逐一详尽分析这些注解的，这里先简单介绍一下。</li>
</ul>
<h2 id="4-1-EnableAutoConfiguration自动装配"><a href="#4-1-EnableAutoConfiguration自动装配" class="headerlink" title="4.1 EnableAutoConfiguration自动装配"></a>4.1 EnableAutoConfiguration自动装配</h2><p>打开EnableAutoConfigration注解的源码，不难发现会带有一个@Import的注解。其实所有以Enable开头的注解都会有一个@Import注解。下面来看下源码吧。</p>
<h2 id="4-1-1-Import注解"><a href="#4-1-1-Import注解" class="headerlink" title="4.1.1 @Import注解"></a>4.1.1 @Import注解</h2><ul>
<li>@EnableAutoConfiguration</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(&#123;EnableAutoConfigurationImportSelector.class&#125;)</span><br><span class="line">public @interface EnableAutoConfiguration &#123;</span><br><span class="line">    Class&lt;?&gt;[] exclude() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() default &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>@EnableScheduling</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Import(&#123;SchedulingConfiguration.class&#125;)</span><br><span class="line">@Documented</span><br><span class="line">public @interface EnableScheduling &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>@EnableWebMvc</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Documented</span><br><span class="line">@Import(&#123;DelegatingWebMvcConfiguration.class&#125;)</span><br><span class="line">public @interface EnableWebMvc &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>类似于<code>&lt;import resource/&gt;</code> 形式的注解，就是把多个容器配置合并在一个配置中。可以配置三种不同的class：</p>
<ul>
<li>普通的bean或者带有@Configuration注解的bean；</li>
<li>实现ImportSelector接口进行动态注入：</li>
<li>实现ImportBeanDefinitionRegistror接口进行动态注入。</li>
</ul>
<h2 id="4-1-2-EnableAutoConfiguration分析"><a href="#4-1-2-EnableAutoConfiguration分析" class="headerlink" title="4.1.2 EnableAutoConfiguration分析"></a>4.1.2 EnableAutoConfiguration分析</h2><p>EnableAutoConfiguration的主要作用就是把SpringBoot中所有符合条件的@Configuration配置都加载到创建并使用的IoC容器中。</p>
<p>在注解源码中我们看到@Import注解中配置了<strong>EnableAutoConfigurationImportSelector</strong>这个类。</p>
<p><strong>EnableAutoConfigurationImportSelector又是什么呢？</strong></p>
<p>从名字上看一定是实现了<strong>ImportSelector</strong>接口，所以是基于动态bean的加载功能。来看下<strong>selectImports</strong>方法的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public String[] selectImports(AnnotationMetadata metadata) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        AnnotationAttributes attributes &#x3D; this.getAttributes(metadata);</span><br><span class="line">        List&lt;String&gt; configurations &#x3D; this.getCandidateConfigurations(metadata, attributes);</span><br><span class="line">        configurations &#x3D; this.removeDuplicates(configurations);</span><br><span class="line">        Set&lt;String&gt; exclusions &#x3D; this.getExclusions(metadata, attributes);</span><br><span class="line">        configurations.removeAll(exclusions);</span><br><span class="line">        configurations &#x3D; this.sort(configurations);</span><br><span class="line">        this.recordWithConditionEvaluationReport(configurations, exclusions);</span><br><span class="line">        return (String[])configurations.toArray(new String[configurations.size()]);</span><br><span class="line">    &#125; catch (IOException var5) &#123;</span><br><span class="line">        throw new IllegalStateException(var5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处返回的String数组，是所有类的全类名，它们都会被纳入到Spring的IoC容器中。</p>
<p>其实 <strong>EnableAutoConfiguration</strong>会帮助SpringBoot应用把所有符合@Configuration 配置都加载到当前SpringBoot创建的IoC容器，而这里面借助了Spring框架提供的一个工具类 <strong>SpringFactoriesLoader</strong>的支持。以及用到了Spring提供的条件注解 <strong>@Conditional</strong>，选择性的针对需要加载的 bean 进行条件过滤。</p>
<h2 id="4-1-3-SpringFactoriesLoader"><a href="#4-1-3-SpringFactoriesLoader" class="headerlink" title="4.1.3 SpringFactoriesLoader"></a>4.1.3 SpringFactoriesLoader</h2><p>SpringFactoriesLoader其实和java中的<strong>SPI</strong>机制是一样的。但是不会像SPI一样一次性加载所有的类，而是根据key进行加载。其key是配置在<strong>META-INF/spring.factories</strong>配置文件中，根据key来加载对于的bean到Ioc容器中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public abstract class SpringFactoriesLoader &#123;</span><br><span class="line">    private static final Log logger &#x3D; LogFactory.getLog(SpringFactoriesLoader.class);</span><br><span class="line">    public static final String FACTORIES_RESOURCE_LOCATION &#x3D; &quot;META-INF&#x2F;spring.factories&quot;;</span><br><span class="line"></span><br><span class="line">    public SpringFactoriesLoader() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SPI机制</strong></p>
<p>Service provider interface<br>满足以下条件</p>
<ul>
<li><p>需要在classpath目录下创建一个 META-INF/services；</p>
</li>
<li><p>在该目录下创建一个扩展点的全路径名：</p>
<p>  1、文件中填写这个扩展点的实现 </p>
<p>  2、文件编码格式UTF-8 </p>
<p>  3、ServiceLoader去进行加载 </p>
</li>
</ul>
<h2 id="4-1-4-条件过滤Conditional的分析"><a href="#4-1-4-条件过滤Conditional的分析" class="headerlink" title="4.1.4 条件过滤Conditional的分析"></a>4.1.4 条件过滤Conditional的分析</h2><p>通过条件过滤减少带有@Configuration注解类的数量，从而减少SpringBoot的启动时间。</p>
<p>@Conditional中的其它注解</p>
<ul>
<li>@ConditionalOnBean（在存在某个bean的时候）；</li>
<li>@ConditionalOnMissingBean（不存在某个bean的时候）；</li>
<li>@ConditionalOnClass（当classpath可以找到某个类型的类时）；</li>
<li>@ConditionalOnMissingClass（当classpath不能找到某个类型的类时）；</li>
<li>@ConditionalOnResource（当前classpath是否存在某个资源文件）；</li>
<li>@ConditionalOnProperty（当前jvm是否包含某个系统属性的某个值）；</li>
<li>@ConditionalOnWebApplication（当前spring context是否是web应用程序）。</li>
</ul>
<h2 id="4-2-Starter"><a href="#4-2-Starter" class="headerlink" title="4.2 Starter"></a>4.2 Starter</h2><p>Starter相当于模块，能将模块所需要的依赖整合起来并对模块内的bean根据环境来进行自动配置。使用者只需要依赖相应功能的Starter，无需做过多的配置和依赖，SpringBoot 就能自动扫描并加载相应的模块。</p>
<ul>
<li>官方包 spring-boot-starter-xxx；</li>
<li>第三方包 xxx-spring-boot-starter</li>
</ul>
<h2 id="4-3-Actuator"><a href="#4-3-Actuator" class="headerlink" title="4.3 Actuator"></a>4.3 Actuator</h2><p>SpringBoot提供了spring-boot-start-actuator支持对SpringBoot应用的监控。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-1-endpoint"><a href="#4-3-1-endpoint" class="headerlink" title="4.3.1 endpoint"></a>4.3.1 endpoint</h2><p>通过访问地址：<a href="http://localhost:8080/actuator" target="_blank" rel="noopener">http://localhost:8080/actuator</a></p>
<p>可以看到非常多的 Endpoint。 有一些 Endpoint 是不能访问的，涉及到安全问题。</p>
<p>开启所有的endpoint：（management.endpoints.web.exposure.include=* *）</p>
<ul>
<li>health（健康检查）:<strong>management.endpoint.health.show-details= always</strong></li>
<li>Loggers（日志配置信息，针对每个package 对应的日志级别）</li>
<li>beans（IoC 容器中所有的 bean）</li>
<li>Dump（获取活动线程的快照）</li>
<li>Mappings（全部的 uri 路径，以及和控制器的映射关系）</li>
<li>conditions（当前所有的条件注解）</li>
<li>shutdown（关闭应用）：<strong>management.endpoint .shutdown.enabled= true</strong>，注意不要开启，比较危险</li>
<li>Env（获取全部的环境信息）</li>
</ul>
<h2 id="4-3-2-Health的原理分析"><a href="#4-3-2-Health的原理分析" class="headerlink" title="4.3.2 Health的原理分析"></a>4.3.2 Health的原理分析</h2><p>应用健康状态的检查应该是监控系统中最基本的需求，所以我们基于 health 来分析一下它是如何实现的。<br><strong>org.springframework.boot.actuate.autoconfigure.HealthIndicatorAutoConfiguration</strong>类自动装配载入的，打开对应包下的spring.foctories文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.AuditAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.CacheStatisticsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.CrshAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.EndpointAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.EndpointMBeanExportAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.EndpointWebMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.HealthIndicatorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.JolokiaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.ManagementServerPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.ManagementWebSecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.MetricFilterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.MetricRepositoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.MetricsDropwizardAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.MetricsChannelAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.MetricExportAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.PublicMetricsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.TraceRepositoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.TraceWebFilterAutoConfiguration</span><br><span class="line"></span><br><span class="line">org.springframework.boot.actuate.autoconfigure.ManagementContextConfiguration&#x3D;\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.EndpointWebMvcManagementContextConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.EndpointWebMvcHypermediaManagementContextConfiguration</span><br></pre></td></tr></table></figure>

<p>Actuator 中提供了非常多的扩展点，默认情况下提供了一些常见的服务的监控检查的支持。</p>
<ul>
<li>DataSourceHealthIndicator</li>
<li>DiskSpaceHealthIndicator</li>
<li>RedisHealthIndicator</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/07/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86SpringBoot%EF%BC%8C%E6%8E%8C%E6%8F%A1%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/" data-id="cke9cjzd4000ff5rabnboex0e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JAVA并发编程关于锁的那些事，ReentantLock的底层设计深入浅出" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/26/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B3%E4%BA%8E%E9%94%81%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%8CReentantLock%E7%9A%84%E5%BA%95%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/" class="article-date">
  <time datetime="2020-06-26T08:34:17.000Z" itemprop="datePublished">2020-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/26/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B3%E4%BA%8E%E9%94%81%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%8CReentantLock%E7%9A%84%E5%BA%95%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/">JAVA并发编程关于锁的那些事，ReentantLock的底层设计深入浅出</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、介绍JUC"><a href="#一、介绍JUC" class="headerlink" title="一、介绍JUC"></a>一、介绍JUC</h1><p>java.util.concurrent是在并发编程中比较常用的工具类，里面包含很多用来在并发场景中使用的组件。比如<strong>线程池、阻塞队列、计时器、同步器、并发集合</strong>等等。</p>
<h1 id="二、介绍Lock"><a href="#二、介绍Lock" class="headerlink" title="二、介绍Lock"></a>二、介绍Lock</h1><p><strong>Lock最为重要的特性就是解决并发程序的安全性问题。</strong> 在JUC大部分组件都使用了Lock，所以了解和使用Lock显得尤为重要。Lock在JUC中本质上是以一个接口的形势表现的。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d4c105e6dc681?w=1498&h=529&f=png&s=50933" alt=""></p>
<p>我们可以从上面的图中可以看出关于锁有很多不同的实现类。下面来简单介绍一翻吧。</p>
<h2 id="2-1-ReentrantLock（重入锁）"><a href="#2-1-ReentrantLock（重入锁）" class="headerlink" title="2.1 ReentrantLock（重入锁）"></a>2.1 ReentrantLock（重入锁）</h2><p>ReentrantLock实现了Lock接口，表示重入锁。是线程在获得锁之后，再次获取锁不需要阻塞，而是直接关联一次计数器增加重入次数。<strong>后面我们重点分析ReentrantLock的原理。</strong></p>
<h2 id="2-2-ReentrantReadWriteLock（重入读写锁）"><a href="#2-2-ReentrantReadWriteLock（重入读写锁）" class="headerlink" title="2.2 ReentrantReadWriteLock（重入读写锁）"></a>2.2 ReentrantReadWriteLock（重入读写锁）</h2><p>ReentrantReadWriteLock实现了ReadWriteLock接口，其中有两把锁，一个<strong>ReadLock</strong>,一个<strong>WriteLock</strong>,它们分别实现了<strong>Lock</strong>接口。<strong>适合读多写少的场景。</strong><br>基本原则：</p>
<ul>
<li>读和读不互斥；</li>
<li>读和写互斥；</li>
<li>写和写互斥。<h2 id="2-3-StampedLock（改进版读写锁）"><a href="#2-3-StampedLock（改进版读写锁）" class="headerlink" title="2.3 StampedLock（改进版读写锁）"></a>2.3 StampedLock（改进版读写锁）</h2>StampedLock是JDK1.8引进的新的锁机制，它是读写锁的一个改进版。一种乐观的读策略，使得乐观锁完全不阻塞写线程。</li>
</ul>
<h1 id="三、ReentrantLock设计"><a href="#三、ReentrantLock设计" class="headerlink" title="三、ReentrantLock设计"></a>三、ReentrantLock设计</h1><p>说到重入锁ReentrantLock，就是再次获取锁的同时，只是对重入次数进行计数，而不需要阻塞来获取锁。先来看一个案例代码，这样容易理解重入锁的概念。</p>
<p>我们在测试代码中调用test()方法获得了当前对象的锁，然后在这个方法中去调用test1()方法，test2()中也存在一个实例锁，这个时候当前线程无法获取test1()中的对象锁而阻塞， 这样就会产生死锁。R<strong>eentrantLock重入锁的目的就是为了避免线程产生死锁。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantLockDemo &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void test() &#123;</span><br><span class="line">        System.out.println(&quot;Begin test...&quot;);</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test1() &#123;</span><br><span class="line">        System.out.println(&quot;Begin test1...&quot;);</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ReentrantLockDemo reentrantLockDemo &#x3D; new ReentrantLockDemo();</span><br><span class="line">        new Thread(reentrantLockDemo::test).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-1-ReentrantLock重入锁使用案例"><a href="#3-1-ReentrantLock重入锁使用案例" class="headerlink" title="3.1 ReentrantLock重入锁使用案例"></a>3.1 ReentrantLock重入锁使用案例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantLockDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    static Lock lock &#x3D; new ReentrantLock(true);</span><br><span class="line"></span><br><span class="line">    public static void incr() &#123;</span><br><span class="line">        &#x2F;&#x2F;线程A获取锁，计数state &#x3D; 1</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;退出线程 中断的过程往下传递.  true</span><br><span class="line">            &#x2F;&#x2F; sleep&#x2F; join&#x2F; wait</span><br><span class="line">            &#x2F;&#x2F;while()</span><br><span class="line">            &#x2F;&#x2F; ...</span><br><span class="line">            Thread.sleep(1);</span><br><span class="line">            count++;</span><br><span class="line">&#x2F;&#x2F;            decr();</span><br><span class="line">        &#125;catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            &#x2F;&#x2F;线程A释放锁，state&#x3D;1-1&#x3D;0</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void decr() &#123;</span><br><span class="line">        &#x2F;&#x2F;线程A再次获取锁，计数加1，state &#x3D; 2</span><br><span class="line">        lock.lock();</span><br><span class="line">        try&#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 &#x3D; new Thread(()-&gt;&#123;</span><br><span class="line">           ReentrantLockDemo.incr();</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t1.interrupt();&#x2F;&#x2F;线程中断</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; 0 ; i &lt; 1000; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                ReentrantLockDemo.incr();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        System.out.println(&quot;result &#x3D; &quot; + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-ReentrantReadWriteLock重入读写锁案例"><a href="#3-2-ReentrantReadWriteLock重入读写锁案例" class="headerlink" title="3.2 ReentrantReadWriteLock重入读写锁案例"></a>3.2 ReentrantReadWriteLock重入读写锁案例</h2><p>读写锁维护了一个读锁，一个写锁。一般情况下读写锁比排它锁的性能要好一些，因为大多数的场景是读多写少的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantReadWriteLockDemo &#123;</span><br><span class="line"></span><br><span class="line">    static Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    static ReentrantReadWriteLock rrwl &#x3D; new ReentrantReadWriteLock();</span><br><span class="line">    static Lock read &#x3D; rrwl.readLock();</span><br><span class="line">    static Lock write &#x3D; rrwl.writeLock();</span><br><span class="line"></span><br><span class="line">    public static Object get(String key) &#123;</span><br><span class="line">        System.out.println(&quot;Begin reading data...&quot;);</span><br><span class="line">        read.lock();</span><br><span class="line">        try&#123;</span><br><span class="line">            return map.get(key);</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            read.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object put(String key, Object obj) &#123;</span><br><span class="line">        System.out.println(&quot;Begin writing data...&quot;);</span><br><span class="line">        write.lock();</span><br><span class="line">        try&#123;</span><br><span class="line">            return map.put(key, obj);</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            write.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>读锁与读锁可以共享；</li>
<li>读锁与写锁不可以共享（排他）；</li>
<li>写锁与写锁不可以共享（排他。</li>
</ul>
<h2 id="3-3-ReentrantLock的实现原理"><a href="#3-3-ReentrantLock的实现原理" class="headerlink" title="3.3 ReentrantLock的实现原理"></a>3.3 ReentrantLock的实现原理</h2><p>我们在Synchronized中分析了<strong>偏向锁、轻量级锁、重量级锁</strong>。它们是基于<strong>乐观锁</strong>以及<strong>自旋锁</strong>来优化synchronized加锁的开销，在<strong>重量级锁阶段</strong>是通过线程的阻塞以及唤醒来达到线程竞争和同步的目的。</p>
<p>那么在ReentrantLock也一定存在这样的问题，那么它是怎么去解决的呢？这里我们需要引入AQS(AbstractQueueSynchronizer)。</p>
<h2 id="3-3-1-什么是AQS"><a href="#3-3-1-什么是AQS" class="headerlink" title="3.3.1 什么是AQS"></a>3.3.1 什么是AQS</h2><p>在Lock中，AQS是一个同步队列，它是一个同步工具，也是Lock用来实现线程同步的核心组件。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d5dcc08f66488?w=1080&h=383&f=png&s=295579" alt=""></p>
<h2 id="3-3-2-AQS的独占锁和共享锁"><a href="#3-3-2-AQS的独占锁和共享锁" class="headerlink" title="3.3.2 AQS的独占锁和共享锁"></a>3.3.2 AQS的独占锁和共享锁</h2><ul>
<li>独占锁：每次只有一个线程持有锁，<strong>ReentrantLock</strong>的独占锁方式；</li>
<li>共享锁：允许多个线程同时获得锁，并访问共享资源，<strong>ReentrantReadWriteLock</strong>的共享锁方式。</li>
</ul>
<h2 id="3-3-3-AQS的内部实现"><a href="#3-3-3-AQS的内部实现" class="headerlink" title="3.3.3 AQS的内部实现"></a>3.3.3 AQS的内部实现</h2><p>AQS内部维护的是一个FIFO的双向链表，这种数据结构的特点就是有<strong>两个指针</strong>，分别指向直接的后继节点next和直接的前驱节点prev。当线程抢占锁失败后，会封装成一个<strong>Node</strong>直接放入到AQS阻塞队列中。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d5dac220c07ab?w=1252&h=280&f=png&s=138903" alt=""></p>
<h2 id="3-3-4-AQS中的Node"><a href="#3-3-4-AQS中的Node" class="headerlink" title="3.3.4 AQS中的Node"></a>3.3.4 AQS中的Node</h2><p>先上AQS中的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line">        &#x2F;** Marker to indicate a node is waiting in shared mode *&#x2F;</span><br><span class="line">        static final Node SHARED &#x3D; new Node();</span><br><span class="line">        &#x2F;** Marker to indicate a node is waiting in exclusive mode *&#x2F;</span><br><span class="line">        static final Node EXCLUSIVE &#x3D; null;</span><br><span class="line"></span><br><span class="line">        &#x2F;** waitStatus value to indicate thread has cancelled *&#x2F;</span><br><span class="line">        static final int CANCELLED &#x3D;  1;</span><br><span class="line">        &#x2F;** waitStatus value to indicate successor&#39;s thread needs unparking *&#x2F;</span><br><span class="line">        static final int SIGNAL    &#x3D; -1;</span><br><span class="line">        &#x2F;** waitStatus value to indicate thread is waiting on condition *&#x2F;</span><br><span class="line">        static final int CONDITION &#x3D; -2;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * waitStatus value to indicate the next acquireShared should</span><br><span class="line">         * unconditionally propagate</span><br><span class="line">         *&#x2F;</span><br><span class="line">        static final int PROPAGATE &#x3D; -3;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Status field, taking on only the values:</span><br><span class="line">         *   SIGNAL:     The successor of this node is (or will soon be)</span><br><span class="line">         *               blocked (via park), so the current node must</span><br><span class="line">         *               unpark its successor when it releases or</span><br><span class="line">         *               cancels. To avoid races, acquire methods must</span><br><span class="line">         *               first indicate they need a signal,</span><br><span class="line">         *               then retry the atomic acquire, and then,</span><br><span class="line">         *               on failure, block.</span><br><span class="line">         *   CANCELLED:  This node is cancelled due to timeout or interrupt.</span><br><span class="line">         *               Nodes never leave this state. In particular,</span><br><span class="line">         *               a thread with cancelled node never again blocks.</span><br><span class="line">         *   CONDITION:  This node is currently on a condition queue.</span><br><span class="line">         *               It will not be used as a sync queue node</span><br><span class="line">         *               until transferred, at which time the status</span><br><span class="line">         *               will be set to 0. (Use of this value here has</span><br><span class="line">         *               nothing to do with the other uses of the</span><br><span class="line">         *               field, but simplifies mechanics.)</span><br><span class="line">         *   PROPAGATE:  A releaseShared should be propagated to other</span><br><span class="line">         *               nodes. This is set (for head node only) in</span><br><span class="line">         *               doReleaseShared to ensure propagation</span><br><span class="line">         *               continues, even if other operations have</span><br><span class="line">         *               since intervened.</span><br><span class="line">         *   0:          None of the above</span><br><span class="line">         *</span><br><span class="line">         * The values are arranged numerically to simplify use.</span><br><span class="line">         * Non-negative values mean that a node doesn&#39;t need to</span><br><span class="line">         * signal. So, most code doesn&#39;t need to check for particular</span><br><span class="line">         * values, just for sign.</span><br><span class="line">         *</span><br><span class="line">         * The field is initialized to 0 for normal sync nodes, and</span><br><span class="line">         * CONDITION for condition nodes.  It is modified using CAS</span><br><span class="line">         * (or when possible, unconditional volatile writes).</span><br><span class="line">         *&#x2F;</span><br><span class="line">        volatile int waitStatus;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Link to predecessor node that current node&#x2F;thread relies on</span><br><span class="line">         * for checking waitStatus. Assigned during enqueuing, and nulled</span><br><span class="line">         * out (for sake of GC) only upon dequeuing.  Also, upon</span><br><span class="line">         * cancellation of a predecessor, we short-circuit while</span><br><span class="line">         * finding a non-cancelled one, which will always exist</span><br><span class="line">         * because the head node is never cancelled: A node becomes</span><br><span class="line">         * head only as a result of successful acquire. A</span><br><span class="line">         * cancelled thread never succeeds in acquiring, and a thread only</span><br><span class="line">         * cancels itself, not any other node.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        volatile Node prev;&#x2F;&#x2F;前驱节点</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Link to the successor node that the current node&#x2F;thread</span><br><span class="line">         * unparks upon release. Assigned during enqueuing, adjusted</span><br><span class="line">         * when bypassing cancelled predecessors, and nulled out (for</span><br><span class="line">         * sake of GC) when dequeued.  The enq operation does not</span><br><span class="line">         * assign next field of a predecessor until after attachment,</span><br><span class="line">         * so seeing a null next field does not necessarily mean that</span><br><span class="line">         * node is at end of queue. However, if a next field appears</span><br><span class="line">         * to be null, we can scan prev&#39;s from the tail to</span><br><span class="line">         * double-check.  The next field of cancelled nodes is set to</span><br><span class="line">         * point to the node itself instead of null, to make life</span><br><span class="line">         * easier for isOnSyncQueue.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        volatile Node next;&#x2F;&#x2F;后继节点</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * The thread that enqueued this node.  Initialized on</span><br><span class="line">         * construction and nulled out after use.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        volatile Thread thread;&#x2F;&#x2F;当前线程</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Link to next node waiting on condition, or the special</span><br><span class="line">         * value SHARED.  Because condition queues are accessed only</span><br><span class="line">         * when holding in exclusive mode, we just need a simple</span><br><span class="line">         * linked queue to hold nodes while they are waiting on</span><br><span class="line">         * conditions. They are then transferred to the queue to</span><br><span class="line">         * re-acquire. And because conditions can only be exclusive,</span><br><span class="line">         * we save a field by using special value to indicate shared</span><br><span class="line">         * mode.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        Node nextWaiter;&#x2F;&#x2F;存储在condition队列中的后继节点</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Returns true if node is waiting in shared mode.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        &#x2F;&#x2F;是否为共享锁</span><br><span class="line">        final boolean isShared() &#123;</span><br><span class="line">            return nextWaiter &#x3D;&#x3D; SHARED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Returns previous node, or throws NullPointerException if null.</span><br><span class="line">         * Use when predecessor cannot be null.  The null check could</span><br><span class="line">         * be elided, but is present to help the VM.</span><br><span class="line">         *</span><br><span class="line">         * @return the predecessor of this node</span><br><span class="line">         *&#x2F;</span><br><span class="line">        final Node predecessor() throws NullPointerException &#123;</span><br><span class="line">            Node p &#x3D; prev;</span><br><span class="line">            if (p &#x3D;&#x3D; null)</span><br><span class="line">                throw new NullPointerException();</span><br><span class="line">            else</span><br><span class="line">                return p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node() &#123;    &#x2F;&#x2F; Used to establish initial head or SHARED marker</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;将线程组装成一个Node，添加到队列中</span><br><span class="line">        Node(Thread thread, Node mode) &#123;     &#x2F;&#x2F; Used by addWaiter</span><br><span class="line">            this.nextWaiter &#x3D; mode;</span><br><span class="line">            this.thread &#x3D; thread;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;在condition队列中进行使用</span><br><span class="line">        Node(Thread thread, int waitStatus) &#123; &#x2F;&#x2F; Used by Condition</span><br><span class="line">            this.waitStatus &#x3D; waitStatus;</span><br><span class="line">            this.thread &#x3D; thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h1 id="四、ReentrantLock的源码分析"><a href="#四、ReentrantLock的源码分析" class="headerlink" title="四、ReentrantLock的源码分析"></a>四、ReentrantLock的源码分析</h1><h2 id="4-1-画出ReentrantLock时序图"><a href="#4-1-画出ReentrantLock时序图" class="headerlink" title="4.1 画出ReentrantLock时序图"></a>4.1 画出ReentrantLock时序图</h2><p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d6465503eb58f?w=1600&h=680&f=png&s=77986" alt=""></p>
<h2 id="4-2-ReentrantLock-lock"><a href="#4-2-ReentrantLock-lock" class="headerlink" title="4.2 ReentrantLock.lock()"></a>4.2 ReentrantLock.lock()</h2><p>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void lock() &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d64a181e4952f?w=1231&h=226&f=png&s=30412" alt=""><br>根据源码可以看到具体的实现，分别是FairSync（公平）和NonFairSync（非公平）两个类。</p>
<ul>
<li>FairSync：所有线程严格按照FIFO规则获取锁；</li>
<li>NonFairSync：可以存在抢占锁的功能，不管队列上是否存在其他线程等待，新线程都有机会抢占锁。</li>
</ul>
<h2 id="4-3-NonFairSync-lock"><a href="#4-3-NonFairSync-lock" class="headerlink" title="4.3 NonFairSync.lock()"></a>4.3 NonFairSync.lock()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 7316153563782823691L;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Performs lock.  Try immediate barge, backing up to normal</span><br><span class="line">     * acquire on failure.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final void lock() &#123;</span><br><span class="line">        &#x2F;&#x2F;对于非公平锁，一开始就CAS抢占一下</span><br><span class="line">        &#x2F;&#x2F;如果CAS成功了，就表示获得了锁</span><br><span class="line">        if (compareAndSetState(0, 1))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        else&#x2F;&#x2F;如果CAS失败了，调用acquire()方法走竞争逻辑</span><br><span class="line">            acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        return nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-1-CAS的实现原理"><a href="#4-3-1-CAS的实现原理" class="headerlink" title="4.3.1 CAS的实现原理"></a>4.3.1 CAS的实现原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean compareAndSetState(int expect, int update) &#123;</span><br><span class="line">    &#x2F;&#x2F; See below for intrinsics setup to support this</span><br><span class="line">    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> CAS 就是 Unsafe 类中提供的一个原子操作。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/25/172e9942c6022b84?w=1342&h=265&f=png&s=29677" alt=""></p>
<ul>
<li>var1：需要改变的对象；</li>
<li>var2：偏移量(headOffset的值)；</li>
<li>var4：期待的值；</li>
<li>var5：更新后的值。</li>
</ul>
<p><strong>整个方法更新成功返回true，失败则返回false。</strong></p>
<p>state是AQS中的一个属性，对于重入锁（ReentrantLock）而言，它表示一个同步状态。有两层含义：</p>
<ul>
<li>当state=0时，表示无锁状态；</li>
<li><strong>当state&gt;0时，表示线程获得了锁，state+1，重入多少次数，state会递增；而当锁释放的时候，state次数递减，直到state=0其它线程才有资格抢占锁</strong></li>
</ul>
<p>接下来我们来看unsafe.cpp文件中最终执行的源码方法吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(&quot;Unsafe_CompareAndSwapInt&quot;);</span><br><span class="line">  &#x2F;&#x2F;将Java对象解析成JVM的oop</span><br><span class="line">  oop p &#x3D; JNIHandles::resolve(obj);</span><br><span class="line">  &#x2F;&#x2F;根据对象p和地址偏移量找到地址</span><br><span class="line">  jint* addr &#x3D; (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  &#x2F;&#x2F;基于 cas 比较并替换， x 表示需要更新的值，addr 表示 state 在内存中的地址，e 表示预期值</span><br><span class="line">  return (jint)(Atomic::cmpxchg(x, addr, e)) &#x3D;&#x3D; e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>

<h2 id="4-3-2-Unsafe类"><a href="#4-3-2-Unsafe类" class="headerlink" title="4.3.2 Unsafe类"></a>4.3.2 Unsafe类</h2><p>属于sun.misc包，不属于Java标准。但是很多 Java 的基础类库，包<br>括一些被广泛使用的高性能开发库都是基于 Unsafe 类开发的，比如<strong>Netty、<br>Hadoop、Kafka</strong> 等；</p>
<p>Unsafe 可认为是 Java 中留下的后门，提供了一些低层次操作，如直接内存访问、<br>线程的挂起和恢复、CAS、线程同步、内存屏障等。</p>
<h2 id="4-4-AQS-acquire"><a href="#4-4-AQS-acquire" class="headerlink" title="4.4 AQS.acquire()"></a>4.4 AQS.acquire()</h2><p>从下面源码分析来看，如果CAS未能操作成功，说明state已经不等于0了，此时需要执行acquire(1)方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    if (compareAndSetState(0, 1))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    else</span><br><span class="line">        acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看acquire(1)方法的源码吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>尝试使用tryAcquire(arg)获得独占锁，如果成功返回true，失败返回false；</li>
<li>如果tryAcquire失败，则通过addWaiter方法将当前线程封装成Node对象加入到AQS队列尾部；</li>
<li>acquireQueued，将Node作为参数，通过自旋的方式获得锁，下面是对于的源码。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted &#x3D; false;</span><br><span class="line">        for (;;) &#123;&#x2F;&#x2F;自旋方式获得锁</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                failed &#x3D; false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4-1-NonfairSync-tryAcquire"><a href="#4-4-1-NonfairSync-tryAcquire" class="headerlink" title="4.4.1 NonfairSync.tryAcquire()"></a>4.4.1 NonfairSync.tryAcquire()</h2><p>这个方法的作用是尝试获取锁，如果成功返回 true，不成功返回 false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    return nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来看此方法的具体实现：</p>
<ul>
<li>获得当前线程，判断当前锁的状态；</li>
<li>如果state=0表示无锁状态，通过CAS更新state状态的值；</li>
<li>如果当前线程属于重入，则增加重入次数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    int c &#x3D; getState();</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc &#x3D; c + acquires;</span><br><span class="line">        if (nextc &lt; 0) &#x2F;&#x2F; overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-AQS-addWaiter"><a href="#4-5-AQS-addWaiter" class="headerlink" title="4.5 AQS.addWaiter()"></a>4.5 AQS.addWaiter()</h2><p>当tryAcquire()获取锁失败时，则会调用此方法来将当前线程封装成Node对象加入到AQS队列尾部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">    &#x2F;&#x2F; Try the fast path of enq; backup to full enq on failure</span><br><span class="line">    &#x2F;&#x2F;tail表示AQS队列的尾部，默认为null</span><br><span class="line">    Node pred &#x3D; tail;</span><br><span class="line">    if (pred !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;当前线程的prev执行tail</span><br><span class="line">        node.prev &#x3D; pred;</span><br><span class="line">        &#x2F;&#x2F;通过CAS把node加入到队列中，并设置为tail</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            &#x2F;&#x2F;设置成功后，把tail节点的next指向当前node</span><br><span class="line">            pred.next &#x3D; node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;tail为null时，把node加入到同步队列</span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>enq(node)方法通过自旋的方式，把当前节点node加入到同步队列中去，下面看一下enq源码吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        &#x2F;&#x2F;将新的节点prev指向tail</span><br><span class="line">        Node t &#x3D; tail;</span><br><span class="line">        if (t &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; Must initialize</span><br><span class="line">            &#x2F;&#x2F;通过CAS将tail设置为新的节点</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail &#x3D; head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.prev &#x3D; t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                &#x2F;&#x2F;将原来的tail的next节点指向新的节点</span><br><span class="line">                t.next &#x3D; node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172eea9bb11f862b?w=996&h=529&f=png&s=66511" alt=""></p>
<h2 id="4-6-AQS-acquireQueued"><a href="#4-6-AQS-acquireQueued" class="headerlink" title="4.6 AQS.acquireQueued()"></a>4.6 AQS.acquireQueued()</h2><p>通过 addWaiter 方法把线程添加到链表后，会接着把 Node 作为参数传递给<br>acquireQueued 方法，去竞争锁。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172eed6b9d9d8b11?w=790&h=157&f=png&s=15582" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;线程中断标记</span><br><span class="line">        boolean interrupted &#x3D; false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            &#x2F;&#x2F;获得当前节点的prev节点</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            &#x2F;&#x2F;如果是head节点，说明有资格去抢占锁</span><br><span class="line">            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                &#x2F;&#x2F;获取锁成功，线程A已经释放了锁，然后设置head为线程B获得执行权限</span><br><span class="line">                setHead(node);</span><br><span class="line">                &#x2F;&#x2F;把原来的head节点从链表中移除，弱引用</span><br><span class="line">                p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                failed &#x3D; false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;线程A可能还没释放锁，使得线程B在执行tryAcquire时返回false</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                &#x2F;&#x2F;当前线程在等待过程中有没有中断</span><br><span class="line">                interrupted &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F;取消锁的操作</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-6-1-shouldParkAfterFailedAcquire"><a href="#4-6-1-shouldParkAfterFailedAcquire" class="headerlink" title="4.6.1 shouldParkAfterFailedAcquire()"></a>4.6.1 shouldParkAfterFailedAcquire()</h2><p>线程A的锁可能还没释放，那么此时线程B来抢占锁肯定失败，就会调用此方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    &#x2F;&#x2F;前置节点</span><br><span class="line">    int ws &#x3D; pred.waitStatus;</span><br><span class="line">    &#x2F;&#x2F;如果前置节点为 SIGNAL，意味着只需要等待其他前置节点的线程被释放</span><br><span class="line">    if (ws &#x3D;&#x3D; Node.SIGNAL)</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * This node has already set status asking a release</span><br><span class="line">         * to signal it, so it can safely park.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        &#x2F;&#x2F;返回true，可以放心挂起了</span><br><span class="line">        return true;</span><br><span class="line">    &#x2F;&#x2F;ws 大于 0，意味着 prev 节点取消了排队，直接移除这个节点就行</span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">         * indicate retry.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        do &#123;</span><br><span class="line">            &#x2F;&#x2F;相当于: pred&#x3D;pred.prev;node.prev&#x3D;pred;</span><br><span class="line">            node.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);&#x2F;&#x2F;这里采用循环，从双向列表中移除 CANCELLED 的节点</span><br><span class="line">        pred.next &#x3D; node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="line">         * need a signal, but don&#39;t park yet.  Caller will need to</span><br><span class="line">         * retry to make sure it cannot acquire before parking.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        &#x2F;&#x2F;利用 cas 设置 prev 节点的状态为 SIGNAL(-1)</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Node的状态有5种，默认状态是0，以下是其它四种状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该 Node 的结点, 其结点的 waitStatus为CANCELLED，即结束状态，进入该状态后的结点将不会再变化</span><br><span class="line">static final int CANCELLED &#x3D;  1;</span><br><span class="line">&#x2F;&#x2F;只要前置节点释放锁，就会通知标识为 SIGNAL 状态的后续节点的线程</span><br><span class="line">static final int SIGNAL    &#x3D; -1;</span><br><span class="line">&#x2F;&#x2F;表示该线程在condition队列中阻塞</span><br><span class="line">static final int CONDITION &#x3D; -2;</span><br><span class="line">&#x2F;&#x2F;共享模式下，PROPAGATE 状态的线程处于可运行状态</span><br><span class="line">static final int PROPAGATE &#x3D; -3;</span><br></pre></td></tr></table></figure>

<h2 id="4-6-2-parkAndCheckInterrupt"><a href="#4-6-2-parkAndCheckInterrupt" class="headerlink" title="4.6.2 parkAndCheckInterrupt()"></a>4.6.2 parkAndCheckInterrupt()</h2><p>使用LockSupport.park(this)挂起当前线程为WAITING状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    LockSupport.park(this);</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Thread.interrupted，返回当前线程是否被其他线程触发过中断请求，也就是<br>thread.interrupt(); 如果有触发过中断请求，那么这个方法会返回当前的中断标识<br>true，并且对中断标识进行复位标识已经响应过了中断请求。如果返回 true，意味<br>着在 acquire 方法中会执行 selfInterrupt()。</p>
<h2 id="4-6-3-selfInterrupt"><a href="#4-6-3-selfInterrupt" class="headerlink" title="4.6.3 selfInterrupt()"></a>4.6.3 selfInterrupt()</h2><p>当前线程在acquireQueued中被中断过，则需要产生一个中断请求，原因是线程在调用acquireQueued方法的时候不会响应中断请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void selfInterrupt() &#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-6-4-LockSupport"><a href="#4-6-4-LockSupport" class="headerlink" title="4.6.4 LockSupport"></a>4.6.4 LockSupport</h2><p>从Java6开始引用的一个提供了基本的线程同步原语的类，LockSupport本质还是调用了Unsafe中的方法：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172ef8298e418507?w=757&h=172&f=png&s=11808" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(void, Unsafe_Unpark(JNIEnv *env, jobject unsafe, jobject jthread))</span><br><span class="line">  UnsafeWrapper(&quot;Unsafe_Unpark&quot;);</span><br><span class="line">  Parker* p &#x3D; NULL;</span><br><span class="line">  if (jthread !&#x3D; NULL) &#123;</span><br><span class="line">    oop java_thread &#x3D; JNIHandles::resolve_non_null(jthread);</span><br><span class="line">    if (java_thread !&#x3D; NULL) &#123;</span><br><span class="line">      jlong lp &#x3D; java_lang_Thread::park_event(java_thread);</span><br><span class="line">      if (lp !&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; This cast is OK even though the jlong might have been read</span><br><span class="line">        &#x2F;&#x2F; non-atomically on 32bit systems, since there, one word will</span><br><span class="line">        &#x2F;&#x2F; always be zero anyway and the value set is always the same</span><br><span class="line">        p &#x3D; (Parker*)addr_from_java(lp);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; Grab lock if apparently null or using older version of library</span><br><span class="line">        MutexLocker mu(Threads_lock);</span><br><span class="line">        java_thread &#x3D; JNIHandles::resolve_non_null(jthread);</span><br><span class="line">        if (java_thread !&#x3D; NULL) &#123;</span><br><span class="line">          JavaThread* thr &#x3D; java_lang_Thread::thread(java_thread);</span><br><span class="line">          if (thr !&#x3D; NULL) &#123;</span><br><span class="line">            p &#x3D; thr-&gt;parker();</span><br><span class="line">            if (p !&#x3D; NULL) &#123; &#x2F;&#x2F; Bind to Java thread for next time.</span><br><span class="line">              java_lang_Thread::set_park_event(java_thread, addr_to_java(p));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (p !&#x3D; NULL) &#123;</span><br><span class="line">#ifndef USDT2</span><br><span class="line">    HS_DTRACE_PROBE1(hotspot, thread__unpark, p);</span><br><span class="line">#else &#x2F;* USDT2 *&#x2F;</span><br><span class="line">    HOTSPOT_THREAD_UNPARK(</span><br><span class="line">                          (uintptr_t) p);</span><br><span class="line">#endif &#x2F;* USDT2 *&#x2F;</span><br><span class="line">    p-&gt;unpark();</span><br><span class="line">  &#125;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(void, Unsafe_Park(JNIEnv *env, jobject unsafe, jboolean isAbsolute, jlong time))</span><br><span class="line">  UnsafeWrapper(&quot;Unsafe_Park&quot;);</span><br><span class="line">  EventThreadPark event;</span><br><span class="line">#ifndef USDT2</span><br><span class="line">  HS_DTRACE_PROBE3(hotspot, thread__park__begin, thread-&gt;parker(), (int) isAbsolute, time);</span><br><span class="line">#else &#x2F;* USDT2 *&#x2F;</span><br><span class="line">   HOTSPOT_THREAD_PARK_BEGIN(</span><br><span class="line">                             (uintptr_t) thread-&gt;parker(), (int) isAbsolute, time);</span><br><span class="line">#endif &#x2F;* USDT2 *&#x2F;</span><br><span class="line">  JavaThreadParkedState jtps(thread, time !&#x3D; 0);</span><br><span class="line">  thread-&gt;parker()-&gt;park(isAbsolute !&#x3D; 0, time);</span><br><span class="line">#ifndef USDT2</span><br><span class="line">  HS_DTRACE_PROBE1(hotspot, thread__park__end, thread-&gt;parker());</span><br><span class="line">#else &#x2F;* USDT2 *&#x2F;</span><br><span class="line">  HOTSPOT_THREAD_PARK_END(</span><br><span class="line">                          (uintptr_t) thread-&gt;parker());</span><br><span class="line">#endif &#x2F;* USDT2 *&#x2F;</span><br><span class="line">  if (event.should_commit()) &#123;</span><br><span class="line">    oop obj &#x3D; thread-&gt;current_park_blocker();</span><br><span class="line">    event.set_klass((obj !&#x3D; NULL) ? obj-&gt;klass() : NULL);</span><br><span class="line">    event.set_timeout(time);</span><br><span class="line">    event.set_address((obj !&#x3D; NULL) ? (TYPE_ADDRESS) cast_from_oop&lt;uintptr_t&gt;(obj) : 0);</span><br><span class="line">    event.commit();</span><br><span class="line">  &#125;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>

<h2 id="4-7-ReentrantLock-unlock"><a href="#4-7-ReentrantLock-unlock" class="headerlink" title="4.7 ReentrantLock.unlock()"></a>4.7 ReentrantLock.unlock()</h2><p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172ef99ae113acc9?w=776&h=146&f=png&s=11943" alt=""><br>在unlock()方法中，会调用release()方法来释放锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    &#x2F;&#x2F;释放锁成功</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        &#x2F;&#x2F;得到AQS队列中的head节点</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        &#x2F;&#x2F;如果head不为空并且状态不等于0，调用unpark唤醒后续节点</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-7-1-tryRelease"><a href="#4-7-1-tryRelease" class="headerlink" title="4.7.1 tryRelease()"></a>4.7.1 tryRelease()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    &#x2F;&#x2F;state状态减掉传入的参数1</span><br><span class="line">    int c &#x3D; getState() - releases;</span><br><span class="line">    if (Thread.currentThread() !&#x3D; getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    boolean free &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;如果结果为0，将排它锁的Owner设置为null</span><br><span class="line">    &#x2F;&#x2F;解锁的时候减掉 1，同一个锁，在可以重入后，可能会被叠加为 2、3、4 这些值，只有 unlock()的次数与 lock()的次数对应才会将 Owner 线程设置为空，而且也只有这种情况下才会返回 true</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        free &#x3D; true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-7-2-unparkSuccessor"><a href="#4-7-2-unparkSuccessor" class="headerlink" title="4.7.2 unparkSuccessor()"></a>4.7.2 unparkSuccessor()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">       &#x2F;*</span><br><span class="line">        * If status is negative (i.e., possibly needing signal) try</span><br><span class="line">        * to clear in anticipation of signalling.  It is OK if this</span><br><span class="line">        * fails or if status is changed by waiting thread.</span><br><span class="line">        *&#x2F;</span><br><span class="line">       &#x2F;&#x2F;获得head节点的状态</span><br><span class="line">       int ws &#x3D; node.waitStatus;</span><br><span class="line">       if (ws &lt; 0)</span><br><span class="line">           &#x2F;&#x2F;设置head节点的状态为0</span><br><span class="line">           compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">       &#x2F;*</span><br><span class="line">        * Thread to unpark is held in successor, which is normally</span><br><span class="line">        * just the next node.  But if cancelled or apparently null,</span><br><span class="line">        * traverse backwards from tail to find the actual</span><br><span class="line">        * non-cancelled successor.</span><br><span class="line">        *&#x2F;</span><br><span class="line">       &#x2F;&#x2F;得到head节点的下一个节点</span><br><span class="line">       Node s &#x3D; node.next;</span><br><span class="line">       &#x2F;&#x2F;如果下一个节点为 null 或者 status&gt;0 表示 cancelled 状态</span><br><span class="line">       if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">           s &#x3D; null;</span><br><span class="line">           &#x2F;&#x2F;通过从尾部节点开始扫描，找到距离 head 最近的一个waitStatus&lt;&#x3D;0 的节点</span><br><span class="line">           for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)</span><br><span class="line">               if (t.waitStatus &lt;&#x3D; 0)</span><br><span class="line">                   s &#x3D; t;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F;next 节点不为空，直接唤醒这个线程即可</span><br><span class="line">       if (s !&#x3D; null)</span><br><span class="line">           LockSupport.unpark(s.thread);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-7-3-为什么释放锁的时候是从tail节点开始扫描的？"><a href="#4-7-3-为什么释放锁的时候是从tail节点开始扫描的？" class="headerlink" title="4.7.3 为什么释放锁的时候是从tail节点开始扫描的？"></a>4.7.3 为什么释放锁的时候是从tail节点开始扫描的？</h2><p>我们在加锁的enq()方法中，在 cas 操作之后，t.next=node 操作之前。 存在其他线程调用 unlock 方法从 head开始往后遍历，由于 t.next=node 还没执行意味着链表的关系还没有建立完整。就会导致遍历到 t 节点的时候被中断。所以从后往前遍历，一定不会存在这个问题。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172efa6404e1343a?w=893&h=214&f=png&s=21823" alt=""></p>
<h2 id="4-8-原本挂起的线程如何执行呢？"><a href="#4-8-原本挂起的线程如何执行呢？" class="headerlink" title="4.8 原本挂起的线程如何执行呢？"></a>4.8 原本挂起的线程如何执行呢？</h2><p>通过ReentrantLock.unlock()将原本挂起的线程换唤醒后继续执行，原来被挂起的线程是在 <strong>acquireQueued</strong>() 方法中，所以被唤醒以后继续从这个方法开始执行.</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172efb16874cc2df?w=1156&h=230&f=png&s=24416" alt=""></p>
<h1 id="五、公平锁与非公平锁的区别"><a href="#五、公平锁与非公平锁的区别" class="headerlink" title="五、公平锁与非公平锁的区别"></a>五、公平锁与非公平锁的区别</h1><p>锁的公平性是相对于获取锁的顺序而言的，如果是一个公平锁，那么锁的获取顺序<br>就应该符合请求的绝对时间顺序，也就是 <strong>FIFO</strong>。 只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁则不一样，差异点<br>有两个：</p>
<p>1、FairSync.lock()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、NonfairSync.lock()方法</p>
<p>非公平锁在获取锁的时候，会先通过 CAS 进行抢占，而公平锁则不会。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    if (compareAndSetState(0, 1))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    else</span><br><span class="line">        acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/06/26/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B3%E4%BA%8E%E9%94%81%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%8CReentantLock%E7%9A%84%E5%BA%95%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/" data-id="cke9cjzfh000zf5radbdp9eua" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JAVA并发编程阶段总结篇，解决死锁问题以及ThreadLocal原理分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/20/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E7%AF%87%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2020-06-20T10:08:17.000Z" itemprop="datePublished">2020-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/20/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E7%AF%87%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">JAVA并发编程阶段总结篇，解决死锁问题以及ThreadLocal原理分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、线程的死锁问题"><a href="#一、线程的死锁问题" class="headerlink" title="一、线程的死锁问题"></a>一、线程的死锁问题</h1><p>首先来看下死锁的概念吧：一组相互竞争的线程因为相互等待，造成“永久”阻塞的现象，我们称之为死锁；那么有死锁必然就有活锁了，什么是活锁呢？即任务或者执行者都没有被阻塞，由于某些条件未被满足，一直处于重试-&gt;尝试执行-&gt;执行失败的过程被成为活锁。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/14/172b0a706ee448b8?w=1273&h=744&f=png&s=163373" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/14/172b0a72988b6f3f?w=756&h=406&f=png&s=17964" alt=""></p>
<h2 id="1-1-死锁发生的条件"><a href="#1-1-死锁发生的条件" class="headerlink" title="1.1 死锁发生的条件"></a>1.1 死锁发生的条件</h2><p>只要满足以下<strong>四个条件</strong>，就必然会产生死锁：</p>
<ul>
<li><strong>线程互斥</strong>，共享资源只能被一个线程占用，要么线程A要么线程B（<strong>有一个坑位，谁抢到就是谁的</strong>）；</li>
<li><strong>占有且等待</strong>，线程T已经获得资源A，在同时等待资源B的时候，不释放资源A（<strong>占着茅坑等送纸</strong>）；</li>
<li><strong>不可抢占</strong>，其它线程不能强制抢占线程T占有的资源（<strong>有且仅有的坑位被占，不能马上赶走别人</strong>）；</li>
<li><strong>循环等待</strong>，线程T1等待线程T2占有的资源，线程T2等待线程T2占有的资源（<strong>我惦记着你的，你惦记着我的</strong>）。</li>
</ul>
<h2 id="1-2-如何解决死锁问题"><a href="#1-2-如何解决死锁问题" class="headerlink" title="1.2 如何解决死锁问题"></a>1.2 如何解决死锁问题</h2><p>针对上面的发生死锁的四个条件，只需要破坏其中的一个条件，就不会发生死锁。</p>
<ul>
<li>互斥条件无法破坏，因为使用锁（lock或synchronized）就是互斥的；</li>
<li>占有且等待，一次性申请所有的资源，就不存在等待了；</li>
<li>不可抢占，占有资源的线程如果需要申请其它资源的时候，可以主动释放占有的资源；</li>
<li>循环等待，可以有线性顺序的方式来申请资源。从序号小的开始，然后再接着申请序号大的资源。</li>
</ul>
<h2 id="1-3-Thread-join"><a href="#1-3-Thread-join" class="headerlink" title="1.3 Thread.join"></a>1.3 Thread.join</h2><p>它的作用就是让线程的执行结果对后续线程的访问可见。</p>
<h1 id="二、-ThreadLocal原理分析"><a href="#二、-ThreadLocal原理分析" class="headerlink" title="二、 ThreadLocal原理分析"></a>二、 ThreadLocal原理分析</h1><p>ThreadLocal实际上是一种线程的隔离机制，就是为了保证在多线程环境下对于共享变量的访问的安全性。</p>
<h2 id="2-1-set-方法"><a href="#2-1-set-方法" class="headerlink" title="2.1 set()方法"></a>2.1 set()方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line"> * Sets the current thread&#39;s copy of this thread-local variable</span><br><span class="line"> * to the specified value.  Most subclasses will have no need to</span><br><span class="line"> * override this method, relying solely on the &#123;@link #initialValue&#125;</span><br><span class="line"> * method to set the values of thread-locals.</span><br><span class="line"> *</span><br><span class="line"> * @param value the value to be stored in the current thread&#39;s copy of</span><br><span class="line"> *        this thread-local.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">    if (map !&#x3D; null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当map不为空时，执行map.set(this, value)方法</strong>，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; We don&#39;t use a fast path as with get() because it is at</span><br><span class="line">    &#x2F;&#x2F; least as common to use set() to create new entries as</span><br><span class="line">    &#x2F;&#x2F; it is to replace existing ones, in which case, a fast</span><br><span class="line">    &#x2F;&#x2F; path would fail more often than not.</span><br><span class="line"></span><br><span class="line">    Entry[] tab &#x3D; table;</span><br><span class="line">    int len &#x3D; tab.length;</span><br><span class="line">    &#x2F;&#x2F;根据哈希码和数组长度求得元素的放置位置，即Entry数组的下标</span><br><span class="line">    int i &#x3D; key.threadLocalHashCode &amp; (len-1);</span><br><span class="line">    &#x2F;&#x2F;从i开始遍历到数组的最后一个Entry（进行线性探索）</span><br><span class="line">    for (Entry e &#x3D; tab[i];</span><br><span class="line">         e !&#x3D; null;</span><br><span class="line">         e &#x3D; tab[i &#x3D; nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line">        &#x2F;&#x2F;如果key相等，就覆盖value</span><br><span class="line">        if (k &#x3D;&#x3D; key) &#123;</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果key为空，用新的key，value，同时清理历史key&#x3D;null（弱引用）的旧数据</span><br><span class="line">        if (k &#x3D;&#x3D; null) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] &#x3D; new Entry(key, value);</span><br><span class="line">    int sz &#x3D; ++size;</span><br><span class="line">    &#x2F;&#x2F;如果超过设置的閥值，则需要进行扩容</span><br><span class="line">    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;&#x3D; threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-线性探测"><a href="#2-2-线性探测" class="headerlink" title="2.2 线性探测"></a>2.2 线性探测</h2><p>在上面的源码中使用了<strong>线性探测</strong>的方式来解决<strong>hash冲突</strong>问题。</p>
<p>那么什么是线性探测呢？</p>
<p>线性探测是一种开放的寻址策略。hash表是直接通过key访问数据结构的，通过hash函数来把key映射到hash表中的一个位置的访问记录，从而加速查找的速度。存储记录的就叫hash表（也成为散列表）。</p>
<p>由两种方式情况解决这个冲突问题：</p>
<ul>
<li><strong>写入</strong>：找到发生冲突的最近单元</li>
<li><strong>查找</strong>：从发生冲突的位置开始，往后查找</li>
</ul>
<p>通俗的解释是这样子的：<strong>我们去蹲坑的时候发现坑位被占，就找后面的一个坑，如果后面的这个坑空着，那么就占用；如果后面的坑被占用，则一直往后面的坑位遍历，直到找到空闲的坑位为止，否则就一直憋着。</strong></p>
<h2 id="2-3-repalceStaleEntry-方法"><a href="#2-3-repalceStaleEntry-方法" class="headerlink" title="2.3 repalceStaleEntry()方法"></a>2.3 repalceStaleEntry()方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value,</span><br><span class="line">                               int staleSlot) &#123;</span><br><span class="line">    Entry[] tab &#x3D; table;</span><br><span class="line">    int len &#x3D; tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Back up to check for prior stale entry in current run.</span><br><span class="line">    &#x2F;&#x2F; We clean out whole runs at a time to avoid continual</span><br><span class="line">    &#x2F;&#x2F; incremental rehashing due to garbage collector freeing</span><br><span class="line">    &#x2F;&#x2F; up refs in bunches (i.e., whenever the collector runs).</span><br><span class="line">    &#x2F;&#x2F;向前扫描，查找最前一个无效的slot</span><br><span class="line">    int slotToExpunge &#x3D; staleSlot;</span><br><span class="line">    for (int i &#x3D; prevIndex(staleSlot, len);</span><br><span class="line">         (e &#x3D; tab[i]) !&#x3D; null;</span><br><span class="line">         i &#x3D; prevIndex(i, len))</span><br><span class="line">        if (e.get() &#x3D;&#x3D; null)</span><br><span class="line">            &#x2F;&#x2F;通过循环遍历，可以定位到最前面的一个无效的slot</span><br><span class="line">            slotToExpunge &#x3D; i;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Find either the key or trailing null slot of run, whichever</span><br><span class="line">    &#x2F;&#x2F; occurs first</span><br><span class="line">    &#x2F;&#x2F;从i开始遍历到数组的最后一个Entry（进行线性探索）</span><br><span class="line">    for (int i &#x3D; nextIndex(staleSlot, len);</span><br><span class="line">         (e &#x3D; tab[i]) !&#x3D; null;</span><br><span class="line">         i &#x3D; nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If we find key, then we need to swap it</span><br><span class="line">        &#x2F;&#x2F; with the stale entry to maintain hash table order.</span><br><span class="line">        &#x2F;&#x2F; The newly stale slot, or any other stale slot</span><br><span class="line">        &#x2F;&#x2F; encountered above it, can then be sent to expungeStaleEntry</span><br><span class="line">        &#x2F;&#x2F; to remove or rehash all of the other entries in run.</span><br><span class="line">        &#x2F;&#x2F;找到匹配的key</span><br><span class="line">        if (k &#x3D;&#x3D; key) &#123;</span><br><span class="line">            &#x2F;&#x2F;更新对应的slot对应的value</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line">            &#x2F;&#x2F;与无效的slot进行替换</span><br><span class="line">            tab[i] &#x3D; tab[staleSlot];</span><br><span class="line">            tab[staleSlot] &#x3D; e;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Start expunge at preceding stale entry if it exists</span><br><span class="line">            &#x2F;&#x2F;&#x2F;&#x2F;如果最早的一个无效的slot和当前的staleSlot相等，则从i作为清理的起点</span><br><span class="line">            if (slotToExpunge &#x3D;&#x3D; staleSlot)</span><br><span class="line">                slotToExpunge &#x3D; i;</span><br><span class="line">            &#x2F;&#x2F;从slotToExpunge开始做一次连续的清理    </span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If we didn&#39;t find stale entry on backward scan, the</span><br><span class="line">        &#x2F;&#x2F; first stale entry seen while scanning for key is the</span><br><span class="line">        &#x2F;&#x2F; first still present in the run.</span><br><span class="line">        &#x2F;&#x2F;如果当前的slot已经无效，并且向前扫描过程中没有无效slot，则更新slotToExpunge为当前位置</span><br><span class="line">        if (k &#x3D;&#x3D; null &amp;&amp; slotToExpunge &#x3D;&#x3D; staleSlot)</span><br><span class="line">            slotToExpunge &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If key not found, put new entry in stale slot</span><br><span class="line">    &#x2F;&#x2F;如果key对应的value在entry中不存在，则直接放一个新的entry</span><br><span class="line">    tab[staleSlot].value &#x3D; null;</span><br><span class="line">    tab[staleSlot] &#x3D; new Entry(key, value);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If there are any other stale entries in run, expunge them</span><br><span class="line">    &#x2F;&#x2F;如果有任何一个无效的slot，则做一次清理</span><br><span class="line">    if (slotToExpunge !&#x3D; staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-斐波那契额散列（Fibonacci散列算法）"><a href="#2-4-斐波那契额散列（Fibonacci散列算法）" class="headerlink" title="2.4 斐波那契额散列（Fibonacci散列算法）"></a>2.4 斐波那契额散列（Fibonacci散列算法）</h2><p>下面还是给一段ThreadLocal的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;HASH_INCREMENT是为了让哈希码能均匀的分布在2的N次方的数组里</span><br><span class="line">private static final int HASH_INCREMENT &#x3D; 0x61c88647;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Returns the next hash code.</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static int nextHashCode() &#123;</span><br><span class="line">    return nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中定义了一个魔法值 HASH_INCREMENT = <strong>0x61c88647</strong>，对于实例变量threadLocalHashCode，每当创建ThreadLocal实例时这个值都会<strong>getAndAdd(0x61c88647)</strong>。</p>
<p>HASH_INCREMENT 再借助一定的算法，就可以将哈希码能均匀的分布在 2 的 N 次方的数组里，<strong>保证了散列表的离散度</strong>，从而降低了冲突几率。我们不妨来写段测试代码吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class FibonacciHash &#123;</span><br><span class="line"></span><br><span class="line">    private static final int HASH_INCREMENT &#x3D; 0x61c88647;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        magicHash(16);</span><br><span class="line">        magicHash(32);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void magicHash(int size) &#123;</span><br><span class="line">        int hashCode &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">            hashCode &#x3D; i * HASH_INCREMENT + HASH_INCREMENT;</span><br><span class="line">            System.out.print((hashCode &amp; (size - 1)) + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行main()方法的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7 14 5 12 3 10 1 8 15 6 13 4 11 2 9 0 </span><br><span class="line">7 14 21 28 3 10 17 24 31 6 13 20 27 2 9 16 23 30 5 12 19 26 1 8 15 22 29 4 11 18 25 0</span><br></pre></td></tr></table></figure>

<p><strong>产生的哈希码分布确实是很均匀，而且没有任何冲突。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/06/20/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E7%AF%87%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" data-id="cke9cjzcw0008f5ra0ptpf41m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JAVA并发编程递进篇，探索线程安全性volatile关键字如何保证可见性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/30/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%80%92%E8%BF%9B%E7%AF%87%EF%BC%8C%E6%8E%A2%E7%B4%A2%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7/" class="article-date">
  <time datetime="2020-05-30T08:56:53.000Z" itemprop="datePublished">2020-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/30/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%80%92%E8%BF%9B%E7%AF%87%EF%BC%8C%E6%8E%A2%E7%B4%A2%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7/">JAVA并发编程递进篇，探索线程安全性volatile关键字如何保证可见性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一开始就直接上代码，直接来看一段木有使用<strong>volatile</strong>关键字的线程调用代码吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class VolatileDemo &#123;</span><br><span class="line">    public static boolean stop &#x3D; false;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t &#x3D; new Thread(()-&gt;&#123;</span><br><span class="line">            int i &#x3D; 0;</span><br><span class="line">            while(!stop) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                &#x2F;&#x2F;System.out.println(&quot;result:&quot; + i);</span><br><span class="line">                &#x2F;*</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(0);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                *&#x2F;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;myThread&quot;);</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        stop&#x3D;true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然运行<strong>main</strong>()方法后，循环并没有结束，程序一直处于运行状态。</p>
<p>如果我们要使得循环结束该怎么做呢？</p>
<h1 id="一、Volatile关键字的使用递进"><a href="#一、Volatile关键字的使用递进" class="headerlink" title="一、Volatile关键字的使用递进"></a>一、Volatile关键字的使用递进</h1><h2 id="1-1-System-out-println"><a href="#1-1-System-out-println" class="headerlink" title="1.1 System.out.println"></a>1.1 System.out.println</h2><p>使用print打印i的值，发现循环就被终止了。这是为什么呢？我们不妨来看下<strong>println</strong>()方法的源码吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void println(String x) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>底层方法使用<strong>synchronized</strong>关键字，这个同步会防止循环期间对变量stop的值缓存。</p>
<p>从IO角度来说<strong>，print本质上是一个IO的操作</strong>，我们知道磁盘IO的效率一定要比CPU的计算效率慢得多，所以IO可以使得CPU有时间去做内存刷新的事情，从而导致这个现象。比如我们可以在里面定义一个new File()。同样会达到效果。</p>
<h2 id="1-2-Thread-sleep-0"><a href="#1-2-Thread-sleep-0" class="headerlink" title="1.2 Thread.sleep(0)"></a>1.2 Thread.sleep(0)</h2><p>增加Thread.sleep(0)也能生效，是和cpu、以及jvm、操作系统等因素有关系。</p>
<p>官方文档上是说，Thread.sleep没有任何同步语义，编译器不需要在调用Thread.sleep之前把缓存在寄存器中的写刷新到给共享内存、也不需要在Thread.sleep之后重新加载缓存在寄存器中的值。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/26/172514091156910a?w=1453&h=523&f=png&s=83759" alt=""></p>
<p>编译器可以自由选择读取stop的值一次或者多次，这个是由编译器自己来决定的。<br>Thread.sleep(0)导致线程切换，线程切换会导致缓存失效从而读取到了新的值。</p>
<h2 id="1-3-Volatile关键字"><a href="#1-3-Volatile关键字" class="headerlink" title="1.3 Volatile关键字"></a>1.3 Volatile关键字</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public volatile static boolean stop &#x3D; false;</span><br></pre></td></tr></table></figure>
<p>我们在stop变量加上<strong>volatile</strong>关键字进行修饰，可以查看汇编指令，使用HSDIS工具进行查看。</p>
<ul>
<li>在IDEA中加入VM options：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-server -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:CompileCommand&#x3D;compileonly,*VolatileDemo.*</span><br></pre></td></tr></table></figure>
运行程序后，在输出的结果中，查找下 <strong>lock</strong> 指令，会发现，在修改带有<strong>volatile</strong> 修饰的成员变量时，会多一个 <strong>lock</strong> 指令。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x00000000034e49f3: lock add dword ptr [rsp],0h  ;*putstatic stop</span><br><span class="line">                                                ; - com.sy.sa.thread.VolatileDemo::&lt;clinit&gt;@1 (line 5)</span><br><span class="line">0x00000000034e4643: lock add dword ptr [rsp],0h  ;*putstatic stop</span><br><span class="line">                                                ; - com.sy.sa.thread.VolatileDemo::&lt;clinit&gt;@1 (line 5)</span><br></pre></td></tr></table></figure>
<p>运行加了<strong>volatile</strong>关键字的代码，发现中多了<strong>lock</strong>汇编指令。那么lock指令是怎么保证可见性的呢？</p>
<h2 id="1-3-1-什么是可见性？"><a href="#1-3-1-什么是可见性？" class="headerlink" title="1.3.1 什么是可见性？"></a>1.3.1 什么是可见性？</h2><p>在单线程的环境下，如果向一个变量先写入一个值，然后在没有写干涉的情况下读取这个变量的值，那这个时候读取到的这个变量的值应该是之前写入的那个值。这本来是一个很正常的事情。但是在多线程环境下，读和写发生在不同的线程中的时候，可能会出现：读线程不能及时的读取到其他线程写入的最新的值。这就是所谓的<strong>可见性</strong>。</p>
<h2 id="1-3-2-硬件方面了解可见性本质"><a href="#1-3-2-硬件方面了解可见性本质" class="headerlink" title="1.3.2 硬件方面了解可见性本质"></a>1.3.2 硬件方面了解可见性本质</h2><p>硬件方面将从<strong>CPU、内存、磁盘I/O</strong> 三方面着手。</p>
<h2 id="1-3-2-1-CPU的高速缓存"><a href="#1-3-2-1-CPU的高速缓存" class="headerlink" title="1.3.2.1 CPU的高速缓存"></a>1.3.2.1 CPU的高速缓存</h2><p>因为高速缓存的存在，会导致一个缓存一致性问题。<br><img src="https://user-gold-cdn.xitu.io/2020/5/27/1725562186444afd?w=480&h=385&f=png&s=17195" alt=""></p>
<h2 id="1-3-2-2-总线锁和缓存锁"><a href="#1-3-2-2-总线锁和缓存锁" class="headerlink" title="1.3.2.2 总线锁和缓存锁"></a>1.3.2.2 总线锁和缓存锁</h2><p>总线锁，简单来说就是，在多cpu下，当其中一个处理器要对共享内存进行操作的时候，在总线上发出一个LOCK#信号，这个信号使得其他处理器无法通过总线来访问到共享内存中的数据，总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，这种机制显然是不合适的 。</p>
<p>如何优化呢？最好的方法就是控制锁的保护粒度，我们只需要保证对于被多个CPU缓存的同一份数据是一致的就行。在P6架构的CPU后，引入了缓存锁，如果当前数据已经被CPU缓存了，并且是要协会到主内存中的，就可以采用缓存锁来解决问题。</p>
<p>所谓的缓存锁，就是指内存区域如果被缓存在处理器的缓存行中，并且在Lock期间被锁定，那么当它执行锁操作回写到内存时，不再总线上加锁，而是修改内部的内存地址，基于缓存一致性协议来保证操作的原子性。</p>
<p>总线锁和缓存锁怎么选择，取决于很多因素，比如CPU是否支持、以及存在无法缓存的数据时（比较大或者快约多个缓存行的数据），必然还是会使用总线锁。</p>
<h2 id="1-3-2-3-缓存一致性"><a href="#1-3-2-3-缓存一致性" class="headerlink" title="1.3.2.3 缓存一致性"></a>1.3.2.3 缓存一致性</h2><p>MSI ，MESI 、MOSI …<br>为了达到数据访问的一致，需要各个处理器在访问缓存时遵循一些协议，在读写时根据协议来操作，常见的协议有MSI，MESI，MOSI等。最常见的就是MESI协议。接下来给大家简单讲解一下MESIMESI表示缓存行的四种状态，分别是：</p>
<ul>
<li>M(Modify)： 表示共享数据只缓存在当前CPU缓存中，并且是被修改状态，也就是缓存的数据和主内存中的数据不一致；</li>
<li>E(Exclusive)： 表示缓存的独占状态，数据只缓存在当前CPU缓存中，并且没有被修改；</li>
<li>S(Shared)： 表示数据可能被多个CPU缓存，并且各个缓存中的数据和主内存数据一致；</li>
<li>I(Invalid)： 表示缓存已经失效。</li>
</ul>
<h2 id="1-3-2-4-MESI带来的优化"><a href="#1-3-2-4-MESI带来的优化" class="headerlink" title="1.3.2.4 MESI带来的优化"></a>1.3.2.4 MESI带来的优化</h2><p>各CPU通过消息传递来更新各个缓存行的状态。在CPU中引入了Store Bufferes。<br><img src="https://user-gold-cdn.xitu.io/2020/5/30/172644f7dcdc9647?w=443&h=372&f=png&s=19534" alt=""><br>CPU0 只需要在写入共享数据时，直接把数据写入到 <strong>store bufferes</strong> 中，同时发送 <strong>invalidate</strong> 消息，然后继续去处理其他指令。<br>当收到其他所有CPU发送了<strong>invalidate acknowledge</strong>消息时，再将 <strong>store bufferes</strong> 中的数据数据存储至 <strong>cache line</strong>中。最后再从缓存行同步到主内存。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/30/172645273b4233b8?w=322&h=284&f=png&s=11075" alt=""></p>
<p><strong>指令重排序</strong></p>
<p>来关注下面这段代码，假设分别有两个线程，分别执行executeToCPU0和executeToCPU1，分别由两个不同的CPU来执行。引入Store Bufferes之后，就可能出现 b==1返回true ，但是assert(a==1)返回false。很多肯定会表示不理解，这种情况怎么可能成立？那接下来我们去分析一下，写一段伪代码吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">executeToCPU0()&#123;</span><br><span class="line">  a&#x3D;1;</span><br><span class="line">  b&#x3D;1;</span><br><span class="line">&#125;</span><br><span class="line">executeToCPU1()&#123;</span><br><span class="line">  while(b&#x3D;&#x3D;1)&#123;</span><br><span class="line">    assert(a&#x3D;&#x3D;1);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>通过内存屏障禁止了指令重排序</strong></p>
<p>X86的memory barrier指令包括<strong>lfence(读屏障) sfence(写屏障) mfence(全屏障)</strong>。</p>
<ul>
<li>Store Memory Barrier(写屏障)：告诉处理器在写屏障之前的所有已经存储在存储缓存(store bufferes)中的数据同步到主内存，简单来说就是使得写屏障之前的指令的结果对屏障之后的读或者写是可见的</li>
<li>Load Memory Barrier(读屏障)：处理器在读屏障之后的读操作，都在读屏障之后执行。配合写屏障，使得写屏障之前的内存更新对于读屏障之后的读操作是可见的</li>
<li>Full Memory Barrier(全屏障)：确保屏障前的内存读写操作的结果提交到内存之后，再执行屏障后的读写操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">volatile int a&#x3D;0;</span><br><span class="line">executeToCpu0()&#123;</span><br><span class="line">  a&#x3D;1;</span><br><span class="line">  &#x2F;&#x2F;storeMemoryBarrier()写屏障，写入到内存</span><br><span class="line">  b&#x3D;1;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; CPU层面的重排序</span><br><span class="line">  &#x2F;&#x2F;b&#x3D;1;</span><br><span class="line">  &#x2F;&#x2F;a&#x3D;1;</span><br><span class="line">&#125;</span><br><span class="line">executeToCpu1()&#123;</span><br><span class="line">  while(b&#x3D;&#x3D;1)&#123;  &#x2F;&#x2F;true</span><br><span class="line">    loadMemoryBarrier(); &#x2F;&#x2F;读屏障</span><br><span class="line">    assert(a&#x3D;&#x3D;1) &#x2F;&#x2F;false</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="1-3-3-软件方面了解可见性本质"><a href="#1-3-3-软件方面了解可见性本质" class="headerlink" title="1.3.3 软件方面了解可见性本质"></a>1.3.3 软件方面了解可见性本质</h2><h2 id="1-3-3-1-JMM（Java内存模型）"><a href="#1-3-3-1-JMM（Java内存模型）" class="headerlink" title="1.3.3.1 JMM（Java内存模型）"></a>1.3.3.1 JMM（Java内存模型）</h2><p>简单来说，JMM定义了共享内存中多线程程序读写操作的行为规范：在虚拟机中把共享变量存储到内存以及从内存中取出共享变量的底层实现细节。通过这些规则来规范对内存的读写操作从而保证指令的正确性，<strong>解决了CPU多级缓存、处理器优化、指令重排序导致的内存访问问题，保证了并发场景下的可见性</strong>。</p>
<p>需要注意的是，JMM并没有主动限制执行引擎使用处理器的寄存器和高速缓存来提升指令执行速度，也没主动限制编译器对于指令的重排序，也就是说在JMM这个模型之上，仍然会存在缓存一致性问题和指令重排序问题。JMM是一个抽象模型，它是建立在不同的操作系统和硬件层面之上对问题进行了统一的抽象，然后再Java层面提供了一些高级指令，让用户选择在合适的时候去引入这些高级指令来解决可见性问题。</p>
<h2 id="1-3-3-2-JMM解决可见性有序性"><a href="#1-3-3-2-JMM解决可见性有序性" class="headerlink" title="1.3.3.2 JMM解决可见性有序性"></a>1.3.3.2 JMM解决可见性有序性</h2><p>其实通过前面的内容分析我们发现，导致可见性问题有两个因素，一个是高速缓存导致的可见性问题，另一个是指令重排序。那JMM是如何解决可见性和有序性问题的呢？其实前面在分析硬件层面的内容时，已经提到过了，对于缓存一致性问题，有总线锁和缓存锁，缓存锁是基于MESI协议。而对于指令重排序，硬件层面提供了内存屏障指令。</p>
<p>而JMM在这个基础上提供了<strong>volatile、final</strong>等关键字，使得开发者可以在合适的时候增加相应相应的关键字来<strong>禁止高速缓存</strong>和<strong>禁止指令重排序</strong>来解决可见性和有序性问题。</p>
<h2 id="1-3-3-3-Volatile底层的原理"><a href="#1-3-3-3-Volatile底层的原理" class="headerlink" title="1.3.3.3 Volatile底层的原理"></a>1.3.3.3 Volatile底层的原理</h2><p>通过javap -v VolatileDemo.class 分析汇编指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static volatile boolean stop;</span><br><span class="line"> descriptor: Z</span><br><span class="line"> flags: ACC_PUBLIC, ACC_STATIC, ACC_VOLATILE</span><br><span class="line">int field_offset &#x3D; cache-&gt;f2_as_index();</span><br><span class="line">     if (cache-&gt;is_volatile()) &#123;</span><br><span class="line">      if (tos_type &#x3D;&#x3D; itos) &#123;</span><br><span class="line">       obj-&gt;release_int_field_put(field_offset, STACK_INT(-1));</span><br><span class="line">     &#125; else if (tos_type &#x3D;&#x3D; atos) &#123;</span><br><span class="line">       VERIFY_OOP(STACK_OBJECT(-1));</span><br><span class="line">       obj-&gt;release_obj_field_put(field_offset, STACK_OBJECT(-1));</span><br><span class="line">       OrderAccess::release_store(&amp;BYTE_MAP_BASE[(uintptr_t)obj &gt;&gt;</span><br><span class="line">CardTableModRefBS::card_shift], 0);</span><br><span class="line">     &#125; else if (tos_type &#x3D;&#x3D; btos) &#123;</span><br><span class="line">       obj-&gt;release_byte_field_put(field_offset, STACK_INT(-1));</span><br><span class="line">     &#125; else if (tos_type &#x3D;&#x3D; ltos) &#123;</span><br><span class="line">       obj-&gt;release_long_field_put(field_offset, STACK_LONG(-1));</span><br><span class="line">     &#125; else if (tos_type &#x3D;&#x3D; ctos) &#123;</span><br><span class="line">       obj-&gt;release_char_field_put(field_offset, STACK_INT(-1));</span><br><span class="line">     &#125; else if (tos_type &#x3D;&#x3D; stos) &#123;</span><br><span class="line">       obj-&gt;release_short_field_put(field_offset, STACK_INT(-1));</span><br><span class="line">     &#125; else if (tos_type &#x3D;&#x3D; ftos) &#123;</span><br><span class="line">       obj-&gt;release_float_field_put(field_offset, STACK_FLOAT(-1));</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       obj-&gt;release_double_field_put(field_offset, STACK_DOUBLE(-1));</span><br><span class="line">     &#125;</span><br><span class="line">      OrderAccess::storeload();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-4-Happens-Before模型"><a href="#1-3-4-Happens-Before模型" class="headerlink" title="1.3.4 Happens-Before模型"></a>1.3.4 Happens-Before模型</h2><p>除了显示引用volatile关键字能够保证可见性以外，在Java中，还有很多的可见性保障的规则。</p>
<p>从JDK1.5开始，引入了一个<strong>happens-before</strong>的概念来阐述多个线程操作共享变量的可见性问题。所以我们可以认为在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作必须要存在<strong>happens-before</strong>关系。这两个操作可以是同一个线程，也可以是不同的线程。</p>
<h2 id="1-3-4-1-程序顺序规则"><a href="#1-3-4-1-程序顺序规则" class="headerlink" title="1.3.4.1 程序顺序规则"></a>1.3.4.1 程序顺序规则</h2><p>可以认为是<strong>as-if-serial</strong>语义。</p>
<ul>
<li>不能改变程序的执行结果(在单线程环境下，执行的结果不变)</li>
<li>依赖问题， 如果两个指令存在依赖关系，是不允许重排序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int a&#x3D;0;</span><br><span class="line">int b&#x3D;0;</span><br><span class="line">void test()&#123;</span><br><span class="line">  int a&#x3D;1;   a</span><br><span class="line">  int b&#x3D;1;   b</span><br><span class="line">  &#x2F;&#x2F;int b&#x3D;1;</span><br><span class="line">  &#x2F;&#x2F;int a&#x3D;1;</span><br><span class="line">  int c&#x3D;a*b;  c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>a happens -before b ; b happens before c</strong></p>
<h2 id="1-3-4-2-传递性规则"><a href="#1-3-4-2-传递性规则" class="headerlink" title="1.3.4.2 传递性规则"></a>1.3.4.2 传递性规则</h2><p><strong>a happens-before b , b happens- before c, a happens-before c</strong></p>
<h2 id="1-3-4-3-volatile变量规则"><a href="#1-3-4-3-volatile变量规则" class="headerlink" title="1.3.4.3 volatile变量规则"></a>1.3.4.3 volatile变量规则</h2><ul>
<li>volatile 修饰的变量的写操作，一定happens-before后续对于volatile变量的读操作.</li>
<li>内存屏障机制来防止指令重排.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class VolatileExample&#123;</span><br><span class="line">  int a&#x3D;0;</span><br><span class="line">  volatile boolean flag&#x3D;false;</span><br><span class="line">  public void writer()&#123;</span><br><span class="line">    a&#x3D;1;             1</span><br><span class="line">    flag&#x3D;true; &#x2F;&#x2F;修改       2</span><br><span class="line"> &#125;</span><br><span class="line">  public void reader()&#123;</span><br><span class="line">    if(flag)&#123; &#x2F;&#x2F;true       3</span><br><span class="line">      int i&#x3D;a;  &#x2F;&#x2F;1      4</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>1 happens-before 2 是否成立？ 是 -&gt; ?</li>
<li>3 happens-before 4 是否成立? 是</li>
<li>2 happens -before 3 -&gt;volatile规则</li>
<li>1 happens-before 4 ; i=1成立.</li>
</ul>
<h2 id="1-3-4-4-监视器锁规则"><a href="#1-3-4-4-监视器锁规则" class="headerlink" title="1.3.4.4 监视器锁规则"></a>1.3.4.4 监视器锁规则</h2><p>对一个锁的解锁，happens-before 于随后对这个锁的加锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int x&#x3D;10;</span><br><span class="line">synchronized(this)&#123;</span><br><span class="line">  &#x2F;&#x2F;后续线程读取到的x的值一定12</span><br><span class="line">  if(x&lt;12)&#123;</span><br><span class="line">    x&#x3D;12;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">x&#x3D;12;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-4-5-start规则"><a href="#1-3-4-5-start规则" class="headerlink" title="1.3.4.5 start规则"></a>1.3.4.5 start规则</h2><p>如果线程 A 执行操作 ThreadB.start(),那么线程 A 的 ThreadB.start()操作 happens-before 线程 B 中的任意操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class StartDemo&#123;</span><br><span class="line">  int x&#x3D;0;</span><br><span class="line">  Thread t1&#x3D;new Thread(()-&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F;读取x的值 一定是20</span><br><span class="line">    if(x&#x3D;&#x3D;20)&#123;</span><br><span class="line">     </span><br><span class="line">   &#125;</span><br><span class="line"> &#125;);</span><br><span class="line">  x&#x3D;20;</span><br><span class="line">  t1.start();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-4-6-Join规则"><a href="#1-3-4-6-Join规则" class="headerlink" title="1.3.4.6 Join规则"></a>1.3.4.6 Join规则</h2><p>如果线程 A 执行操作 ThreadB.join()并成功返回，那么线程 B 中的任意操作 happens-before 于线程A 从 ThreadB.join()操作成功返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">  int x&#x3D;0;</span><br><span class="line">  Thread t1&#x3D;new Thread(()-&gt;&#123;</span><br><span class="line">    x&#x3D;200;</span><br><span class="line"> &#125;);</span><br><span class="line">  t1.start();</span><br><span class="line">  t1.join(); &#x2F;&#x2F;保证结果的可见性。</span><br><span class="line">  &#x2F;&#x2F;在此处读取到的x的值一定是200.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/05/30/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%80%92%E8%BF%9B%E7%AF%87%EF%BC%8C%E6%8E%A2%E7%B4%A2%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7/" data-id="cke9cjzcv0007f5ra6kr9ehip" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JAVA并发编程入门篇，思考同步锁Synchronized背后的实现哲学" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/23/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%8C%E6%80%9D%E8%80%83%E5%90%8C%E6%AD%A5%E9%94%81Synchronized%E8%83%8C%E5%90%8E%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%93%B2%E5%AD%A6/" class="article-date">
  <time datetime="2020-05-23T11:38:30.000Z" itemprop="datePublished">2020-05-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/23/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%8C%E6%80%9D%E8%80%83%E5%90%8C%E6%AD%A5%E9%94%81Synchronized%E8%83%8C%E5%90%8E%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%93%B2%E5%AD%A6/">JAVA并发编程入门篇，思考同步锁Synchronized背后的实现哲学</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>多线程在概念上类似抢占式多任务处理，线程的合理使用能够提升程序的处理能力，但是使用的同时也带来了弊端，对于共享变量访问就会产生安全性的问题。下面来看一个多线程访问共享变量的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadSafty &#123;</span><br><span class="line"></span><br><span class="line">    private static int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public static void incr() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; 1000; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                ThreadSafty.incr();</span><br><span class="line">            &#125;,&quot;threadSafty&quot; + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(3);</span><br><span class="line">        System.out.println(&quot;运行结果是：&quot; + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量count的运行结果始终是小于等于1000的随机数，因为线程的可见性和原子性。</p>
<h1 id="一、多线程访问的数据安全性"><a href="#一、多线程访问的数据安全性" class="headerlink" title="一、多线程访问的数据安全性"></a>一、多线程访问的数据安全性</h1><p>如何保证线程并行运行的数据安全性问题，这里首先能够想到的是加锁吧。关系型数据库中有乐观锁、悲观锁，那么什么是锁呢？它是处理并发的一种手段，实现互斥的特性。</p>
<p>在Java语言中实现锁的关键字是<strong>Synchronized</strong>。</p>
<h1 id="二、Synchronized的基本应用"><a href="#二、Synchronized的基本应用" class="headerlink" title="二、Synchronized的基本应用"></a>二、Synchronized的基本应用</h1><h2 id="2-1-Synchronized的三种加锁方式"><a href="#2-1-Synchronized的三种加锁方式" class="headerlink" title="2.1 Synchronized的三种加锁方式"></a>2.1 Synchronized的三种加锁方式</h2><ul>
<li>静态方法：作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">synchronized  static void method()&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>修饰代码块：指定加锁对象，进入同步代码前要获得指定对象的锁</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void method()&#123;</span><br><span class="line">    synchronized (SynchronizedDemo.class)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改实例方法：作用于当前实例加锁，进入同步代码前要获得当前实例的锁<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object lock &#x3D; new Object();</span><br><span class="line">&#x2F;&#x2F;只针对于当前对象实例有效.</span><br><span class="line">public SynchronizedDemo(Object lock)&#123;</span><br><span class="line">        this.lock &#x3D; lock;</span><br><span class="line">&#125;</span><br><span class="line"> void method()&#123;</span><br><span class="line">     synchronized(lock)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="2-2-Synchronized锁是如何存储数据的呢？"><a href="#2-2-Synchronized锁是如何存储数据的呢？" class="headerlink" title="2.2 Synchronized锁是如何存储数据的呢？"></a>2.2 Synchronized锁是如何存储数据的呢？</h2><p>以对象在<strong>jvm</strong>内存中是如何存储作为切入点，去看看对象里面有什么特性能够实现锁的</p>
<h2 id="2-2-1-对象在Heap内存中的布局"><a href="#2-2-1-对象在Heap内存中的布局" class="headerlink" title="2.2.1 对象在Heap内存中的布局"></a>2.2.1 对象在Heap内存中的布局</h2><p>在Hotspot虚拟机中，对象在堆内存中的布局，可以分为三个部分：</p>
<ul>
<li>对象头：包括对象标记、类元信息</li>
<li>实例数据</li>
<li>对齐填充</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/19/1722bcba856d89b3?w=925&h=368&f=png&s=158024" alt=""></p>
<p><strong>Hotspot</strong> 采用<strong>instanceOopDesc</strong> 和 <strong>arrayOopDesc</strong> 来描述对象头，<strong>arrayOopDesc</strong> 对象用来描述数组类型的。<br><strong>instanceOopDesc</strong>的定义在Hotspot源码中的<strong>instanceOop.hpp</strong>文件中，另外，<strong>arrayOopDesc</strong>的定义对应<strong>arrayOop.hpp</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class instanceOopDesc : public oopDesc &#123;</span><br><span class="line"> public:</span><br><span class="line">  &#x2F;&#x2F; aligned header size.</span><br><span class="line">  static int header_size() &#123; return sizeof(instanceOopDesc)&#x2F;HeapWordSize; &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; If compressed, the offset of the fields of the instance may not be aligned.</span><br><span class="line">  static int base_offset_in_bytes() &#123;</span><br><span class="line">    &#x2F;&#x2F; offset computation code breaks if UseCompressedClassPointers</span><br><span class="line">    &#x2F;&#x2F; only is true</span><br><span class="line">    return (UseCompressedOops &amp;&amp; UseCompressedClassPointers) ?</span><br><span class="line">             klass_gap_offset_in_bytes() :</span><br><span class="line">             sizeof(instanceOopDesc);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static bool contains_field_offset(int offset, int nonstatic_field_size) &#123;</span><br><span class="line">    int base_in_bytes &#x3D; base_offset_in_bytes();</span><br><span class="line">    return (offset &gt;&#x3D; base_in_bytes &amp;&amp;</span><br><span class="line">            (offset-base_in_bytes) &lt; nonstatic_field_size * heapOopSize);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F; SHARE_VM_OOPS_INSTANCEOOP_HPP</span><br></pre></td></tr></table></figure>
<p>看源码instanceOopDesc继承自oopDesc，oopDesc定义在oop.hpp文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class oopDesc &#123;</span><br><span class="line">  friend class VMStructs;</span><br><span class="line">  private:</span><br><span class="line">  volatile markOop  _mark;</span><br><span class="line">  union _metadata &#123;</span><br><span class="line">    Klass*      _klass;&#x2F;&#x2F;普通指针</span><br><span class="line">    narrowKlass _compressed_klass;&#x2F;&#x2F;压缩类指针</span><br><span class="line">  &#125; _metadata;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Fast access to barrier set.  Must be initialized.</span><br><span class="line">  static BarrierSet* _bs;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>在oopDesc类中有两个重要的成员变量，_mark：记录对象和锁有关的信息，属于markOop类型，_metadata：记录类元信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class markOopDesc: public oopDesc &#123;</span><br><span class="line"> private:</span><br><span class="line">  &#x2F;&#x2F; Conversion</span><br><span class="line">  uintptr_t value() const &#123; return (uintptr_t) this; &#125;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  &#x2F;&#x2F; Constants</span><br><span class="line">  enum &#123; </span><br><span class="line">     age_bits                 &#x3D; 4,&#x2F;&#x2F;分代年龄</span><br><span class="line">     lock_bits                &#x3D; 2,&#x2F;&#x2F;锁标识</span><br><span class="line">     biased_lock_bits         &#x3D; 1,&#x2F;&#x2F;是否为偏向锁</span><br><span class="line">     max_hash_bits            &#x3D; BitsPerWord - age_bits - lock_bits - biased_lock_bits,</span><br><span class="line">     hash_bits                &#x3D; max_hash_bits &gt; 31 ? 31 : max_hash_bits,&#x2F;&#x2F;对象的hashCode</span><br><span class="line">     cms_bits                 &#x3D; LP64_ONLY(1) NOT_LP64(0),</span><br><span class="line">     epoch_bits               &#x3D; 2&#x2F;&#x2F;偏向锁的时间戳</span><br><span class="line">  &#125;;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p><strong>markOopDesc</strong>记录了对象和锁有关的信息，也就是我们常说的<strong>Mark Word</strong>，当某个对象加上<strong>Synchronized</strong>关键字时，那么和锁有关的一系列操作都与它有关。<br><strong>32位</strong>系统<strong>Mark Word</strong>的长度是<strong>32bit</strong>，<strong>64位</strong>系统则是<strong>64bit</strong>。</p>
<p><strong>Mark Word</strong>里面的数据会随着锁的标志位的变化而变化的。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/19/1722cd90ccc7c61e?w=1024&h=329&f=png&s=291618" alt=""></p>
<h2 id="2-2-2-Java中打印对象的布局"><a href="#2-2-2-Java中打印对象的布局" class="headerlink" title="2.2.2 Java中打印对象的布局"></a>2.2.2 Java中打印对象的布局</h2><p>pom依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jol&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jol-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.10&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ClassLayout.parseInstance(synchronizedDemo).toPrintable());</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">com.sy.sa.thread.SynchronizedDemo object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           31 00 00 00 (00110001 00000000 00000000 00000000) (49)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total</span><br></pre></td></tr></table></figure>
<p><strong>大端存储和小端存储</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0     4        (object header)                           31 00 00 00 (00110001 00000000 00000000 00000000) (49)</span><br><span class="line">4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">16进制： 0x 00 00 00 00 00 00 00 01</span><br><span class="line">(64位)2进制： 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000 0</span><br></pre></td></tr></table></figure>
<p><strong>0 01 (无锁状态)</strong></p>
<ul>
<li>通过最后三位来看锁的状态和标记。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           a8 f7 76 02 (10101000 11110111 01110110 00000010) (41351080)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total</span><br></pre></td></tr></table></figure>

<p><strong>000表示为轻量级锁</strong></p>
<h2 id="2-2-3-为什么什么对象都能实现锁？"><a href="#2-2-3-为什么什么对象都能实现锁？" class="headerlink" title="2.2.3 为什么什么对象都能实现锁？"></a>2.2.3 为什么什么对象都能实现锁？</h2><p><strong>Java</strong> 中的每个对象都派生自 <strong>Object</strong> 类，而每个<strong>Java Object</strong> 在 <strong>JVM</strong> 内部都有一个 <strong>native</strong> 的 C++对象<strong>oop/oopDesc</strong> 进行对应。</p>
<p>线程在获取锁的时候，实际上就是获得一个监视器对象(<strong>monitor</strong>) ,<strong>monitor</strong> 可以认为是一个同步对象，所有的Java 对象是天生携带 <strong>monitor</strong>。在 <strong>hotspot</strong> 源码的<strong>markOop.hpp</strong> 文件中，可以看到下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor* monitor() const &#123;</span><br><span class="line">    assert(has_monitor(), &quot;check&quot;);</span><br><span class="line">    &#x2F;&#x2F; Use xor instead of &amp;~ to provide one extra tag-bit check.</span><br><span class="line">    return (ObjectMonitor*) (value() ^ monitor_value);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>多个线程访问同步代码块时，相当于去争抢对象监视器修改对象中的锁标识，上面的代码中<strong>ObjectMonitor</strong>这个对象和线程争抢锁的逻辑有密切的关系。</p>
<h1 id="2-3-Synchronized的锁升级"><a href="#2-3-Synchronized的锁升级" class="headerlink" title="2.3 Synchronized的锁升级"></a>2.3 Synchronized的锁升级</h1><p>锁的状态有：<strong>无锁、偏向锁、轻量级锁、重量级锁。</strong> 锁的状态根据竞争激烈程度从低到高不断升级。</p>
<h2 id="2-3-1-偏向锁"><a href="#2-3-1-偏向锁" class="headerlink" title="2.3.1 偏向锁"></a>2.3.1 偏向锁</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">存储（以32位为例）：线程ID（23bit）</span><br><span class="line">                   Epoch（2bit）</span><br><span class="line">                   age（4bit）</span><br><span class="line">                   是否偏向锁（1bit）</span><br><span class="line">                   锁标志位（2bit）</span><br></pre></td></tr></table></figure>
<p>当一个线程加入了Synchronized同步锁之后，会在对象头（Object Header）存储线程ID，后续这个线程进入或者退出这个同步代码块的代码时，不需要再次加入和释放锁，而是直接比较对象头里面是否存储了指向当前线程的偏向锁。如果线程ID相等，就表示偏向锁偏向于当前线程，就不需要再重新获得锁了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">com.sy.sa.thread.ClassLayoutDemo object internals:</span><br><span class="line">OFFSET SIZE  TYPE DESCRIPTION                VALUE</span><br><span class="line">  0   4    (object header)              05 e8 45 03</span><br><span class="line">(00000101 11101000 01000101 00000011) (54913029)</span><br><span class="line">  4   4    (object header)              00 00 00 00</span><br><span class="line">(00000000 00000000 00000000 00000000) (0)</span><br><span class="line">  8   4    (object header)              05 c1 00 f8</span><br><span class="line">(00000101 11000001 00000000 11111000) (-134168315)</span><br><span class="line">  12   4    (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/5/23/1723fa8d22c31cea?w=865&h=969&f=png&s=405855" alt=""></p>
<h2 id="2-3-2-轻量级锁"><a href="#2-3-2-轻量级锁" class="headerlink" title="2.3.2 轻量级锁"></a>2.3.2 轻量级锁</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">存储（以32位为例）：指向栈中锁记录的指针（30bit）</span><br><span class="line">                   锁标志位（2bit）</span><br></pre></td></tr></table></figure>
<p>如果偏向锁关闭或者当前偏向锁指向其它的线程，那么这个时候有线程去抢占锁，那么将升级为轻量级锁。</p>
<p>轻量级锁在加锁的过程中使用了自旋锁，JDK1.6之后使用了自适应的自旋锁。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/23/172402845dd99783?w=865&h=840&f=png&s=282670" alt=""></p>
<h2 id="2-3-3-重量级锁"><a href="#2-3-3-重量级锁" class="headerlink" title="2.3.3 重量级锁"></a>2.3.3 重量级锁</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">存储（以32位为例）：指向互斥量（重量级锁）的指针（30bit）</span><br><span class="line">                   锁标志位（2bit）</span><br></pre></td></tr></table></figure>
<p>当轻量级锁膨胀为重量级锁后，线程只能被挂起阻塞等待被唤醒了。先来看一个重量级锁的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class HeavyweightLock &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HeavyweightLock heavyweightLock &#x3D; new HeavyweightLock();</span><br><span class="line">        Thread t1 &#x3D; new Thread(()-&gt;&#123;</span><br><span class="line">            synchronized (heavyweightLock) &#123;</span><br><span class="line">                System.out.println(&quot;tl lock&quot;);</span><br><span class="line">                System.out.println(ClassLayout.parseInstance(heavyweightLock).toPrintable());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;heavyheightLock&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        synchronized (heavyweightLock) &#123;</span><br><span class="line">            System.out.println(&quot;main lock&quot;);</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(heavyweightLock).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">com.sy.sa.thread.HeavyweightLock object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           2a cc e9 02 (00101010 11001100 11101001 00000010) (48876586)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total</span><br><span class="line"></span><br><span class="line">tl lock</span><br><span class="line">com.sy.sa.thread.HeavyweightLock object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           2a cc e9 02 (00101010 11001100 11101001 00000010) (48876586)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total</span><br></pre></td></tr></table></figure>
<p>每一个<strong>Java</strong>对象都会与一个监视器<strong>monitor</strong>关联，可以把它理解成<strong>一把锁</strong>，当一个线程要执行用<strong>Synchronized</strong>修改的代码块或者对象时，该线程最先获取到的是<strong>Synchronized</strong>修饰对象的<strong>monitor</strong>。<br><strong>重量级加锁的基本流程：</strong><br><img src="https://user-gold-cdn.xitu.io/2020/5/23/172406dcbbcbb4b4?w=1369&h=477&f=jpeg&s=79460" alt=""><br><strong>monitorenter</strong>表示去获得一个对象监视器。<strong>monitorexit</strong>表示释放<strong>monitor</strong>监视器的所有权，使得其他被阻塞的线程可以尝试去获得这个监视器。</p>
<h2 id="2-3-4-锁升级总结"><a href="#2-3-4-锁升级总结" class="headerlink" title="2.3.4 锁升级总结"></a>2.3.4 锁升级总结</h2><ul>
<li><strong>偏向锁</strong>只有在第一次请求时采用CAS在锁对象的标记中记录当前线程的地址，在之后该线程再次进入同步代码块时，不需要抢占锁，直接判断线程ID即可，这种适用于锁会被同一个线程多次抢占的情况。</li>
<li><strong>轻量级锁</strong>才用CAS操作，把锁对象的标记字段替换为一个指针指向当前线程栈帧中的LockRecord，该工件存储锁对象原本的标记字段，它针对的是多个线程在不同时间段内申请通一把锁的情况。</li>
<li><strong>重量级锁</strong>会阻塞、和唤醒加锁的线程，它适用于多个线程同时竞争同一把锁的情况。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/23/172408d4b0ec868d?w=1527&h=349&f=jpeg&s=91081" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/05/23/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%8C%E6%80%9D%E8%80%83%E5%90%8C%E6%AD%A5%E9%94%81Synchronized%E8%83%8C%E5%90%8E%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%93%B2%E5%AD%A6/" data-id="cke9cjzcl0006f5ra69oe26fo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JAVA并发编程揭开篇章，并发编程基本认识，了解多线程意义和使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/18/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%8F%AD%E5%BC%80%E7%AF%87%E7%AB%A0%EF%BC%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86%EF%BC%8C%E4%BA%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%84%8F%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/" class="article-date">
  <time datetime="2020-05-18T09:57:37.000Z" itemprop="datePublished">2020-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/18/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%8F%AD%E5%BC%80%E7%AF%87%E7%AB%A0%EF%BC%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86%EF%BC%8C%E4%BA%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%84%8F%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/">JAVA并发编程揭开篇章，并发编程基本认识，了解多线程意义和使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>多线程</strong>（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括对称多处理机、多核心处理器以及芯片级多处理（Chip-level multithreading）或同时多线程（Simultaneous multithreading）处理器。</p>
<h1 id="一、什么是线程"><a href="#一、什么是线程" class="headerlink" title="一、什么是线程"></a>一、什么是线程</h1><p><strong>线程</strong>（thread）是操作系统能够进行运算调度的最小单位。大部分情况下，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。</p>
<p>线程是独立调度和分派的基本单位。线程可以为操作系统内核调度的内核线程，如Win32线程；由用户进程自行调度的用户线程，如Linux平台的POSIX Thread；或者由内核与用户进程，如Windows 10的线程，进行混合调度。</p>
<p>同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。</p>
<p><strong>一个进程可以有很多线程，每条线程并行执行不同的任务。</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/17/172209a9816e933b?w=1280&h=795&f=png&s=2278208" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/5/17/172209dc54329651?w=960&h=640&f=png&s=1405727" alt=""></p>
<h1 id="二、什么是并发"><a href="#二、什么是并发" class="headerlink" title="二、什么是并发"></a>二、什么是并发</h1><p>并发，在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。</p>
<p>举个例子，简单来说并发是指单位时间内能够同时处理的请求数。默认情况下Tomcat可以支持的最大请求数是150，也就是同时支持150个并发。当超过这个并发数的时候，就会开始导致响应延迟，连接丢失等问题。</p>
<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>并行是指两个或者多个事件在同一时刻发生；</p>
<p>并发是指两个或多个事件在同一时间间隔内发生，这个词可以冲宏观和微观两个层面来讲，如果从微观角度来看。以线程为例，假设当前电脑的cpu是单核，但是能不能支持多线程呢？当然也是能的，此时如果是多线程运行的话，那么CPU是通过不断分配时间片的方式来实现线程切换，由于切换的速度足够快，我们很难感知到卡顿的过程。</p>
<h1 id="三、Java中的线程"><a href="#三、Java中的线程" class="headerlink" title="三、Java中的线程"></a>三、Java中的线程</h1><h2 id="3-1-Runnable-接口"><a href="#3-1-Runnable-接口" class="headerlink" title="3.1 Runnable 接口"></a>3.1 Runnable 接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends OtherClass implements Runnable &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;MyThread.run()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-Thread-类"><a href="#3-2-Thread-类" class="headerlink" title="3.2 Thread 类"></a>3.2 Thread 类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">    System.out.println(&quot;MyThread.run()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    MyThread myThread1 &#x3D; new MyThread();</span><br><span class="line">    MyThread myThread2 &#x3D; new MyThread();</span><br><span class="line">    myThread1.start();</span><br><span class="line">    myThread2.start();</span><br></pre></td></tr></table></figure>
<h2 id="3-3-Callable-Future-带返回值的"><a href="#3-3-Callable-Future-带返回值的" class="headerlink" title="3.3 Callable/Future 带返回值的"></a>3.3 Callable/Future 带返回值的</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class CallableDemo implements Callable&lt;String&gt; &#123;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newFixedThreadPool (1);</span><br><span class="line">        CallableDemo callableDemo &#x3D; new CallableDemo();</span><br><span class="line">        Future&lt;String&gt; future &#x3D; executorService.submit(callableDemo);</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        int a &#x3D; 1;</span><br><span class="line">        int b &#x3D; 2;</span><br><span class="line">        System.out.println(a + b);</span><br><span class="line">        return &quot;执行结果:&quot; + (a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、-多线程的应用场景"><a href="#四、-多线程的应用场景" class="headerlink" title="四、 多线程的应用场景"></a>四、 多线程的应用场景</h1><ul>
<li>网络请求分发的场景</li>
<li>文件导入</li>
<li>短信发送场景</li>
</ul>
<h1 id="五、-Java并发编程基础"><a href="#五、-Java并发编程基础" class="headerlink" title="五、 Java并发编程基础"></a>五、 Java并发编程基础</h1><h2 id="5-1-线程的生命周期"><a href="#5-1-线程的生命周期" class="headerlink" title="5.1 线程的生命周期"></a>5.1 线程的生命周期</h2><p>Java线程一共有 6 种状态（<strong>NEW、RUNNABLE、BLOCKED、WAITING、TIME_WAITING、TERMINATED</strong>）</p>
<ul>
<li>NEW：初始状态，线程被构建，但是还没有调用 <strong>start</strong>()方法；</li>
<li>RUNNABLE：运行状态，JAVA线程把操作系统中的就绪和运行两种状态统一称为“运行中”</li>
<li>BLOCK：阻塞状态，表示线程进入等待状态,也就是线程因为某种原因放弃了 CPU 使用权，阻塞也分为几种情况：</li>
</ul>
<p>➢ 等待阻塞：运行的线程执行 wait 方法，jvm 会把当前线程放入到等待队列</p>
<p>➢ 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被其他线程锁占用了，那么 jvm 会把当前的线程放入到锁池中</p>
<p>➢ 其他阻塞：运行的线程执行 Thread.sleep 或者 t.join 方法，或者发出了 I/O 请求时，JVM 会把当前线程设置为阻塞状态，当 sleep 结束、join 线程终止、io 处理完毕则线程恢复</p>
<ul>
<li>WAITING：正在无限期等待另一个线程执行状态，需要唤醒</li>
<li>TIME_WAITING：超时等待状态，超时以后自动返回</li>
<li>TERMINATED：终止状态，表示当前线程执行完毕</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/18/17225f1a457b93a5?w=1204&h=1014&f=jpeg&s=128924" alt=""></p>
<h2 id="5-2-线程的启动"><a href="#5-2-线程的启动" class="headerlink" title="5.2 线程的启动"></a>5.2 线程的启动</h2><p>启动线程的两种方式：</p>
<ul>
<li>new Thread().start();//启动一个线程</li>
<li>Thread thread = new Thread(); thread.run();//调用实例中的方法</li>
</ul>
<p>启动线程是调用<strong>start</strong>()方法，而不是<strong>run</strong>()方法，我们来看下<strong>Thread</strong>类中的<strong>start</strong>()方法源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line">    &#x2F;* Make sure registerNatives is the first thing &lt;clinit&gt; does. *&#x2F;</span><br><span class="line">    private static native void registerNatives();</span><br><span class="line">    static &#123;</span><br><span class="line">        registerNatives();&#x2F;&#x2F;start0()方法是在此方法中注册的</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public synchronized void start() &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * This method is not invoked for the main method thread or &quot;system&quot;</span><br><span class="line">         * group threads created&#x2F;set up by the VM. Any new functionality added</span><br><span class="line">         * to this method in the future may have to also be added to the VM.</span><br><span class="line">         *</span><br><span class="line">         * A zero status value corresponds to state &quot;NEW&quot;.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        if (threadStatus !&#x3D; 0)</span><br><span class="line">            throw new IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">        &#x2F;* Notify the group that this thread is about to be started</span><br><span class="line">         * so that it can be added to the group&#39;s list of threads</span><br><span class="line">         * and the group&#39;s unstarted count can be decremented. *&#x2F;</span><br><span class="line">        group.add(this);</span><br><span class="line"></span><br><span class="line">        boolean started &#x3D; false;</span><br><span class="line">        try &#123;</span><br><span class="line">            start0();&#x2F;&#x2F;实体调用的是这个方法，它是native的</span><br><span class="line">            started &#x3D; true;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(this);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Throwable ignore) &#123;</span><br><span class="line">                &#x2F;* do nothing. If start0 threw a Throwable then</span><br><span class="line">                  it will be passed up the call stack *&#x2F;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private native void start0();&#x2F;&#x2F;调用C++中的start0()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>start0</strong>()方法注册在<strong>registerNatives</strong>()中，<strong>registerNatives</strong>的本地方法定义在<strong>Thread.c</strong>中，<strong>Thread.c</strong>定义了各个操作系统平台要用的关于线程的公共数据和操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static JNINativeMethod methods[] &#x3D; &#123;</span><br><span class="line">    &#123;&quot;start0&quot;,           &quot;()V&quot;,        (void *)&amp;JVM_StartThread&#125;,</span><br><span class="line">    &#123;&quot;stop0&quot;,            &quot;(&quot; OBJ &quot;)V&quot;, (void *)&amp;JVM_StopThread&#125;,</span><br><span class="line">    &#123;&quot;isAlive&quot;,          &quot;()Z&quot;,        (void *)&amp;JVM_IsThreadAlive&#125;,</span><br><span class="line">    &#123;&quot;suspend0&quot;,         &quot;()V&quot;,        (void *)&amp;JVM_SuspendThread&#125;,</span><br><span class="line">    &#123;&quot;resume0&quot;,          &quot;()V&quot;,        (void *)&amp;JVM_ResumeThread&#125;,</span><br><span class="line">    &#123;&quot;setPriority0&quot;,     &quot;(I)V&quot;,       (void *)&amp;JVM_SetThreadPriority&#125;,</span><br><span class="line">    &#123;&quot;yield&quot;,            &quot;()V&quot;,        (void *)&amp;JVM_Yield&#125;,</span><br><span class="line">    &#123;&quot;sleep&quot;,            &quot;(J)V&quot;,       (void *)&amp;JVM_Sleep&#125;,</span><br><span class="line">    &#123;&quot;currentThread&quot;,    &quot;()&quot; THD,     (void *)&amp;JVM_CurrentThread&#125;,</span><br><span class="line">    &#123;&quot;countStackFrames&quot;, &quot;()I&quot;,        (void *)&amp;JVM_CountStackFrames&#125;,</span><br><span class="line">    &#123;&quot;interrupt0&quot;,       &quot;()V&quot;,        (void *)&amp;JVM_Interrupt&#125;,</span><br><span class="line">    &#123;&quot;isInterrupted&quot;,    &quot;(Z)Z&quot;,       (void *)&amp;JVM_IsInterrupted&#125;,</span><br><span class="line">    &#123;&quot;holdsLock&quot;,        &quot;(&quot; OBJ &quot;)Z&quot;, (void *)&amp;JVM_HoldsLock&#125;,</span><br><span class="line">    &#123;&quot;getThreads&quot;,        &quot;()[&quot; THD,   (void *)&amp;JVM_GetAllThreads&#125;,</span><br><span class="line">    &#123;&quot;dumpThreads&quot;,      &quot;([&quot; THD &quot;)[[&quot; STE, (void *)&amp;JVM_DumpThreads&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#undef THD</span><br><span class="line">#undef OBJ</span><br><span class="line">#undef STE</span><br><span class="line"></span><br><span class="line">JNIEXPORT void JNICALL</span><br><span class="line">Java_java_lang_Thread_registerNatives(JNIEnv *env, jclass cls)</span><br><span class="line">&#123;</span><br><span class="line">    (*env)-&gt;RegisterNatives(env, cls, methods, ARRAY_LENGTH(methods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>start0</strong>()实际上在C++中真正的执行的是<strong>JVM_StartThread</strong>方法，这个方法是在<strong>JVM</strong>层面执行的方法，这样需要下载<strong>hotspot</strong>的源码才能找到答案，我们接着找。在<strong>jvm.cpp</strong>文件中找到如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread))</span><br><span class="line">  JVMWrapper(&quot;JVM_StartThread&quot;);</span><br><span class="line">  JavaThread *native_thread &#x3D; NULL;</span><br></pre></td></tr></table></figure>
<p>再在<strong>thread.cpp</strong>中<strong>JavaThread</strong>相关的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz) :</span><br><span class="line">  Thread()</span><br><span class="line">#if INCLUDE_ALL_GCS</span><br><span class="line">  , _satb_mark_queue(&amp;_satb_mark_queue_set),</span><br><span class="line">  _dirty_card_queue(&amp;_dirty_card_queue_set)</span><br><span class="line">#endif &#x2F;&#x2F; INCLUDE_ALL_GCS</span><br><span class="line">&#123;</span><br><span class="line">  if (TraceThreadEvents) &#123;</span><br><span class="line">    tty-&gt;print_cr(&quot;creating thread %p&quot;, this);</span><br><span class="line">  &#125;</span><br><span class="line">  initialize();</span><br><span class="line">  _jni_attach_state &#x3D; _not_attaching_via_jni;</span><br><span class="line">  set_entry_point(entry_point);</span><br><span class="line">  &#x2F;&#x2F; Create the native thread itself.</span><br><span class="line">  &#x2F;&#x2F; %note runtime_23</span><br><span class="line">  os::ThreadType thr_type &#x3D; os::java_thread;</span><br><span class="line">  thr_type &#x3D; entry_point &#x3D;&#x3D; &amp;compiler_thread_entry ? os::compiler_thread :</span><br><span class="line">                                                     os::java_thread;</span><br><span class="line">  os::create_thread(this, thr_type, stack_sz);</span><br><span class="line">  _safepoint_visible &#x3D; false;</span><br><span class="line">  &#x2F;&#x2F; The _osthread may be NULL here because we ran out of memory (too many threads active).</span><br><span class="line">  &#x2F;&#x2F; We need to throw and OutOfMemoryError - however we cannot do this here because the caller</span><br><span class="line">  &#x2F;&#x2F; may hold a lock and all locks must be unlocked before throwing the exception (throwing</span><br><span class="line">  &#x2F;&#x2F; the exception consists of creating the exception object &amp; initializing it, initialization</span><br><span class="line">  &#x2F;&#x2F; will leave the VM via a JavaCall and then all locks must be unlocked).</span><br><span class="line">  &#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F; The thread is still suspended when we reach here. Thread must be explicit started</span><br><span class="line">  &#x2F;&#x2F; by creator! Furthermore, the thread must also explicitly be added to the Threads list</span><br><span class="line">  &#x2F;&#x2F; by calling Threads:add. The reason why this is not done here, is because the thread</span><br><span class="line">  &#x2F;&#x2F; object must be fully initialized (take a look at JVM_Start)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>os::create_thread</strong> 就是调用系统创建线程的方法来<strong>创建java线程</strong>。创建完线程之后就来启动线程。启动线程调用<strong>Thread.cpp</strong>的<strong>Thread::start(Thread* thread)</strong> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void Thread::start(Thread* thread) &#123;</span><br><span class="line">  trace(&quot;start&quot;, thread);</span><br><span class="line">  &#x2F;&#x2F; Start is different from resume in that its safety is guaranteed by context or</span><br><span class="line">  &#x2F;&#x2F; being called from a Java method synchronized on the Thread object.</span><br><span class="line">  if (!DisableStartThread) &#123;</span><br><span class="line">    if (thread-&gt;is_Java_thread()) &#123;</span><br><span class="line">      &#x2F;&#x2F; Initialize the thread state to RUNNABLE before starting this thread.</span><br><span class="line">      &#x2F;&#x2F; Can not set it after the thread started because we do not know the</span><br><span class="line">      &#x2F;&#x2F; exact thread state at that time. It could be in MONITOR_WAIT or</span><br><span class="line">      &#x2F;&#x2F; in SLEEPING or some other state.</span><br><span class="line">      java_lang_Thread::set_thread_status(((JavaThread*)thread)-&gt;threadObj(),</span><br><span class="line">                                          java_lang_Thread::RUNNABLE);</span><br><span class="line">    &#125;</span><br><span class="line">    os::start_thread(thread);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用平台启动线程的方法，最终会调用<strong>Thread.cpp</strong>的<strong>JavaThread::run()</strong> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; The first routine called by a new Java thread</span><br><span class="line">void JavaThread::run() &#123;</span><br><span class="line">  &#x2F;&#x2F; initialize thread-local alloc buffer related fields</span><br><span class="line">  this-&gt;initialize_tlab();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; used to test validitity of stack trace backs</span><br><span class="line">  this-&gt;record_base_of_stack_pointer();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Record real stack base and size.</span><br><span class="line">  this-&gt;record_stack_base_and_size();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Initialize thread local storage; set before calling MutexLocker</span><br><span class="line">  this-&gt;initialize_thread_local_storage();</span><br><span class="line"></span><br><span class="line">  this-&gt;create_stack_guard_pages();</span><br><span class="line"></span><br><span class="line">  this-&gt;cache_global_variables();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Thread is now sufficient initialized to be handled by the safepoint code as being</span><br><span class="line">  &#x2F;&#x2F; in the VM. Change thread state from _thread_new to _thread_in_vm</span><br><span class="line">  ThreadStateTransition::transition_and_fence(this, _thread_new, _thread_in_vm);</span><br><span class="line"></span><br><span class="line">  assert(JavaThread::current() &#x3D;&#x3D; this, &quot;sanity check&quot;);</span><br><span class="line">  assert(!Thread::current()-&gt;owns_locks(), &quot;sanity check&quot;);</span><br><span class="line"></span><br><span class="line">  DTRACE_THREAD_PROBE(start, this);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; This operation might block. We call that after all safepoint checks for a new thread has</span><br><span class="line">  &#x2F;&#x2F; been completed.</span><br><span class="line">  this-&gt;set_active_handles(JNIHandleBlock::allocate_block());</span><br><span class="line"></span><br><span class="line">  if (JvmtiExport::should_post_thread_life()) &#123;</span><br><span class="line">    JvmtiExport::post_thread_start(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  EventThreadStart event;</span><br><span class="line">  if (event.should_commit()) &#123;</span><br><span class="line">     event.set_javalangthread(java_lang_Thread::thread_id(this-&gt;threadObj()));</span><br><span class="line">     event.commit();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; We call another function to do the rest so we are sure that the stack addresses used</span><br><span class="line">  &#x2F;&#x2F; from there will be lower than the stack base just computed</span><br><span class="line">  thread_main_inner();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Note, thread is no longer valid at this point!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后来一张图总结一下Java线程的启动：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/18/17226afc4b4063f7?w=1500&h=446&f=jpeg&s=92481" alt=""></p>
<h1 id="5-3-线程的终止"><a href="#5-3-线程的终止" class="headerlink" title="5.3 线程的终止"></a>5.3 线程的终止</h1><p>对于线程的终止并不是调用<strong>stop</strong>()方法的，在线程中提供了<strong>interrput</strong>()方法去优雅的中断一个线程。</p>
<p>下面通过一个例子来说明线程终止，调用<strong>interrupted</strong>()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class InterruptDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static int i;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread &#x3D; new Thread(()-&gt;&#123;</span><br><span class="line">            &#x2F;&#x2F;默认情况下isInterrupted 返回 false、通过 thread.interrupt 变成了 true</span><br><span class="line">            while(!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;Num:&quot;+ i);</span><br><span class="line">        &#125;,&quot;interruptDemo&quot;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <strong>interrupt</strong>()方法，设置了一个标识告诉线程可以终止了 ，线程中还提供了静态方法<strong>Thread.interrupted()对设置中断标识的线程复位</strong>。</p>
<h2 id="5-3-1-线程复位"><a href="#5-3-1-线程复位" class="headerlink" title="5.3.1 线程复位"></a>5.3.1 线程复位</h2><p>我们来改造上面示例中的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class InterruptDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static int i;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread &#x3D; new Thread(()-&gt;&#123;</span><br><span class="line">            while(true) &#123;</span><br><span class="line">                if(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(&quot;before&quot; + Thread.currentThread().isInterrupted());</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.interrupted();&#x2F;&#x2F;对线程进行复位，由true变为false</span><br><span class="line">                System.out.println(&quot;after&quot; + Thread.currentThread().isInterrupted());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;interruptDemo&quot;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了使用<strong>Thread.interrupted()</strong>的方法对线程中断标识进行复位之外，还有一种被动的复位场景，就是抛出<strong>InterruptedException</strong>异常的方法，在InterruptedException 抛出之前，JVM 会先把线程的中断标识位清除，然后才会抛出 InterruptedException，这个时候如果调用 <strong>isInterrupted</strong> 方法，将会返回 <strong>false</strong>。</p>
<h2 id="5-3-2-为什么要进行复位"><a href="#5-3-2-为什么要进行复位" class="headerlink" title="5.3.2 为什么要进行复位"></a>5.3.2 为什么要进行复位</h2><p><strong>Thread.interrupted</strong>()是属于当前线程的，是当前线程对外界中断信号的一个响应，表示自己已经得到了中断信号，但不会立刻中断自己，具体什么时候中断由自己决定，让外界知道在自身中断前，他的中断状态仍然是 false，这就是复位的原因</p>
<h2 id="5-3-3-线程的终止原理"><a href="#5-3-3-线程的终止原理" class="headerlink" title="5.3.3 线程的终止原理"></a>5.3.3 线程的终止原理</h2><p>终止线程是调用<strong>interrupt</strong>()方法，我们来看下<strong>Thread</strong>类中的<strong>interrupt</strong>()方法源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void interrupt() &#123;</span><br><span class="line">        if (this !&#x3D; Thread.currentThread())</span><br><span class="line">            checkAccess();</span><br><span class="line"></span><br><span class="line">        synchronized (blockerLock) &#123;</span><br><span class="line">            Interruptible b &#x3D; blocker;</span><br><span class="line">            if (b !&#x3D; null) &#123;</span><br><span class="line">                interrupt0();           &#x2F;&#x2F; Just to set the interrupt flag</span><br><span class="line">                b.interrupt(this);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终调用一个<strong>native</strong>的<strong>interrupt0</strong>()方法，和start0()方法一样，找到<strong>jvm.cpp</strong>中的<strong>JVM_Interrupt</strong>的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(void, JVM_Interrupt(JNIEnv* env, jobject jthread))</span><br><span class="line">  JVMWrapper(&quot;JVM_Interrupt&quot;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Ensure that the C++ Thread and OSThread structures aren&#39;t freed before we operate</span><br><span class="line">  oop java_thread &#x3D; JNIHandles::resolve_non_null(jthread);</span><br><span class="line">  MutexLockerEx ml(thread-&gt;threadObj() &#x3D;&#x3D; java_thread ? NULL : Threads_lock);</span><br><span class="line">  &#x2F;&#x2F; We need to re-resolve the java_thread, since a GC might have happened during the</span><br><span class="line">  &#x2F;&#x2F; acquire of the lock</span><br><span class="line">  JavaThread* thr &#x3D; java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread));</span><br><span class="line">  if (thr !&#x3D; NULL) &#123;</span><br><span class="line">    Thread::interrupt(thr);</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure>
<p><strong>thread.cpp</strong>中的<strong>Thread::interrupt</strong>()方法源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Thread::interrupt(Thread* thread) &#123;</span><br><span class="line">  trace(&quot;interrupt&quot;, thread);</span><br><span class="line">  debug_only(check_for_dangling_thread_pointer(thread);)</span><br><span class="line">  os::interrupt(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Thread::interrupt</strong>() 方法调用了 <strong>os::interrupt</strong>() 方法，这个是调用平台的 interrupt 方法，这个方法的实现是在 <strong>os_*.cpp</strong><br>文件中，我们以 <strong>os_linux.cpp</strong> 文件为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void os::interrupt(Thread* thread) &#123;</span><br><span class="line">  assert(Thread::current() &#x3D;&#x3D; thread || Threads_lock-&gt;owned_by_self(),</span><br><span class="line">    &quot;possibility of dangling Thread pointer&quot;);</span><br><span class="line">  &#x2F;&#x2F;获取本地线程对象</span><br><span class="line">  OSThread* osthread &#x3D; thread-&gt;osthread();</span><br><span class="line">  &#x2F;&#x2F;判断本地线程是否为中断</span><br><span class="line">  if (!osthread-&gt;interrupted()) &#123;</span><br><span class="line">    &#x2F;&#x2F;设置中断状态为true</span><br><span class="line">    osthread-&gt;set_interrupted(true);</span><br><span class="line">    &#x2F;&#x2F; More than one thread can get here with the same value of osthread,</span><br><span class="line">    &#x2F;&#x2F; resulting in multiple notifications.  We do, however, want the store</span><br><span class="line">    &#x2F;&#x2F; to interrupted() to be visible to other threads before we execute unpark().</span><br><span class="line">    &#x2F;&#x2F;内存屏障的目的是使得interrupted状态对其他线程立即可见</span><br><span class="line">    OrderAccess::fence();</span><br><span class="line">    &#x2F;&#x2F;_SleepEvent相当于Thread.sleep，表示如果线程调用了sleep方法，则通过unpark唤醒</span><br><span class="line">    ParkEvent * const slp &#x3D; thread-&gt;_SleepEvent ;</span><br><span class="line">    if (slp !&#x3D; NULL) slp-&gt;unpark() ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; For JSR166. Unpark even if interrupt status already was set</span><br><span class="line">  if (thread-&gt;is_Java_thread())</span><br><span class="line">    ((JavaThread*)thread)-&gt;parker()-&gt;unpark();</span><br><span class="line">  &#x2F;&#x2F;_ParkEvent用于synchronized同步块和Object.wait()，这里相当于也是通过unpark进行唤醒</span><br><span class="line">  ParkEvent * ev &#x3D; thread-&gt;_ParkEvent ;</span><br><span class="line">  if (ev !&#x3D; NULL) ev-&gt;unpark() ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>set_interrupted(true)</strong> 实际上就是调<strong>用osThread.hpp</strong>中的<strong>set_interrupted()</strong>方法，在 <strong>osThread</strong> 中定义了一个成员属性 <strong>volatile jint _interrupted</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">volatile jint _interrupted;     &#x2F;&#x2F; Thread.isInterrupted state</span><br><span class="line"></span><br><span class="line">void set_interrupted(bool z)                      &#123; _interrupted &#x3D; z ? 1 : 0; &#125;</span><br></pre></td></tr></table></figure>
<p><strong>thread.interrupt</strong>()方法实际就是设置一个 <strong>interrupted</strong> 状态标识为 true、并且通过<strong>ParkEvent</strong> 的 <strong>unpark</strong> 方法来唤醒线程。</p>
<ul>
<li>对于 <strong>synchronized</strong>阻塞的线程，被唤醒以后会继续尝试获取锁，如果失败仍然可能被 <strong>park</strong></li>
<li>在调用 <strong>ParkEvent</strong> 的 <strong>park</strong>方法之前，会先判断线程的中断状态，如果为 <strong>true</strong>，会清除当前线程的中断标识</li>
<li><strong>Object.wait 、 Thread.sleep、Thread.join</strong>会抛出<strong>InterruptedException</strong>，不难发现这些方法都是阻塞的。阻塞方法的释放会取决于一些外部的事件，所以<br>它允许一个线程请求自己来停止它正在做的事情。当一个方法抛出InterruptedException 时，它是在告诉调用者如果执行该方法的线程被中断，它会尝试停止正在做的事情并且通过抛出 InterruptedException 表示提前返回。</li>
</ul>
<p><strong>InterruptedException</strong>这个异常的意思是表示一个阻塞被其他线程中断了。然后，由于线程调用了 <strong>interrupt</strong>()中断方法，那么<strong>Object.wait**</strong>、Thread.sleep** 等被阻塞的线程被唤醒以后会通过<strong>is_interrupted</strong>方法判断中断标识的状态变化，如果发现中断标识为<strong>true</strong>，则先清除中断标识，然后抛<strong>出InterruptedException</strong>需要注意的是，<strong>InterruptedException</strong>异常的抛出并不意味着线程必须终止，而是提醒当前线程有中断的操作发生，至于接下来怎么处理取决于线程本身，比如：</p>
<ul>
<li>直接捕获异常不做任何处理</li>
<li>将异常往外抛出</li>
<li>停止当前线程，并打印异常信息</li>
</ul>
<p>为了让大家能够更好的理解上面这段话，我们以<strong>Thread.sleep</strong>为例直接从jdk的源码中找到中断标识的清除以及异常抛出的方法代码找到<strong>is_interrupted</strong>() 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static native void sleep(long millis) throws InterruptedException;</span><br></pre></td></tr></table></figure>
<p><strong>jvm.cpp</strong>中的<strong>JVM_Sleep</strong>的源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(void, JVM_Sleep(JNIEnv* env, jclass threadClass, jlong millis))</span><br><span class="line">  JVMWrapper(&quot;JVM_Sleep&quot;);</span><br><span class="line"></span><br><span class="line">  if (millis &lt; 0) &#123;</span><br><span class="line">    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;判断并清除线程中断状态，如果中断状态为true，则抛出中断异常</span><br><span class="line">  if (Thread::is_interrupted (THREAD, true) &amp;&amp; !HAS_PENDING_EXCEPTION) &#123;</span><br><span class="line">    THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Save current thread state and restore it at the end of this block.</span><br><span class="line">  &#x2F;&#x2F; And set new thread state to SLEEPING.</span><br><span class="line">  JavaThreadSleepState jtss(thread);</span><br></pre></td></tr></table></figure>

<p><strong>os_linux.cpp</strong>中的<strong>is_interrupted</strong>()方法源代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool os::is_interrupted(Thread* thread, bool clear_interrupted) &#123;</span><br><span class="line">  assert(Thread::current() &#x3D;&#x3D; thread || Threads_lock-&gt;owned_by_self(),</span><br><span class="line">    &quot;possibility of dangling Thread pointer&quot;);</span><br><span class="line"></span><br><span class="line">  OSThread* osthread &#x3D; thread-&gt;osthread();</span><br><span class="line">  &#x2F;&#x2F;获取线程中断标识</span><br><span class="line">  bool interrupted &#x3D; osthread-&gt;interrupted();</span><br><span class="line">  &#x2F;&#x2F;如果中断标识为true</span><br><span class="line">  if (interrupted &amp;&amp; clear_interrupted) &#123;</span><br><span class="line">    &#x2F;&#x2F;设置中断标识为false</span><br><span class="line">    osthread-&gt;set_interrupted(false);</span><br><span class="line">    &#x2F;&#x2F; consider thread-&gt;_SleepEvent-&gt;reset() ... optional optimization</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return interrupted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们就已经分析清楚了中断的整个流程。最后还是来画图总结一下吧。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/18/172272fde0b4219a?w=1547&h=456&f=jpeg&s=121301" alt=""></p>
<h2 id="5-3-4-interrupt-的作用"><a href="#5-3-4-interrupt-的作用" class="headerlink" title="5.3.4 interrupt()的作用"></a>5.3.4 interrupt()的作用</h2><ul>
<li>设置一个共享变量的值 true</li>
<li>唤醒处于阻塞状态下的线程</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/05/18/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%8F%AD%E5%BC%80%E7%AF%87%E7%AB%A0%EF%BC%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86%EF%BC%8C%E4%BA%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%84%8F%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/" data-id="cke9cjzdv000rf5rab6pehbx3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-手把手教你阅读mybatis核心源码，掌握底层工作原理与设计思想" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/15/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%98%85%E8%AF%BBmybatis%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%EF%BC%8C%E6%8E%8C%E6%8F%A1%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/" class="article-date">
  <time datetime="2020-05-15T03:29:27.878Z" itemprop="datePublished">2020-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/15/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%98%85%E8%AF%BBmybatis%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%EF%BC%8C%E6%8E%8C%E6%8F%A1%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/">手把手教你阅读mybatis核心源码，掌握底层工作原理与设计思想</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: 手把手教你阅读mybatis核心源码，掌握底层工作原理与设计思想<br>date: 2020-05-15 11:27:43<br>tags:<br>–<br>Mybatis目前作为互联网公司Java体系开源ORM框架的首选，它有着天然的优势，很多同学只关注其公司业务CRUD程序的编写，忽略了其源码阅读的重要性。下面来看一段使用Mybatis API写的代码示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String resource &#x3D; &quot;mybatis-config.xml&quot;;</span><br><span class="line">InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">SqlSession session &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">try &#123;</span><br><span class="line">    BusinessMapper mapper &#x3D; session.getMapper(BusinessMapper.class);</span><br><span class="line">    Business business &#x3D; mapper.selectBusinessById(1);</span><br><span class="line">    System.out.println(business);</span><br><span class="line">    </span><br><span class="line">&#125;finally &#123;</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来按照示例代码的步骤一步一步地来分析代码的运行背后的秘密，揭开mybatis源码的真实面目。给出的源码片段均有中文注释，方便同学们加深理解。</p>
<h1 id="一、全局配置解析过程"><a href="#一、全局配置解析过程" class="headerlink" title="一、全局配置解析过程"></a>一、全局配置解析过程</h1><h2 id="1-1-SqlSessionFactoryBuilder（构建工厂类）"><a href="#1-1-SqlSessionFactoryBuilder（构建工厂类）" class="headerlink" title="1.1 SqlSessionFactoryBuilder（构建工厂类）"></a>1.1 SqlSessionFactoryBuilder（构建工厂类）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure>

<p>创建一个新的<strong>SqlSessionFactoryBuilder</strong>对象，这里使用了建造者模式。调用了build()方法创建了<strong>SqlSessionFactory</strong>对象，在<strong>SqlSessionFactoryBuilder</strong>中有9个重载的build()方法，可以使用不同的方式来创建<strong>SqlSessionFactory</strong>对象，其默认是单例模式的。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/14/17211ef5a2c1f056?w=621&h=330&f=png&s=34774" alt=""></p>
<h2 id="1-2-XmlConfigBuilder（解析全局配置文件）"><a href="#1-2-XmlConfigBuilder（解析全局配置文件）" class="headerlink" title="1.2 XmlConfigBuilder（解析全局配置文件）"></a>1.2 XmlConfigBuilder（解析全局配置文件）</h2><p>创建<strong>XmlConfigBuilder</strong>对象用来解析全局配置文件，解析完成之后会返回一个<strong>Configuration</strong>对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public SqlSessionFactory build(Reader reader, String environment, Properties properties) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F;1、创建XMLConfigBuilder对象</span><br><span class="line">      XMLConfigBuilder parser &#x3D; new XMLConfigBuilder(reader, environment, properties);</span><br><span class="line">      &#x2F;&#x2F;2、调用解析方法返回Configuration对象</span><br><span class="line">      return build(parser.parse());</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">      try &#123;</span><br><span class="line">        reader.close();</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">        &#x2F;&#x2F; Intentionally ignore. Prefer previous error.</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>XMLConfigBuilder</strong>继承自抽象类<strong>BaseBuilder</strong>，解析全局的配置文件，<strong>BaseBuilder</strong>还有一些子类，用来创建不同的目标的。例如：</p>
<ul>
<li>XMLMapperBuilder：解析Mapper映射器</li>
<li>XMLStatementBuilder：解析增删改查标签</li>
<li>XMLScriptBuilder：解析动态SQL</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/14/17212043919beb10?w=1719&h=201&f=png&s=17962" alt=""></p>
<p>接着来看下<strong>XMLConfigBuilder</strong>对象调用的<strong>parse</strong>()方法的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Configuration parse() &#123;</span><br><span class="line">   if (parsed) &#123;</span><br><span class="line">     throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   parsed &#x3D; true;</span><br><span class="line">   &#x2F;&#x2F; XPathParser，dom 和 SAX 都有用到 &gt;&gt;</span><br><span class="line">   parseConfiguration(parser.evalNode(&quot;&#x2F;configuration&quot;));</span><br><span class="line">   return configuration;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>java中解析xml配置文件的方式有很多种，mybatis对DOM和SAX两种方式做了不同的封装。接着看<strong>parseConfiguration</strong>()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private void parseConfiguration(XNode root) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F;issue #117 read properties first</span><br><span class="line">      &#x2F;&#x2F; 对于全局配置文件各种标签的解析</span><br><span class="line">      1、解析&lt;properties&gt;标签，可以读取外部引入的属性文件，比如database.properties</span><br><span class="line">      propertiesElement(root.evalNode(&quot;properties&quot;));</span><br><span class="line">      &#x2F;&#x2F; 2、解析 settings 标签</span><br><span class="line">      Properties settings &#x3D; settingsAsProperties(root.evalNode(&quot;settings&quot;));</span><br><span class="line">      &#x2F;&#x2F;3、获取Virtual File System自定义实现类，比如读取本地文件</span><br><span class="line">      loadCustomVfs(settings);</span><br><span class="line">      &#x2F;&#x2F;4、根据&lt;longImpl&gt;标签获取日志实现类</span><br><span class="line">      loadCustomLogImpl(settings);</span><br><span class="line">      &#x2F;&#x2F;5、解析类型别名</span><br><span class="line">      typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));</span><br><span class="line">      &#x2F;&#x2F;6、解析plugins标签，比如翻页插件PageHelper</span><br><span class="line">      pluginElement(root.evalNode(&quot;plugins&quot;));</span><br><span class="line">      &#x2F;&#x2F; 用于创建对象</span><br><span class="line">      objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));</span><br><span class="line">      &#x2F;&#x2F; 用于对对象进行加工</span><br><span class="line">      objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));</span><br><span class="line">      &#x2F;&#x2F; 反射工具箱</span><br><span class="line">      reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));</span><br><span class="line">      &#x2F;&#x2F; settings 子标签赋值，默认值就是在这里提供的 &gt;&gt;</span><br><span class="line">      settingsElement(settings);</span><br><span class="line">      &#x2F;&#x2F; read it after objectFactory and objectWrapperFactory issue #631</span><br><span class="line">      &#x2F;&#x2F; 创建了数据源 &gt;&gt;</span><br><span class="line">      environmentsElement(root.evalNode(&quot;environments&quot;));</span><br><span class="line">      &#x2F;&#x2F; 解析databaseIdProvider标签，生成DatabaseIdProvider对象</span><br><span class="line">      databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));</span><br><span class="line">      &#x2F;&#x2F; 用来做映射的，得到JavaType和JdbcType，存放在TypeHandlerRegistry对象中</span><br><span class="line">      typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));</span><br><span class="line">      &#x2F;&#x2F; 解析引用的Mapper映射器</span><br><span class="line">      mapperElement(root.evalNode(&quot;mappers&quot;));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法中所有的值都会封装到<strong>Configuration</strong>对象中。下面是创建过程的时序图。<br><img src="https://user-gold-cdn.xitu.io/2020/5/14/172122a8ead77411?w=720&h=590&f=jpeg&s=66823" alt=""></p>
<h1 id="二、会话创建过程"><a href="#二、会话创建过程" class="headerlink" title="二、会话创建过程"></a>二、会话创建过程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session &#x3D; sqlSessionFactory.openSession();</span><br></pre></td></tr></table></figure>
<p>这里实际上调用了<strong>DefaultSqlSessionFactory</strong>类的<strong>openSessionFromDataSource</strong>()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123;</span><br><span class="line">    Transaction tx &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      final Environment environment &#x3D; configuration.getEnvironment();</span><br><span class="line">      &#x2F;&#x2F; 获取事务工厂</span><br><span class="line">      final TransactionFactory transactionFactory &#x3D; getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">      &#x2F;&#x2F; 创建事务</span><br><span class="line">      tx &#x3D; transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">      &#x2F;&#x2F; 根据事务工厂和默认的执行器类型，创建执行器 &gt;&gt;</span><br><span class="line">      final Executor executor &#x3D; configuration.newExecutor(tx, execType);</span><br><span class="line">      return new DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      closeTransaction(tx); &#x2F;&#x2F; may have fetched a connection so lets call close()</span><br><span class="line">      throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-1-获取Environment对象"><a href="#2-1-获取Environment对象" class="headerlink" title="2.1 获取Environment对象"></a>2.1 获取Environment对象</h2><p>从<strong>Configuration</strong>对象中获取<strong>Environment</strong>对象，环境对象中有事务工厂类；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final class Environment &#123;</span><br><span class="line">  private final String id;</span><br><span class="line">  private final TransactionFactory transactionFactory;</span><br><span class="line">  private final DataSource dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-创建事务"><a href="#2-2-创建事务" class="headerlink" title="2.2 创建事务"></a>2.2 创建事务</h2><p>从<strong>Environment</strong>对象中获取一个<strong>TranscationFactory</strong>对象，事务工厂类型可以配置成<strong>JDBC</strong>或者<strong>MANAGED</strong>。</p>
<ul>
<li>JDBC；使用jdbc的Connection对象来管理事务；</li>
<li>MANAGED：事务将有容器进行管理。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private TransactionFactory getTransactionFactoryFromEnvironment(Environment environment) &#123;</span><br><span class="line">   if (environment &#x3D;&#x3D; null || environment.getTransactionFactory() &#x3D;&#x3D; null) &#123;</span><br><span class="line">     return new ManagedTransactionFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   return environment.getTransactionFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-创建执行器"><a href="#2-3-创建执行器" class="headerlink" title="2.3 创建执行器"></a>2.3 创建执行器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final Executor executor &#x3D; configuration.newExecutor(tx, execType);</span><br></pre></td></tr></table></figure>
<p>执行器<strong>Executor</strong>的基本类型有三种：</p>
<ul>
<li>SIMPLE（默认）</li>
<li>BATCH</li>
<li>REUSE</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (ExecutorType.BATCH &#x3D;&#x3D; executorType) &#123;</span><br><span class="line">      executor &#x3D; new BatchExecutor(this, transaction);</span><br><span class="line">    &#125; else if (ExecutorType.REUSE &#x3D;&#x3D; executorType) &#123;</span><br><span class="line">      executor &#x3D; new ReuseExecutor(this, transaction);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 默认 SimpleExecutor</span><br><span class="line">      executor &#x3D; new SimpleExecutor(this, transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/5/14/1721245f64e5e6e9?w=1239&h=378&f=png&s=26496" alt=""></p>
<p>抽象类BaseExecutor实现Executor接口，这是模板设计模式的体现。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/14/172125b1eace1d19?w=981&h=234&f=png&s=32839" alt=""></p>
<p><strong>缓存装饰</strong></p>
<p>在newExecutor()方法中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 二级缓存开关，settings 中的 cacheEnabled 默认是 true</span><br><span class="line">if (cacheEnabled) &#123;</span><br><span class="line">  executor &#x3D; new CachingExecutor(executor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代理插件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 植入插件的逻辑，至此，四大对象已经全部拦截完毕</span><br><span class="line">executor &#x3D; (Executor) interceptorChain.pluginAll(executor);</span><br></pre></td></tr></table></figure>

<h2 id="2-4-返回SqlSession"><a href="#2-4-返回SqlSession" class="headerlink" title="2.4 返回SqlSession"></a>2.4 返回SqlSession</h2><p><strong>SqlSession</strong>类中包括<strong>Configuration</strong>和<strong>Executor</strong>两大对象。下面是创建过程的时序图。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/14/1721265937c7c78b?w=720&h=539&f=jpeg&s=65450" alt=""></p>
<h1 id="三、获取代理对象"><a href="#三、获取代理对象" class="headerlink" title="三、获取代理对象"></a>三、获取代理对象</h1><p>接口中的名称和Mapper.xml文件中的namespace是一一对应的，方法名称也是StatementId也是对应的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BusinessMapper mapper &#x3D; session.getMapper(BusinessMapper.class);</span><br><span class="line">Business business &#x3D; mapper.selectBusinessById(1);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace&#x3D;&quot;com.sy.mapper.BusinessMapper&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id&#x3D;&quot;selectBusinessById&quot; resultMap&#x3D;&quot;BaseResultMap&quot; statementType&#x3D;&quot;PREPARED&quot; &gt;</span><br><span class="line">        select * from bsuiness where bid &#x3D; #&#123;bid&#125;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-1-getMapper-方法"><a href="#3-1-getMapper-方法" class="headerlink" title="3.1 getMapper()方法"></a>3.1 getMapper()方法</h2><p>1、<strong>DefaultSqlSession</strong>中的<strong>getMapper()</strong>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type) &#123;</span><br><span class="line">    return configuration.getMapper(type, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、<strong>Configuration</strong>类中的<strong>getMapper</strong>()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</span><br><span class="line">    return mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>3、<strong>MapperRegistry</strong>中的<strong>getMapper</strong>()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</span><br><span class="line">    final MapperProxyFactory&lt;T&gt; mapperProxyFactory &#x3D; (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    if (mapperProxyFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      return mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在解析mapper标签和Mapper.xml的时候已经把接口类型和类型对应的<strong>MapperProxyFactory</strong>放到一个map中，获取<strong>Mapper</strong>的代理对象，实际上是从map中获取对应的工厂类后，最终通过<strong>JDK动态代理</strong>创建的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123;</span><br><span class="line">    &#x2F;&#x2F; 1：类加载器;</span><br><span class="line">    &#x2F;&#x2F; 2：被代理类实现的接口;</span><br><span class="line">    &#x2F;&#x2F; 3：实现了 InvocationHandler 的触发管理类</span><br><span class="line">    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public T newInstance(SqlSession sqlSession) &#123;</span><br><span class="line">    final MapperProxy&lt;T&gt; mapperProxy &#x3D; new MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    return newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>MapperProxy</strong>实现了<strong>InvocationHandler</strong>接口，参数有<strong>sqlSession, mapperInterface, methodCache</strong>，最终是通过JDK的动态代理创建返回代理对象（类型是$<strong>Proxy数字</strong>）。这个对象继承<strong>Proxy类</strong>，实例被代理的接口，里面持有了一个<strong>MapperProxy</strong>类型的触发管理类。</p>
<h2 id="3-2-MapperProxy-实现对接口的代理"><a href="#3-2-MapperProxy-实现对接口的代理" class="headerlink" title="3.2 MapperProxy 实现对接口的代理"></a>3.2 MapperProxy 实现对接口的代理</h2><p>JDK的动态代理有三个核心角色：</p>
<ul>
<li>被代理类（实现类）</li>
<li>接口</li>
<li>实现了InvocationHandler的触发管理类</li>
</ul>
<p>用来生成代理对象。被代理的类必须实现接口，因为要通过接口获取方法，而且代理类也要实现这个接口。<br><img src="https://user-gold-cdn.xitu.io/2020/5/14/17213567060a5a09?w=935&h=487&f=png&s=224353" alt=""><br>而MyBatis里面的Mapper没有实现类，它直接忽略了实现类，直接对接口进行代理。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/14/172135b12a5dd6af?w=933&h=527&f=png&s=227459" alt=""><br>获取Mapper对象的过程，实际上是获取了一个JDK动态代理对象。这个代理类继承Proxy类，实现被代理的接口，里面持有一个MapperProxy类型的触发管理类。来看下代理类过程的时序图吧。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/14/172135df8fd7a684?w=720&h=511&f=jpeg&s=55503" alt=""></p>
<h1 id="四、执行SQL"><a href="#四、执行SQL" class="headerlink" title="四、执行SQL"></a>四、执行SQL</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Business business &#x3D; mapper.selectBusinessById(1);</span><br></pre></td></tr></table></figure>
<h2 id="4-1-MapperProxy-invoke-方法"><a href="#4-1-MapperProxy-invoke-方法" class="headerlink" title="4.1 MapperProxy.invoke()方法"></a>4.1 MapperProxy.invoke()方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; toString hashCode equals getClass等方法，无需走到执行SQL的流程</span><br><span class="line">      if (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        return method.invoke(this, args);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 提升获取 mapperMethod 的效率，到 MapperMethodInvoker（内部接口） 的 invoke</span><br><span class="line">        &#x2F;&#x2F; 普通方法会走到 PlainMethodInvoker（内部类） 的 invoke</span><br><span class="line">        return cachedInvoker(method).invoke(proxy, method, args, sqlSession);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">      throw ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-1-1、首先判断是否要执行SQL还是直接执行方法"><a href="#4-1-1、首先判断是否要执行SQL还是直接执行方法" class="headerlink" title="4.1.1、首先判断是否要执行SQL还是直接执行方法"></a>4.1.1、首先判断是否要执行SQL还是直接执行方法</h2><p>Object本身的方法和Java 8中的默认方法不需要取执行SQL</p>
<h2 id="4-1-2、获取缓存"><a href="#4-1-2、获取缓存" class="headerlink" title="4.1.2、获取缓存"></a>4.1.2、获取缓存</h2><p>这里加入缓存时为了提升MapperMethod的获取速度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private MapperMethodInvoker cachedInvoker(Method method) throws Throwable &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; Java8 中 Map 的方法，根据 key 获取值，如果值是 null，则把后面Object 的值赋给 key</span><br><span class="line">     &#x2F;&#x2F; 如果获取不到，就创建</span><br><span class="line">     &#x2F;&#x2F; 获取的是 MapperMethodInvoker（接口） 对象，只有一个invoke方法</span><br><span class="line">     return methodCache.computeIfAbsent(method, m -&gt; &#123;</span><br><span class="line">       if (m.isDefault()) &#123;</span><br><span class="line">         &#x2F;&#x2F; 接口的默认方法(Java8)，只要实现接口都会继承接口的默认方法，例如 List.sort()</span><br><span class="line">         try &#123;</span><br><span class="line">           if (privateLookupInMethod &#x3D;&#x3D; null) &#123;</span><br><span class="line">             return new DefaultMethodInvoker(getMethodHandleJava8(method));</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">             return new DefaultMethodInvoker(getMethodHandleJava9(method));</span><br><span class="line">           &#125;</span><br><span class="line">         &#125; catch (IllegalAccessException | InstantiationException | InvocationTargetException</span><br><span class="line">             | NoSuchMethodException e) &#123;</span><br><span class="line">           throw new RuntimeException(e);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         &#x2F;&#x2F; 创建了一个 MapperMethod</span><br><span class="line">         return new PlainMethodInvoker(new MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125; catch (RuntimeException re) &#123;</span><br><span class="line">     Throwable cause &#x3D; re.getCause();</span><br><span class="line">     throw cause &#x3D;&#x3D; null ? re : cause;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>Map 的 <strong>computeIfAbsent</strong>()方法：只有key不存在或者value为null，则把后面的Object的值赋给key。<strong>Java8</strong>和<strong>Java9</strong>中的接口默认方法由特殊处理，返回<strong>DefaultMethodInvoker</strong>对象。普通的方法返回的是<strong>PlainMethodInvoker</strong>，<strong>MapperMethod</strong>。</p>
<p>在MapperMethod对象中有两个比较重要的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; statement id （例如：com.sy.mapper.BusinessMapper.selectBusinessById） 和 SQL 类型</span><br><span class="line"> private final SqlCommand command;</span><br><span class="line"> &#x2F;&#x2F; 方法签名，主要是返回值的类型</span><br><span class="line"> private final MethodSignature method;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-MappperMethod-execute-方法"><a href="#4-2-MappperMethod-execute-方法" class="headerlink" title="4.2 MappperMethod.execute()方法"></a>4.2 MappperMethod.execute()方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public Object execute(SqlSession sqlSession, Object[] args) &#123;</span><br><span class="line">    Object result;</span><br><span class="line">    switch (command.getType()) &#123;</span><br><span class="line">      case INSERT: &#123;</span><br><span class="line">        Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result &#x3D; rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      case UPDATE: &#123;</span><br><span class="line">        Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result &#x3D; rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      case DELETE: &#123;</span><br><span class="line">        Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result &#x3D; rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      case SELECT:</span><br><span class="line">        if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">          executeWithResultHandler(sqlSession, args);</span><br><span class="line">          result &#x3D; null;</span><br><span class="line">        &#125; else if (method.returnsMany()) &#123;</span><br><span class="line">          result &#x3D; executeForMany(sqlSession, args);</span><br><span class="line">        &#125; else if (method.returnsMap()) &#123;</span><br><span class="line">          result &#x3D; executeForMap(sqlSession, args);</span><br><span class="line">        &#125; else if (method.returnsCursor()) &#123;</span><br><span class="line">          result &#x3D; executeForCursor(sqlSession, args);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">          &#x2F;&#x2F; 普通 select 语句的执行入口 &gt;&gt;</span><br><span class="line">          result &#x3D; sqlSession.selectOne(command.getName(), param);</span><br><span class="line">          if (method.returnsOptional()</span><br><span class="line">              &amp;&amp; (result &#x3D;&#x3D; null || !method.getReturnType().equals(result.getClass()))) &#123;</span><br><span class="line">            result &#x3D; Optional.ofNullable(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">      case FLUSH:</span><br><span class="line">        result &#x3D; sqlSession.flushStatements();</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    if (result &#x3D;&#x3D; null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">      throw new BindingException(&quot;Mapper method &#39;&quot; + command.getName()</span><br><span class="line">          + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>根据不同的类型（<strong>INSERT、UPDATE、DELETE、SELECT</strong>）和返回类型：</p>
<ul>
<li>调用<strong>convertArgsToSqlCommandParam</strong>()将方法的参数转换为SQL的参数。</li>
<li>调用sqlSession的insert()、update()、delete()、selectOne()方法。</li>
</ul>
<p>下面重点来讲下查询的selectOne()方法。调用了<strong>DefaultSqlSession</strong>的selectOne()方法。</p>
<h2 id="4-3-DefaultSqlSession-selectOne-方法"><a href="#4-3-DefaultSqlSession-selectOne-方法" class="headerlink" title="4.3 DefaultSqlSession.selectOne()方法"></a>4.3 DefaultSqlSession.selectOne()方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T selectOne(String statement, Object parameter) &#123;</span><br><span class="line">    &#x2F;&#x2F; 来到了 DefaultSqlSession</span><br><span class="line">    &#x2F;&#x2F; Popular vote was to return null on 0 results and throw exception on too many.</span><br><span class="line">    List&lt;T&gt; list &#x3D; this.selectList(statement, parameter);</span><br><span class="line">    if (list.size() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">      return list.get(0);</span><br><span class="line">    &#125; else if (list.size() &gt; 1) &#123;</span><br><span class="line">      throw new TooManyResultsException(&quot;Expected one result (or null) to be returned by selectOne(), but found: &quot; + list.size());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在SelectList()中，我们先根据commandname（StatementID）从Configuration中拿到MappedStatement，这个ms上面有我们在xml中配置的所有属性，包括id、statementType、sqlSource、useCache、入参、出参等等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      MappedStatement ms &#x3D; configuration.getMappedStatement(statement);</span><br><span class="line">      &#x2F;&#x2F; 如果 cacheEnabled &#x3D; true（默认），Executor会被 CachingExecutor装饰</span><br><span class="line">      return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>然后执行executor.query()，前面我们说到了Executor有三种基本类型，SIMPLE/REUSE/BATCH，还有一种包装类型，CachingExecutor。那么在这里到底会选择哪一种执行器呢？我们要回过头去看看DefaultSqlSession在初始化的时候是怎么赋值的，这个就是我们的会话创建过程。如果启用了二级缓存，就会先调用CachingExecutor 的query()方法，里面有缓存相关的操作，然后才是再调用基本类型的执行器，比如默认的SimpleExecutor。在没有开启二级缓存的情况下，先会走到BaseExecutor的query()方法（否则会先走到CachingExecutor）。</p>
<h2 id="4-4-CachingExector-query-方法"><a href="#4-4-CachingExector-query-方法" class="headerlink" title="4.4 CachingExector.query()方法"></a>4.4 CachingExector.query()方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取SQL</span><br><span class="line">    BoundSql boundSql &#x3D; ms.getBoundSql(parameterObject);</span><br><span class="line">    &#x2F;&#x2F; 创建CacheKey：什么样的SQL是同一条SQL？ &gt;&gt;</span><br><span class="line">    CacheKey key &#x3D; createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-4-1、创建CacheKey"><a href="#4-4-1、创建CacheKey" class="headerlink" title="4.4.1、创建CacheKey"></a>4.4.1、创建CacheKey</h2><p>二级缓存的CacheKey是如何构成的呢？换句话说，什么样的查询才能确定是同一个查询呢？在BaseExector中createCacheKey()方法，用到了六要素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) &#123;</span><br><span class="line">    if (closed) &#123;</span><br><span class="line">      throw new ExecutorException(&quot;Executor was closed.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    CacheKey cacheKey &#x3D; new CacheKey();</span><br><span class="line">    cacheKey.update(ms.getId()); </span><br><span class="line">    cacheKey.update(rowBounds.getOffset()); &#x2F;&#x2F; 0</span><br><span class="line">    cacheKey.update(rowBounds.getLimit()); &#x2F;&#x2F; 2147483647 &#x3D; 2^31-1</span><br><span class="line">    cacheKey.update(boundSql.getSql());</span><br><span class="line">    List&lt;ParameterMapping&gt; parameterMappings &#x3D; boundSql.getParameterMappings();</span><br><span class="line">    TypeHandlerRegistry typeHandlerRegistry &#x3D; ms.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">    &#x2F;&#x2F; mimic DefaultParameterHandler logic</span><br><span class="line">    for (ParameterMapping parameterMapping : parameterMappings) &#123;</span><br><span class="line">      if (parameterMapping.getMode() !&#x3D; ParameterMode.OUT) &#123;</span><br><span class="line">        Object value;</span><br><span class="line">        String propertyName &#x3D; parameterMapping.getProperty();</span><br><span class="line">        if (boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">          value &#x3D; boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">        &#125; else if (parameterObject &#x3D;&#x3D; null) &#123;</span><br><span class="line">          value &#x3D; null;</span><br><span class="line">        &#125; else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">          value &#x3D; parameterObject;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          MetaObject metaObject &#x3D; configuration.newMetaObject(parameterObject);</span><br><span class="line">          value &#x3D; metaObject.getValue(propertyName);</span><br><span class="line">        &#125;</span><br><span class="line">        cacheKey.update(value); &#x2F;&#x2F; development</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (configuration.getEnvironment() !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; issue #176</span><br><span class="line">      cacheKey.update(configuration.getEnvironment().getId());</span><br><span class="line">    &#125;</span><br><span class="line">    return cacheKey;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>即为方法相同、翻页偏移相同、SQL相同、参数值相同、数据源环境相同才会被认定为同一个查询。</p>
<p>注意看下CacheKey类的属性，里面有一个List按照顺序存放了上面的六要素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static final int DEFAULT_MULTIPLIER &#x3D; 37;</span><br><span class="line"> private static final int DEFAULT_HASHCODE &#x3D; 17;</span><br><span class="line"></span><br><span class="line"> private final int multiplier;</span><br><span class="line"> private int hashcode;</span><br><span class="line"> private long checksum;</span><br><span class="line"> private int count;</span><br><span class="line"> &#x2F;&#x2F; 8&#x2F;21&#x2F;2017 - Sonarlint flags this as needing to be marked transient.  While true if content is not serializable, this is not always true and thus should not be marked transient.</span><br><span class="line"> private List&lt;Object&gt; updateList;</span><br></pre></td></tr></table></figure>

<p>怎么比较两个CacheKey是否相等呢？如果一上来就依次比较六个要素是否相等，这样要比6次，这样效率不高。每一个类都继承自Object，都有一个hashCode()方法，用来生成哈希码。它是用来在集合中快速判重的。</p>
<p>在生成cacheKey的时候也就是调用update()方法，也更新了cacheKey的hashCode，它是用乘法哈希生成的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void update(Object object) &#123;</span><br><span class="line">    &#x2F;&#x2F; 加法哈希</span><br><span class="line">    int baseHashCode &#x3D; object &#x3D;&#x3D; null ? 1 : ArrayUtil.hashCode(object);</span><br><span class="line"></span><br><span class="line">    count++;</span><br><span class="line">    checksum +&#x3D; baseHashCode;</span><br><span class="line">    baseHashCode *&#x3D; count;</span><br><span class="line">    &#x2F;&#x2F; 37 * 17 + </span><br><span class="line">    hashcode &#x3D; multiplier * hashcode + baseHashCode;</span><br><span class="line"></span><br><span class="line">    updateList.add(object);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Object中的hashCode()方法是一个本地方法，通过<strong>随机数算法生成</strong>（OpenJDK8 默认，可以通过-XX:hashCode修改）。CacheKey中的hashCode()方法进行了重写，返回生成新的hashCode。</p>
<p>为什么需要用37作为乘法因子呢？这是一个经验值，跟String类中的31类似。看下String类中的hashCode()方法源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int hashCode() &#123;</span><br><span class="line">    int h &#x3D; hash;</span><br><span class="line">    if (h &#x3D;&#x3D; 0 &amp;&amp; value.length &gt; 0) &#123;</span><br><span class="line">        char val[] &#x3D; value;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; value.length; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;31作为乘法因子</span><br><span class="line">            h &#x3D; 31 * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash &#x3D; h;</span><br><span class="line">    &#125;</span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CacheKey中的equals()方法也进行了重写，比较cacheKey是否相等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object object) &#123;</span><br><span class="line">    &#x2F;&#x2F; 同一个对象</span><br><span class="line">    if (this &#x3D;&#x3D; object) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 被比较的对象不是 CacheKey</span><br><span class="line">    if (!(object instanceof CacheKey)) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    final CacheKey cacheKey &#x3D; (CacheKey) object;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; hashcode 不相等</span><br><span class="line">    if (hashcode !&#x3D; cacheKey.hashcode) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; checksum 不相等</span><br><span class="line">    if (checksum !&#x3D; cacheKey.checksum) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; count 不相等</span><br><span class="line">    if (count !&#x3D; cacheKey.count) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i &lt; updateList.size(); i++) &#123;</span><br><span class="line">      Object thisObject &#x3D; updateList.get(i);</span><br><span class="line">      Object thatObject &#x3D; cacheKey.updateList.get(i);</span><br><span class="line">      if (!ArrayUtil.equals(thisObject, thatObject)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果哈希值（乘法哈希），校验值（加法哈希），要素个数任何一个不相等，都不是同一个查询，最后再循环比较要素，防止hash碰撞。</p>
<p>CacheKey生成之后，调用CachingExecutor类的query()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取SQL</span><br><span class="line">    BoundSql boundSql &#x3D; ms.getBoundSql(parameterObject);</span><br><span class="line">    &#x2F;&#x2F; 创建CacheKey：什么样的SQL是同一条SQL？ &gt;&gt;</span><br><span class="line">    CacheKey key &#x3D; createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4-2、处理二级缓存"><a href="#4-4-2、处理二级缓存" class="headerlink" title="4.4.2、处理二级缓存"></a>4.4.2、处理二级缓存</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span><br><span class="line">      throws SQLException &#123;</span><br><span class="line">    Cache cache &#x3D; ms.getCache();</span><br><span class="line">    &#x2F;&#x2F; cache 对象是在哪里创建的？  XMLMapperBuilder类 xmlconfigurationElement()</span><br><span class="line">    &#x2F;&#x2F; 由 &lt;cache&gt; 标签决定</span><br><span class="line">    if (cache !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; flushCache&#x3D;&quot;true&quot; 清空一级二级缓存 &gt;&gt;</span><br><span class="line">      flushCacheIfRequired(ms);</span><br><span class="line">      if (ms.isUseCache() &amp;&amp; resultHandler &#x3D;&#x3D; null) &#123;</span><br><span class="line">        ensureNoOutParams(ms, boundSql);</span><br><span class="line">        &#x2F;&#x2F; 获取二级缓存</span><br><span class="line">        &#x2F;&#x2F; 缓存通过 TransactionalCacheManager、TransactionalCache 管理</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        List&lt;E&gt; list &#x3D; (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">        if (list &#x3D;&#x3D; null) &#123;</span><br><span class="line">          list &#x3D; delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">          &#x2F;&#x2F; 写入二级缓存</span><br><span class="line">          tcm.putObject(cache, key, list); &#x2F;&#x2F; issue #578 and #116</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 走到 SimpleExecutor | ReuseExecutor | BatchExecutor</span><br><span class="line">    return delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>首先从<strong>MappedStatement</strong>对象中调用<strong>getCache</strong>()方法，判断对象是否为空，如果为空，则没有查询二级缓存、写入二级缓存的流程。</p>
<p>那么Cache对象是什么时候被创建出来的呢？用来解析Mapper.xml的<strong>XMLMapperBuilder</strong>类，<strong>configurationElement</strong>()方法中调用<strong>cacheElement</strong>()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cacheElement(context.evalNode(&quot;cache&quot;));</span><br></pre></td></tr></table></figure>
<p>只有Mapper.xml中的cache标签不为空才会被解析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void cacheElement(XNode context) &#123;</span><br><span class="line">   &#x2F;&#x2F; 只有 cache 标签不为空才解析</span><br><span class="line">   if (context !&#x3D; null) &#123;</span><br><span class="line">     String type &#x3D; context.getStringAttribute(&quot;type&quot;, &quot;PERPETUAL&quot;);</span><br><span class="line">     Class&lt;? extends Cache&gt; typeClass &#x3D; typeAliasRegistry.resolveAlias(type);</span><br><span class="line">     String eviction &#x3D; context.getStringAttribute(&quot;eviction&quot;, &quot;LRU&quot;);</span><br><span class="line">     Class&lt;? extends Cache&gt; evictionClass &#x3D; typeAliasRegistry.resolveAlias(eviction);</span><br><span class="line">     Long flushInterval &#x3D; context.getLongAttribute(&quot;flushInterval&quot;);</span><br><span class="line">     Integer size &#x3D; context.getIntAttribute(&quot;size&quot;);</span><br><span class="line">     boolean readWrite &#x3D; !context.getBooleanAttribute(&quot;readOnly&quot;, false);</span><br><span class="line">     boolean blocking &#x3D; context.getBooleanAttribute(&quot;blocking&quot;, false);</span><br><span class="line">     Properties props &#x3D; context.getChildrenAsProperties();</span><br><span class="line">     builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>builderAssistant.useNewCache</strong>()方法创建了一个Cache对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public Cache useNewCache(Class&lt;? extends Cache&gt; typeClass,</span><br><span class="line">      Class&lt;? extends Cache&gt; evictionClass,</span><br><span class="line">      Long flushInterval,</span><br><span class="line">      Integer size,</span><br><span class="line">      boolean readWrite,</span><br><span class="line">      boolean blocking,</span><br><span class="line">      Properties props) &#123;</span><br><span class="line">    Cache cache &#x3D; new CacheBuilder(currentNamespace)</span><br><span class="line">        .implementation(valueOrDefault(typeClass, PerpetualCache.class))</span><br><span class="line">        .addDecorator(valueOrDefault(evictionClass, LruCache.class))</span><br><span class="line">        .clearInterval(flushInterval)</span><br><span class="line">        .size(size)</span><br><span class="line">        .readWrite(readWrite)</span><br><span class="line">        .blocking(blocking)</span><br><span class="line">        .properties(props)</span><br><span class="line">        .build();</span><br><span class="line">    configuration.addCache(cache);</span><br><span class="line">    currentCache &#x3D; cache;</span><br><span class="line">    return cache;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>二级缓存为什么要用TCM来进行管理呢？</strong></p>
<p>我们来思考一个问题，在一个事务中：</p>
<ul>
<li>1、首先插入一条数据（没有提交），此时二级缓存会被清空。</li>
<li>2、在这个事务中查询数据，写入二级缓存。</li>
<li>3、提交事务，出现异常，数据回滚。</li>
</ul>
<p>此时出现了数据库没有这条数据，但是二级缓存有这条数据的情况。所以MyBatis<br>的二级缓存需要跟事务关联起来。</p>
<p><strong>那么为什么一级缓存不这么做？</strong></p>
<p>因为一个session就是一个事务，事务回滚，会话就结束了，缓存也清空了，不存<br>在读到一级缓存中脏数据的情况。二级缓存是跨session的，也就是跨事务的，才有可能出现对同一个方法的不同事务访问。</p>
<h2 id="4-4-2-1-写入二级缓存"><a href="#4-4-2-1-写入二级缓存" class="headerlink" title="4.4.2.1 写入二级缓存"></a>4.4.2.1 写入二级缓存</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcm.putObject(cache, key, list); &#x2F;&#x2F; issue #578 and #116</span><br></pre></td></tr></table></figure>

<p>调用<strong>TranscationalCacheManager</strong>的<strong>putObject</strong>()方法，从map中拿出TransactionalCache对象，把value添加到待提交的map中。此时缓存还没有真正的写入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void putObject(Cache cache, CacheKey key, Object value) &#123;</span><br><span class="line">    getTransactionalCache(cache).putObject(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private TransactionalCache getTransactionalCache(Cache cache) &#123;</span><br><span class="line">    return transactionalCaches.computeIfAbsent(cache, TransactionalCache::new);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<strong>TranscationalCache</strong>的<strong>putObject</strong>()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void putObject(Object key, Object object) &#123;</span><br><span class="line">    entriesToAddOnCommit.put(key, object);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>只有真正的提交事务的时候才真正的写入缓存。</strong></p>
<h2 id="4-4-2-2-获取二级缓存"><a href="#4-4-2-2-获取二级缓存" class="headerlink" title="4.4.2.2 获取二级缓存"></a>4.4.2.2 获取二级缓存</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;E&gt; list &#x3D; (List&lt;E&gt;) tcm.getObject(cache, key);</span><br></pre></td></tr></table></figure>
<p>从map中拿出<strong>Transcational</strong>对象，这个对象也是对<strong>PerpetualCache</strong>经过层层装饰的缓存对象。<strong>getObject</strong>()方法层层递归，直到到达<strong>PerpetualCache</strong>，拿到value。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public Object getObject(Object key) &#123;</span><br><span class="line">    &#x2F;&#x2F; issue #116</span><br><span class="line">    Object object &#x3D; delegate.getObject(key);</span><br><span class="line">    if (object &#x3D;&#x3D; null) &#123;</span><br><span class="line">      entriesMissedInCache.add(key);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; issue #146</span><br><span class="line">    if (clearOnCommit) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return object;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>PerpetualCache</strong>中的<strong>getObject</strong>()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object getObject(Object key) &#123;</span><br><span class="line">    return cache.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-BaseExecutor-query-方法"><a href="#4-5-BaseExecutor-query-方法" class="headerlink" title="4.5 BaseExecutor.query()方法"></a>4.5 BaseExecutor.query()方法</h2><h2 id="4-5-1-清空本地缓存"><a href="#4-5-1-清空本地缓存" class="headerlink" title="4.5.1 清空本地缓存"></a>4.5.1 清空本地缓存</h2><p><strong>queryStack</strong>用于记录查询栈，防止递归时候查询重复处理缓存。<strong>flushCache=true</strong>的时候，会先清除本地缓存LocalCache（一级缓存）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (queryStack &#x3D;&#x3D; 0 &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">      &#x2F;&#x2F; flushCache&#x3D;&quot;true&quot;时，即使是查询，也清空一级缓存</span><br><span class="line">      clearLocalCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有缓存，会从数据库查询。调用<strong>queryFromDatabase()</strong>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list &#x3D; queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br></pre></td></tr></table></figure>

<p><strong>LocalCacheScope == STATEMENT</strong>，就会清空本地缓存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (configuration.getLocalCacheScope() &#x3D;&#x3D; LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">    &#x2F;&#x2F; issue #482</span><br><span class="line">    clearLocalCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-2-数据库查询"><a href="#4-5-2-数据库查询" class="headerlink" title="4.5.2 数据库查询"></a>4.5.2 数据库查询</h2><p>1、先在缓存用占位符进行占位。执行查询后，移除占位符，放入数据。</p>
<p>2、执行Exector的doQuery()方法，默认是SimpleExector。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">   List&lt;E&gt; list;</span><br><span class="line">   &#x2F;&#x2F; 先占位</span><br><span class="line">   localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; 三种 Executor 的区别，看doUpdate</span><br><span class="line">     &#x2F;&#x2F; 默认Simple</span><br><span class="line">     list &#x3D; doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">     &#x2F;&#x2F; 移除占位符</span><br><span class="line">     localCache.removeObject(key);</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 写入一级缓存</span><br><span class="line">   localCache.putObject(key, list);</span><br><span class="line">   if (ms.getStatementType() &#x3D;&#x3D; StatementType.CALLABLE) &#123;</span><br><span class="line">     localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">   &#125;</span><br><span class="line">   return list;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-6-SimpleExecutor-query-方法"><a href="#4-6-SimpleExecutor-query-方法" class="headerlink" title="4.6 SimpleExecutor.query()方法"></a>4.6 SimpleExecutor.query()方法</h2><h2 id="4-6-1-创建StatementHandler"><a href="#4-6-1-创建StatementHandler" class="headerlink" title="4.6.1 创建StatementHandler"></a>4.6.1 创建StatementHandler</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">    Statement stmt &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      Configuration configuration &#x3D; ms.getConfiguration();</span><br><span class="line">      &#x2F;&#x2F; 注意，已经来到SQL处理的关键对象 StatementHandler &gt;&gt;</span><br><span class="line">      StatementHandler handler &#x3D; configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      &#x2F;&#x2F; 获取一个 Statement对象</span><br><span class="line">      stmt &#x3D; prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">      &#x2F;&#x2F; 执行查询</span><br><span class="line">      return handler.query(stmt, resultHandler);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      &#x2F;&#x2F; 用完就关闭</span><br><span class="line">      closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>configuration.newStatementHandler</strong>()先得到<strong>RoutingStatementHandler</strong>。RoutingStatementHandler没有任何实现，用来创建基本的<strong>StatementHandler</strong>，这里会根据<strong>MappedStatement</strong>里面的<strong>statementType</strong>决定<strong>StatementHandler</strong>的类型。默认是<strong>PREPARED（STATEMENT、PREPARED、CALLABLE）</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public RoutingStatementHandler(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">    &#x2F;&#x2F; StatementType 是怎么来的？ 增删改查标签中的 statementType&#x3D;&quot;PREPARED&quot;，默认值 PREPARED</span><br><span class="line">    switch (ms.getStatementType()) &#123;</span><br><span class="line">      case STATEMENT:</span><br><span class="line">        delegate &#x3D; new SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        break;</span><br><span class="line">      case PREPARED:</span><br><span class="line">        &#x2F;&#x2F; 创建 StatementHandler 的时候做了什么？ &gt;&gt;</span><br><span class="line">        delegate &#x3D; new PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        break;</span><br><span class="line">      case CALLABLE:</span><br><span class="line">        delegate &#x3D; new CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        throw new ExecutorException(&quot;Unknown statement type: &quot; + ms.getStatementType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>StatementHandler</strong>里面包含了处理参数的<strong>ParamterHandler</strong>和处理结果集的<strong>ResultHandler</strong>。这两个对象都是在上面new的时候创建的。</p>
<p><strong>StatementHandler</strong>父类<strong>BaseStatementHandler</strong>类中的构造函数中创建以上两个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected BaseStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">   this.configuration &#x3D; mappedStatement.getConfiguration();</span><br><span class="line">   this.executor &#x3D; executor;</span><br><span class="line">   this.mappedStatement &#x3D; mappedStatement;</span><br><span class="line">   this.rowBounds &#x3D; rowBounds;</span><br><span class="line"></span><br><span class="line">   this.typeHandlerRegistry &#x3D; configuration.getTypeHandlerRegistry();</span><br><span class="line">   this.objectFactory &#x3D; configuration.getObjectFactory();</span><br><span class="line"></span><br><span class="line">   if (boundSql &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; issue #435, get the key before calculating the statement</span><br><span class="line">     generateKeys(parameterObject);</span><br><span class="line">     boundSql &#x3D; mappedStatement.getBoundSql(parameterObject);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   this.boundSql &#x3D; boundSql;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 创建了四大对象的其它两大对象 &gt;&gt;</span><br><span class="line">   &#x2F;&#x2F; 创建这两大对象的时候分别做了什么？</span><br><span class="line">   this.parameterHandler &#x3D; configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">   this.resultSetHandler &#x3D; configuration.newResultSetHandler(executor, mappedStatement, rowBounds, parameterHandler, resultHandler, boundSql);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这些对象都是可以被插件拦截的四大对象，所以在创建之后都要用拦截器进行包装的方法。在<strong>Configuration</strong>中进行拦截调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) &#123;</span><br><span class="line">    ParameterHandler parameterHandler &#x3D; mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    &#x2F;&#x2F; 植入插件逻辑（返回代理对象）</span><br><span class="line">    parameterHandler &#x3D; (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">    return parameterHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span><br><span class="line">      ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">    ResultSetHandler resultSetHandler &#x3D; new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">    &#x2F;&#x2F; 植入插件逻辑（返回代理对象）</span><br><span class="line">    resultSetHandler &#x3D; (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">    return resultSetHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">    StatementHandler statementHandler &#x3D; new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">    &#x2F;&#x2F; 植入插件逻辑（返回代理对象）</span><br><span class="line">    statementHandler &#x3D; (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">    return statementHandler;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里只有对其中的三个对象，还有一个对象呢？它什么时候创建呢？</p>
<h2 id="4-6-2-创建Statement"><a href="#4-6-2-创建Statement" class="headerlink" title="4.6.2 创建Statement"></a>4.6.2 创建Statement</h2><p>用new出来的<strong>StatementHandler</strong>创建<strong>Statement</strong>对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException &#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    Connection connection &#x3D; getConnection(statementLog);</span><br><span class="line">    &#x2F;&#x2F; 获取 Statement 对象，如果有插件包装，会先走到被拦截的业务逻辑</span><br><span class="line">    stmt &#x3D; handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">    &#x2F;&#x2F; 为 Statement 设置参数，对sql语句进行预编译，处理参数</span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    return stmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void parameterize(Statement statement) throws SQLException &#123;</span><br><span class="line">    delegate.parameterize(statement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-6-3-执行StatementHandler的query-方法"><a href="#4-6-3-执行StatementHandler的query-方法" class="headerlink" title="4.6.3 执行StatementHandler的query()方法"></a>4.6.3 执行StatementHandler的query()方法</h1><p>RoutingStatementHandler的query()方法，delegate委派，最终执行PreparedStatementHandler的query()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">   return delegate.query(statement, resultHandler);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-6-4-执行PreparedStatementHandler的query-方法"><a href="#4-6-4-执行PreparedStatementHandler的query-方法" class="headerlink" title="4.6.4 执行PreparedStatementHandler的query()方法"></a>4.6.4 执行PreparedStatementHandler的query()方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">    PreparedStatement ps &#x3D; (PreparedStatement) statement;</span><br><span class="line">    &#x2F;&#x2F; 到了JDBC的流程</span><br><span class="line">    ps.execute();</span><br><span class="line">    &#x2F;&#x2F; 处理结果集</span><br><span class="line">    return resultSetHandler.handleResultSets(ps);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-6-5-ResultHandler处理结果集"><a href="#4-6-5-ResultHandler处理结果集" class="headerlink" title="4.6.5 ResultHandler处理结果集"></a>4.6.5 ResultHandler处理结果集</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resultSetHandler.handleResultSets(ps);</span><br></pre></td></tr></table></figure>

<p>怎么把ResultSet转换成List<ObJect>?</p>
<p><strong>ResultSetHandIer</strong>只有一个实现类：<strong>DefaultResultSetHandler</strong>也就是执行<br>DefaultResultSetHandler的<strong>handleResultSets</strong>()方法。首先我们会先拿到第一个结果集，如果没有配置一个查询返回多个结果集的情况，一般只有一个结果集。如果下面的这个while循环我们也不用，就执行一次。然后会调用<strong>handleResuItSet</strong>()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public List&lt;Object&gt; handleResultSets(Statement stmt) throws SQLException &#123;</span><br><span class="line">    ErrorContext.instance().activity(&quot;handling results&quot;).object(mappedStatement.getId());</span><br><span class="line"></span><br><span class="line">    final List&lt;Object&gt; multipleResults &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    int resultSetCount &#x3D; 0;</span><br><span class="line">    ResultSetWrapper rsw &#x3D; getFirstResultSet(stmt);</span><br><span class="line"></span><br><span class="line">    List&lt;ResultMap&gt; resultMaps &#x3D; mappedStatement.getResultMaps();</span><br><span class="line">    int resultMapCount &#x3D; resultMaps.size();</span><br><span class="line">    validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line">    while (rsw !&#x3D; null &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</span><br><span class="line">      ResultMap resultMap &#x3D; resultMaps.get(resultSetCount);</span><br><span class="line">      handleResultSet(rsw, resultMap, multipleResults, null);</span><br><span class="line">      rsw &#x3D; getNextResultSet(stmt);</span><br><span class="line">      cleanUpAfterHandlingResultSet();</span><br><span class="line">      resultSetCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] resultSets &#x3D; mappedStatement.getResultSets();</span><br><span class="line">    if (resultSets !&#x3D; null) &#123;</span><br><span class="line">      while (rsw !&#x3D; null &amp;&amp; resultSetCount &lt; resultSets.length) &#123;</span><br><span class="line">        ResultMapping parentMapping &#x3D; nextResultMaps.get(resultSets[resultSetCount]);</span><br><span class="line">        if (parentMapping !&#x3D; null) &#123;</span><br><span class="line">          String nestedResultMapId &#x3D; parentMapping.getNestedResultMapId();</span><br><span class="line">          ResultMap resultMap &#x3D; configuration.getResultMap(nestedResultMapId);</span><br><span class="line">          handleResultSet(rsw, resultMap, null, parentMapping);</span><br><span class="line">        &#125;</span><br><span class="line">        rsw &#x3D; getNextResultSet(stmt);</span><br><span class="line">        cleanUpAfterHandlingResultSet();</span><br><span class="line">        resultSetCount++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return collapseSingleResultList(multipleResults);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void handleResultSet(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Object&gt; multipleResults, ResultMapping parentMapping) throws SQLException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      if (parentMapping !&#x3D; null) &#123;</span><br><span class="line">        handleRowValues(rsw, resultMap, null, RowBounds.DEFAULT, parentMapping);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (resultHandler &#x3D;&#x3D; null) &#123;</span><br><span class="line">          DefaultResultHandler defaultResultHandler &#x3D; new DefaultResultHandler(objectFactory);</span><br><span class="line">          handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, null);</span><br><span class="line">          multipleResults.add(defaultResultHandler.getResultList());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          handleRowValues(rsw, resultMap, resultHandler, rowBounds, null);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      &#x2F;&#x2F; issue #228 (close resultsets)</span><br><span class="line">      closeResultSet(rsw.getResultSet());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://user-gold-cdn.xitu.io/2020/5/15/1721652a86370b3e?w=720&h=466&f=jpeg&s=51595" alt=""></h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/05/15/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%98%85%E8%AF%BBmybatis%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%EF%BC%8C%E6%8E%8C%E6%8F%A1%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/" data-id="cke9cjzfx0011f5raewg0ftwo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试官口中的Mybatis，工作流程、架构分层与模块划分以及缓存机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/14/%E9%9D%A2%E8%AF%95%E5%AE%98%E5%8F%A3%E4%B8%AD%E7%9A%84Mybatis%EF%BC%8C%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E3%80%81%E6%9E%B6%E6%9E%84%E5%88%86%E5%B1%82%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86%E4%BB%A5%E5%8F%8A%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" class="article-date">
  <time datetime="2020-05-14T08:30:35.000Z" itemprop="datePublished">2020-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/14/%E9%9D%A2%E8%AF%95%E5%AE%98%E5%8F%A3%E4%B8%AD%E7%9A%84Mybatis%EF%BC%8C%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E3%80%81%E6%9E%B6%E6%9E%84%E5%88%86%E5%B1%82%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86%E4%BB%A5%E5%8F%8A%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/">面试官口中的Mybatis，工作流程、架构分层与模块划分以及缓存机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在我们平时的业务开发中，经常会使用“半自动化”的ORM框架Mybatis解决程序对数据库操作问题。MyBatis是一个Java持久化框架，它通过XML描述符或注解把对象与存储过程或SQL语句关联起来。MyBatis是在Apache许可证2.0下分发的自由软件，是iBATIS 3.0的分支版本。2001年开始开发的，是“internet”和“abtis（障碍物）”两个单词的组合。2004年捐赠给Apache，2010年更名为MyBatis。</p>
<p>对于MyBatis在java程序中的使用想必大家一定都比较清楚了，这里主要说说它的工作流程、架构分层与模块划分以及缓存机制。</p>
<h1 id="一、MyBatis的工作流程"><a href="#一、MyBatis的工作流程" class="headerlink" title="一、MyBatis的工作流程"></a>一、MyBatis的工作流程</h1><h2 id="1-1-解析配置文件（Configuration）"><a href="#1-1-解析配置文件（Configuration）" class="headerlink" title="1.1 解析配置文件（Configuration）"></a>1.1 解析配置文件（Configuration）</h2><p>mybatis启动的时候需要解析配置文件，包括全局配置文件和映射器配置文件，我们会把它们解析成一个Configuration对象。它包含了控制mybatis的行为以及对数据库下达的指令（SQL操作）。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720cadf26dc0fb1?w=1170&h=684&f=png&s=60901" alt=""></p>
<h2 id="1-2-提供操作接口（SqlSession）"><a href="#1-2-提供操作接口（SqlSession）" class="headerlink" title="1.2 提供操作接口（SqlSession）"></a>1.2 提供操作接口（SqlSession）</h2><p>应用程序与数据库进行连接是通过<strong>SqlSession</strong>对象完成的，如果需要获取一个会话，则需要通过会话工厂<strong>SqlSessionFactory</strong>接口来获取。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720cb4d24765ed0?w=903&h=723&f=png&s=45946" alt=""></p>
<p>通过建造者模式<strong>SqlSessionFactoryBuilder</strong>来创建一个工厂类，它包含所有配置文件的配置信息。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720cbae2332dcc2?w=1275&h=759&f=png&s=77410" alt=""></p>
<p><strong>SqlSession</strong>只是提供了一个接口，它还不是真正的操作数据库的SQL执行对象。</p>
<h2 id="1-3-执行SQL操作"><a href="#1-3-执行SQL操作" class="headerlink" title="1.3 执行SQL操作"></a>1.3 执行SQL操作</h2><p><strong>Executor</strong>接口用来封装对数据库的操作。调用其中query和update接口会创建一系列的对象，来处理参数、执行SQL、处理结果集，把它简化成一个对象接口就是<strong>StatementHandler</strong>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720cc5c5fe3bacd?w=1272&h=774&f=png&s=71911" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720cc6901975614?w=1044&h=660&f=png&s=41739" alt=""></p>
<p>简要的画一下MyBatis的工作流程图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720cf3d66fbec46?w=1008&h=1113&f=jpeg&s=102937" alt=""></p>
<h1 id="二、MyBatis的架构分层与模块划分"><a href="#二、MyBatis的架构分层与模块划分" class="headerlink" title="二、MyBatis的架构分层与模块划分"></a>二、MyBatis的架构分层与模块划分</h1><p>我们打开Mybatis的package，发现类似下面的结构：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720cd789fedb487?w=426&h=762&f=png&s=33468" alt=""><br>按照不同的功能职责，也可以分成不同的工作层次。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720cf2c68d193ce?w=1236&h=708&f=jpeg&s=190304" alt=""></p>
<h1 id="三、MyBatis的缓存"><a href="#三、MyBatis的缓存" class="headerlink" title="三、MyBatis的缓存"></a>三、MyBatis的缓存</h1><h2 id="3-1-缓存体系结构"><a href="#3-1-缓存体系结构" class="headerlink" title="3.1 缓存体系结构"></a>3.1 缓存体系结构</h2><p>Mybatis缓存的默认实现是<strong>PerpetualCache</strong>类，它是基于HashMap实现的。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720d014edda20f5?w=915&h=765&f=png&s=50014" alt=""></p>
<p><strong>PerpetualCache</strong>在Mybatis是基础缓存，但是缓存有额外的功能，比如策略回收、日志记录、定时刷新等等，如果需要使用这些功能，那么需要在基础缓存的基础上进行添加，需要的时候添加，不需要即可不用添加。在缓存cache包下，有很多装饰器模式的类实现了Cache接口，通过这些实现类可以实现很多缓存额外的功能。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720d0db0ca3a36b?w=1758&h=225&f=png&s=19663" alt=""></p>
<p>所有的缓存实现总体上可以分为三大类：基本缓存、淘汰算法缓存、装饰器缓存。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720d13d5a5214ef?w=1326&h=822&f=png&s=163943" alt=""></p>
<h2 id="3-2-一级缓存（Local-Cache）"><a href="#3-2-一级缓存（Local-Cache）" class="headerlink" title="3.2 一级缓存（Local Cache）"></a>3.2 一级缓存（Local Cache）</h2><p>Mybatis的一级缓存是存放在会话（<strong>SqlSession</strong>）层面的，一级缓存是默认开启的，不需要额外的配置，关闭的话设置<strong>localCacheScope</strong>的值为<strong>STATEMENT</strong>。源码的位置在<strong>BaseExecutor</strong>中，如下图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720d5285b143b74?w=1071&h=294&f=png&s=22388" alt=""><br>如果需要在同一个会话共享一级缓存的话，那么最好的办法是在SqlSession内创建会话对象，让其成为SqlSession的一个属性，这样的话就很方便的操作一级缓存了。在同一个会话里多次执行相同的SQL语句，会直接从内存拿到缓存的结果集，不会再去数据库进行操作。如果在不同的会话中，即使SQL语句一模一样，也不会使用一级缓存的。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720d77581caeddf?w=1113&h=448&f=jpeg&s=59003" alt=""></p>
<p><strong>一级缓存的验证方式</strong></p>
<p>判断是否命中缓存？如果第二次发送SQL并且到数据库中执行，则说明没有命中缓存；如果直接打印对象，则说明是从内存中获取到的结果。</p>
<p>测试一级缓存需要先关闭二级缓存，将<strong>LocalCacheScope</strong>设置为<strong>SESSION</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void testCache() throws IOException &#123;</span><br><span class="line">    String resource &#x3D; &quot;mybatis-config.xml&quot;;</span><br><span class="line">    InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);</span><br><span class="line">    SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">    SqlSession session1 &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">    SqlSession session2 &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;在同一个session中共享</span><br><span class="line">        BlogMapper mapper0 &#x3D; session1.getMapper(BlogMapper.class);</span><br><span class="line">        BlogMapper mapper1 &#x3D; session1.getMapper(BlogMapper.class);</span><br><span class="line">        Blog blog &#x3D; mapper0.selectBlogById(1);</span><br><span class="line">        System.out.println(blog);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;第二次查询，相同会话，获取到缓存了吗？&quot;);</span><br><span class="line">        System.out.println(mapper1.selectBlogById(1));</span><br><span class="line">        &#x2F;&#x2F;不同的session不能共享</span><br><span class="line">        System.out.println(&quot;第三次查询，不同会话，获取到缓存了吗？&quot;);</span><br><span class="line">        BlogMapper mapper2 &#x3D; session2.getMapper(BlogMapper.class);</span><br><span class="line">        System.out.println(mapper2.selectBlogById(1));</span><br><span class="line"></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        session1.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一级缓存在什么时候被清空失效的呢？<strong>在同一个session中update（包括delete）会导致一级缓存被清空。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void testCacheInvalid() throws IOException &#123;</span><br><span class="line">    String resource &#x3D; &quot;mybatis-config.xml&quot;;</span><br><span class="line">    InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);</span><br><span class="line">    SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">    SqlSession session &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">    try &#123;</span><br><span class="line">        BlogMapper mapper &#x3D; session.getMapper(BlogMapper.class);</span><br><span class="line">        System.out.println(mapper.selectBlogById(1));</span><br><span class="line"></span><br><span class="line">        Blog blog &#x3D; new Blog();</span><br><span class="line">        blog.setBid(1);</span><br><span class="line">        blog.setName(&quot;after modified 666&quot;);</span><br><span class="line">        mapper.updateByPrimaryKey(blog);</span><br><span class="line">        session.commit();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 相同会话执行了更新操作，缓存是否被清空？</span><br><span class="line">        System.out.println(&quot;在[同一个会话]执行更新操作之后，是否命中缓存？&quot;);</span><br><span class="line">        System.out.println(mapper.selectBlogById(1));</span><br><span class="line"></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一级缓存的工作范围是一个session中，如果跨session会出现什么问题呢？<strong>如果其它的session更新了数据，会导致读取到过时的数据（一级缓存不能跨session共享）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void testDirtyRead() throws IOException &#123;</span><br><span class="line">    String resource &#x3D; &quot;mybatis-config.xml&quot;;</span><br><span class="line">    InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);</span><br><span class="line">    SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">    SqlSession session1 &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">    SqlSession session2 &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">    try &#123;</span><br><span class="line">        BlogMapper mapper1 &#x3D; session1.getMapper(BlogMapper.class);</span><br><span class="line">        System.out.println(mapper1.selectBlogById(1));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 会话2更新了数据，会话2的一级缓存更新</span><br><span class="line">        Blog blog &#x3D; new Blog();</span><br><span class="line">        blog.setBid(1);</span><br><span class="line">        blog.setName(&quot;after modified 333333333333333333&quot;);</span><br><span class="line">        BlogMapper mapper2 &#x3D; session2.getMapper(BlogMapper.class);</span><br><span class="line">        mapper2.updateByPrimaryKey(blog);</span><br><span class="line">        session2.commit();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 其他会话更新了数据，本会话的一级缓存还在么？</span><br><span class="line">        System.out.println(&quot;会话1查到最新的数据了吗？&quot;);</span><br><span class="line">        System.out.println(mapper1.selectBlogById(1));</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        session1.close();</span><br><span class="line">        session2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一级缓存的不足之处</strong></p>
<p>一级缓存不能跨会话共享，不同的会话之间对于相同的数据可能有不同的缓存。在分布式环境（多会话）下，会存在查询到过时的数据的情况。如果有解决这个问题，那么需要引进工作范围更为广发的二级缓存。</p>
<h2 id="3-3-二级缓存"><a href="#3-3-二级缓存" class="headerlink" title="3.3 二级缓存"></a>3.3 二级缓存</h2><p>二级缓存的生命周期和应用同步，它是用来解决一级缓存不能跨会话共享数据的问题，范围是namespace级别的，可以被多个会话共享（只要是同一个接口的相同方法，都可以进行共享）。</p>
<p><strong>二级缓存的流程图：</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720e94cf8cced21?w=1113&h=601&f=jpeg&s=83476" alt=""></p>
<p>一级缓存是默认开始的，二级缓存如何开启呢？<br>1、在mybatis-config.xml中配置（默认是true）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 控制全局缓存（二级缓存），默认 true--&gt;</span><br><span class="line">&lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>只要没有显式地设置cacheEnabled为false，都会使用CachingExector装饰基本的执行器（SIMPLE、REUSE、BATCH）。<br><strong>二级缓存总是默认开启的，但是每个Mapper的二级开关是默认关闭的。</strong></p>
<p>2、在Mapper中配置cache标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 声明这个namespace使用二级缓存 --&gt;</span><br><span class="line">&lt;cache type&#x3D;&quot;org.apache.ibatis.cache.impl.PerpetualCache&quot;</span><br><span class="line">   size&#x3D;&quot;1024&quot;&lt;!-- 最多缓存对象个数，默认是1024 --&gt;</span><br><span class="line">   eviction&#x3D;&quot;LRU&quot;&lt;!-- 缓存策略 --&gt;</span><br><span class="line">   flushInterval&#x3D;&quot;120000&quot;&lt;!-- 自动刷新时间ms，未配置是只有调用时刷新 --&gt;</span><br><span class="line">   readOnly&#x3D;&quot;false&quot;&#x2F;&gt;&lt;!-- 默认是false（安全），改为true可读写时，对象必须支持序列化 --&gt;</span><br></pre></td></tr></table></figure>
<p><strong>Cache属性详解：</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720ebad5c692f36?w=1160&h=432&f=png&s=94894" alt=""></p>
<p>默认的回收内存策略是 LRU。可用的内存回收策略有：</p>
<ul>
<li>LRU – 最近最少使用：移除最长时间不被使用的对象。</li>
<li>FIFO – 先进先出：按对象进入缓存的顺序来移除它们。</li>
<li>SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。</li>
<li>WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。</li>
</ul>
<p>Mapper.xml 配置了cache之后，select()会被缓存。update()、delete()、insert()会刷新缓存。：如果cacheEnabled=true，Mapper.xml 没有配置标签，还有二级缓存吗？（没有）还会出现CachingExecutor 包装对象吗？（会）</p>
<p>只要cacheEnabled=true基本执行器就会被装饰。有没有配置cache，决定了在启动的时候会不会创建这个mapper的Cache对象，只是最终会影响到CachingExecutorquery 方法里面的判断。如果某些查询方法对数据的实时性要求很高，不需要二级缓存，怎么办？我们可以在单个Statement ID 上显式关闭二级缓存（默认是true）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;selectBlog&quot; resultMap&#x3D;&quot;BaseResultMap&quot; useCache&#x3D;&quot;false&quot;&gt;</span><br></pre></td></tr></table></figure>
<p><strong>二级缓存的验证方式</strong></p>
<p>1、事务不提交，二级缓存会写入吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void testCache() throws IOException &#123;</span><br><span class="line">    String resource &#x3D; &quot;mybatis-config.xml&quot;;</span><br><span class="line">    InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);</span><br><span class="line">    SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">    SqlSession session1 &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">    SqlSession session2 &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">    try &#123;</span><br><span class="line">        BlogMapper mapper1 &#x3D; session1.getMapper(BlogMapper.class);</span><br><span class="line">        System.out.println(mapper1.selectBlogById(1));</span><br><span class="line">        &#x2F;&#x2F; 事务不提交的情况下，二级缓存会写入吗？显然不会，为什么呢？</span><br><span class="line">        session1.commit();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;第二次查询&quot;);</span><br><span class="line">        BlogMapper mapper2 &#x3D; session2.getMapper(BlogMapper.class);</span><br><span class="line">        System.out.println(mapper2.selectBlogById(1));</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        session1.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为什么事务不提交，二级缓存不生效呢？</strong><br>因为二级缓存使用<strong>TransactionalCacheManager</strong>（TCM）来管理，最后又调用了TransactionalCache 的getObject()、putObject和commit()方法，TransactionalCache里面又持有了真正的Cache对象，比如是经过层层装饰的<strong>PerpetualCache</strong>。在putObject 的时候，只是添加到了entriesToAddOnCommit里面，<strong>只有它的commit()方法被调用的时候才会调用flushPendingEntries()真正写入缓存</strong>。它就是在<strong>DefaultSqlSession</strong> 调用<strong>commit</strong>()的时候被调用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void commit() &#123;</span><br><span class="line">    if (clearOnCommit) &#123;</span><br><span class="line">      delegate.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 真正写入二级缓存</span><br><span class="line">    flushPendingEntries();</span><br><span class="line">    reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void flushPendingEntries() &#123;</span><br><span class="line">   for (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) &#123;</span><br><span class="line">     delegate.putObject(entry.getKey(), entry.getValue());</span><br><span class="line">   &#125;</span><br><span class="line">   for (Object entry : entriesMissedInCache) &#123;</span><br><span class="line">     if (!entriesToAddOnCommit.containsKey(entry)) &#123;</span><br><span class="line">       delegate.putObject(entry, null);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在其它的会话中执行增删改操作，验证缓存被刷新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public void testCacheInvalid() throws IOException &#123;</span><br><span class="line">    String resource &#x3D; &quot;mybatis-config.xml&quot;;</span><br><span class="line">    InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);</span><br><span class="line">    SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">    SqlSession session1 &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">    SqlSession session2 &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">    SqlSession session3 &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">    try &#123;</span><br><span class="line">        BlogMapper mapper1 &#x3D; session1.getMapper(BlogMapper.class);</span><br><span class="line">        BlogMapper mapper2 &#x3D; session2.getMapper(BlogMapper.class);</span><br><span class="line">        BlogMapper mapper3 &#x3D; session3.getMapper(BlogMapper.class);</span><br><span class="line">        System.out.println(mapper1.selectBlogById(1));</span><br><span class="line">        session1.commit();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 是否命中二级缓存</span><br><span class="line">        System.out.println(&quot;是否命中二级缓存？&quot;);</span><br><span class="line">        System.out.println(mapper2.selectBlogById(1));</span><br><span class="line"></span><br><span class="line">        Blog blog &#x3D; new Blog();</span><br><span class="line">        blog.setBid(1);</span><br><span class="line">        blog.setName(&quot;2020年5月13日15:03:38&quot;);</span><br><span class="line">        mapper3.updateByPrimaryKey(blog);</span><br><span class="line">        session3.commit();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;更新后再次查询，是否命中二级缓存？&quot;);</span><br><span class="line">        &#x2F;&#x2F; 在其他会话中执行了更新操作，二级缓存是否被清空？</span><br><span class="line">        System.out.println(mapper2.selectBlogById(1));</span><br><span class="line"></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        session1.close();</span><br><span class="line">        session2.close();</span><br><span class="line">        session3.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么增删改操作会清空缓存？</strong><br>在<strong>CachingExecutor</strong>的update()方法里面会调用flushCacheIfRequired(ms)，<strong>isFlushCacheRequired</strong> 就是从标签里面渠道的flushCache 的值。而增删改操作的<strong>flushCache</strong> 属性默认为true。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void flushCacheIfRequired(MappedStatement ms) &#123;</span><br><span class="line">    Cache cache &#x3D; ms.getCache();</span><br><span class="line">    &#x2F;&#x2F; 增删改查的标签上有属性：flushCache&#x3D;&quot;true&quot; （select语句默认是false）</span><br><span class="line">    &#x2F;&#x2F; 一级二级缓存都会被清理</span><br><span class="line">    if (cache !&#x3D; null &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">      tcm.clear(cache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>什么时候开启二级缓存呢？</strong></p>
<p>一级缓存默认是打开的，二级缓存需要配置才可以开启。那么我们必须思考一个问题，在什么情况下才有必要去开启二级缓存？</p>
<p>因为所有的增删改都会刷新二级缓存，导致二级缓存失效，所以适合在查询为主的应用中使用，比如历史交易、历史订单的查询。否则缓存就失去了意义。如果多个namespace 中有针对于同一个表的操作，如果在一个namespace中刷新了缓存，另一个namespace中没有刷新，就会出现读到脏数据的情况。所以，推荐在一个Mapper 里面只操作单表的情况使用。如果要让多个namespace共享一个二级缓存，应该怎么做？跨namespace的缓存共享的问题，可以使用cache-ref配置来解决：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;cache-ref namespace&#x3D;&quot;com.sy.crud.dao.DepartmentMapper&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>　　cache-ref 代表引用别的命名空间的Cache配置，两个命名空间的操作使用的是同一个Cache。在关联的表比较少，或者按照业务可以对表进行分组的时候可以使用。</p>
<p>注意：在这种情况下，多个Mapper的操作都会引起缓存刷新，缓存的意义已经不大了</p>
<p><strong>第三方缓存做二级缓存</strong></p>
<p>除了MyBatis 自带的二级缓存之外，我们也可以通过实现Cache 接口来自定义二级缓存。MyBatis官方提供了一些第三方缓存集成方式，比如ehcache 和redis：</p>
<p><a href="https://github.com/mybatis/redis-cache" target="_blank" rel="noopener">https://github.com/mybatis/redis-cache</a> </p>
<p>当然，我们也可以使用独立的缓存服务，不使用MyBatis 自带的二级缓存。</p>
<p>pom文件引入的依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.caches&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0.0-beta2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<p>mapper.xml配置文件的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用Redis作为二级缓存 --&gt;</span><br><span class="line">   &lt;cache type&#x3D;&quot;org.mybatis.caches.redis.RedisCache&quot;</span><br><span class="line">          eviction&#x3D;&quot;FIFO&quot; flushInterval&#x3D;&quot;60000&quot; size&#x3D;&quot;512&quot; readOnly&#x3D;&quot;true&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>redis.properties配置文件内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">host&#x3D;localhost</span><br><span class="line">port&#x3D;6379</span><br><span class="line">connectionTimeout&#x3D;5000</span><br><span class="line">soTimeout&#x3D;5000</span><br><span class="line">database&#x3D;0</span><br></pre></td></tr></table></figure>

<p>当然，我们在分布式的环境中，也可以使用独立的缓存服务，不使用MyBatis自带的二级缓存。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/05/14/%E9%9D%A2%E8%AF%95%E5%AE%98%E5%8F%A3%E4%B8%AD%E7%9A%84Mybatis%EF%BC%8C%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E3%80%81%E6%9E%B6%E6%9E%84%E5%88%86%E5%B1%82%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86%E4%BB%A5%E5%8F%8A%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" data-id="cke9cjzee000yf5ra0lsk7wvt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/25/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E7%9A%84%E7%8E%8B%E8%80%85Apache-Atlas%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84API/">数据治理的王者Apache-Atlas如何构建自己的API</a>
          </li>
        
          <li>
            <a href="/2020/07/26/CountDownLatch%E3%80%81Semaphore%E3%80%81CyclicBarrier%E3%80%81Condition%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">CountDownLatch、Semaphore、CyclicBarrier、Condition源码分析</a>
          </li>
        
          <li>
            <a href="/2020/07/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86SpringBoot%EF%BC%8C%E6%8E%8C%E6%8F%A1%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/">微服务核心重新认识SpringBoot，掌握核心特性及设计思想</a>
          </li>
        
          <li>
            <a href="/2020/06/26/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B3%E4%BA%8E%E9%94%81%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%8CReentantLock%E7%9A%84%E5%BA%95%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/">JAVA并发编程关于锁的那些事，ReentantLock的底层设计深入浅出</a>
          </li>
        
          <li>
            <a href="/2020/06/20/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E7%AF%87%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">JAVA并发编程阶段总结篇，解决死锁问题以及ThreadLocal原理分析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Kevin Shaw<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>