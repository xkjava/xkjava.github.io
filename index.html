<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>来一杯咖啡</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="互联网Java体系平台架构，分布式系统，中间件技术等">
<meta property="og:type" content="website">
<meta property="og:title" content="来一杯咖啡">
<meta property="og:url" content="https://xkjava.github.io/index.html">
<meta property="og:site_name" content="来一杯咖啡">
<meta property="og:description" content="互联网Java体系平台架构，分布式系统，中间件技术等">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Kevin Shaw">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="Netty">
<meta property="article:tag" content="Kafka...">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="来一杯咖啡" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">来一杯咖啡</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">互联网技术无边界，学习与交流</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://xkjava.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-JAVA并发编程揭开篇章，并发编程基本认识，了解多线程意义和使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/18/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%8F%AD%E5%BC%80%E7%AF%87%E7%AB%A0%EF%BC%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86%EF%BC%8C%E4%BA%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%84%8F%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/" class="article-date">
  <time datetime="2020-05-18T09:57:37.000Z" itemprop="datePublished">2020-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/18/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%8F%AD%E5%BC%80%E7%AF%87%E7%AB%A0%EF%BC%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86%EF%BC%8C%E4%BA%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%84%8F%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/">JAVA并发编程揭开篇章，并发编程基本认识，了解多线程意义和使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>多线程</strong>（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括对称多处理机、多核心处理器以及芯片级多处理（Chip-level multithreading）或同时多线程（Simultaneous multithreading）处理器。</p>
<h1 id="一、什么是线程"><a href="#一、什么是线程" class="headerlink" title="一、什么是线程"></a>一、什么是线程</h1><p><strong>线程</strong>（thread）是操作系统能够进行运算调度的最小单位。大部分情况下，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。</p>
<p>线程是独立调度和分派的基本单位。线程可以为操作系统内核调度的内核线程，如Win32线程；由用户进程自行调度的用户线程，如Linux平台的POSIX Thread；或者由内核与用户进程，如Windows 10的线程，进行混合调度。</p>
<p>同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。</p>
<p><strong>一个进程可以有很多线程，每条线程并行执行不同的任务。</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/17/172209a9816e933b?w=1280&h=795&f=png&s=2278208" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/5/17/172209dc54329651?w=960&h=640&f=png&s=1405727" alt=""></p>
<h1 id="二、什么是并发"><a href="#二、什么是并发" class="headerlink" title="二、什么是并发"></a>二、什么是并发</h1><p>并发，在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。</p>
<p>举个例子，简单来说并发是指单位时间内能够同时处理的请求数。默认情况下Tomcat可以支持的最大请求数是150，也就是同时支持150个并发。当超过这个并发数的时候，就会开始导致响应延迟，连接丢失等问题。</p>
<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>并行是指两个或者多个事件在同一时刻发生；</p>
<p>并发是指两个或多个事件在同一时间间隔内发生，这个词可以冲宏观和微观两个层面来讲，如果从微观角度来看。以线程为例，假设当前电脑的cpu是单核，但是能不能支持多线程呢？当然也是能的，此时如果是多线程运行的话，那么CPU是通过不断分配时间片的方式来实现线程切换，由于切换的速度足够快，我们很难感知到卡顿的过程。</p>
<h1 id="三、Java中的线程"><a href="#三、Java中的线程" class="headerlink" title="三、Java中的线程"></a>三、Java中的线程</h1><h2 id="3-1-Runnable-接口"><a href="#3-1-Runnable-接口" class="headerlink" title="3.1 Runnable 接口"></a>3.1 Runnable 接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends OtherClass implements Runnable &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;MyThread.run()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-Thread-类"><a href="#3-2-Thread-类" class="headerlink" title="3.2 Thread 类"></a>3.2 Thread 类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">    System.out.println(&quot;MyThread.run()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    MyThread myThread1 &#x3D; new MyThread();</span><br><span class="line">    MyThread myThread2 &#x3D; new MyThread();</span><br><span class="line">    myThread1.start();</span><br><span class="line">    myThread2.start();</span><br></pre></td></tr></table></figure>
<h2 id="3-3-Callable-Future-带返回值的"><a href="#3-3-Callable-Future-带返回值的" class="headerlink" title="3.3 Callable/Future 带返回值的"></a>3.3 Callable/Future 带返回值的</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class CallableDemo implements Callable&lt;String&gt; &#123;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newFixedThreadPool (1);</span><br><span class="line">        CallableDemo callableDemo &#x3D; new CallableDemo();</span><br><span class="line">        Future&lt;String&gt; future &#x3D; executorService.submit(callableDemo);</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        int a &#x3D; 1;</span><br><span class="line">        int b &#x3D; 2;</span><br><span class="line">        System.out.println(a + b);</span><br><span class="line">        return &quot;执行结果:&quot; + (a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、-多线程的应用场景"><a href="#四、-多线程的应用场景" class="headerlink" title="四、 多线程的应用场景"></a>四、 多线程的应用场景</h1><ul>
<li>网络请求分发的场景</li>
<li>文件导入</li>
<li>短信发送场景</li>
</ul>
<h1 id="五、-Java并发编程基础"><a href="#五、-Java并发编程基础" class="headerlink" title="五、 Java并发编程基础"></a>五、 Java并发编程基础</h1><h2 id="5-1-线程的生命周期"><a href="#5-1-线程的生命周期" class="headerlink" title="5.1 线程的生命周期"></a>5.1 线程的生命周期</h2><p>Java线程一共有 6 种状态（<strong>NEW、RUNNABLE、BLOCKED、WAITING、TIME_WAITING、TERMINATED</strong>）</p>
<ul>
<li>NEW：初始状态，线程被构建，但是还没有调用 <strong>start</strong>()方法；</li>
<li>RUNNABLE：运行状态，JAVA线程把操作系统中的就绪和运行两种状态统一称为“运行中”</li>
<li>BLOCK：阻塞状态，表示线程进入等待状态,也就是线程因为某种原因放弃了 CPU 使用权，阻塞也分为几种情况：</li>
</ul>
<p>➢ 等待阻塞：运行的线程执行 wait 方法，jvm 会把当前线程放入到等待队列</p>
<p>➢ 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被其他线程锁占用了，那么 jvm 会把当前的线程放入到锁池中</p>
<p>➢ 其他阻塞：运行的线程执行 Thread.sleep 或者 t.join 方法，或者发出了 I/O 请求时，JVM 会把当前线程设置为阻塞状态，当 sleep 结束、join 线程终止、io 处理完毕则线程恢复</p>
<ul>
<li>WAITING：正在无限期等待另一个线程执行状态，需要唤醒</li>
<li>TIME_WAITING：超时等待状态，超时以后自动返回</li>
<li>TERMINATED：终止状态，表示当前线程执行完毕</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/18/17225f1a457b93a5?w=1204&h=1014&f=jpeg&s=128924" alt=""></p>
<h2 id="5-2-线程的启动"><a href="#5-2-线程的启动" class="headerlink" title="5.2 线程的启动"></a>5.2 线程的启动</h2><p>启动线程的两种方式：</p>
<ul>
<li>new Thread().start();//启动一个线程</li>
<li>Thread thread = new Thread(); thread.run();//调用实例中的方法</li>
</ul>
<p>启动线程是调用<strong>start</strong>()方法，而不是<strong>run</strong>()方法，我们来看下<strong>Thread</strong>类中的<strong>start</strong>()方法源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line">    &#x2F;* Make sure registerNatives is the first thing &lt;clinit&gt; does. *&#x2F;</span><br><span class="line">    private static native void registerNatives();</span><br><span class="line">    static &#123;</span><br><span class="line">        registerNatives();&#x2F;&#x2F;start0()方法是在此方法中注册的</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public synchronized void start() &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * This method is not invoked for the main method thread or &quot;system&quot;</span><br><span class="line">         * group threads created&#x2F;set up by the VM. Any new functionality added</span><br><span class="line">         * to this method in the future may have to also be added to the VM.</span><br><span class="line">         *</span><br><span class="line">         * A zero status value corresponds to state &quot;NEW&quot;.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        if (threadStatus !&#x3D; 0)</span><br><span class="line">            throw new IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">        &#x2F;* Notify the group that this thread is about to be started</span><br><span class="line">         * so that it can be added to the group&#39;s list of threads</span><br><span class="line">         * and the group&#39;s unstarted count can be decremented. *&#x2F;</span><br><span class="line">        group.add(this);</span><br><span class="line"></span><br><span class="line">        boolean started &#x3D; false;</span><br><span class="line">        try &#123;</span><br><span class="line">            start0();&#x2F;&#x2F;实体调用的是这个方法，它是native的</span><br><span class="line">            started &#x3D; true;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(this);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Throwable ignore) &#123;</span><br><span class="line">                &#x2F;* do nothing. If start0 threw a Throwable then</span><br><span class="line">                  it will be passed up the call stack *&#x2F;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private native void start0();&#x2F;&#x2F;调用C++中的start0()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>start0</strong>()方法注册在<strong>registerNatives</strong>()中，<strong>registerNatives</strong>的本地方法定义在<strong>Thread.c</strong>中，<strong>Thread.c</strong>定义了各个操作系统平台要用的关于线程的公共数据和操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static JNINativeMethod methods[] &#x3D; &#123;</span><br><span class="line">    &#123;&quot;start0&quot;,           &quot;()V&quot;,        (void *)&amp;JVM_StartThread&#125;,</span><br><span class="line">    &#123;&quot;stop0&quot;,            &quot;(&quot; OBJ &quot;)V&quot;, (void *)&amp;JVM_StopThread&#125;,</span><br><span class="line">    &#123;&quot;isAlive&quot;,          &quot;()Z&quot;,        (void *)&amp;JVM_IsThreadAlive&#125;,</span><br><span class="line">    &#123;&quot;suspend0&quot;,         &quot;()V&quot;,        (void *)&amp;JVM_SuspendThread&#125;,</span><br><span class="line">    &#123;&quot;resume0&quot;,          &quot;()V&quot;,        (void *)&amp;JVM_ResumeThread&#125;,</span><br><span class="line">    &#123;&quot;setPriority0&quot;,     &quot;(I)V&quot;,       (void *)&amp;JVM_SetThreadPriority&#125;,</span><br><span class="line">    &#123;&quot;yield&quot;,            &quot;()V&quot;,        (void *)&amp;JVM_Yield&#125;,</span><br><span class="line">    &#123;&quot;sleep&quot;,            &quot;(J)V&quot;,       (void *)&amp;JVM_Sleep&#125;,</span><br><span class="line">    &#123;&quot;currentThread&quot;,    &quot;()&quot; THD,     (void *)&amp;JVM_CurrentThread&#125;,</span><br><span class="line">    &#123;&quot;countStackFrames&quot;, &quot;()I&quot;,        (void *)&amp;JVM_CountStackFrames&#125;,</span><br><span class="line">    &#123;&quot;interrupt0&quot;,       &quot;()V&quot;,        (void *)&amp;JVM_Interrupt&#125;,</span><br><span class="line">    &#123;&quot;isInterrupted&quot;,    &quot;(Z)Z&quot;,       (void *)&amp;JVM_IsInterrupted&#125;,</span><br><span class="line">    &#123;&quot;holdsLock&quot;,        &quot;(&quot; OBJ &quot;)Z&quot;, (void *)&amp;JVM_HoldsLock&#125;,</span><br><span class="line">    &#123;&quot;getThreads&quot;,        &quot;()[&quot; THD,   (void *)&amp;JVM_GetAllThreads&#125;,</span><br><span class="line">    &#123;&quot;dumpThreads&quot;,      &quot;([&quot; THD &quot;)[[&quot; STE, (void *)&amp;JVM_DumpThreads&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#undef THD</span><br><span class="line">#undef OBJ</span><br><span class="line">#undef STE</span><br><span class="line"></span><br><span class="line">JNIEXPORT void JNICALL</span><br><span class="line">Java_java_lang_Thread_registerNatives(JNIEnv *env, jclass cls)</span><br><span class="line">&#123;</span><br><span class="line">    (*env)-&gt;RegisterNatives(env, cls, methods, ARRAY_LENGTH(methods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>start0</strong>()实际上在C++中真正的执行的是<strong>JVM_StartThread</strong>方法，这个方法是在<strong>JVM</strong>层面执行的方法，这样需要下载<strong>hotspot</strong>的源码才能找到答案，我们接着找。在<strong>jvm.cpp</strong>文件中找到如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread))</span><br><span class="line">  JVMWrapper(&quot;JVM_StartThread&quot;);</span><br><span class="line">  JavaThread *native_thread &#x3D; NULL;</span><br></pre></td></tr></table></figure>
<p>再在<strong>thread.cpp</strong>中<strong>JavaThread</strong>相关的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz) :</span><br><span class="line">  Thread()</span><br><span class="line">#if INCLUDE_ALL_GCS</span><br><span class="line">  , _satb_mark_queue(&amp;_satb_mark_queue_set),</span><br><span class="line">  _dirty_card_queue(&amp;_dirty_card_queue_set)</span><br><span class="line">#endif &#x2F;&#x2F; INCLUDE_ALL_GCS</span><br><span class="line">&#123;</span><br><span class="line">  if (TraceThreadEvents) &#123;</span><br><span class="line">    tty-&gt;print_cr(&quot;creating thread %p&quot;, this);</span><br><span class="line">  &#125;</span><br><span class="line">  initialize();</span><br><span class="line">  _jni_attach_state &#x3D; _not_attaching_via_jni;</span><br><span class="line">  set_entry_point(entry_point);</span><br><span class="line">  &#x2F;&#x2F; Create the native thread itself.</span><br><span class="line">  &#x2F;&#x2F; %note runtime_23</span><br><span class="line">  os::ThreadType thr_type &#x3D; os::java_thread;</span><br><span class="line">  thr_type &#x3D; entry_point &#x3D;&#x3D; &amp;compiler_thread_entry ? os::compiler_thread :</span><br><span class="line">                                                     os::java_thread;</span><br><span class="line">  os::create_thread(this, thr_type, stack_sz);</span><br><span class="line">  _safepoint_visible &#x3D; false;</span><br><span class="line">  &#x2F;&#x2F; The _osthread may be NULL here because we ran out of memory (too many threads active).</span><br><span class="line">  &#x2F;&#x2F; We need to throw and OutOfMemoryError - however we cannot do this here because the caller</span><br><span class="line">  &#x2F;&#x2F; may hold a lock and all locks must be unlocked before throwing the exception (throwing</span><br><span class="line">  &#x2F;&#x2F; the exception consists of creating the exception object &amp; initializing it, initialization</span><br><span class="line">  &#x2F;&#x2F; will leave the VM via a JavaCall and then all locks must be unlocked).</span><br><span class="line">  &#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F; The thread is still suspended when we reach here. Thread must be explicit started</span><br><span class="line">  &#x2F;&#x2F; by creator! Furthermore, the thread must also explicitly be added to the Threads list</span><br><span class="line">  &#x2F;&#x2F; by calling Threads:add. The reason why this is not done here, is because the thread</span><br><span class="line">  &#x2F;&#x2F; object must be fully initialized (take a look at JVM_Start)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>os::create_thread</strong> 就是调用系统创建线程的方法来<strong>创建java线程</strong>。创建完线程之后就来启动线程。启动线程调用<strong>Thread.cpp</strong>的<strong>Thread::start(Thread* thread)</strong> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void Thread::start(Thread* thread) &#123;</span><br><span class="line">  trace(&quot;start&quot;, thread);</span><br><span class="line">  &#x2F;&#x2F; Start is different from resume in that its safety is guaranteed by context or</span><br><span class="line">  &#x2F;&#x2F; being called from a Java method synchronized on the Thread object.</span><br><span class="line">  if (!DisableStartThread) &#123;</span><br><span class="line">    if (thread-&gt;is_Java_thread()) &#123;</span><br><span class="line">      &#x2F;&#x2F; Initialize the thread state to RUNNABLE before starting this thread.</span><br><span class="line">      &#x2F;&#x2F; Can not set it after the thread started because we do not know the</span><br><span class="line">      &#x2F;&#x2F; exact thread state at that time. It could be in MONITOR_WAIT or</span><br><span class="line">      &#x2F;&#x2F; in SLEEPING or some other state.</span><br><span class="line">      java_lang_Thread::set_thread_status(((JavaThread*)thread)-&gt;threadObj(),</span><br><span class="line">                                          java_lang_Thread::RUNNABLE);</span><br><span class="line">    &#125;</span><br><span class="line">    os::start_thread(thread);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用平台启动线程的方法，最终会调用<strong>Thread.cpp</strong>的<strong>JavaThread::run()</strong> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; The first routine called by a new Java thread</span><br><span class="line">void JavaThread::run() &#123;</span><br><span class="line">  &#x2F;&#x2F; initialize thread-local alloc buffer related fields</span><br><span class="line">  this-&gt;initialize_tlab();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; used to test validitity of stack trace backs</span><br><span class="line">  this-&gt;record_base_of_stack_pointer();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Record real stack base and size.</span><br><span class="line">  this-&gt;record_stack_base_and_size();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Initialize thread local storage; set before calling MutexLocker</span><br><span class="line">  this-&gt;initialize_thread_local_storage();</span><br><span class="line"></span><br><span class="line">  this-&gt;create_stack_guard_pages();</span><br><span class="line"></span><br><span class="line">  this-&gt;cache_global_variables();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Thread is now sufficient initialized to be handled by the safepoint code as being</span><br><span class="line">  &#x2F;&#x2F; in the VM. Change thread state from _thread_new to _thread_in_vm</span><br><span class="line">  ThreadStateTransition::transition_and_fence(this, _thread_new, _thread_in_vm);</span><br><span class="line"></span><br><span class="line">  assert(JavaThread::current() &#x3D;&#x3D; this, &quot;sanity check&quot;);</span><br><span class="line">  assert(!Thread::current()-&gt;owns_locks(), &quot;sanity check&quot;);</span><br><span class="line"></span><br><span class="line">  DTRACE_THREAD_PROBE(start, this);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; This operation might block. We call that after all safepoint checks for a new thread has</span><br><span class="line">  &#x2F;&#x2F; been completed.</span><br><span class="line">  this-&gt;set_active_handles(JNIHandleBlock::allocate_block());</span><br><span class="line"></span><br><span class="line">  if (JvmtiExport::should_post_thread_life()) &#123;</span><br><span class="line">    JvmtiExport::post_thread_start(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  EventThreadStart event;</span><br><span class="line">  if (event.should_commit()) &#123;</span><br><span class="line">     event.set_javalangthread(java_lang_Thread::thread_id(this-&gt;threadObj()));</span><br><span class="line">     event.commit();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; We call another function to do the rest so we are sure that the stack addresses used</span><br><span class="line">  &#x2F;&#x2F; from there will be lower than the stack base just computed</span><br><span class="line">  thread_main_inner();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Note, thread is no longer valid at this point!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后来一张图总结一下Java线程的启动：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/18/17226afc4b4063f7?w=1500&h=446&f=jpeg&s=92481" alt=""></p>
<h1 id="5-3-线程的终止"><a href="#5-3-线程的终止" class="headerlink" title="5.3 线程的终止"></a>5.3 线程的终止</h1><p>对于线程的终止并不是调用<strong>stop</strong>()方法的，在线程中提供了<strong>interrput</strong>()方法去优雅的中断一个线程。</p>
<p>下面通过一个例子来说明线程终止，调用<strong>interrupted</strong>()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class InterruptDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static int i;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread &#x3D; new Thread(()-&gt;&#123;</span><br><span class="line">            &#x2F;&#x2F;默认情况下isInterrupted 返回 false、通过 thread.interrupt 变成了 true</span><br><span class="line">            while(!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;Num:&quot;+ i);</span><br><span class="line">        &#125;,&quot;interruptDemo&quot;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <strong>interrupt</strong>()方法，设置了一个标识告诉线程可以终止了 ，线程中还提供了静态方法<strong>Thread.interrupted()对设置中断标识的线程复位</strong>。</p>
<h2 id="5-3-1-线程复位"><a href="#5-3-1-线程复位" class="headerlink" title="5.3.1 线程复位"></a>5.3.1 线程复位</h2><p>我们来改造上面示例中的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class InterruptDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static int i;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread &#x3D; new Thread(()-&gt;&#123;</span><br><span class="line">            while(true) &#123;</span><br><span class="line">                if(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(&quot;before&quot; + Thread.currentThread().isInterrupted());</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.interrupted();&#x2F;&#x2F;对线程进行复位，由true变为false</span><br><span class="line">                System.out.println(&quot;after&quot; + Thread.currentThread().isInterrupted());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;interruptDemo&quot;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了使用<strong>Thread.interrupted()</strong>的方法对线程中断标识进行复位之外，还有一种被动的复位场景，就是抛出<strong>InterruptedException</strong>异常的方法，在InterruptedException 抛出之前，JVM 会先把线程的中断标识位清除，然后才会抛出 InterruptedException，这个时候如果调用 <strong>isInterrupted</strong> 方法，将会返回 <strong>false</strong>。</p>
<h2 id="5-3-2-为什么要进行复位"><a href="#5-3-2-为什么要进行复位" class="headerlink" title="5.3.2 为什么要进行复位"></a>5.3.2 为什么要进行复位</h2><p><strong>Thread.interrupted</strong>()是属于当前线程的，是当前线程对外界中断信号的一个响应，表示自己已经得到了中断信号，但不会立刻中断自己，具体什么时候中断由自己决定，让外界知道在自身中断前，他的中断状态仍然是 false，这就是复位的原因</p>
<h2 id="5-3-3-线程的终止原理"><a href="#5-3-3-线程的终止原理" class="headerlink" title="5.3.3 线程的终止原理"></a>5.3.3 线程的终止原理</h2><p>终止线程是调用<strong>interrupt</strong>()方法，我们来看下<strong>Thread</strong>类中的<strong>interrupt</strong>()方法源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void interrupt() &#123;</span><br><span class="line">        if (this !&#x3D; Thread.currentThread())</span><br><span class="line">            checkAccess();</span><br><span class="line"></span><br><span class="line">        synchronized (blockerLock) &#123;</span><br><span class="line">            Interruptible b &#x3D; blocker;</span><br><span class="line">            if (b !&#x3D; null) &#123;</span><br><span class="line">                interrupt0();           &#x2F;&#x2F; Just to set the interrupt flag</span><br><span class="line">                b.interrupt(this);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终调用一个<strong>native</strong>的<strong>interrupt0</strong>()方法，和start0()方法一样，找到<strong>jvm.cpp</strong>中的<strong>JVM_Interrupt</strong>的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(void, JVM_Interrupt(JNIEnv* env, jobject jthread))</span><br><span class="line">  JVMWrapper(&quot;JVM_Interrupt&quot;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Ensure that the C++ Thread and OSThread structures aren&#39;t freed before we operate</span><br><span class="line">  oop java_thread &#x3D; JNIHandles::resolve_non_null(jthread);</span><br><span class="line">  MutexLockerEx ml(thread-&gt;threadObj() &#x3D;&#x3D; java_thread ? NULL : Threads_lock);</span><br><span class="line">  &#x2F;&#x2F; We need to re-resolve the java_thread, since a GC might have happened during the</span><br><span class="line">  &#x2F;&#x2F; acquire of the lock</span><br><span class="line">  JavaThread* thr &#x3D; java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread));</span><br><span class="line">  if (thr !&#x3D; NULL) &#123;</span><br><span class="line">    Thread::interrupt(thr);</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure>
<p><strong>thread.cpp</strong>中的<strong>Thread::interrupt</strong>()方法源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Thread::interrupt(Thread* thread) &#123;</span><br><span class="line">  trace(&quot;interrupt&quot;, thread);</span><br><span class="line">  debug_only(check_for_dangling_thread_pointer(thread);)</span><br><span class="line">  os::interrupt(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Thread::interrupt</strong>() 方法调用了 <strong>os::interrupt</strong>() 方法，这个是调用平台的 interrupt 方法，这个方法的实现是在 <strong>os_*.cpp</strong><br>文件中，我们以 <strong>os_linux.cpp</strong> 文件为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void os::interrupt(Thread* thread) &#123;</span><br><span class="line">  assert(Thread::current() &#x3D;&#x3D; thread || Threads_lock-&gt;owned_by_self(),</span><br><span class="line">    &quot;possibility of dangling Thread pointer&quot;);</span><br><span class="line">  &#x2F;&#x2F;获取本地线程对象</span><br><span class="line">  OSThread* osthread &#x3D; thread-&gt;osthread();</span><br><span class="line">  &#x2F;&#x2F;判断本地线程是否为中断</span><br><span class="line">  if (!osthread-&gt;interrupted()) &#123;</span><br><span class="line">    &#x2F;&#x2F;设置中断状态为true</span><br><span class="line">    osthread-&gt;set_interrupted(true);</span><br><span class="line">    &#x2F;&#x2F; More than one thread can get here with the same value of osthread,</span><br><span class="line">    &#x2F;&#x2F; resulting in multiple notifications.  We do, however, want the store</span><br><span class="line">    &#x2F;&#x2F; to interrupted() to be visible to other threads before we execute unpark().</span><br><span class="line">    &#x2F;&#x2F;内存屏障的目的是使得interrupted状态对其他线程立即可见</span><br><span class="line">    OrderAccess::fence();</span><br><span class="line">    &#x2F;&#x2F;_SleepEvent相当于Thread.sleep，表示如果线程调用了sleep方法，则通过unpark唤醒</span><br><span class="line">    ParkEvent * const slp &#x3D; thread-&gt;_SleepEvent ;</span><br><span class="line">    if (slp !&#x3D; NULL) slp-&gt;unpark() ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; For JSR166. Unpark even if interrupt status already was set</span><br><span class="line">  if (thread-&gt;is_Java_thread())</span><br><span class="line">    ((JavaThread*)thread)-&gt;parker()-&gt;unpark();</span><br><span class="line">  &#x2F;&#x2F;_ParkEvent用于synchronized同步块和Object.wait()，这里相当于也是通过unpark进行唤醒</span><br><span class="line">  ParkEvent * ev &#x3D; thread-&gt;_ParkEvent ;</span><br><span class="line">  if (ev !&#x3D; NULL) ev-&gt;unpark() ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>set_interrupted(true)</strong> 实际上就是调<strong>用osThread.hpp</strong>中的<strong>set_interrupted()</strong>方法，在 <strong>osThread</strong> 中定义了一个成员属性 <strong>volatile jint _interrupted</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">volatile jint _interrupted;     &#x2F;&#x2F; Thread.isInterrupted state</span><br><span class="line"></span><br><span class="line">void set_interrupted(bool z)                      &#123; _interrupted &#x3D; z ? 1 : 0; &#125;</span><br></pre></td></tr></table></figure>
<p><strong>thread.interrupt</strong>()方法实际就是设置一个 <strong>interrupted</strong> 状态标识为 true、并且通过<strong>ParkEvent</strong> 的 <strong>unpark</strong> 方法来唤醒线程。</p>
<ul>
<li>对于 <strong>synchronized</strong>阻塞的线程，被唤醒以后会继续尝试获取锁，如果失败仍然可能被 <strong>park</strong></li>
<li>在调用 <strong>ParkEvent</strong> 的 <strong>park</strong>方法之前，会先判断线程的中断状态，如果为 <strong>true</strong>，会清除当前线程的中断标识</li>
<li><strong>Object.wait 、 Thread.sleep、Thread.join</strong>会抛出<strong>InterruptedException</strong>，不难发现这些方法都是阻塞的。阻塞方法的释放会取决于一些外部的事件，所以<br>它允许一个线程请求自己来停止它正在做的事情。当一个方法抛出InterruptedException 时，它是在告诉调用者如果执行该方法的线程被中断，它会尝试停止正在做的事情并且通过抛出 InterruptedException 表示提前返回。</li>
</ul>
<p><strong>InterruptedException</strong>这个异常的意思是表示一个阻塞被其他线程中断了。然后，由于线程调用了 <strong>interrupt</strong>()中断方法，那么<strong>Object.wait**</strong>、Thread.sleep** 等被阻塞的线程被唤醒以后会通过<strong>is_interrupted</strong>方法判断中断标识的状态变化，如果发现中断标识为<strong>true</strong>，则先清除中断标识，然后抛<strong>出InterruptedException</strong>需要注意的是，<strong>InterruptedException</strong>异常的抛出并不意味着线程必须终止，而是提醒当前线程有中断的操作发生，至于接下来怎么处理取决于线程本身，比如：</p>
<ul>
<li>直接捕获异常不做任何处理</li>
<li>将异常往外抛出</li>
<li>停止当前线程，并打印异常信息</li>
</ul>
<p>为了让大家能够更好的理解上面这段话，我们以<strong>Thread.sleep</strong>为例直接从jdk的源码中找到中断标识的清除以及异常抛出的方法代码找到<strong>is_interrupted</strong>() 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static native void sleep(long millis) throws InterruptedException;</span><br></pre></td></tr></table></figure>
<p><strong>jvm.cpp</strong>中的<strong>JVM_Sleep</strong>的源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(void, JVM_Sleep(JNIEnv* env, jclass threadClass, jlong millis))</span><br><span class="line">  JVMWrapper(&quot;JVM_Sleep&quot;);</span><br><span class="line"></span><br><span class="line">  if (millis &lt; 0) &#123;</span><br><span class="line">    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;判断并清除线程中断状态，如果中断状态为true，则抛出中断异常</span><br><span class="line">  if (Thread::is_interrupted (THREAD, true) &amp;&amp; !HAS_PENDING_EXCEPTION) &#123;</span><br><span class="line">    THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Save current thread state and restore it at the end of this block.</span><br><span class="line">  &#x2F;&#x2F; And set new thread state to SLEEPING.</span><br><span class="line">  JavaThreadSleepState jtss(thread);</span><br></pre></td></tr></table></figure>

<p><strong>os_linux.cpp</strong>中的<strong>is_interrupted</strong>()方法源代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool os::is_interrupted(Thread* thread, bool clear_interrupted) &#123;</span><br><span class="line">  assert(Thread::current() &#x3D;&#x3D; thread || Threads_lock-&gt;owned_by_self(),</span><br><span class="line">    &quot;possibility of dangling Thread pointer&quot;);</span><br><span class="line"></span><br><span class="line">  OSThread* osthread &#x3D; thread-&gt;osthread();</span><br><span class="line">  &#x2F;&#x2F;获取线程中断标识</span><br><span class="line">  bool interrupted &#x3D; osthread-&gt;interrupted();</span><br><span class="line">  &#x2F;&#x2F;如果中断标识为true</span><br><span class="line">  if (interrupted &amp;&amp; clear_interrupted) &#123;</span><br><span class="line">    &#x2F;&#x2F;设置中断标识为false</span><br><span class="line">    osthread-&gt;set_interrupted(false);</span><br><span class="line">    &#x2F;&#x2F; consider thread-&gt;_SleepEvent-&gt;reset() ... optional optimization</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return interrupted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们就已经分析清楚了中断的整个流程。最后还是来画图总结一下吧。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/18/172272fde0b4219a?w=1547&h=456&f=jpeg&s=121301" alt=""></p>
<h2 id="5-3-4-interrupt-的作用"><a href="#5-3-4-interrupt-的作用" class="headerlink" title="5.3.4 interrupt()的作用"></a>5.3.4 interrupt()的作用</h2><ul>
<li>设置一个共享变量的值 true</li>
<li>唤醒处于阻塞状态下的线程</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/05/18/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%8F%AD%E5%BC%80%E7%AF%87%E7%AB%A0%EF%BC%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86%EF%BC%8C%E4%BA%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%84%8F%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/" data-id="ckacbh0g3000lknra6sn659ji" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-手把手教你阅读mybatis核心源码，掌握底层工作原理与设计思想" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/15/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%98%85%E8%AF%BBmybatis%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%EF%BC%8C%E6%8E%8C%E6%8F%A1%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/" class="article-date">
  <time datetime="2020-05-15T03:29:27.878Z" itemprop="datePublished">2020-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/15/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%98%85%E8%AF%BBmybatis%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%EF%BC%8C%E6%8E%8C%E6%8F%A1%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/">手把手教你阅读mybatis核心源码，掌握底层工作原理与设计思想</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: 手把手教你阅读mybatis核心源码，掌握底层工作原理与设计思想<br>date: 2020-05-15 11:27:43<br>tags:<br>–<br>Mybatis目前作为互联网公司Java体系开源ORM框架的首选，它有着天然的优势，很多同学只关注其公司业务CRUD程序的编写，忽略了其源码阅读的重要性。下面来看一段使用Mybatis API写的代码示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String resource &#x3D; &quot;mybatis-config.xml&quot;;</span><br><span class="line">InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">SqlSession session &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">try &#123;</span><br><span class="line">    BusinessMapper mapper &#x3D; session.getMapper(BusinessMapper.class);</span><br><span class="line">    Business business &#x3D; mapper.selectBusinessById(1);</span><br><span class="line">    System.out.println(business);</span><br><span class="line">    </span><br><span class="line">&#125;finally &#123;</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来按照示例代码的步骤一步一步地来分析代码的运行背后的秘密，揭开mybatis源码的真实面目。给出的源码片段均有中文注释，方便同学们加深理解。</p>
<h1 id="一、全局配置解析过程"><a href="#一、全局配置解析过程" class="headerlink" title="一、全局配置解析过程"></a>一、全局配置解析过程</h1><h2 id="1-1-SqlSessionFactoryBuilder（构建工厂类）"><a href="#1-1-SqlSessionFactoryBuilder（构建工厂类）" class="headerlink" title="1.1 SqlSessionFactoryBuilder（构建工厂类）"></a>1.1 SqlSessionFactoryBuilder（构建工厂类）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure>

<p>创建一个新的<strong>SqlSessionFactoryBuilder</strong>对象，这里使用了建造者模式。调用了build()方法创建了<strong>SqlSessionFactory</strong>对象，在<strong>SqlSessionFactoryBuilder</strong>中有9个重载的build()方法，可以使用不同的方式来创建<strong>SqlSessionFactory</strong>对象，其默认是单例模式的。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/14/17211ef5a2c1f056?w=621&h=330&f=png&s=34774" alt=""></p>
<h2 id="1-2-XmlConfigBuilder（解析全局配置文件）"><a href="#1-2-XmlConfigBuilder（解析全局配置文件）" class="headerlink" title="1.2 XmlConfigBuilder（解析全局配置文件）"></a>1.2 XmlConfigBuilder（解析全局配置文件）</h2><p>创建<strong>XmlConfigBuilder</strong>对象用来解析全局配置文件，解析完成之后会返回一个<strong>Configuration</strong>对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public SqlSessionFactory build(Reader reader, String environment, Properties properties) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F;1、创建XMLConfigBuilder对象</span><br><span class="line">      XMLConfigBuilder parser &#x3D; new XMLConfigBuilder(reader, environment, properties);</span><br><span class="line">      &#x2F;&#x2F;2、调用解析方法返回Configuration对象</span><br><span class="line">      return build(parser.parse());</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">      try &#123;</span><br><span class="line">        reader.close();</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">        &#x2F;&#x2F; Intentionally ignore. Prefer previous error.</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>XMLConfigBuilder</strong>继承自抽象类<strong>BaseBuilder</strong>，解析全局的配置文件，<strong>BaseBuilder</strong>还有一些子类，用来创建不同的目标的。例如：</p>
<ul>
<li>XMLMapperBuilder：解析Mapper映射器</li>
<li>XMLStatementBuilder：解析增删改查标签</li>
<li>XMLScriptBuilder：解析动态SQL</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/14/17212043919beb10?w=1719&h=201&f=png&s=17962" alt=""></p>
<p>接着来看下<strong>XMLConfigBuilder</strong>对象调用的<strong>parse</strong>()方法的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Configuration parse() &#123;</span><br><span class="line">   if (parsed) &#123;</span><br><span class="line">     throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   parsed &#x3D; true;</span><br><span class="line">   &#x2F;&#x2F; XPathParser，dom 和 SAX 都有用到 &gt;&gt;</span><br><span class="line">   parseConfiguration(parser.evalNode(&quot;&#x2F;configuration&quot;));</span><br><span class="line">   return configuration;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>java中解析xml配置文件的方式有很多种，mybatis对DOM和SAX两种方式做了不同的封装。接着看<strong>parseConfiguration</strong>()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private void parseConfiguration(XNode root) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F;issue #117 read properties first</span><br><span class="line">      &#x2F;&#x2F; 对于全局配置文件各种标签的解析</span><br><span class="line">      1、解析&lt;properties&gt;标签，可以读取外部引入的属性文件，比如database.properties</span><br><span class="line">      propertiesElement(root.evalNode(&quot;properties&quot;));</span><br><span class="line">      &#x2F;&#x2F; 2、解析 settings 标签</span><br><span class="line">      Properties settings &#x3D; settingsAsProperties(root.evalNode(&quot;settings&quot;));</span><br><span class="line">      &#x2F;&#x2F;3、获取Virtual File System自定义实现类，比如读取本地文件</span><br><span class="line">      loadCustomVfs(settings);</span><br><span class="line">      &#x2F;&#x2F;4、根据&lt;longImpl&gt;标签获取日志实现类</span><br><span class="line">      loadCustomLogImpl(settings);</span><br><span class="line">      &#x2F;&#x2F;5、解析类型别名</span><br><span class="line">      typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));</span><br><span class="line">      &#x2F;&#x2F;6、解析plugins标签，比如翻页插件PageHelper</span><br><span class="line">      pluginElement(root.evalNode(&quot;plugins&quot;));</span><br><span class="line">      &#x2F;&#x2F; 用于创建对象</span><br><span class="line">      objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));</span><br><span class="line">      &#x2F;&#x2F; 用于对对象进行加工</span><br><span class="line">      objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));</span><br><span class="line">      &#x2F;&#x2F; 反射工具箱</span><br><span class="line">      reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));</span><br><span class="line">      &#x2F;&#x2F; settings 子标签赋值，默认值就是在这里提供的 &gt;&gt;</span><br><span class="line">      settingsElement(settings);</span><br><span class="line">      &#x2F;&#x2F; read it after objectFactory and objectWrapperFactory issue #631</span><br><span class="line">      &#x2F;&#x2F; 创建了数据源 &gt;&gt;</span><br><span class="line">      environmentsElement(root.evalNode(&quot;environments&quot;));</span><br><span class="line">      &#x2F;&#x2F; 解析databaseIdProvider标签，生成DatabaseIdProvider对象</span><br><span class="line">      databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));</span><br><span class="line">      &#x2F;&#x2F; 用来做映射的，得到JavaType和JdbcType，存放在TypeHandlerRegistry对象中</span><br><span class="line">      typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));</span><br><span class="line">      &#x2F;&#x2F; 解析引用的Mapper映射器</span><br><span class="line">      mapperElement(root.evalNode(&quot;mappers&quot;));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法中所有的值都会封装到<strong>Configuration</strong>对象中。下面是创建过程的时序图。<br><img src="https://user-gold-cdn.xitu.io/2020/5/14/172122a8ead77411?w=720&h=590&f=jpeg&s=66823" alt=""></p>
<h1 id="二、会话创建过程"><a href="#二、会话创建过程" class="headerlink" title="二、会话创建过程"></a>二、会话创建过程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session &#x3D; sqlSessionFactory.openSession();</span><br></pre></td></tr></table></figure>
<p>这里实际上调用了<strong>DefaultSqlSessionFactory</strong>类的<strong>openSessionFromDataSource</strong>()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123;</span><br><span class="line">    Transaction tx &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      final Environment environment &#x3D; configuration.getEnvironment();</span><br><span class="line">      &#x2F;&#x2F; 获取事务工厂</span><br><span class="line">      final TransactionFactory transactionFactory &#x3D; getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">      &#x2F;&#x2F; 创建事务</span><br><span class="line">      tx &#x3D; transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">      &#x2F;&#x2F; 根据事务工厂和默认的执行器类型，创建执行器 &gt;&gt;</span><br><span class="line">      final Executor executor &#x3D; configuration.newExecutor(tx, execType);</span><br><span class="line">      return new DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      closeTransaction(tx); &#x2F;&#x2F; may have fetched a connection so lets call close()</span><br><span class="line">      throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-1-获取Environment对象"><a href="#2-1-获取Environment对象" class="headerlink" title="2.1 获取Environment对象"></a>2.1 获取Environment对象</h2><p>从<strong>Configuration</strong>对象中获取<strong>Environment</strong>对象，环境对象中有事务工厂类；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final class Environment &#123;</span><br><span class="line">  private final String id;</span><br><span class="line">  private final TransactionFactory transactionFactory;</span><br><span class="line">  private final DataSource dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-创建事务"><a href="#2-2-创建事务" class="headerlink" title="2.2 创建事务"></a>2.2 创建事务</h2><p>从<strong>Environment</strong>对象中获取一个<strong>TranscationFactory</strong>对象，事务工厂类型可以配置成<strong>JDBC</strong>或者<strong>MANAGED</strong>。</p>
<ul>
<li>JDBC；使用jdbc的Connection对象来管理事务；</li>
<li>MANAGED：事务将有容器进行管理。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private TransactionFactory getTransactionFactoryFromEnvironment(Environment environment) &#123;</span><br><span class="line">   if (environment &#x3D;&#x3D; null || environment.getTransactionFactory() &#x3D;&#x3D; null) &#123;</span><br><span class="line">     return new ManagedTransactionFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   return environment.getTransactionFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-创建执行器"><a href="#2-3-创建执行器" class="headerlink" title="2.3 创建执行器"></a>2.3 创建执行器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final Executor executor &#x3D; configuration.newExecutor(tx, execType);</span><br></pre></td></tr></table></figure>
<p>执行器<strong>Executor</strong>的基本类型有三种：</p>
<ul>
<li>SIMPLE（默认）</li>
<li>BATCH</li>
<li>REUSE</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (ExecutorType.BATCH &#x3D;&#x3D; executorType) &#123;</span><br><span class="line">      executor &#x3D; new BatchExecutor(this, transaction);</span><br><span class="line">    &#125; else if (ExecutorType.REUSE &#x3D;&#x3D; executorType) &#123;</span><br><span class="line">      executor &#x3D; new ReuseExecutor(this, transaction);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 默认 SimpleExecutor</span><br><span class="line">      executor &#x3D; new SimpleExecutor(this, transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/5/14/1721245f64e5e6e9?w=1239&h=378&f=png&s=26496" alt=""></p>
<p>抽象类BaseExecutor实现Executor接口，这是模板设计模式的体现。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/14/172125b1eace1d19?w=981&h=234&f=png&s=32839" alt=""></p>
<p><strong>缓存装饰</strong></p>
<p>在newExecutor()方法中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 二级缓存开关，settings 中的 cacheEnabled 默认是 true</span><br><span class="line">if (cacheEnabled) &#123;</span><br><span class="line">  executor &#x3D; new CachingExecutor(executor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代理插件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 植入插件的逻辑，至此，四大对象已经全部拦截完毕</span><br><span class="line">executor &#x3D; (Executor) interceptorChain.pluginAll(executor);</span><br></pre></td></tr></table></figure>

<h2 id="2-4-返回SqlSession"><a href="#2-4-返回SqlSession" class="headerlink" title="2.4 返回SqlSession"></a>2.4 返回SqlSession</h2><p><strong>SqlSession</strong>类中包括<strong>Configuration</strong>和<strong>Executor</strong>两大对象。下面是创建过程的时序图。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/14/1721265937c7c78b?w=720&h=539&f=jpeg&s=65450" alt=""></p>
<h1 id="三、获取代理对象"><a href="#三、获取代理对象" class="headerlink" title="三、获取代理对象"></a>三、获取代理对象</h1><p>接口中的名称和Mapper.xml文件中的namespace是一一对应的，方法名称也是StatementId也是对应的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BusinessMapper mapper &#x3D; session.getMapper(BusinessMapper.class);</span><br><span class="line">Business business &#x3D; mapper.selectBusinessById(1);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace&#x3D;&quot;com.sy.mapper.BusinessMapper&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id&#x3D;&quot;selectBusinessById&quot; resultMap&#x3D;&quot;BaseResultMap&quot; statementType&#x3D;&quot;PREPARED&quot; &gt;</span><br><span class="line">        select * from bsuiness where bid &#x3D; #&#123;bid&#125;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-1-getMapper-方法"><a href="#3-1-getMapper-方法" class="headerlink" title="3.1 getMapper()方法"></a>3.1 getMapper()方法</h2><p>1、<strong>DefaultSqlSession</strong>中的<strong>getMapper()</strong>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type) &#123;</span><br><span class="line">    return configuration.getMapper(type, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、<strong>Configuration</strong>类中的<strong>getMapper</strong>()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</span><br><span class="line">    return mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>3、<strong>MapperRegistry</strong>中的<strong>getMapper</strong>()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</span><br><span class="line">    final MapperProxyFactory&lt;T&gt; mapperProxyFactory &#x3D; (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    if (mapperProxyFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      return mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在解析mapper标签和Mapper.xml的时候已经把接口类型和类型对应的<strong>MapperProxyFactory</strong>放到一个map中，获取<strong>Mapper</strong>的代理对象，实际上是从map中获取对应的工厂类后，最终通过<strong>JDK动态代理</strong>创建的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123;</span><br><span class="line">    &#x2F;&#x2F; 1：类加载器;</span><br><span class="line">    &#x2F;&#x2F; 2：被代理类实现的接口;</span><br><span class="line">    &#x2F;&#x2F; 3：实现了 InvocationHandler 的触发管理类</span><br><span class="line">    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public T newInstance(SqlSession sqlSession) &#123;</span><br><span class="line">    final MapperProxy&lt;T&gt; mapperProxy &#x3D; new MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    return newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>MapperProxy</strong>实现了<strong>InvocationHandler</strong>接口，参数有<strong>sqlSession, mapperInterface, methodCache</strong>，最终是通过JDK的动态代理创建返回代理对象（类型是$<strong>Proxy数字</strong>）。这个对象继承<strong>Proxy类</strong>，实例被代理的接口，里面持有了一个<strong>MapperProxy</strong>类型的触发管理类。</p>
<h2 id="3-2-MapperProxy-实现对接口的代理"><a href="#3-2-MapperProxy-实现对接口的代理" class="headerlink" title="3.2 MapperProxy 实现对接口的代理"></a>3.2 MapperProxy 实现对接口的代理</h2><p>JDK的动态代理有三个核心角色：</p>
<ul>
<li>被代理类（实现类）</li>
<li>接口</li>
<li>实现了InvocationHandler的触发管理类</li>
</ul>
<p>用来生成代理对象。被代理的类必须实现接口，因为要通过接口获取方法，而且代理类也要实现这个接口。<br><img src="https://user-gold-cdn.xitu.io/2020/5/14/17213567060a5a09?w=935&h=487&f=png&s=224353" alt=""><br>而MyBatis里面的Mapper没有实现类，它直接忽略了实现类，直接对接口进行代理。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/14/172135b12a5dd6af?w=933&h=527&f=png&s=227459" alt=""><br>获取Mapper对象的过程，实际上是获取了一个JDK动态代理对象。这个代理类继承Proxy类，实现被代理的接口，里面持有一个MapperProxy类型的触发管理类。来看下代理类过程的时序图吧。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/14/172135df8fd7a684?w=720&h=511&f=jpeg&s=55503" alt=""></p>
<h1 id="四、执行SQL"><a href="#四、执行SQL" class="headerlink" title="四、执行SQL"></a>四、执行SQL</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Business business &#x3D; mapper.selectBusinessById(1);</span><br></pre></td></tr></table></figure>
<h2 id="4-1-MapperProxy-invoke-方法"><a href="#4-1-MapperProxy-invoke-方法" class="headerlink" title="4.1 MapperProxy.invoke()方法"></a>4.1 MapperProxy.invoke()方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; toString hashCode equals getClass等方法，无需走到执行SQL的流程</span><br><span class="line">      if (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        return method.invoke(this, args);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 提升获取 mapperMethod 的效率，到 MapperMethodInvoker（内部接口） 的 invoke</span><br><span class="line">        &#x2F;&#x2F; 普通方法会走到 PlainMethodInvoker（内部类） 的 invoke</span><br><span class="line">        return cachedInvoker(method).invoke(proxy, method, args, sqlSession);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">      throw ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-1-1、首先判断是否要执行SQL还是直接执行方法"><a href="#4-1-1、首先判断是否要执行SQL还是直接执行方法" class="headerlink" title="4.1.1、首先判断是否要执行SQL还是直接执行方法"></a>4.1.1、首先判断是否要执行SQL还是直接执行方法</h2><p>Object本身的方法和Java 8中的默认方法不需要取执行SQL</p>
<h2 id="4-1-2、获取缓存"><a href="#4-1-2、获取缓存" class="headerlink" title="4.1.2、获取缓存"></a>4.1.2、获取缓存</h2><p>这里加入缓存时为了提升MapperMethod的获取速度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private MapperMethodInvoker cachedInvoker(Method method) throws Throwable &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; Java8 中 Map 的方法，根据 key 获取值，如果值是 null，则把后面Object 的值赋给 key</span><br><span class="line">     &#x2F;&#x2F; 如果获取不到，就创建</span><br><span class="line">     &#x2F;&#x2F; 获取的是 MapperMethodInvoker（接口） 对象，只有一个invoke方法</span><br><span class="line">     return methodCache.computeIfAbsent(method, m -&gt; &#123;</span><br><span class="line">       if (m.isDefault()) &#123;</span><br><span class="line">         &#x2F;&#x2F; 接口的默认方法(Java8)，只要实现接口都会继承接口的默认方法，例如 List.sort()</span><br><span class="line">         try &#123;</span><br><span class="line">           if (privateLookupInMethod &#x3D;&#x3D; null) &#123;</span><br><span class="line">             return new DefaultMethodInvoker(getMethodHandleJava8(method));</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">             return new DefaultMethodInvoker(getMethodHandleJava9(method));</span><br><span class="line">           &#125;</span><br><span class="line">         &#125; catch (IllegalAccessException | InstantiationException | InvocationTargetException</span><br><span class="line">             | NoSuchMethodException e) &#123;</span><br><span class="line">           throw new RuntimeException(e);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         &#x2F;&#x2F; 创建了一个 MapperMethod</span><br><span class="line">         return new PlainMethodInvoker(new MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125; catch (RuntimeException re) &#123;</span><br><span class="line">     Throwable cause &#x3D; re.getCause();</span><br><span class="line">     throw cause &#x3D;&#x3D; null ? re : cause;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>Map 的 <strong>computeIfAbsent</strong>()方法：只有key不存在或者value为null，则把后面的Object的值赋给key。<strong>Java8</strong>和<strong>Java9</strong>中的接口默认方法由特殊处理，返回<strong>DefaultMethodInvoker</strong>对象。普通的方法返回的是<strong>PlainMethodInvoker</strong>，<strong>MapperMethod</strong>。</p>
<p>在MapperMethod对象中有两个比较重要的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; statement id （例如：com.sy.mapper.BusinessMapper.selectBusinessById） 和 SQL 类型</span><br><span class="line"> private final SqlCommand command;</span><br><span class="line"> &#x2F;&#x2F; 方法签名，主要是返回值的类型</span><br><span class="line"> private final MethodSignature method;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-MappperMethod-execute-方法"><a href="#4-2-MappperMethod-execute-方法" class="headerlink" title="4.2 MappperMethod.execute()方法"></a>4.2 MappperMethod.execute()方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public Object execute(SqlSession sqlSession, Object[] args) &#123;</span><br><span class="line">    Object result;</span><br><span class="line">    switch (command.getType()) &#123;</span><br><span class="line">      case INSERT: &#123;</span><br><span class="line">        Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result &#x3D; rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      case UPDATE: &#123;</span><br><span class="line">        Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result &#x3D; rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      case DELETE: &#123;</span><br><span class="line">        Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result &#x3D; rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      case SELECT:</span><br><span class="line">        if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">          executeWithResultHandler(sqlSession, args);</span><br><span class="line">          result &#x3D; null;</span><br><span class="line">        &#125; else if (method.returnsMany()) &#123;</span><br><span class="line">          result &#x3D; executeForMany(sqlSession, args);</span><br><span class="line">        &#125; else if (method.returnsMap()) &#123;</span><br><span class="line">          result &#x3D; executeForMap(sqlSession, args);</span><br><span class="line">        &#125; else if (method.returnsCursor()) &#123;</span><br><span class="line">          result &#x3D; executeForCursor(sqlSession, args);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">          &#x2F;&#x2F; 普通 select 语句的执行入口 &gt;&gt;</span><br><span class="line">          result &#x3D; sqlSession.selectOne(command.getName(), param);</span><br><span class="line">          if (method.returnsOptional()</span><br><span class="line">              &amp;&amp; (result &#x3D;&#x3D; null || !method.getReturnType().equals(result.getClass()))) &#123;</span><br><span class="line">            result &#x3D; Optional.ofNullable(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">      case FLUSH:</span><br><span class="line">        result &#x3D; sqlSession.flushStatements();</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    if (result &#x3D;&#x3D; null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">      throw new BindingException(&quot;Mapper method &#39;&quot; + command.getName()</span><br><span class="line">          + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>根据不同的类型（<strong>INSERT、UPDATE、DELETE、SELECT</strong>）和返回类型：</p>
<ul>
<li>调用<strong>convertArgsToSqlCommandParam</strong>()将方法的参数转换为SQL的参数。</li>
<li>调用sqlSession的insert()、update()、delete()、selectOne()方法。</li>
</ul>
<p>下面重点来讲下查询的selectOne()方法。调用了<strong>DefaultSqlSession</strong>的selectOne()方法。</p>
<h2 id="4-3-DefaultSqlSession-selectOne-方法"><a href="#4-3-DefaultSqlSession-selectOne-方法" class="headerlink" title="4.3 DefaultSqlSession.selectOne()方法"></a>4.3 DefaultSqlSession.selectOne()方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T selectOne(String statement, Object parameter) &#123;</span><br><span class="line">    &#x2F;&#x2F; 来到了 DefaultSqlSession</span><br><span class="line">    &#x2F;&#x2F; Popular vote was to return null on 0 results and throw exception on too many.</span><br><span class="line">    List&lt;T&gt; list &#x3D; this.selectList(statement, parameter);</span><br><span class="line">    if (list.size() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">      return list.get(0);</span><br><span class="line">    &#125; else if (list.size() &gt; 1) &#123;</span><br><span class="line">      throw new TooManyResultsException(&quot;Expected one result (or null) to be returned by selectOne(), but found: &quot; + list.size());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在SelectList()中，我们先根据commandname（StatementID）从Configuration中拿到MappedStatement，这个ms上面有我们在xml中配置的所有属性，包括id、statementType、sqlSource、useCache、入参、出参等等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      MappedStatement ms &#x3D; configuration.getMappedStatement(statement);</span><br><span class="line">      &#x2F;&#x2F; 如果 cacheEnabled &#x3D; true（默认），Executor会被 CachingExecutor装饰</span><br><span class="line">      return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>然后执行executor.query()，前面我们说到了Executor有三种基本类型，SIMPLE/REUSE/BATCH，还有一种包装类型，CachingExecutor。那么在这里到底会选择哪一种执行器呢？我们要回过头去看看DefaultSqlSession在初始化的时候是怎么赋值的，这个就是我们的会话创建过程。如果启用了二级缓存，就会先调用CachingExecutor 的query()方法，里面有缓存相关的操作，然后才是再调用基本类型的执行器，比如默认的SimpleExecutor。在没有开启二级缓存的情况下，先会走到BaseExecutor的query()方法（否则会先走到CachingExecutor）。</p>
<h2 id="4-4-CachingExector-query-方法"><a href="#4-4-CachingExector-query-方法" class="headerlink" title="4.4 CachingExector.query()方法"></a>4.4 CachingExector.query()方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取SQL</span><br><span class="line">    BoundSql boundSql &#x3D; ms.getBoundSql(parameterObject);</span><br><span class="line">    &#x2F;&#x2F; 创建CacheKey：什么样的SQL是同一条SQL？ &gt;&gt;</span><br><span class="line">    CacheKey key &#x3D; createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-4-1、创建CacheKey"><a href="#4-4-1、创建CacheKey" class="headerlink" title="4.4.1、创建CacheKey"></a>4.4.1、创建CacheKey</h2><p>二级缓存的CacheKey是如何构成的呢？换句话说，什么样的查询才能确定是同一个查询呢？在BaseExector中createCacheKey()方法，用到了六要素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) &#123;</span><br><span class="line">    if (closed) &#123;</span><br><span class="line">      throw new ExecutorException(&quot;Executor was closed.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    CacheKey cacheKey &#x3D; new CacheKey();</span><br><span class="line">    cacheKey.update(ms.getId()); </span><br><span class="line">    cacheKey.update(rowBounds.getOffset()); &#x2F;&#x2F; 0</span><br><span class="line">    cacheKey.update(rowBounds.getLimit()); &#x2F;&#x2F; 2147483647 &#x3D; 2^31-1</span><br><span class="line">    cacheKey.update(boundSql.getSql());</span><br><span class="line">    List&lt;ParameterMapping&gt; parameterMappings &#x3D; boundSql.getParameterMappings();</span><br><span class="line">    TypeHandlerRegistry typeHandlerRegistry &#x3D; ms.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">    &#x2F;&#x2F; mimic DefaultParameterHandler logic</span><br><span class="line">    for (ParameterMapping parameterMapping : parameterMappings) &#123;</span><br><span class="line">      if (parameterMapping.getMode() !&#x3D; ParameterMode.OUT) &#123;</span><br><span class="line">        Object value;</span><br><span class="line">        String propertyName &#x3D; parameterMapping.getProperty();</span><br><span class="line">        if (boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">          value &#x3D; boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">        &#125; else if (parameterObject &#x3D;&#x3D; null) &#123;</span><br><span class="line">          value &#x3D; null;</span><br><span class="line">        &#125; else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">          value &#x3D; parameterObject;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          MetaObject metaObject &#x3D; configuration.newMetaObject(parameterObject);</span><br><span class="line">          value &#x3D; metaObject.getValue(propertyName);</span><br><span class="line">        &#125;</span><br><span class="line">        cacheKey.update(value); &#x2F;&#x2F; development</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (configuration.getEnvironment() !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; issue #176</span><br><span class="line">      cacheKey.update(configuration.getEnvironment().getId());</span><br><span class="line">    &#125;</span><br><span class="line">    return cacheKey;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>即为方法相同、翻页偏移相同、SQL相同、参数值相同、数据源环境相同才会被认定为同一个查询。</p>
<p>注意看下CacheKey类的属性，里面有一个List按照顺序存放了上面的六要素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static final int DEFAULT_MULTIPLIER &#x3D; 37;</span><br><span class="line"> private static final int DEFAULT_HASHCODE &#x3D; 17;</span><br><span class="line"></span><br><span class="line"> private final int multiplier;</span><br><span class="line"> private int hashcode;</span><br><span class="line"> private long checksum;</span><br><span class="line"> private int count;</span><br><span class="line"> &#x2F;&#x2F; 8&#x2F;21&#x2F;2017 - Sonarlint flags this as needing to be marked transient.  While true if content is not serializable, this is not always true and thus should not be marked transient.</span><br><span class="line"> private List&lt;Object&gt; updateList;</span><br></pre></td></tr></table></figure>

<p>怎么比较两个CacheKey是否相等呢？如果一上来就依次比较六个要素是否相等，这样要比6次，这样效率不高。每一个类都继承自Object，都有一个hashCode()方法，用来生成哈希码。它是用来在集合中快速判重的。</p>
<p>在生成cacheKey的时候也就是调用update()方法，也更新了cacheKey的hashCode，它是用乘法哈希生成的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void update(Object object) &#123;</span><br><span class="line">    &#x2F;&#x2F; 加法哈希</span><br><span class="line">    int baseHashCode &#x3D; object &#x3D;&#x3D; null ? 1 : ArrayUtil.hashCode(object);</span><br><span class="line"></span><br><span class="line">    count++;</span><br><span class="line">    checksum +&#x3D; baseHashCode;</span><br><span class="line">    baseHashCode *&#x3D; count;</span><br><span class="line">    &#x2F;&#x2F; 37 * 17 + </span><br><span class="line">    hashcode &#x3D; multiplier * hashcode + baseHashCode;</span><br><span class="line"></span><br><span class="line">    updateList.add(object);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Object中的hashCode()方法是一个本地方法，通过<strong>随机数算法生成</strong>（OpenJDK8 默认，可以通过-XX:hashCode修改）。CacheKey中的hashCode()方法进行了重写，返回生成新的hashCode。</p>
<p>为什么需要用37作为乘法因子呢？这是一个经验值，跟String类中的31类似。看下String类中的hashCode()方法源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int hashCode() &#123;</span><br><span class="line">    int h &#x3D; hash;</span><br><span class="line">    if (h &#x3D;&#x3D; 0 &amp;&amp; value.length &gt; 0) &#123;</span><br><span class="line">        char val[] &#x3D; value;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; value.length; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;31作为乘法因子</span><br><span class="line">            h &#x3D; 31 * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash &#x3D; h;</span><br><span class="line">    &#125;</span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CacheKey中的equals()方法也进行了重写，比较cacheKey是否相等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object object) &#123;</span><br><span class="line">    &#x2F;&#x2F; 同一个对象</span><br><span class="line">    if (this &#x3D;&#x3D; object) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 被比较的对象不是 CacheKey</span><br><span class="line">    if (!(object instanceof CacheKey)) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    final CacheKey cacheKey &#x3D; (CacheKey) object;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; hashcode 不相等</span><br><span class="line">    if (hashcode !&#x3D; cacheKey.hashcode) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; checksum 不相等</span><br><span class="line">    if (checksum !&#x3D; cacheKey.checksum) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; count 不相等</span><br><span class="line">    if (count !&#x3D; cacheKey.count) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i &lt; updateList.size(); i++) &#123;</span><br><span class="line">      Object thisObject &#x3D; updateList.get(i);</span><br><span class="line">      Object thatObject &#x3D; cacheKey.updateList.get(i);</span><br><span class="line">      if (!ArrayUtil.equals(thisObject, thatObject)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果哈希值（乘法哈希），校验值（加法哈希），要素个数任何一个不相等，都不是同一个查询，最后再循环比较要素，防止hash碰撞。</p>
<p>CacheKey生成之后，调用CachingExecutor类的query()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取SQL</span><br><span class="line">    BoundSql boundSql &#x3D; ms.getBoundSql(parameterObject);</span><br><span class="line">    &#x2F;&#x2F; 创建CacheKey：什么样的SQL是同一条SQL？ &gt;&gt;</span><br><span class="line">    CacheKey key &#x3D; createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4-2、处理二级缓存"><a href="#4-4-2、处理二级缓存" class="headerlink" title="4.4.2、处理二级缓存"></a>4.4.2、处理二级缓存</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span><br><span class="line">      throws SQLException &#123;</span><br><span class="line">    Cache cache &#x3D; ms.getCache();</span><br><span class="line">    &#x2F;&#x2F; cache 对象是在哪里创建的？  XMLMapperBuilder类 xmlconfigurationElement()</span><br><span class="line">    &#x2F;&#x2F; 由 &lt;cache&gt; 标签决定</span><br><span class="line">    if (cache !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; flushCache&#x3D;&quot;true&quot; 清空一级二级缓存 &gt;&gt;</span><br><span class="line">      flushCacheIfRequired(ms);</span><br><span class="line">      if (ms.isUseCache() &amp;&amp; resultHandler &#x3D;&#x3D; null) &#123;</span><br><span class="line">        ensureNoOutParams(ms, boundSql);</span><br><span class="line">        &#x2F;&#x2F; 获取二级缓存</span><br><span class="line">        &#x2F;&#x2F; 缓存通过 TransactionalCacheManager、TransactionalCache 管理</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        List&lt;E&gt; list &#x3D; (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">        if (list &#x3D;&#x3D; null) &#123;</span><br><span class="line">          list &#x3D; delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">          &#x2F;&#x2F; 写入二级缓存</span><br><span class="line">          tcm.putObject(cache, key, list); &#x2F;&#x2F; issue #578 and #116</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 走到 SimpleExecutor | ReuseExecutor | BatchExecutor</span><br><span class="line">    return delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>首先从<strong>MappedStatement</strong>对象中调用<strong>getCache</strong>()方法，判断对象是否为空，如果为空，则没有查询二级缓存、写入二级缓存的流程。</p>
<p>那么Cache对象是什么时候被创建出来的呢？用来解析Mapper.xml的<strong>XMLMapperBuilder</strong>类，<strong>configurationElement</strong>()方法中调用<strong>cacheElement</strong>()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cacheElement(context.evalNode(&quot;cache&quot;));</span><br></pre></td></tr></table></figure>
<p>只有Mapper.xml中的cache标签不为空才会被解析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void cacheElement(XNode context) &#123;</span><br><span class="line">   &#x2F;&#x2F; 只有 cache 标签不为空才解析</span><br><span class="line">   if (context !&#x3D; null) &#123;</span><br><span class="line">     String type &#x3D; context.getStringAttribute(&quot;type&quot;, &quot;PERPETUAL&quot;);</span><br><span class="line">     Class&lt;? extends Cache&gt; typeClass &#x3D; typeAliasRegistry.resolveAlias(type);</span><br><span class="line">     String eviction &#x3D; context.getStringAttribute(&quot;eviction&quot;, &quot;LRU&quot;);</span><br><span class="line">     Class&lt;? extends Cache&gt; evictionClass &#x3D; typeAliasRegistry.resolveAlias(eviction);</span><br><span class="line">     Long flushInterval &#x3D; context.getLongAttribute(&quot;flushInterval&quot;);</span><br><span class="line">     Integer size &#x3D; context.getIntAttribute(&quot;size&quot;);</span><br><span class="line">     boolean readWrite &#x3D; !context.getBooleanAttribute(&quot;readOnly&quot;, false);</span><br><span class="line">     boolean blocking &#x3D; context.getBooleanAttribute(&quot;blocking&quot;, false);</span><br><span class="line">     Properties props &#x3D; context.getChildrenAsProperties();</span><br><span class="line">     builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>builderAssistant.useNewCache</strong>()方法创建了一个Cache对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public Cache useNewCache(Class&lt;? extends Cache&gt; typeClass,</span><br><span class="line">      Class&lt;? extends Cache&gt; evictionClass,</span><br><span class="line">      Long flushInterval,</span><br><span class="line">      Integer size,</span><br><span class="line">      boolean readWrite,</span><br><span class="line">      boolean blocking,</span><br><span class="line">      Properties props) &#123;</span><br><span class="line">    Cache cache &#x3D; new CacheBuilder(currentNamespace)</span><br><span class="line">        .implementation(valueOrDefault(typeClass, PerpetualCache.class))</span><br><span class="line">        .addDecorator(valueOrDefault(evictionClass, LruCache.class))</span><br><span class="line">        .clearInterval(flushInterval)</span><br><span class="line">        .size(size)</span><br><span class="line">        .readWrite(readWrite)</span><br><span class="line">        .blocking(blocking)</span><br><span class="line">        .properties(props)</span><br><span class="line">        .build();</span><br><span class="line">    configuration.addCache(cache);</span><br><span class="line">    currentCache &#x3D; cache;</span><br><span class="line">    return cache;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>二级缓存为什么要用TCM来进行管理呢？</strong></p>
<p>我们来思考一个问题，在一个事务中：</p>
<ul>
<li>1、首先插入一条数据（没有提交），此时二级缓存会被清空。</li>
<li>2、在这个事务中查询数据，写入二级缓存。</li>
<li>3、提交事务，出现异常，数据回滚。</li>
</ul>
<p>此时出现了数据库没有这条数据，但是二级缓存有这条数据的情况。所以MyBatis<br>的二级缓存需要跟事务关联起来。</p>
<p><strong>那么为什么一级缓存不这么做？</strong></p>
<p>因为一个session就是一个事务，事务回滚，会话就结束了，缓存也清空了，不存<br>在读到一级缓存中脏数据的情况。二级缓存是跨session的，也就是跨事务的，才有可能出现对同一个方法的不同事务访问。</p>
<h2 id="4-4-2-1-写入二级缓存"><a href="#4-4-2-1-写入二级缓存" class="headerlink" title="4.4.2.1 写入二级缓存"></a>4.4.2.1 写入二级缓存</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcm.putObject(cache, key, list); &#x2F;&#x2F; issue #578 and #116</span><br></pre></td></tr></table></figure>

<p>调用<strong>TranscationalCacheManager</strong>的<strong>putObject</strong>()方法，从map中拿出TransactionalCache对象，把value添加到待提交的map中。此时缓存还没有真正的写入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void putObject(Cache cache, CacheKey key, Object value) &#123;</span><br><span class="line">    getTransactionalCache(cache).putObject(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private TransactionalCache getTransactionalCache(Cache cache) &#123;</span><br><span class="line">    return transactionalCaches.computeIfAbsent(cache, TransactionalCache::new);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<strong>TranscationalCache</strong>的<strong>putObject</strong>()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void putObject(Object key, Object object) &#123;</span><br><span class="line">    entriesToAddOnCommit.put(key, object);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>只有真正的提交事务的时候才真正的写入缓存。</strong></p>
<h2 id="4-4-2-2-获取二级缓存"><a href="#4-4-2-2-获取二级缓存" class="headerlink" title="4.4.2.2 获取二级缓存"></a>4.4.2.2 获取二级缓存</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;E&gt; list &#x3D; (List&lt;E&gt;) tcm.getObject(cache, key);</span><br></pre></td></tr></table></figure>
<p>从map中拿出<strong>Transcational</strong>对象，这个对象也是对<strong>PerpetualCache</strong>经过层层装饰的缓存对象。<strong>getObject</strong>()方法层层递归，直到到达<strong>PerpetualCache</strong>，拿到value。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public Object getObject(Object key) &#123;</span><br><span class="line">    &#x2F;&#x2F; issue #116</span><br><span class="line">    Object object &#x3D; delegate.getObject(key);</span><br><span class="line">    if (object &#x3D;&#x3D; null) &#123;</span><br><span class="line">      entriesMissedInCache.add(key);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; issue #146</span><br><span class="line">    if (clearOnCommit) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return object;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>PerpetualCache</strong>中的<strong>getObject</strong>()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object getObject(Object key) &#123;</span><br><span class="line">    return cache.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-BaseExecutor-query-方法"><a href="#4-5-BaseExecutor-query-方法" class="headerlink" title="4.5 BaseExecutor.query()方法"></a>4.5 BaseExecutor.query()方法</h2><h2 id="4-5-1-清空本地缓存"><a href="#4-5-1-清空本地缓存" class="headerlink" title="4.5.1 清空本地缓存"></a>4.5.1 清空本地缓存</h2><p><strong>queryStack</strong>用于记录查询栈，防止递归时候查询重复处理缓存。<strong>flushCache=true</strong>的时候，会先清除本地缓存LocalCache（一级缓存）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (queryStack &#x3D;&#x3D; 0 &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">      &#x2F;&#x2F; flushCache&#x3D;&quot;true&quot;时，即使是查询，也清空一级缓存</span><br><span class="line">      clearLocalCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有缓存，会从数据库查询。调用<strong>queryFromDatabase()</strong>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list &#x3D; queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br></pre></td></tr></table></figure>

<p><strong>LocalCacheScope == STATEMENT</strong>，就会清空本地缓存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (configuration.getLocalCacheScope() &#x3D;&#x3D; LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">    &#x2F;&#x2F; issue #482</span><br><span class="line">    clearLocalCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-2-数据库查询"><a href="#4-5-2-数据库查询" class="headerlink" title="4.5.2 数据库查询"></a>4.5.2 数据库查询</h2><p>1、先在缓存用占位符进行占位。执行查询后，移除占位符，放入数据。</p>
<p>2、执行Exector的doQuery()方法，默认是SimpleExector。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">   List&lt;E&gt; list;</span><br><span class="line">   &#x2F;&#x2F; 先占位</span><br><span class="line">   localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; 三种 Executor 的区别，看doUpdate</span><br><span class="line">     &#x2F;&#x2F; 默认Simple</span><br><span class="line">     list &#x3D; doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">     &#x2F;&#x2F; 移除占位符</span><br><span class="line">     localCache.removeObject(key);</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 写入一级缓存</span><br><span class="line">   localCache.putObject(key, list);</span><br><span class="line">   if (ms.getStatementType() &#x3D;&#x3D; StatementType.CALLABLE) &#123;</span><br><span class="line">     localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">   &#125;</span><br><span class="line">   return list;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-6-SimpleExecutor-query-方法"><a href="#4-6-SimpleExecutor-query-方法" class="headerlink" title="4.6 SimpleExecutor.query()方法"></a>4.6 SimpleExecutor.query()方法</h2><h2 id="4-6-1-创建StatementHandler"><a href="#4-6-1-创建StatementHandler" class="headerlink" title="4.6.1 创建StatementHandler"></a>4.6.1 创建StatementHandler</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">    Statement stmt &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      Configuration configuration &#x3D; ms.getConfiguration();</span><br><span class="line">      &#x2F;&#x2F; 注意，已经来到SQL处理的关键对象 StatementHandler &gt;&gt;</span><br><span class="line">      StatementHandler handler &#x3D; configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      &#x2F;&#x2F; 获取一个 Statement对象</span><br><span class="line">      stmt &#x3D; prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">      &#x2F;&#x2F; 执行查询</span><br><span class="line">      return handler.query(stmt, resultHandler);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      &#x2F;&#x2F; 用完就关闭</span><br><span class="line">      closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>configuration.newStatementHandler</strong>()先得到<strong>RoutingStatementHandler</strong>。RoutingStatementHandler没有任何实现，用来创建基本的<strong>StatementHandler</strong>，这里会根据<strong>MappedStatement</strong>里面的<strong>statementType</strong>决定<strong>StatementHandler</strong>的类型。默认是<strong>PREPARED（STATEMENT、PREPARED、CALLABLE）</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public RoutingStatementHandler(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">    &#x2F;&#x2F; StatementType 是怎么来的？ 增删改查标签中的 statementType&#x3D;&quot;PREPARED&quot;，默认值 PREPARED</span><br><span class="line">    switch (ms.getStatementType()) &#123;</span><br><span class="line">      case STATEMENT:</span><br><span class="line">        delegate &#x3D; new SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        break;</span><br><span class="line">      case PREPARED:</span><br><span class="line">        &#x2F;&#x2F; 创建 StatementHandler 的时候做了什么？ &gt;&gt;</span><br><span class="line">        delegate &#x3D; new PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        break;</span><br><span class="line">      case CALLABLE:</span><br><span class="line">        delegate &#x3D; new CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        throw new ExecutorException(&quot;Unknown statement type: &quot; + ms.getStatementType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>StatementHandler</strong>里面包含了处理参数的<strong>ParamterHandler</strong>和处理结果集的<strong>ResultHandler</strong>。这两个对象都是在上面new的时候创建的。</p>
<p><strong>StatementHandler</strong>父类<strong>BaseStatementHandler</strong>类中的构造函数中创建以上两个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected BaseStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">   this.configuration &#x3D; mappedStatement.getConfiguration();</span><br><span class="line">   this.executor &#x3D; executor;</span><br><span class="line">   this.mappedStatement &#x3D; mappedStatement;</span><br><span class="line">   this.rowBounds &#x3D; rowBounds;</span><br><span class="line"></span><br><span class="line">   this.typeHandlerRegistry &#x3D; configuration.getTypeHandlerRegistry();</span><br><span class="line">   this.objectFactory &#x3D; configuration.getObjectFactory();</span><br><span class="line"></span><br><span class="line">   if (boundSql &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; issue #435, get the key before calculating the statement</span><br><span class="line">     generateKeys(parameterObject);</span><br><span class="line">     boundSql &#x3D; mappedStatement.getBoundSql(parameterObject);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   this.boundSql &#x3D; boundSql;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 创建了四大对象的其它两大对象 &gt;&gt;</span><br><span class="line">   &#x2F;&#x2F; 创建这两大对象的时候分别做了什么？</span><br><span class="line">   this.parameterHandler &#x3D; configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">   this.resultSetHandler &#x3D; configuration.newResultSetHandler(executor, mappedStatement, rowBounds, parameterHandler, resultHandler, boundSql);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这些对象都是可以被插件拦截的四大对象，所以在创建之后都要用拦截器进行包装的方法。在<strong>Configuration</strong>中进行拦截调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) &#123;</span><br><span class="line">    ParameterHandler parameterHandler &#x3D; mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    &#x2F;&#x2F; 植入插件逻辑（返回代理对象）</span><br><span class="line">    parameterHandler &#x3D; (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">    return parameterHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span><br><span class="line">      ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">    ResultSetHandler resultSetHandler &#x3D; new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">    &#x2F;&#x2F; 植入插件逻辑（返回代理对象）</span><br><span class="line">    resultSetHandler &#x3D; (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">    return resultSetHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">    StatementHandler statementHandler &#x3D; new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">    &#x2F;&#x2F; 植入插件逻辑（返回代理对象）</span><br><span class="line">    statementHandler &#x3D; (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">    return statementHandler;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里只有对其中的三个对象，还有一个对象呢？它什么时候创建呢？</p>
<h2 id="4-6-2-创建Statement"><a href="#4-6-2-创建Statement" class="headerlink" title="4.6.2 创建Statement"></a>4.6.2 创建Statement</h2><p>用new出来的<strong>StatementHandler</strong>创建<strong>Statement</strong>对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException &#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    Connection connection &#x3D; getConnection(statementLog);</span><br><span class="line">    &#x2F;&#x2F; 获取 Statement 对象，如果有插件包装，会先走到被拦截的业务逻辑</span><br><span class="line">    stmt &#x3D; handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">    &#x2F;&#x2F; 为 Statement 设置参数，对sql语句进行预编译，处理参数</span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    return stmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void parameterize(Statement statement) throws SQLException &#123;</span><br><span class="line">    delegate.parameterize(statement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-6-3-执行StatementHandler的query-方法"><a href="#4-6-3-执行StatementHandler的query-方法" class="headerlink" title="4.6.3 执行StatementHandler的query()方法"></a>4.6.3 执行StatementHandler的query()方法</h1><p>RoutingStatementHandler的query()方法，delegate委派，最终执行PreparedStatementHandler的query()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">   return delegate.query(statement, resultHandler);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-6-4-执行PreparedStatementHandler的query-方法"><a href="#4-6-4-执行PreparedStatementHandler的query-方法" class="headerlink" title="4.6.4 执行PreparedStatementHandler的query()方法"></a>4.6.4 执行PreparedStatementHandler的query()方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">    PreparedStatement ps &#x3D; (PreparedStatement) statement;</span><br><span class="line">    &#x2F;&#x2F; 到了JDBC的流程</span><br><span class="line">    ps.execute();</span><br><span class="line">    &#x2F;&#x2F; 处理结果集</span><br><span class="line">    return resultSetHandler.handleResultSets(ps);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-6-5-ResultHandler处理结果集"><a href="#4-6-5-ResultHandler处理结果集" class="headerlink" title="4.6.5 ResultHandler处理结果集"></a>4.6.5 ResultHandler处理结果集</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resultSetHandler.handleResultSets(ps);</span><br></pre></td></tr></table></figure>

<p>怎么把ResultSet转换成List<ObJect>?</p>
<p><strong>ResultSetHandIer</strong>只有一个实现类：<strong>DefaultResultSetHandler</strong>也就是执行<br>DefaultResultSetHandler的<strong>handleResultSets</strong>()方法。首先我们会先拿到第一个结果集，如果没有配置一个查询返回多个结果集的情况，一般只有一个结果集。如果下面的这个while循环我们也不用，就执行一次。然后会调用<strong>handleResuItSet</strong>()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public List&lt;Object&gt; handleResultSets(Statement stmt) throws SQLException &#123;</span><br><span class="line">    ErrorContext.instance().activity(&quot;handling results&quot;).object(mappedStatement.getId());</span><br><span class="line"></span><br><span class="line">    final List&lt;Object&gt; multipleResults &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    int resultSetCount &#x3D; 0;</span><br><span class="line">    ResultSetWrapper rsw &#x3D; getFirstResultSet(stmt);</span><br><span class="line"></span><br><span class="line">    List&lt;ResultMap&gt; resultMaps &#x3D; mappedStatement.getResultMaps();</span><br><span class="line">    int resultMapCount &#x3D; resultMaps.size();</span><br><span class="line">    validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line">    while (rsw !&#x3D; null &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</span><br><span class="line">      ResultMap resultMap &#x3D; resultMaps.get(resultSetCount);</span><br><span class="line">      handleResultSet(rsw, resultMap, multipleResults, null);</span><br><span class="line">      rsw &#x3D; getNextResultSet(stmt);</span><br><span class="line">      cleanUpAfterHandlingResultSet();</span><br><span class="line">      resultSetCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] resultSets &#x3D; mappedStatement.getResultSets();</span><br><span class="line">    if (resultSets !&#x3D; null) &#123;</span><br><span class="line">      while (rsw !&#x3D; null &amp;&amp; resultSetCount &lt; resultSets.length) &#123;</span><br><span class="line">        ResultMapping parentMapping &#x3D; nextResultMaps.get(resultSets[resultSetCount]);</span><br><span class="line">        if (parentMapping !&#x3D; null) &#123;</span><br><span class="line">          String nestedResultMapId &#x3D; parentMapping.getNestedResultMapId();</span><br><span class="line">          ResultMap resultMap &#x3D; configuration.getResultMap(nestedResultMapId);</span><br><span class="line">          handleResultSet(rsw, resultMap, null, parentMapping);</span><br><span class="line">        &#125;</span><br><span class="line">        rsw &#x3D; getNextResultSet(stmt);</span><br><span class="line">        cleanUpAfterHandlingResultSet();</span><br><span class="line">        resultSetCount++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return collapseSingleResultList(multipleResults);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void handleResultSet(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Object&gt; multipleResults, ResultMapping parentMapping) throws SQLException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      if (parentMapping !&#x3D; null) &#123;</span><br><span class="line">        handleRowValues(rsw, resultMap, null, RowBounds.DEFAULT, parentMapping);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (resultHandler &#x3D;&#x3D; null) &#123;</span><br><span class="line">          DefaultResultHandler defaultResultHandler &#x3D; new DefaultResultHandler(objectFactory);</span><br><span class="line">          handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, null);</span><br><span class="line">          multipleResults.add(defaultResultHandler.getResultList());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          handleRowValues(rsw, resultMap, resultHandler, rowBounds, null);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      &#x2F;&#x2F; issue #228 (close resultsets)</span><br><span class="line">      closeResultSet(rsw.getResultSet());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://user-gold-cdn.xitu.io/2020/5/15/1721652a86370b3e?w=720&h=466&f=jpeg&s=51595" alt=""></h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/05/15/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%98%85%E8%AF%BBmybatis%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%EF%BC%8C%E6%8E%8C%E6%8F%A1%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/" data-id="ckacbh170000uknraa3lxgct6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试官口中的Mybatis，工作流程、架构分层与模块划分以及缓存机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/14/%E9%9D%A2%E8%AF%95%E5%AE%98%E5%8F%A3%E4%B8%AD%E7%9A%84Mybatis%EF%BC%8C%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E3%80%81%E6%9E%B6%E6%9E%84%E5%88%86%E5%B1%82%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86%E4%BB%A5%E5%8F%8A%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" class="article-date">
  <time datetime="2020-05-14T08:30:35.000Z" itemprop="datePublished">2020-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/14/%E9%9D%A2%E8%AF%95%E5%AE%98%E5%8F%A3%E4%B8%AD%E7%9A%84Mybatis%EF%BC%8C%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E3%80%81%E6%9E%B6%E6%9E%84%E5%88%86%E5%B1%82%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86%E4%BB%A5%E5%8F%8A%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/">面试官口中的Mybatis，工作流程、架构分层与模块划分以及缓存机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在我们平时的业务开发中，经常会使用“半自动化”的ORM框架Mybatis解决程序对数据库操作问题。MyBatis是一个Java持久化框架，它通过XML描述符或注解把对象与存储过程或SQL语句关联起来。MyBatis是在Apache许可证2.0下分发的自由软件，是iBATIS 3.0的分支版本。2001年开始开发的，是“internet”和“abtis（障碍物）”两个单词的组合。2004年捐赠给Apache，2010年更名为MyBatis。</p>
<p>对于MyBatis在java程序中的使用想必大家一定都比较清楚了，这里主要说说它的工作流程、架构分层与模块划分以及缓存机制。</p>
<h1 id="一、MyBatis的工作流程"><a href="#一、MyBatis的工作流程" class="headerlink" title="一、MyBatis的工作流程"></a>一、MyBatis的工作流程</h1><h2 id="1-1-解析配置文件（Configuration）"><a href="#1-1-解析配置文件（Configuration）" class="headerlink" title="1.1 解析配置文件（Configuration）"></a>1.1 解析配置文件（Configuration）</h2><p>mybatis启动的时候需要解析配置文件，包括全局配置文件和映射器配置文件，我们会把它们解析成一个Configuration对象。它包含了控制mybatis的行为以及对数据库下达的指令（SQL操作）。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720cadf26dc0fb1?w=1170&h=684&f=png&s=60901" alt=""></p>
<h2 id="1-2-提供操作接口（SqlSession）"><a href="#1-2-提供操作接口（SqlSession）" class="headerlink" title="1.2 提供操作接口（SqlSession）"></a>1.2 提供操作接口（SqlSession）</h2><p>应用程序与数据库进行连接是通过<strong>SqlSession</strong>对象完成的，如果需要获取一个会话，则需要通过会话工厂<strong>SqlSessionFactory</strong>接口来获取。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720cb4d24765ed0?w=903&h=723&f=png&s=45946" alt=""></p>
<p>通过建造者模式<strong>SqlSessionFactoryBuilder</strong>来创建一个工厂类，它包含所有配置文件的配置信息。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720cbae2332dcc2?w=1275&h=759&f=png&s=77410" alt=""></p>
<p><strong>SqlSession</strong>只是提供了一个接口，它还不是真正的操作数据库的SQL执行对象。</p>
<h2 id="1-3-执行SQL操作"><a href="#1-3-执行SQL操作" class="headerlink" title="1.3 执行SQL操作"></a>1.3 执行SQL操作</h2><p><strong>Executor</strong>接口用来封装对数据库的操作。调用其中query和update接口会创建一系列的对象，来处理参数、执行SQL、处理结果集，把它简化成一个对象接口就是<strong>StatementHandler</strong>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720cc5c5fe3bacd?w=1272&h=774&f=png&s=71911" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720cc6901975614?w=1044&h=660&f=png&s=41739" alt=""></p>
<p>简要的画一下MyBatis的工作流程图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720cf3d66fbec46?w=1008&h=1113&f=jpeg&s=102937" alt=""></p>
<h1 id="二、MyBatis的架构分层与模块划分"><a href="#二、MyBatis的架构分层与模块划分" class="headerlink" title="二、MyBatis的架构分层与模块划分"></a>二、MyBatis的架构分层与模块划分</h1><p>我们打开Mybatis的package，发现类似下面的结构：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720cd789fedb487?w=426&h=762&f=png&s=33468" alt=""><br>按照不同的功能职责，也可以分成不同的工作层次。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720cf2c68d193ce?w=1236&h=708&f=jpeg&s=190304" alt=""></p>
<h1 id="三、MyBatis的缓存"><a href="#三、MyBatis的缓存" class="headerlink" title="三、MyBatis的缓存"></a>三、MyBatis的缓存</h1><h2 id="3-1-缓存体系结构"><a href="#3-1-缓存体系结构" class="headerlink" title="3.1 缓存体系结构"></a>3.1 缓存体系结构</h2><p>Mybatis缓存的默认实现是<strong>PerpetualCache</strong>类，它是基于HashMap实现的。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720d014edda20f5?w=915&h=765&f=png&s=50014" alt=""></p>
<p><strong>PerpetualCache</strong>在Mybatis是基础缓存，但是缓存有额外的功能，比如策略回收、日志记录、定时刷新等等，如果需要使用这些功能，那么需要在基础缓存的基础上进行添加，需要的时候添加，不需要即可不用添加。在缓存cache包下，有很多装饰器模式的类实现了Cache接口，通过这些实现类可以实现很多缓存额外的功能。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720d0db0ca3a36b?w=1758&h=225&f=png&s=19663" alt=""></p>
<p>所有的缓存实现总体上可以分为三大类：基本缓存、淘汰算法缓存、装饰器缓存。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720d13d5a5214ef?w=1326&h=822&f=png&s=163943" alt=""></p>
<h2 id="3-2-一级缓存（Local-Cache）"><a href="#3-2-一级缓存（Local-Cache）" class="headerlink" title="3.2 一级缓存（Local Cache）"></a>3.2 一级缓存（Local Cache）</h2><p>Mybatis的一级缓存是存放在会话（<strong>SqlSession</strong>）层面的，一级缓存是默认开启的，不需要额外的配置，关闭的话设置<strong>localCacheScope</strong>的值为<strong>STATEMENT</strong>。源码的位置在<strong>BaseExecutor</strong>中，如下图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720d5285b143b74?w=1071&h=294&f=png&s=22388" alt=""><br>如果需要在同一个会话共享一级缓存的话，那么最好的办法是在SqlSession内创建会话对象，让其成为SqlSession的一个属性，这样的话就很方便的操作一级缓存了。在同一个会话里多次执行相同的SQL语句，会直接从内存拿到缓存的结果集，不会再去数据库进行操作。如果在不同的会话中，即使SQL语句一模一样，也不会使用一级缓存的。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720d77581caeddf?w=1113&h=448&f=jpeg&s=59003" alt=""></p>
<p><strong>一级缓存的验证方式</strong></p>
<p>判断是否命中缓存？如果第二次发送SQL并且到数据库中执行，则说明没有命中缓存；如果直接打印对象，则说明是从内存中获取到的结果。</p>
<p>测试一级缓存需要先关闭二级缓存，将<strong>LocalCacheScope</strong>设置为<strong>SESSION</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void testCache() throws IOException &#123;</span><br><span class="line">    String resource &#x3D; &quot;mybatis-config.xml&quot;;</span><br><span class="line">    InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);</span><br><span class="line">    SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">    SqlSession session1 &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">    SqlSession session2 &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;在同一个session中共享</span><br><span class="line">        BlogMapper mapper0 &#x3D; session1.getMapper(BlogMapper.class);</span><br><span class="line">        BlogMapper mapper1 &#x3D; session1.getMapper(BlogMapper.class);</span><br><span class="line">        Blog blog &#x3D; mapper0.selectBlogById(1);</span><br><span class="line">        System.out.println(blog);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;第二次查询，相同会话，获取到缓存了吗？&quot;);</span><br><span class="line">        System.out.println(mapper1.selectBlogById(1));</span><br><span class="line">        &#x2F;&#x2F;不同的session不能共享</span><br><span class="line">        System.out.println(&quot;第三次查询，不同会话，获取到缓存了吗？&quot;);</span><br><span class="line">        BlogMapper mapper2 &#x3D; session2.getMapper(BlogMapper.class);</span><br><span class="line">        System.out.println(mapper2.selectBlogById(1));</span><br><span class="line"></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        session1.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一级缓存在什么时候被清空失效的呢？<strong>在同一个session中update（包括delete）会导致一级缓存被清空。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void testCacheInvalid() throws IOException &#123;</span><br><span class="line">    String resource &#x3D; &quot;mybatis-config.xml&quot;;</span><br><span class="line">    InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);</span><br><span class="line">    SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">    SqlSession session &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">    try &#123;</span><br><span class="line">        BlogMapper mapper &#x3D; session.getMapper(BlogMapper.class);</span><br><span class="line">        System.out.println(mapper.selectBlogById(1));</span><br><span class="line"></span><br><span class="line">        Blog blog &#x3D; new Blog();</span><br><span class="line">        blog.setBid(1);</span><br><span class="line">        blog.setName(&quot;after modified 666&quot;);</span><br><span class="line">        mapper.updateByPrimaryKey(blog);</span><br><span class="line">        session.commit();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 相同会话执行了更新操作，缓存是否被清空？</span><br><span class="line">        System.out.println(&quot;在[同一个会话]执行更新操作之后，是否命中缓存？&quot;);</span><br><span class="line">        System.out.println(mapper.selectBlogById(1));</span><br><span class="line"></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一级缓存的工作范围是一个session中，如果跨session会出现什么问题呢？<strong>如果其它的session更新了数据，会导致读取到过时的数据（一级缓存不能跨session共享）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void testDirtyRead() throws IOException &#123;</span><br><span class="line">    String resource &#x3D; &quot;mybatis-config.xml&quot;;</span><br><span class="line">    InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);</span><br><span class="line">    SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">    SqlSession session1 &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">    SqlSession session2 &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">    try &#123;</span><br><span class="line">        BlogMapper mapper1 &#x3D; session1.getMapper(BlogMapper.class);</span><br><span class="line">        System.out.println(mapper1.selectBlogById(1));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 会话2更新了数据，会话2的一级缓存更新</span><br><span class="line">        Blog blog &#x3D; new Blog();</span><br><span class="line">        blog.setBid(1);</span><br><span class="line">        blog.setName(&quot;after modified 333333333333333333&quot;);</span><br><span class="line">        BlogMapper mapper2 &#x3D; session2.getMapper(BlogMapper.class);</span><br><span class="line">        mapper2.updateByPrimaryKey(blog);</span><br><span class="line">        session2.commit();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 其他会话更新了数据，本会话的一级缓存还在么？</span><br><span class="line">        System.out.println(&quot;会话1查到最新的数据了吗？&quot;);</span><br><span class="line">        System.out.println(mapper1.selectBlogById(1));</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        session1.close();</span><br><span class="line">        session2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一级缓存的不足之处</strong></p>
<p>一级缓存不能跨会话共享，不同的会话之间对于相同的数据可能有不同的缓存。在分布式环境（多会话）下，会存在查询到过时的数据的情况。如果有解决这个问题，那么需要引进工作范围更为广发的二级缓存。</p>
<h2 id="3-3-二级缓存"><a href="#3-3-二级缓存" class="headerlink" title="3.3 二级缓存"></a>3.3 二级缓存</h2><p>二级缓存的生命周期和应用同步，它是用来解决一级缓存不能跨会话共享数据的问题，范围是namespace级别的，可以被多个会话共享（只要是同一个接口的相同方法，都可以进行共享）。</p>
<p><strong>二级缓存的流程图：</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720e94cf8cced21?w=1113&h=601&f=jpeg&s=83476" alt=""></p>
<p>一级缓存是默认开始的，二级缓存如何开启呢？<br>1、在mybatis-config.xml中配置（默认是true）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 控制全局缓存（二级缓存），默认 true--&gt;</span><br><span class="line">&lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>只要没有显式地设置cacheEnabled为false，都会使用CachingExector装饰基本的执行器（SIMPLE、REUSE、BATCH）。<br><strong>二级缓存总是默认开启的，但是每个Mapper的二级开关是默认关闭的。</strong></p>
<p>2、在Mapper中配置cache标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 声明这个namespace使用二级缓存 --&gt;</span><br><span class="line">&lt;cache type&#x3D;&quot;org.apache.ibatis.cache.impl.PerpetualCache&quot;</span><br><span class="line">   size&#x3D;&quot;1024&quot;&lt;!-- 最多缓存对象个数，默认是1024 --&gt;</span><br><span class="line">   eviction&#x3D;&quot;LRU&quot;&lt;!-- 缓存策略 --&gt;</span><br><span class="line">   flushInterval&#x3D;&quot;120000&quot;&lt;!-- 自动刷新时间ms，未配置是只有调用时刷新 --&gt;</span><br><span class="line">   readOnly&#x3D;&quot;false&quot;&#x2F;&gt;&lt;!-- 默认是false（安全），改为true可读写时，对象必须支持序列化 --&gt;</span><br></pre></td></tr></table></figure>
<p><strong>Cache属性详解：</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/13/1720ebad5c692f36?w=1160&h=432&f=png&s=94894" alt=""></p>
<p>默认的回收内存策略是 LRU。可用的内存回收策略有：</p>
<ul>
<li>LRU – 最近最少使用：移除最长时间不被使用的对象。</li>
<li>FIFO – 先进先出：按对象进入缓存的顺序来移除它们。</li>
<li>SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。</li>
<li>WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。</li>
</ul>
<p>Mapper.xml 配置了cache之后，select()会被缓存。update()、delete()、insert()会刷新缓存。：如果cacheEnabled=true，Mapper.xml 没有配置标签，还有二级缓存吗？（没有）还会出现CachingExecutor 包装对象吗？（会）</p>
<p>只要cacheEnabled=true基本执行器就会被装饰。有没有配置cache，决定了在启动的时候会不会创建这个mapper的Cache对象，只是最终会影响到CachingExecutorquery 方法里面的判断。如果某些查询方法对数据的实时性要求很高，不需要二级缓存，怎么办？我们可以在单个Statement ID 上显式关闭二级缓存（默认是true）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;selectBlog&quot; resultMap&#x3D;&quot;BaseResultMap&quot; useCache&#x3D;&quot;false&quot;&gt;</span><br></pre></td></tr></table></figure>
<p><strong>二级缓存的验证方式</strong></p>
<p>1、事务不提交，二级缓存会写入吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void testCache() throws IOException &#123;</span><br><span class="line">    String resource &#x3D; &quot;mybatis-config.xml&quot;;</span><br><span class="line">    InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);</span><br><span class="line">    SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">    SqlSession session1 &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">    SqlSession session2 &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">    try &#123;</span><br><span class="line">        BlogMapper mapper1 &#x3D; session1.getMapper(BlogMapper.class);</span><br><span class="line">        System.out.println(mapper1.selectBlogById(1));</span><br><span class="line">        &#x2F;&#x2F; 事务不提交的情况下，二级缓存会写入吗？显然不会，为什么呢？</span><br><span class="line">        session1.commit();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;第二次查询&quot;);</span><br><span class="line">        BlogMapper mapper2 &#x3D; session2.getMapper(BlogMapper.class);</span><br><span class="line">        System.out.println(mapper2.selectBlogById(1));</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        session1.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为什么事务不提交，二级缓存不生效呢？</strong><br>因为二级缓存使用<strong>TransactionalCacheManager</strong>（TCM）来管理，最后又调用了TransactionalCache 的getObject()、putObject和commit()方法，TransactionalCache里面又持有了真正的Cache对象，比如是经过层层装饰的<strong>PerpetualCache</strong>。在putObject 的时候，只是添加到了entriesToAddOnCommit里面，<strong>只有它的commit()方法被调用的时候才会调用flushPendingEntries()真正写入缓存</strong>。它就是在<strong>DefaultSqlSession</strong> 调用<strong>commit</strong>()的时候被调用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void commit() &#123;</span><br><span class="line">    if (clearOnCommit) &#123;</span><br><span class="line">      delegate.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 真正写入二级缓存</span><br><span class="line">    flushPendingEntries();</span><br><span class="line">    reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void flushPendingEntries() &#123;</span><br><span class="line">   for (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) &#123;</span><br><span class="line">     delegate.putObject(entry.getKey(), entry.getValue());</span><br><span class="line">   &#125;</span><br><span class="line">   for (Object entry : entriesMissedInCache) &#123;</span><br><span class="line">     if (!entriesToAddOnCommit.containsKey(entry)) &#123;</span><br><span class="line">       delegate.putObject(entry, null);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在其它的会话中执行增删改操作，验证缓存被刷新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public void testCacheInvalid() throws IOException &#123;</span><br><span class="line">    String resource &#x3D; &quot;mybatis-config.xml&quot;;</span><br><span class="line">    InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);</span><br><span class="line">    SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">    SqlSession session1 &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">    SqlSession session2 &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">    SqlSession session3 &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">    try &#123;</span><br><span class="line">        BlogMapper mapper1 &#x3D; session1.getMapper(BlogMapper.class);</span><br><span class="line">        BlogMapper mapper2 &#x3D; session2.getMapper(BlogMapper.class);</span><br><span class="line">        BlogMapper mapper3 &#x3D; session3.getMapper(BlogMapper.class);</span><br><span class="line">        System.out.println(mapper1.selectBlogById(1));</span><br><span class="line">        session1.commit();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 是否命中二级缓存</span><br><span class="line">        System.out.println(&quot;是否命中二级缓存？&quot;);</span><br><span class="line">        System.out.println(mapper2.selectBlogById(1));</span><br><span class="line"></span><br><span class="line">        Blog blog &#x3D; new Blog();</span><br><span class="line">        blog.setBid(1);</span><br><span class="line">        blog.setName(&quot;2020年5月13日15:03:38&quot;);</span><br><span class="line">        mapper3.updateByPrimaryKey(blog);</span><br><span class="line">        session3.commit();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;更新后再次查询，是否命中二级缓存？&quot;);</span><br><span class="line">        &#x2F;&#x2F; 在其他会话中执行了更新操作，二级缓存是否被清空？</span><br><span class="line">        System.out.println(mapper2.selectBlogById(1));</span><br><span class="line"></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        session1.close();</span><br><span class="line">        session2.close();</span><br><span class="line">        session3.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么增删改操作会清空缓存？</strong><br>在<strong>CachingExecutor</strong>的update()方法里面会调用flushCacheIfRequired(ms)，<strong>isFlushCacheRequired</strong> 就是从标签里面渠道的flushCache 的值。而增删改操作的<strong>flushCache</strong> 属性默认为true。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void flushCacheIfRequired(MappedStatement ms) &#123;</span><br><span class="line">    Cache cache &#x3D; ms.getCache();</span><br><span class="line">    &#x2F;&#x2F; 增删改查的标签上有属性：flushCache&#x3D;&quot;true&quot; （select语句默认是false）</span><br><span class="line">    &#x2F;&#x2F; 一级二级缓存都会被清理</span><br><span class="line">    if (cache !&#x3D; null &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">      tcm.clear(cache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>什么时候开启二级缓存呢？</strong></p>
<p>一级缓存默认是打开的，二级缓存需要配置才可以开启。那么我们必须思考一个问题，在什么情况下才有必要去开启二级缓存？</p>
<p>因为所有的增删改都会刷新二级缓存，导致二级缓存失效，所以适合在查询为主的应用中使用，比如历史交易、历史订单的查询。否则缓存就失去了意义。如果多个namespace 中有针对于同一个表的操作，如果在一个namespace中刷新了缓存，另一个namespace中没有刷新，就会出现读到脏数据的情况。所以，推荐在一个Mapper 里面只操作单表的情况使用。如果要让多个namespace共享一个二级缓存，应该怎么做？跨namespace的缓存共享的问题，可以使用cache-ref配置来解决：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;cache-ref namespace&#x3D;&quot;com.sy.crud.dao.DepartmentMapper&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>　　cache-ref 代表引用别的命名空间的Cache配置，两个命名空间的操作使用的是同一个Cache。在关联的表比较少，或者按照业务可以对表进行分组的时候可以使用。</p>
<p>注意：在这种情况下，多个Mapper的操作都会引起缓存刷新，缓存的意义已经不大了</p>
<p><strong>第三方缓存做二级缓存</strong></p>
<p>除了MyBatis 自带的二级缓存之外，我们也可以通过实现Cache 接口来自定义二级缓存。MyBatis官方提供了一些第三方缓存集成方式，比如ehcache 和redis：</p>
<p><a href="https://github.com/mybatis/redis-cache" target="_blank" rel="noopener">https://github.com/mybatis/redis-cache</a> </p>
<p>当然，我们也可以使用独立的缓存服务，不使用MyBatis 自带的二级缓存。</p>
<p>pom文件引入的依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.caches&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0.0-beta2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<p>mapper.xml配置文件的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用Redis作为二级缓存 --&gt;</span><br><span class="line">   &lt;cache type&#x3D;&quot;org.mybatis.caches.redis.RedisCache&quot;</span><br><span class="line">          eviction&#x3D;&quot;FIFO&quot; flushInterval&#x3D;&quot;60000&quot; size&#x3D;&quot;512&quot; readOnly&#x3D;&quot;true&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>redis.properties配置文件内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">host&#x3D;localhost</span><br><span class="line">port&#x3D;6379</span><br><span class="line">connectionTimeout&#x3D;5000</span><br><span class="line">soTimeout&#x3D;5000</span><br><span class="line">database&#x3D;0</span><br></pre></td></tr></table></figure>

<p>当然，我们在分布式的环境中，也可以使用独立的缓存服务，不使用MyBatis自带的二级缓存。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/05/14/%E9%9D%A2%E8%AF%95%E5%AE%98%E5%8F%A3%E4%B8%AD%E7%9A%84Mybatis%EF%BC%8C%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E3%80%81%E6%9E%B6%E6%9E%84%E5%88%86%E5%B1%82%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86%E4%BB%A5%E5%8F%8A%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" data-id="ckacbh0gs000sknrafp5x3691" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="对于gof-23种设计模式的学习，我们需要掌握的是“道”，而不只是“术”" class="article article-type-对于gof" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/05/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%8C%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E6%98%AF%E2%80%9C%E9%81%93%E2%80%9D%EF%BC%8C%E8%80%8C%E4%B8%8D%E5%8F%AA%E6%98%AF%E2%80%9C%E6%9C%AF%E2%80%9D/" class="article-date">
  <time datetime="2020-05-05T07:45:53.000Z" itemprop="datePublished">2020-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/05/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%8C%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E6%98%AF%E2%80%9C%E9%81%93%E2%80%9D%EF%BC%8C%E8%80%8C%E4%B8%8D%E5%8F%AA%E6%98%AF%E2%80%9C%E6%9C%AF%E2%80%9D/">23种设计模式的学习，我们需要掌握的是“道”，而不只是“术”</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>设计模式是一门艺术，因为它们来源于生活，不要为了套用设计模式而去使用设计模式。我们在编写程序的时候用好设计模式可以防范于未然，它们可以很好地提供一种解决问题的方案。从古至今，我们在遇到问题的时候，都会去寻求帮助，咨询懂的人，或者去图书馆查阅资料，或者在电脑前面搜索，等等方法。在学习23种设计模式之前我们必然需要学习软件架构的设计原则，下面用一句话来概括这七大设计原则。</p>
<h1 id="一、一句话总结设计原则"><a href="#一、一句话总结设计原则" class="headerlink" title="一、一句话总结设计原则"></a>一、一句话总结设计原则</h1><p><img src="https://user-gold-cdn.xitu.io/2020/5/5/171e2f3498f43bac?w=1445&h=699&f=png&s=715467" alt=""></p>
<h1 id="二、设计模式简介"><a href="#二、设计模式简介" class="headerlink" title="二、设计模式简介"></a>二、设计模式简介</h1><p>建筑师克里斯托佛·亚历山大在1977/79年编制了一本汇集设计模式的书，但是这种设计模式的思想在建筑设计领域里的影响远没有后来在软件开发领域里传播的广泛。</p>
<p>肯特·贝克和沃德·坎宁安在1987年，利用克里斯托佛·亚历山大在建筑设计领域里的思想开发了设计模式并把此思想应用在Smalltalk中的图形用户接口（GUI）的生成中。一年后埃里希·伽玛在他的苏黎世大学博士毕业论文中开始尝试把这种思想改写为适用于软件开发。与此同时James Coplien 在1989年至1991年也在利用相同的思想致力于C++的开发，而后于1991年发表了他的著作Advanced C++ Programming Styles and Idioms。同年Erich Gamma 得到了博士学位，然后去了美国，在那与Richard Helm, Ralph Johnson ,John Vlissides 合作出版了《设计模式：可复用面向对象软件的基础》（Design Patterns - Elements of Reusable Object-Oriented Software） 一书，在此书中共收录了 23 种设计模式。</p>
<p>这四位作者在软件开发领域里以“四人帮”（英语，Gang of Four，简称GoF）而闻名，并且他们在此书中的协作导致了软件设计模式的突破。有时，GoF也会用于代指《设计模式》这本书。</p>
<p>设计模式是前人经验的总结，提供给后人去借鉴使用的，前人种树后人乘凉。它不但可以解决复杂的业务问题，也可以帮助我们提高代码的可读性、扩展性，降低维护成本。下面对GoF23种设计模式进行归纳和总结。</p>
<h2 id="2-1-创建型"><a href="#2-1-创建型" class="headerlink" title="2.1 创建型"></a>2.1 创建型</h2><p>创建型全部是关于如何创建实例的。这组范例可以被划分为两组：类创建范例及对象创建范例。类创建实例在实例化过程中有效的使用类之间的继承关系，对象创建范例则使用代理来完成其任务。</p>
<ul>
<li>抽象工厂 (Abstract Factory)</li>
<li>建造者 (Builder Pattern)</li>
<li>工厂方法 (Factory Method pattern)</li>
<li>原型 (Prototype pattern)</li>
<li>单例模式 (Singleton pattern)</li>
</ul>
<h2 id="2-2-结构型"><a href="#2-2-结构型" class="headerlink" title="2.2 结构型"></a>2.2 结构型</h2><p>这组都是关于类及对象复合关系的。</p>
<ul>
<li>适配器(Adapter pattern)</li>
<li>桥接(Bridge pattern)</li>
<li>组合(Composite pattern)</li>
<li>装饰器(Decorator pattern)</li>
<li>门面(Facade pattern)</li>
<li>享元(Flyweight pattern)</li>
<li>代理(Proxy pattern)</li>
</ul>
<h2 id="2-3-行为型"><a href="#2-3-行为型" class="headerlink" title="2.3 行为型"></a>2.3 行为型</h2><p>这组都是关于对象之间如何通讯的。</p>
<ul>
<li>职责链(Chain-of-responsibility pattern)</li>
<li>命令(Command pattern)</li>
<li>翻译器(Interpreter pattern)</li>
<li>迭代器(Iterator pattern)</li>
<li>中介者(Mediator pattern)</li>
<li>备忘录(Memento pattern)</li>
<li>观察者(Observer pattern)</li>
<li>状态(State pattern)</li>
<li>策略(Strategy pattern)</li>
<li>模板方法(Template method pattern)</li>
<li>访问者(Visitor)</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/5/171e3a5306ebdc3b?w=819&h=888&f=jpeg&s=147445" alt=""></p>
<h2 id="2-4-创建型使用频率"><a href="#2-4-创建型使用频率" class="headerlink" title="2.4 创建型使用频率"></a>2.4 创建型使用频率</h2><p><img src="https://user-gold-cdn.xitu.io/2020/5/5/171e37790660d323?w=1396&h=700&f=png&s=207945" alt=""></p>
<h2 id="2-5-结构型使用频率"><a href="#2-5-结构型使用频率" class="headerlink" title="2.5 结构型使用频率"></a>2.5 结构型使用频率</h2><p><img src="https://user-gold-cdn.xitu.io/2020/5/5/171e3785f71efd67?w=1366&h=766&f=png&s=226762" alt=""></p>
<h2 id="2-6-行为型使用频率"><a href="#2-6-行为型使用频率" class="headerlink" title="2.6 行为型使用频率"></a>2.6 行为型使用频率</h2><p><img src="https://user-gold-cdn.xitu.io/2020/5/5/171e37902da27f32?w=1705&h=727&f=png&s=319249" alt=""></p>
<h1 id="三、一句话总结设计模式"><a href="#三、一句话总结设计模式" class="headerlink" title="三、一句话总结设计模式"></a>三、一句话总结设计模式</h1><p><img src="https://user-gold-cdn.xitu.io/2020/5/5/171e3a1f10dc35df?w=1731&h=792&f=jpeg&s=168839" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/5/5/171e39ecef3d60f4?w=1701&h=756&f=png&s=707659" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/5/5/171e39b611a2ebb8?w=1674&h=858&f=jpeg&s=317182" alt=""></p>
<h1 id="四、设计模式之间的关系和对比"><a href="#四、设计模式之间的关系和对比" class="headerlink" title="四、设计模式之间的关系和对比"></a>四、设计模式之间的关系和对比</h1><h2 id="4-1-单例模式和工厂模式"><a href="#4-1-单例模式和工厂模式" class="headerlink" title="4.1 单例模式和工厂模式"></a>4.1 单例模式和工厂模式</h2><p>在实际业务中，通常把工厂类设计为单例模式。</p>
<h2 id="4-2-策略模式和工厂模式"><a href="#4-2-策略模式和工厂模式" class="headerlink" title="4.2 策略模式和工厂模式"></a>4.2 策略模式和工厂模式</h2><p>1、工厂模式包含工厂方法模式和抽象工厂模式，它是创建型模式，而策略模式是行为型模式；</p>
<p>2、工厂模式的目的是封装好创建逻辑，策略模式接收工厂创建好的对象，从而实现不同的行为。</p>
<h2 id="4-3-策略模式和委派模式"><a href="#4-3-策略模式和委派模式" class="headerlink" title="4.3 策略模式和委派模式"></a>4.3 策略模式和委派模式</h2><p>1、策略模式是委派模式内部的一种实现形式，策略模式关注的结构是否能够相互替代。</p>
<p>2、委派模式更关注分发和调度的过程。</p>
<h2 id="4-4-模板方法模式和工厂方法模式"><a href="#4-4-模板方法模式和工厂方法模式" class="headerlink" title="4.4 模板方法模式和工厂方法模式"></a>4.4 模板方法模式和工厂方法模式</h2><p>工厂方法是模板方法的一种特殊实现。</p>
<h2 id="4-5-模板方法模式和策略模式"><a href="#4-5-模板方法模式和策略模式" class="headerlink" title="4.5 模板方法模式和策略模式"></a>4.5 模板方法模式和策略模式</h2><p>1、模板方法模式和策略模式都有封装的算法；</p>
<p>2、策略模式是使不同的算法可以相互替换，且不影响客户端应用层的使用；</p>
<p>3、模板方法是针对定义一个算法的流程，将一些有细微差异的部分交给子类实现；</p>
<p>4、模板方法模式不能改变算法流程，策略模式可以改变算法流程且可以替换。策略模式通常用来代理if…else等分支条件语句。</p>
<h2 id="4-6-装饰者模式和静态代理模式"><a href="#4-6-装饰者模式和静态代理模式" class="headerlink" title="4.6 装饰者模式和静态代理模式"></a>4.6 装饰者模式和静态代理模式</h2><p>1、装饰者模式在于给对象动态添加方法，而代理更加关注控制对象的访问；</p>
<p>2、代理模式通常会在代理类中创建被代理对象的实例，而装饰者模式通常把装饰者作为构造行数。</p>
<h2 id="4-7-装饰者模式和适配器模式"><a href="#4-7-装饰者模式和适配器模式" class="headerlink" title="4.7 装饰者模式和适配器模式"></a>4.7 装饰者模式和适配器模式</h2><p>1、装饰者模式和适配器模式都属于包装器模式；</p>
<p>2、装饰者模式可以实现被装饰者与相同的接口或者继承被装饰者作为它的子类，而适配器和被适配着可以实现不同的接口。</p>
<h2 id="4-8-适配器模式和静态代理模式"><a href="#4-8-适配器模式和静态代理模式" class="headerlink" title="4.8 适配器模式和静态代理模式"></a>4.8 适配器模式和静态代理模式</h2><p>适配器模式可以结合静态代理来实现，保存被适配对象的引用，但不是唯一的实现方式；</p>
<h2 id="4-9-适配器模式和策略模式"><a href="#4-9-适配器模式和策略模式" class="headerlink" title="4.9 适配器模式和策略模式"></a>4.9 适配器模式和策略模式</h2><p>在适配业务复杂的情况下，利用策略模式优化动态适配逻辑。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/05/05/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%8C%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E6%98%AF%E2%80%9C%E9%81%93%E2%80%9D%EF%BC%8C%E8%80%8C%E4%B8%8D%E5%8F%AA%E6%98%AF%E2%80%9C%E6%9C%AF%E2%80%9D/" data-id="ckacbgzq00000knra8zig32vz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-深度阅读Spring5-x源码后，使用Java实现迷你版Spring的基本思路实践" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/05/%E6%B7%B1%E5%BA%A6%E9%98%85%E8%AF%BBSpring5-x%E6%BA%90%E7%A0%81%E5%90%8E%EF%BC%8C%E4%BD%BF%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E8%BF%B7%E4%BD%A0%E7%89%88Spring%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF%E5%AE%9E%E8%B7%B5/" class="article-date">
  <time datetime="2020-04-05T12:33:42.000Z" itemprop="datePublished">2020-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/05/%E6%B7%B1%E5%BA%A6%E9%98%85%E8%AF%BBSpring5-x%E6%BA%90%E7%A0%81%E5%90%8E%EF%BC%8C%E4%BD%BF%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E8%BF%B7%E4%BD%A0%E7%89%88Spring%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF%E5%AE%9E%E8%B7%B5/">深度阅读Spring5.x源码后，使用Java实现迷你版Spring的基本思路实践</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>看过Spring5源码的同学们，一开始肯定会边看边去用断点进行源码调试，调试来调试去时间长了肯定会晕车的，最有效的方式是先猜测后进行验证，当然猜测是建立在对阅读源码相当有经验的基础上的，否则也是一头雾水。对于使用很长时间Spring框架的开发者来说，应该对其架构和结构不会太陌生，可以大胆地进行猜测。</p>
<p>根据源码猜测，整理了迷你版Spring的基本实现思路，如下图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/5/17148ecb3282078e?w=1729&h=661&f=png&s=303698" alt=""></p>
<h1 id="一、web-xml配置文件"><a href="#一、web-xml配置文件" class="headerlink" title="一、web.xml配置文件"></a>一、web.xml配置文件</h1><p>所有依赖于Web容器的项目，基本都是从web.xml文件开始的，首先我们先配置好web.xml的文件内容，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;</span><br><span class="line">         version&#x3D;&quot;4.0&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;display-name&gt;mini-spring&lt;&#x2F;display-name&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;symvc&lt;&#x2F;servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;com.sy.sa.framework.servlet.SyDispatcherServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">            &lt;param-value&gt;application.properties&lt;&#x2F;param-value&gt;</span><br><span class="line">        &lt;&#x2F;init-param&gt;</span><br><span class="line"></span><br><span class="line">        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;</span><br><span class="line">    &lt;&#x2F;servlet&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;symvc&lt;&#x2F;servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">    &lt;&#x2F;servlet-mapping&gt;</span><br><span class="line">    </span><br><span class="line">&lt;&#x2F;web-app&gt;</span><br></pre></td></tr></table></figure>
<p>SyDispatcherServlet是模拟的Spring实现的核心类，后面会讲解具体的实现源码的。</p>
<h1 id="二、配置application-properties"><a href="#二、配置application-properties" class="headerlink" title="二、配置application.properties"></a>二、配置application.properties</h1><p>无论是xml、properties、yml都是配置文件的表现形式，无论格式怎样变化，其表现的内容大致上是没有什么变化的。具体的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scanPackage&#x3D;com.sy.sa</span><br></pre></td></tr></table></figure>

<h1 id="三、自定义注解Annotation"><a href="#三、自定义注解Annotation" class="headerlink" title="三、自定义注解Annotation"></a>三、自定义注解Annotation</h1><h2 id="3-1-SyAutoWired"><a href="#3-1-SyAutoWired" class="headerlink" title="3.1 @SyAutoWired"></a>3.1 @SyAutoWired</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.sy.sa.framework.annotation;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line">@Target(&#123;ElementType.FIELD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface SyAutoWired &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-SyController"><a href="#3-2-SyController" class="headerlink" title="3.2 @SyController"></a>3.2 @SyController</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.sy.sa.framework.annotation;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface SyController &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-SyRequestMapping"><a href="#3-3-SyRequestMapping" class="headerlink" title="3.3 @SyRequestMapping"></a>3.3 @SyRequestMapping</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.sy.sa.framework.annotation;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface SyRequestMapping &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-SyRequestParam"><a href="#3-4-SyRequestParam" class="headerlink" title="3.4 @SyRequestParam"></a>3.4 @SyRequestParam</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.sy.sa.framework.annotation;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line">@Target(&#123;ElementType.PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface SyRequestParam &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-SyService"><a href="#3-5-SyService" class="headerlink" title="3.5 @SyService"></a>3.5 @SyService</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.sy.sa.framework.annotation;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface SyService &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、配置注解Annotation"><a href="#四、配置注解Annotation" class="headerlink" title="四、配置注解Annotation"></a>四、配置注解Annotation</h1><h2 id="4-1-IDemoService接口"><a href="#4-1-IDemoService接口" class="headerlink" title="4.1 IDemoService接口"></a>4.1 IDemoService接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface IDemoService &#123;</span><br><span class="line"></span><br><span class="line">    String get(String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-DemoServiceImpl实现类"><a href="#4-2-DemoServiceImpl实现类" class="headerlink" title="4.2 DemoServiceImpl实现类"></a>4.2 DemoServiceImpl实现类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class DemoService implements IDemoService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String get(String name) &#123;</span><br><span class="line">        return &quot;Hello World, [&quot; + name + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-DemoController类"><a href="#4-3-DemoController类" class="headerlink" title="4.3 DemoController类"></a>4.3 DemoController类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@SyController</span><br><span class="line">@SyRequestMapping(&quot;&#x2F;sy&quot;)</span><br><span class="line">public class DemoController &#123;</span><br><span class="line"></span><br><span class="line">    @SyAutoWired</span><br><span class="line">    private IDemoService demoService;</span><br><span class="line"></span><br><span class="line">    @SyRequestMapping(&quot;&#x2F;query&quot;)</span><br><span class="line">    public void query(HttpServletRequest request, HttpServletResponse response,</span><br><span class="line">                      @SyRequestParam(&quot;name&quot;) String name) &#123;</span><br><span class="line">        String result &#x3D; demoService.get(name);</span><br><span class="line">        try&#123;</span><br><span class="line">            response.getWriter().write(result);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、自定义SyDispatcherServlet的实现"><a href="#五、自定义SyDispatcherServlet的实现" class="headerlink" title="五、自定义SyDispatcherServlet的实现"></a>五、自定义SyDispatcherServlet的实现</h1><h2 id="5-1-覆盖实现HttpServlet中的init-方法"><a href="#5-1-覆盖实现HttpServlet中的init-方法" class="headerlink" title="5.1 覆盖实现HttpServlet中的init()方法"></a>5.1 覆盖实现HttpServlet中的init()方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * mini-spring的第一步初始化阶段</span><br><span class="line"> * @param config</span><br><span class="line"> * @throws ServletException</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public void init(ServletConfig config) throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;1.加载application.properties配置文件</span><br><span class="line">    doLoadConfig(config.getInitParameter(&quot;contextConfigLocation&quot;));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;2.扫描对应包下的所有类</span><br><span class="line">    doScanner(contextConfig.getProperty(&quot;scanPackage&quot;));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;3.初始化扫描到的类，并将它们放入到IoC容器中</span><br><span class="line">    doInstance();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;4.完成DI依赖注入</span><br><span class="line">    doAutowried();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;5.初始化HandlerMapping</span><br><span class="line">    initHandlerMapping();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;Sy Spring framework is init.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 初始化url和Method的一一对应的关系</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void initHandlerMapping() &#123;</span><br><span class="line">    if(ioc.isEmpty()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (Map.Entry&lt;String, Object&gt; entry : ioc.entrySet()</span><br><span class="line">         ) &#123;</span><br><span class="line">        Class&lt;?&gt; clazz &#x3D; entry.getValue().getClass();</span><br><span class="line">        if(!clazz.isAnnotationPresent(SyController.class)) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        String baseUrl &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        if(clazz.isAnnotationPresent(SyRequestMapping.class)) &#123;</span><br><span class="line">            SyRequestMapping requestMapping &#x3D; clazz.getAnnotation(SyRequestMapping.class);</span><br><span class="line">            baseUrl &#x3D; requestMapping.value();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;获取所有的public方法</span><br><span class="line">        for (Method method :</span><br><span class="line">             clazz.getMethods()) &#123;</span><br><span class="line">            if(method.isAnnotationPresent(SyRequestMapping.class)) &#123;</span><br><span class="line">                SyRequestMapping requestMapping &#x3D; method.getAnnotation(SyRequestMapping.class);</span><br><span class="line">                &#x2F;&#x2F; &#x2F;&#x2F;sy&#x2F;&#x2F;&#x2F;query</span><br><span class="line">                String regex &#x3D; (&quot;&#x2F;&quot; + baseUrl + &quot;&#x2F;&quot; + requestMapping.value())</span><br><span class="line">                        .replaceAll(&quot;&#x2F;+&quot;,&quot;&#x2F;&quot;);</span><br><span class="line">                Pattern pattern &#x3D; Pattern.compile(regex);</span><br><span class="line"></span><br><span class="line">                handlerMapping.add(new Handler(pattern, entry.getValue(), method));</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;Mapped :&quot; + pattern + &quot;,&quot; + method);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 将容器中的类进行依赖注入</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void doAutowried() &#123;</span><br><span class="line"></span><br><span class="line">    if(ioc.isEmpty()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (Map.Entry&lt;String, Object&gt; entry:</span><br><span class="line">         ioc.entrySet()) &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Declared 所有的，特定的 字段，包括private&#x2F;protected&#x2F;default</span><br><span class="line">         * 正常来说，普通的OOP编程只能拿到public的属性</span><br><span class="line">         *&#x2F;</span><br><span class="line">        Field[] fields &#x3D; entry.getValue().getClass().getDeclaredFields();</span><br><span class="line">        for(Field field: fields) &#123;</span><br><span class="line">            if(!field.isAnnotationPresent(SyAutoWired.class)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            SyAutoWired autoWired &#x3D; field.getAnnotation(SyAutoWired.class);</span><br><span class="line">            String beanName &#x3D; autoWired.value().trim();</span><br><span class="line">            if(&quot;&quot;.equals(beanName)) &#123;</span><br><span class="line">                &#x2F;&#x2F;获得接口的类型，作为key待会拿这个key到ioc容器中去取值</span><br><span class="line">                beanName &#x3D; field.getType().getName();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;**</span><br><span class="line">             * 如果是public以外的修饰符，只要加了@Autowired注解，都要强制赋值</span><br><span class="line">             * 反射中叫做暴力访问， 强吻</span><br><span class="line">             *&#x2F;</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                field.set(entry.getValue(), ioc.get(beanName));</span><br><span class="line">            &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 初始化类放入IoC容器中，为依赖注入做准备</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void doInstance() &#123;</span><br><span class="line">    if (classNames.isEmpty()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (String className :</span><br><span class="line">                classNames) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz &#x3D; Class.forName(className);</span><br><span class="line">            &#x2F;&#x2F;根据注解实例化对应的类</span><br><span class="line">            if(clazz.isAnnotationPresent(SyController.class)) &#123;</span><br><span class="line">                Object instance &#x3D; clazz.newInstance();</span><br><span class="line">                &#x2F;&#x2F;Spring默认类名首字母小写</span><br><span class="line">                String beanName &#x3D; this.toLowerFirstCase(clazz.getSimpleName());</span><br><span class="line">                &#x2F;&#x2F;获取到的类的实例放入到IoC容器中</span><br><span class="line">                ioc.put(beanName, instance);</span><br><span class="line">            &#125;else if(clazz.isAnnotationPresent(SyService.class)) &#123;</span><br><span class="line">                &#x2F;&#x2F;1、自定义的beanName</span><br><span class="line">                SyService service &#x3D; clazz.getAnnotation(SyService.class);</span><br><span class="line">                String beanName &#x3D; service.value();</span><br><span class="line">                &#x2F;&#x2F;2、默认类名首字母小写</span><br><span class="line">                if(&quot;&quot;.equals(beanName.trim())) &#123;</span><br><span class="line">                    beanName &#x3D; toLowerFirstCase(clazz.getSimpleName());</span><br><span class="line">                &#125;</span><br><span class="line">                Object instance &#x3D; clazz.newInstance();</span><br><span class="line">                ioc.put(beanName, instance);</span><br><span class="line">                &#x2F;&#x2F;3、根据类型自动赋值,投机取巧的方式</span><br><span class="line">                for (Class&lt;?&gt; cls:</span><br><span class="line">                clazz.getInterfaces()) &#123;</span><br><span class="line">                    if(ioc.containsKey(cls.getName())) &#123;</span><br><span class="line">                        throw new Exception(&quot;The “&quot; + cls.getName() + &quot;” is exists!!&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;把接口的类型直接当成key了</span><br><span class="line">                    ioc.put(cls.getName(), instance);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;catch (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (InstantiationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 根据包路径扫描相关的类</span><br><span class="line"> * @param scanPackage</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void doScanner(String scanPackage) &#123;</span><br><span class="line">    &#x2F;&#x2F;将包路径中的“.”替换为“&#x2F;”</span><br><span class="line">    URL url &#x3D; this.getClass().getClassLoader().getResource(&quot;&#x2F;&quot; +</span><br><span class="line">            scanPackage.replaceAll(&quot;\\.&quot;, &quot;&#x2F;&quot;));</span><br><span class="line">    File classPath &#x3D; new File(url.getFile());</span><br><span class="line">    for (File file : classPath.listFiles()</span><br><span class="line">         ) &#123;</span><br><span class="line">        if(file.isDirectory()) &#123;</span><br><span class="line">            doScanner(scanPackage + &quot;.&quot; + file.getName());</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            if(!file.getName().endsWith(&quot;.class&quot;)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            String className &#x3D; (scanPackage + &quot;.&quot;</span><br><span class="line">                    + file.getName().replace(&quot;.class&quot;, &quot;&quot;));</span><br><span class="line">            &#x2F;&#x2F;将完整类名保存到List中</span><br><span class="line">            classNames.add(className);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 加载配置文件application.properties，放到properties中</span><br><span class="line"> * @param contextConfigLocation</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void doLoadConfig(String contextConfigLocation) &#123;</span><br><span class="line">    InputStream is &#x3D; this.getClass().getClassLoader().getResourceAsStream(contextConfigLocation);</span><br><span class="line">    try &#123;</span><br><span class="line">        contextConfig.load(is);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if(null !&#x3D; is) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 将类名首字母变成小写字母</span><br><span class="line"> * @param simpleName</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">private String toLowerFirstCase(String simpleName) &#123;</span><br><span class="line">    char[] chars &#x3D; simpleName.toCharArray();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 之所以加，是因为大小写字母的ASCII码相差32，</span><br><span class="line">     * 而且大写字母的ASCII码要小于小写字母的ASCII码</span><br><span class="line">     * 在Java中对char做算学运算，实际上就是对ASCII码做算学运算</span><br><span class="line">     *&#x2F;</span><br><span class="line">    chars[0] +&#x3D;  32;</span><br><span class="line">    return String.valueOf(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-Handler类"><a href="#5-2-Handler类" class="headerlink" title="5.2 Handler类"></a>5.2 Handler类</h2><p>保存url和method的对应关系，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">package com.sy.sa.framework.handler;</span><br><span class="line"></span><br><span class="line">import com.sy.sa.framework.annotation.SyRequestParam;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.lang.annotation.Annotation;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 保存一个url和一个method的关系</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Handler &#123;</span><br><span class="line"></span><br><span class="line">    private Pattern pattern;</span><br><span class="line">    private Method method;</span><br><span class="line">    private Object controller;</span><br><span class="line">    private Class&lt;?&gt;[] paramTypes;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 形参列表</span><br><span class="line">     * 参数的名字作为key，参数的顺序，位置作为值</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Map&lt;String, Integer&gt; paramIndexMapping;</span><br><span class="line"></span><br><span class="line">    public Pattern getPattern() &#123;</span><br><span class="line">        return pattern;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Method getMethod() &#123;</span><br><span class="line">        return method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getController() &#123;</span><br><span class="line">        return controller;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Class&lt;?&gt;[] getParamTypes() &#123;</span><br><span class="line">        return paramTypes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Handler(Pattern pattern, Object controller, Method method) &#123;</span><br><span class="line">        this.pattern &#x3D; pattern;</span><br><span class="line">        this.method &#x3D; method;</span><br><span class="line">        this.controller &#x3D; controller;</span><br><span class="line"></span><br><span class="line">        paramTypes &#x3D; method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">        paramIndexMapping &#x3D; new HashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">        this.putParamIndexMapping(method);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void putParamIndexMapping(Method method) &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 根据方法得到注解是一个二维数组</span><br><span class="line">         * 一个参数可以有多个注解，而一个方法又有多个参数</span><br><span class="line">         *&#x2F;</span><br><span class="line">        Annotation[][] result &#x3D; method.getParameterAnnotations();</span><br><span class="line">        for(int i &#x3D; 0; i &lt; result.length; i++) &#123;</span><br><span class="line">            for (Annotation annotation : result[i]) &#123;</span><br><span class="line">                if(annotation instanceof SyRequestParam) &#123;</span><br><span class="line">                    String paramName &#x3D; ((SyRequestParam) annotation).value();</span><br><span class="line">                    if(!&quot;&quot;.equals(paramName.trim())) &#123;</span><br><span class="line">                        paramIndexMapping.put(paramName, i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 提取方法中的request、response参数</span><br><span class="line">         *&#x2F;</span><br><span class="line">        Class&lt;?&gt;[] paramTypes &#x3D; method.getParameterTypes();</span><br><span class="line">        for(int i &#x3D; 0 ; i &lt; paramTypes.length; i++) &#123;</span><br><span class="line">            Class&lt;?&gt; type &#x3D; paramTypes[i];</span><br><span class="line">            if(type &#x3D;&#x3D; HttpServletRequest.class ||</span><br><span class="line">                        type &#x3D;&#x3D; HttpServletResponse.class) &#123;</span><br><span class="line">                paramIndexMapping.put(type.getName(), i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-doPost-doGet-方法"><a href="#5-3-doPost-doGet-方法" class="headerlink" title="5.3 doPost()/doGet()方法"></a>5.3 doPost()/doGet()方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"> @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        this.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">    &#x2F;&#x2F;6、调用，运行阶段</span><br><span class="line">    try &#123;</span><br><span class="line">        doDispatch(req,resp);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        resp.getWriter().write(&quot;500 Exection,Detail : &quot; + Arrays.toString(e.getStackTrace()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doDispatch(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123;</span><br><span class="line">    Handler handler &#x3D; this.getHandler(req);</span><br><span class="line">    if(handler &#x3D;&#x3D; null) &#123;</span><br><span class="line">        resp.getWriter().write(&quot;404 Not Found!!!&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Integer&gt; paramIndexMapping &#x3D; handler.getParamIndexMapping();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获得方法的形参列表</span><br><span class="line">    Class&lt;?&gt; [] paramTypes &#x3D; handler.getParamTypes();</span><br><span class="line"></span><br><span class="line">    Object [] paramValues &#x3D; new Object[paramTypes.length];</span><br><span class="line"></span><br><span class="line">    Map&lt;String,String[]&gt; params &#x3D; req.getParameterMap();</span><br><span class="line">    for (Map.Entry&lt;String, String[]&gt; parm : params.entrySet()) &#123;</span><br><span class="line">        String value &#x3D; Arrays.toString(parm.getValue()).replaceAll(&quot;\\[|\\]&quot;,&quot;&quot;)</span><br><span class="line">                .replaceAll(&quot;\\s&quot;,&quot;,&quot;);</span><br><span class="line">        if(!paramIndexMapping.containsKey(parm.getKey()))&#123;continue;&#125;</span><br><span class="line"></span><br><span class="line">        int index &#x3D; paramIndexMapping.get(parm.getKey());</span><br><span class="line">        paramValues[index] &#x3D; convert(paramTypes[index],value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(paramIndexMapping.containsKey(HttpServletRequest.class.getName())) &#123;</span><br><span class="line">        int reqIndex &#x3D; paramIndexMapping.get(HttpServletRequest.class.getName());</span><br><span class="line">        paramValues[reqIndex] &#x3D; req;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(paramIndexMapping.containsKey(HttpServletResponse.class.getName())) &#123;</span><br><span class="line">        int respIndex &#x3D; paramIndexMapping.get(HttpServletResponse.class.getName());</span><br><span class="line">        paramValues[respIndex] &#x3D; resp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object returnValue &#x3D; handler.getMethod().invoke(handler.getController(),paramValues);</span><br><span class="line">    if(returnValue &#x3D;&#x3D; null || returnValue instanceof Void)&#123; return; &#125;</span><br><span class="line">    resp.getWriter().write(returnValue.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doPost()方法中使用了委派模式，委派模式的代码逻辑在doDispath()方法中。</p>
<p>至此，迷你版Spring的基本思路代码实践就完成了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/04/05/%E6%B7%B1%E5%BA%A6%E9%98%85%E8%AF%BBSpring5-x%E6%BA%90%E7%A0%81%E5%90%8E%EF%BC%8C%E4%BD%BF%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E8%BF%B7%E4%BD%A0%E7%89%88Spring%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF%E5%AE%9E%E8%B7%B5/" data-id="ckacbh0fn000kknraack8462i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，23种设计模式中最为复杂的访问者模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/30/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E6%9C%80%E4%B8%BA%E5%A4%8D%E6%9D%82%E7%9A%84%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-03-30T03:37:03.000Z" itemprop="datePublished">2020-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/30/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E6%9C%80%E4%B8%BA%E5%A4%8D%E6%9D%82%E7%9A%84%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，23种设计模式中最为复杂的访问者模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>访问者模式（Visitor Pattern）是一种将数据结构和数据操作分离的设计模式。是指封装一些作用于某种数据结构中的各种元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。</p>
<p>访问者模式被称为最复杂的设计模式，并且使用频率不高，设计模式的作者也评价为：大多情况下，你不需要使用访问者模式，但是一旦需要使用它时，那就真的需要使用了。访问者模式的基本思想是，针对系统中拥有固定类型数的对象结构（元素），在其内提供一个accept()方法用来接受访问者对象的访问。不同的访问者对同一元素的访问内容不同，使得相同的元素集合可以产生不同的数据结果。accept()方法可以接收不同的访问者对象，然后在内部将自己（元素）转发到接收到的访问者对象的visit()方法内。访问者内部对应类型的visit()方法就会得到回调执行，对元素进行操作。也就是通过两次动态分发（第一次是对访问者的分发accept()方法，第二次是对元素的分发visit()方法），才最终将一个具体的元素传递到一个具体的访问者。如此一来，就解耦了数据结构与操作，且数据操作不会改变元素状态。</p>
<h1 id="一、访问者模式的应用场景"><a href="#一、访问者模式的应用场景" class="headerlink" title="一、访问者模式的应用场景"></a>一、访问者模式的应用场景</h1><p>访问者模式在生活场景中也是非常当多的，例如每年年底的KPI考核，KPI考核标准是相对稳定的，但是参与KPI考核的员工可能每年都会发生变化，那么员工就是访问者。我们平时去食堂或者餐厅吃饭，餐厅的菜单和就餐方式是相对稳定的，但是去餐厅就餐的人员是每天都在发生变化的，因此就餐人员就是访问者。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/29/17124e40cf3045f9?w=600&h=327&f=png&s=121106" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/3/29/17124e533c17755f?w=480&h=359&f=png&s=308415" alt=""></p>
<p>访问者模式的核心是，解耦数据结构与数据操作，使得对元素的操作具备优秀的扩展性。可以通过扩展不同的数据操作类型（访问者）实现对相同元素的不同的操作。简而言之就是对集合中的不同类型数据（类型数量稳定）进行多种操作，则使用访问者模式。</p>
<p>访问者模式的应用场景适用于以下几个场景：</p>
<ul>
<li>数据结构稳定，作用于数据结构的操作经常变化的场景；</li>
<li>需要数据结构与数据操作呢分离的场景；</li>
<li>需要对不同数据类型（元素）进行操作，而不使用分支判断具体类型的场景。</li>
</ul>
<p>访问者模式主要包含五种角色：</p>
<ul>
<li>抽象访问者（Visitor)：接口或抽象类，该类地冠以了对每一个具体元素（Element）的访问行为visit()方法，其参数就是具体的元素（Element）对象。理论上来说，Visitor的方法个数与元素（Element）个数是相等的。如果元素（Element）个数经常变动，会导致Visitor的方法也要进行变动，此时，该情形并不适用访问者模式；</li>
<li>具体访问者（ConcreteVisitor）：实现对具体元素的操作；</li>
<li>抽象元素（Element）：接囗或抽象类，定义了一个接受访问者访问的方法accept()表示所有元素类型都支持被访问者访问；</li>
<li>具体元素（ConcreteElement）：具体元素类型，提供接受访问者的具体实现。通常的实现都为：visitor.visit(this)；</li>
<li>结构对象（ObjectStructure）：内部维护了元素集合，并提供方法接受访问者对该集合所有元素进行操作。</li>
</ul>
<h2 id="1-1-利用访问者模式实现公司KPI考核"><a href="#1-1-利用访问者模式实现公司KPI考核" class="headerlink" title="1.1 利用访问者模式实现公司KPI考核"></a>1.1 利用访问者模式实现公司KPI考核</h2><p>每到年底，公司的管理层就要开始评定员工一年的工作绩效了，管理层有CEO和CTO，那么CEO关注的是工程师的KPI和经理的KPI以及新产品的数量，而CTO关心的是工程师的代码量、经理的新产品数量。</p>
<p>由于CEO和CTO对于不同员工的关注点是不一样的，这就需要对不同的员工类型进行不同的处理。此时访问者模式就派上用场了。下面来看下具体的代码实现，首先创建员工Employee类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Employee &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private int kpi;</span><br><span class="line"></span><br><span class="line">    public Employee(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.kpi &#x3D; new Random().nextInt(10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 接收访问者的访问</span><br><span class="line">     * @param visitor</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public abstract void accept(IVisitor visitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Employee类的accept()方法表示接受访问者的访问，由具体的子类实现。<strong>访问者是一个接口，传入不同的实现类，可以访问不同的数据。</strong> 分别创建工程师Engineer类和经理Manager类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Engineer extends Employee &#123;</span><br><span class="line">    public Engineer(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void accept(IVisitor visitor) &#123;</span><br><span class="line">        visitor.visit(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getCodeLines() &#123;</span><br><span class="line">        return new Random().nextInt(10 * 10000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Manager extends Employee &#123;</span><br><span class="line">    public Manager(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void accept(IVisitor visitor) &#123;</span><br><span class="line">        visitor.visit(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getPrducts() &#123;</span><br><span class="line">        return new Random().nextInt(10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工程师考核的是代码数量，经理考核的是产品数量，二者的职责不一样。也正是因为有这样的差异性，才使得访问模式能够在这个场景下发挥作用。将这些员工添加到一个业务报表类中，公司高层可以通过该报表类的showReport()方法查看所有员工的绩效，创建BusinessReport类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class BusinessReport &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;Employee&gt; employeeList &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public BusinessReport() &#123;</span><br><span class="line">        employeeList.add(new Engineer(&quot;工程师1&quot;));</span><br><span class="line">        employeeList.add(new Engineer(&quot;工程师2&quot;));</span><br><span class="line">        employeeList.add(new Engineer(&quot;工程师3&quot;));</span><br><span class="line">        employeeList.add(new Engineer(&quot;工程师4&quot;));</span><br><span class="line"></span><br><span class="line">        employeeList.add(new Manager(&quot;产品经理1&quot;));</span><br><span class="line">        employeeList.add(new Manager(&quot;产品经理2&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * @param visitor 公司高层，如CEO，CTO</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void showReport(IVisitor visitor) &#123;</span><br><span class="line">        for(Employee employee : employeeList) &#123;</span><br><span class="line">            employee.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义访问者类型，创建接口IVisitor，访问者声明了两个visit()方法，分别针对工程师和经理，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface IVisitor &#123;</span><br><span class="line"></span><br><span class="line">    void visit(Engineer engineer);</span><br><span class="line"></span><br><span class="line">    void visit(Manager manager);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体访问者CEOVisitor和CTOVisitor类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class CEOVisitor implements IVisitor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void visit(Engineer engineer) &#123;</span><br><span class="line">        System.out.println(&quot;工程师：&quot; + engineer.name + &quot;, KPI：&quot; + engineer.kpi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void visit(Manager manager) &#123;</span><br><span class="line">        System.out.println(&quot;经理：&quot; + manager.name + &quot;, KPI：&quot; + manager.kpi +</span><br><span class="line">                            &quot;, 新产品数量&quot; + manager.getPrducts() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class CTOVisitor implements IVisitor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void visit(Engineer engineer) &#123;</span><br><span class="line">        System.out.println(&quot;工程师：&quot; + engineer.name + &quot;, 代码数量：&quot; + engineer.getCodeLines());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void visit(Manager manager) &#123;</span><br><span class="line">        System.out.println(&quot;经理：&quot; + manager.name +</span><br><span class="line">                            &quot;, 新产品数量&quot; + manager.getPrducts() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    BusinessReport businessReport &#x3D; new BusinessReport();</span><br><span class="line">    businessReport.showReport(new CEOVisitor());</span><br><span class="line">    businessReport.showReport(new CTOVisitor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/29/171256fdfa21be22?w=721&h=556&f=png&s=46852" alt=""><br>在上述的案例中，Employee扮演了Element角色，而Engineer和Manager都是ConcreteElement；CEOVisitor和CTOVisitor都是具体的Visitor对象；而BusinessReport就是ObjectStructure。</p>
<p>访问者模式最大的优点就是增加访问者非常容，我们从代码中可以看到，如果要增加一访问者，只要新实现一个访问者接口的类，从而达到数据对象与数据操作相分离的效果。如果不实用访问者模式而又不想对不同的元素进行不同的操作，那么必定需要使用if-else和类型转换，这使得代码唯以升级维护。</p>
<p>我们要根据具体情况来评估是否适合使用访问者模式，例如，我们的对象结构是否足够稳定是否需要经常定义新的操作，使用访问者模式是否能优化我们的代码而不是使我们的代码变得更复杂。</p>
<h2 id="1-2-从静态分派到动态分派"><a href="#1-2-从静态分派到动态分派" class="headerlink" title="1.2 从静态分派到动态分派"></a>1.2 从静态分派到动态分派</h2><p><strong>变量被声明时的类型叫做变量的静态类型（Static Type），有些人把静态类型叫做明显类型（Apparent Type）；而变量所引用的对象的真是类型又叫做变量的实际类型（Actual Type）。</strong> 比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List list &#x3D; null;</span><br><span class="line">list &#x3D; new ArrayList();</span><br></pre></td></tr></table></figure>

<p>上面的代码声明了一个list，它的静态类型（也叫明显类型）是List，而它的实际类型是ArrayList。根据对象的类型而对方法进行的选择，就是分派（Dispatch）。分派又分为两种，即动态分派和静态分派。</p>
<h2 id="1-2-1-静态分派"><a href="#1-2-1-静态分派" class="headerlink" title="1.2.1 静态分派"></a>1.2.1 静态分派</h2><p>静态分派（Static Dispatch）就是按照变量的静态类型进行分派，从而确定方法的执行版本，静态分派在编译时期就可以确定方法的版本。而静态分配最经典的就是方法重载，请看下面的这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class StaticDispatch &#123;</span><br><span class="line"></span><br><span class="line">    public void test(String string) &#123;</span><br><span class="line">        System.out.println(&quot;string&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test(Integer integer) &#123;</span><br><span class="line">        System.out.println(&quot;integer&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String string &#x3D; &quot;1&quot;;</span><br><span class="line">        Integer integer &#x3D; 1;</span><br><span class="line">        StaticDispatch staticDispatch &#x3D; new StaticDispatch();</span><br><span class="line">        staticDispatch.test(string);</span><br><span class="line">        staticDispatch.test(integer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在静态分派判断的时候，我们根据多个判断依据（即参数类型和个数）判断出了方法的版本，那么这个就是多分派的概念，因为有一个以上的考量标准。所以<strong>Java语言是静态多分派语言。</strong></p>
<h2 id="1-2-2-动态分派"><a href="#1-2-2-动态分派" class="headerlink" title="1.2.2 动态分派"></a>1.2.2 动态分派</h2><p>动态分派，与静态相反，它不是在编译期间确定方法的版本，而是在运行时确定的。Java是动态单分派语言。</p>
<h2 id="1-2-3-访问者模式中的伪动态双分派"><a href="#1-2-3-访问者模式中的伪动态双分派" class="headerlink" title="1.2.3 访问者模式中的伪动态双分派"></a>1.2.3 访问者模式中的伪动态双分派</h2><p>通过前面分析，我们知道Java是静态多分派、动态单分派的语言。Java底层不支持动态的双分派。但是通过使用设计模式，也可以在Java语言里实现伪动态双分派。在访问者模式中使用的就是伪动态双分派。所谓动态双分派就是在运行时依据两个实际类型去判断一个方法的运行行为，而访问者模式实现的手段是进行了两次动态单分派来达到这个效果。<br>还是回到前面的公司KPI考核业务场景当中，BusinessReport类中的showReport()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line"> *</span><br><span class="line"> * @param visitor 公司高层，如CEO，CTO</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void showReport(IVisitor visitor) &#123;</span><br><span class="line">    for(Employee employee : employeeList) &#123;</span><br><span class="line">        employee.accept(visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是依据Employee和IVisitor两个实际类型决定了showReport()方法的执行结果从而决定了accept()方法的动作。</p>
<p>分析accept()方法的调用过程<br>1、当调用accept()方法时，根据Employee的实际类型决定是调用Engineer还是Manager的accept()方法。</p>
<p>2、这时accept()方法的版本已经确定，假如是Engineer，它的accept()方去是调用下面这行代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void accept(IVisitor visitor) &#123;</span><br><span class="line">    visitor.visit(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时的this是Engineer类型，所以对应的IVisitor接口的visit(Engineer enginner)方法，此时需要再根据访问者的实际类型确定visit()方法的版本，这样一来，就完成了动态分派的过程。</p>
<p>以上的过程就是通过两次动态双分派，第一次对accept()方法进行动态分派，第二次访问者的visit()方法进行动态分派，从而到达了根据两个实际类型确定一个方法的行为结果。</p>
<h1 id="二、访问者模式在源码中的体现"><a href="#二、访问者模式在源码中的体现" class="headerlink" title="二、访问者模式在源码中的体现"></a>二、访问者模式在源码中的体现</h1><h2 id="2-1-NIO中的FileVisitor接口"><a href="#2-1-NIO中的FileVisitor接口" class="headerlink" title="2.1 NIO中的FileVisitor接口"></a>2.1 NIO中的FileVisitor接口</h2><p>JDK中的NIO模块下的FileVisitor接口，它提供递归遍历文件树的支持。来看下源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">public interface FileVisitor&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Invoked for a directory before entries in the directory are visited.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; If this method returns &#123;@link FileVisitResult#CONTINUE CONTINUE&#125;,</span><br><span class="line">     * then entries in the directory are visited. If this method returns &#123;@link</span><br><span class="line">     * FileVisitResult#SKIP_SUBTREE SKIP_SUBTREE&#125; or &#123;@link</span><br><span class="line">     * FileVisitResult#SKIP_SIBLINGS SKIP_SIBLINGS&#125; then entries in the</span><br><span class="line">     * directory (and any descendants) will not be visited.</span><br><span class="line">     *</span><br><span class="line">     * @param   dir</span><br><span class="line">     *          a reference to the directory</span><br><span class="line">     * @param   attrs</span><br><span class="line">     *          the directory&#39;s basic attributes</span><br><span class="line">     *</span><br><span class="line">     * @return  the visit result</span><br><span class="line">     *</span><br><span class="line">     * @throws  IOException</span><br><span class="line">     *          if an I&#x2F;O error occurs</span><br><span class="line">     *&#x2F;</span><br><span class="line">    FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs)</span><br><span class="line">        throws IOException;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Invoked for a file in a directory.</span><br><span class="line">     *</span><br><span class="line">     * @param   file</span><br><span class="line">     *          a reference to the file</span><br><span class="line">     * @param   attrs</span><br><span class="line">     *          the file&#39;s basic attributes</span><br><span class="line">     *</span><br><span class="line">     * @return  the visit result</span><br><span class="line">     *</span><br><span class="line">     * @throws  IOException</span><br><span class="line">     *          if an I&#x2F;O error occurs</span><br><span class="line">     *&#x2F;</span><br><span class="line">    FileVisitResult visitFile(T file, BasicFileAttributes attrs)</span><br><span class="line">        throws IOException;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Invoked for a file that could not be visited. This method is invoked</span><br><span class="line">     * if the file&#39;s attributes could not be read, the file is a directory</span><br><span class="line">     * that could not be opened, and other reasons.</span><br><span class="line">     *</span><br><span class="line">     * @param   file</span><br><span class="line">     *          a reference to the file</span><br><span class="line">     * @param   exc</span><br><span class="line">     *          the I&#x2F;O exception that prevented the file from being visited</span><br><span class="line">     *</span><br><span class="line">     * @return  the visit result</span><br><span class="line">     *</span><br><span class="line">     * @throws  IOException</span><br><span class="line">     *          if an I&#x2F;O error occurs</span><br><span class="line">     *&#x2F;</span><br><span class="line">    FileVisitResult visitFileFailed(T file, IOException exc)</span><br><span class="line">        throws IOException;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Invoked for a directory after entries in the directory, and all of their</span><br><span class="line">     * descendants, have been visited. This method is also invoked when iteration</span><br><span class="line">     * of the directory completes prematurely (by a &#123;@link #visitFile visitFile&#125;</span><br><span class="line">     * method returning &#123;@link FileVisitResult#SKIP_SIBLINGS SKIP_SIBLINGS&#125;,</span><br><span class="line">     * or an I&#x2F;O error when iterating over the directory).</span><br><span class="line">     *</span><br><span class="line">     * @param   dir</span><br><span class="line">     *          a reference to the directory</span><br><span class="line">     * @param   exc</span><br><span class="line">     *          &#123;@code null&#125; if the iteration of the directory completes without</span><br><span class="line">     *          an error; otherwise the I&#x2F;O exception that caused the iteration</span><br><span class="line">     *          of the directory to complete prematurely</span><br><span class="line">     *</span><br><span class="line">     * @return  the visit result</span><br><span class="line">     *</span><br><span class="line">     * @throws  IOException</span><br><span class="line">     *          if an I&#x2F;O error occurs</span><br><span class="line">     *&#x2F;</span><br><span class="line">    FileVisitResult postVisitDirectory(T dir, IOException exc)</span><br><span class="line">        throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口上面定义的方法表示了遍历文件的关键过程，允许在文件被访问、目录被访问、目录已被访问、放生错误过程中进行控制整个流程。调用接口中的方法，会返回访问结果FileVisitResult对象值，用于决定当前操作完成后接下来该如何处理。FileVisitResult的标准返回值存放到枚举类型中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public enum FileVisitResult &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Continue. When returned from a &#123;@link FileVisitor#preVisitDirectory</span><br><span class="line">     * preVisitDirectory&#125; method then the entries in the directory should also</span><br><span class="line">     * be visited.</span><br><span class="line">     *&#x2F;</span><br><span class="line">     &#x2F;&#x2F;当前的遍历过程将会继续</span><br><span class="line">    CONTINUE,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Terminate.</span><br><span class="line">     *&#x2F;</span><br><span class="line">     &#x2F;&#x2F;表示当前的遍历过程将会停止</span><br><span class="line">    TERMINATE,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Continue without visiting the entries in this directory. This result</span><br><span class="line">     * is only meaningful when returned from the &#123;@link</span><br><span class="line">     * FileVisitor#preVisitDirectory preVisitDirectory&#125; method; otherwise</span><br><span class="line">     * this result type is the same as returning &#123;@link #CONTINUE&#125;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">     &#x2F;&#x2F;当前的遍历过程将会继续，但是要忽略当前目录下的所有节点</span><br><span class="line">    SKIP_SUBTREE,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Continue without visiting the &lt;em&gt;siblings&lt;&#x2F;em&gt; of this file or directory.</span><br><span class="line">     * If returned from the &#123;@link FileVisitor#preVisitDirectory</span><br><span class="line">     * preVisitDirectory&#125; method then the entries in the directory are also</span><br><span class="line">     * skipped and the &#123;@link FileVisitor#postVisitDirectory postVisitDirectory&#125;</span><br><span class="line">     * method is not invoked.</span><br><span class="line">     *&#x2F;</span><br><span class="line">     &#x2F;&#x2F;当前的遍历过程将会继续，但是要忽略当前文件&#x2F;目录的兄弟节点</span><br><span class="line">    SKIP_SIBLINGS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-Spring中的BeanDefinitionVisitor类"><a href="#2-2-Spring中的BeanDefinitionVisitor类" class="headerlink" title="2.2 Spring中的BeanDefinitionVisitor类"></a>2.2 Spring中的BeanDefinitionVisitor类</h2><p>在Spring的Ioc中有个BeanDefinitionVisitor类，它有一个visitBeanDefinition()方法，看下源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void visitBeanDefinition(BeanDefinition beanDefinition) &#123;</span><br><span class="line">	visitParentName(beanDefinition);</span><br><span class="line">	visitBeanClassName(beanDefinition);</span><br><span class="line">	visitFactoryBeanName(beanDefinition);</span><br><span class="line">	visitFactoryMethodName(beanDefinition);</span><br><span class="line">	visitScope(beanDefinition);</span><br><span class="line">	if (beanDefinition.hasPropertyValues()) &#123;</span><br><span class="line">		visitPropertyValues(beanDefinition.getPropertyValues());</span><br><span class="line">	&#125;</span><br><span class="line">	if (beanDefinition.hasConstructorArgumentValues()) &#123;</span><br><span class="line">		ConstructorArgumentValues cas &#x3D; beanDefinition.getConstructorArgumentValues();</span><br><span class="line">		visitIndexedArgumentValues(cas.getIndexedArgumentValues());</span><br><span class="line">		visitGenericArgumentValues(cas.getGenericArgumentValues());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在其方法中分别访问了其它的数据，比如父类的名字、自己的类名、在Ioc容器中的名称等各种信息。</p>
<h1 id="三、访问者模式的优缺点"><a href="#三、访问者模式的优缺点" class="headerlink" title="三、访问者模式的优缺点"></a>三、访问者模式的优缺点</h1><p>优点</p>
<ul>
<li>解耦了数据结构与数据操作，使得操作集合可以独立变化；</li>
<li>扩展性好：可以通过扩展访问者角色，实现对数据集的不同操作；</li>
<li>元素具体类型并非单一，访问者均可操作；</li>
<li>各角色职责分离，符合单一职责原则。</li>
</ul>
<p>缺点</p>
<ul>
<li>无法增加元素类型：若系统数据结构对象另于变化，经常有新的数据对象增加进来，则访问者类必须增加对应元素类型的操作，违背了开闭原则。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/03/30/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E6%9C%80%E4%B8%BA%E5%A4%8D%E6%9D%82%E7%9A%84%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="ckacbh0g6000nknra85p0bgfm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，被誉为摩斯密码的解释器模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/27/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E8%A2%AB%E8%AA%89%E4%B8%BA%E6%91%A9%E6%96%AF%E5%AF%86%E7%A0%81%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-03-27T06:26:08.000Z" itemprop="datePublished">2020-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/27/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E8%A2%AB%E8%AA%89%E4%B8%BA%E6%91%A9%E6%96%AF%E5%AF%86%E7%A0%81%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，被誉为摩斯密码的解释器模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>解释器模式（Interpreter Pattern）是指给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。是一种按照规定语法进行解析的模式。</p>
<p>就比如编译器可以将源码编译解释为机器码，让CPU能进行识别并运行。解释器模式的作用其实与编译器一样，都是将一些固定的文法（即语法）进行解释，构建出一个解释句子的解释器。简单理解，解释器是一个简单语法分析工具，它可以识别句子语义，分离终结符号和非终结符号，提取出需要的信息，让我们能针对不同的信息做出相应的处理。其核心思想是识别文法，构建解释。</p>
<h1 id="一、解释器模式的应用场景"><a href="#一、解释器模式的应用场景" class="headerlink" title="一、解释器模式的应用场景"></a>一、解释器模式的应用场景</h1><p>其中我们每天都生活在解释器模式中，平时所听到的音乐都可以通过简谱记录下来；还有战争年代发明的摩尔斯密码（又称为摩斯密码，Morse code），其实也是一种解释器。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/25/171103af69c610c0?w=580&h=435&f=png&s=103295" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/3/25/171103b4545d7c3a?w=287&h=270&f=png&s=51822" alt=""></p>
<p>我们在程序中，如果存在一种特定类型的问题，该类型问题涉及多个不同实例，但是具备固定文法描述，那么可以使用解释器模式对该类型问题进行解释，分离出需要的信息，根据获取的信息做出相应的处理。简而言之，对于一些固定文法构建一个解释句子的解释器。解释器模式适用于以下应用场景：</p>
<ul>
<li>一些重复出现的问题可以用一种简单的语言来进行表达；</li>
<li>一个简单语法需要解释的场景。</li>
</ul>
<p>解释器模式主要包含4种角色：</p>
<ul>
<li><p>抽象表达式（Expression）：负责定义一个解释方法interpret，交由具体子类进行具体解释；</p>
</li>
<li><p>终结符表达式（TerminalExpression）：实现文法中与终结符有关的解释操作。文法中的每一个终结符都有一个具体终结表达式与之相对应，比如公式R=R1+R2，R1和R2就是终结符对应的解析R1和R2的解释器就是终结符表达式。通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符（R1，R2）；</p>
</li>
<li><p>非终结符表达式（NonterminalExpression）：实现文法中与非终结符有关的解释操作。文法中的每条规则都对应于一个非终结符表达式。非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，”+”就是非终结符，解析“+“的解释器就是一个非终结符表达式。非终结符表达式根据逻辑的复杂程度而增加原则上每个文法规则都对应一个非终结符表达式；</p>
</li>
<li><p>上下文环境类（Context）：包含解释器之外的全局信息。它的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，给R1赋值100，给R2赋值200，这些信息需要存放到环境中。</p>
</li>
</ul>
<h2 id="使用解释器模式解析数据表达式"><a href="#使用解释器模式解析数据表达式" class="headerlink" title="使用解释器模式解析数据表达式"></a>使用解释器模式解析数据表达式</h2><p>用解释器模式来实现一个数学表达式计算器，包含加减乘除四种运算能力。</p>
<p>首先定义抽象表达式角色接口IArithmeticInterpreter：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface IArithmeticInterpreter &#123;</span><br><span class="line"></span><br><span class="line">    int interpret();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建终结者表达式角色Interpreter抽象类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Interpreter implements IArithmeticInterpreter &#123;</span><br><span class="line"></span><br><span class="line">    protected IArithmeticInterpreter left;</span><br><span class="line">    protected IArithmeticInterpreter right;</span><br><span class="line"></span><br><span class="line">    public Interpreter(IArithmeticInterpreter left, IArithmeticInterpreter right) &#123;</span><br><span class="line">        this.left &#x3D; left;</span><br><span class="line">        this.right &#x3D; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别创建非终结表达式角色加、减、乘、除4个解释器，加法运算表达式AddInterpreter类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class AddInterpreter extends Interpreter &#123;</span><br><span class="line">    public AddInterpreter(IArithmeticInterpreter left, IArithmeticInterpreter right) &#123;</span><br><span class="line">        super(left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int interpret() &#123;</span><br><span class="line">        return this.left.interpret() + this.right.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建减法运算表达式SubInterpreter类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class SubInterpreter extends Interpreter &#123;</span><br><span class="line">    public SubInterpreter(IArithmeticInterpreter left, IArithmeticInterpreter right) &#123;</span><br><span class="line">        super(left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int interpret() &#123;</span><br><span class="line">        return this.left.interpret() - this.right.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建乘法运算表达式MultiInterpreter类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MultiInterpreter extends Interpreter &#123;</span><br><span class="line">    public MultiInterpreter(IArithmeticInterpreter left, IArithmeticInterpreter right) &#123;</span><br><span class="line">        super(left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int interpret() &#123;</span><br><span class="line">        return this.left.interpret() * this.right.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建除法运算表达式DivInterpreter类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class DivInterpreter extends Interpreter &#123;</span><br><span class="line">    public DivInterpreter(IArithmeticInterpreter left, IArithmeticInterpreter right) &#123;</span><br><span class="line">        super(left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int interpret() &#123;</span><br><span class="line">        return this.left.interpret() &#x2F; this.right.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建数学表达式NumInterpreter类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class NumInterpreter implements IArithmeticInterpreter &#123;</span><br><span class="line"></span><br><span class="line">    private int value;</span><br><span class="line"></span><br><span class="line">    public NumInterpreter(int value) &#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int interpret() &#123;</span><br><span class="line">        return this.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建工具OperatorUtil类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class OperatorUtil &#123;</span><br><span class="line"></span><br><span class="line">    public static boolean isOperator(String symbol) &#123;</span><br><span class="line">        return (symbol.equals(&quot;+&quot;) || symbol.equals(&quot;-&quot;) || symbol.equals(&quot;*&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Interpreter getInterpreter(IArithmeticInterpreter left,</span><br><span class="line">                                             IArithmeticInterpreter right, String symbol) &#123;</span><br><span class="line">        if(symbol.equals(&quot;+&quot;)) &#123;</span><br><span class="line">            return new AddInterpreter(left, right);</span><br><span class="line">        &#125;else if(symbol.equals(&quot;-&quot;)) &#123;</span><br><span class="line">            return new SubInterpreter(left, right);</span><br><span class="line">        &#125;else if(symbol.equals(&quot;*&quot;)) &#123;</span><br><span class="line">            return new MultiInterpreter(left, right);</span><br><span class="line">        &#125;else if(symbol.equals(&quot;&#x2F;&quot;)) &#123;</span><br><span class="line">            return new DivInterpreter(left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建计算器Calculator类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class Calculator &#123;</span><br><span class="line"></span><br><span class="line">    private Stack&lt;IArithmeticInterpreter&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public Calculator(String experssion) &#123;</span><br><span class="line">        parse(experssion);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void parse(String expression) &#123;</span><br><span class="line">        String[] elements &#x3D; expression.split(&quot; &quot;);</span><br><span class="line">        IArithmeticInterpreter left, right;</span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; 0; i &lt; elements.length; i++) &#123;</span><br><span class="line">            String operator &#x3D; elements[i];</span><br><span class="line">            if(OperatorUtil.isOperator(operator)) &#123;</span><br><span class="line">                left &#x3D; this.stack.pop();</span><br><span class="line">                right &#x3D; new NumInterpreter(Integer.valueOf(elements[++i]));</span><br><span class="line">                System.out.println(&quot;出栈：&quot; + left.interpret() + &quot;和&quot; + right.interpret());</span><br><span class="line">                this.stack.push(OperatorUtil.getInterpreter(left, right, operator));</span><br><span class="line">                System.out.println(&quot;应用运算符：&quot; + operator);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                NumInterpreter numInterpreter &#x3D; new NumInterpreter(Integer.valueOf(elements[i]));</span><br><span class="line">                this.stack.push(numInterpreter);</span><br><span class="line">                System.out.println(&quot;入栈：&quot; + numInterpreter.interpret());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int calculate() &#123;</span><br><span class="line">        return this.stack.pop().interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    System.out.println(&quot;测试结果是：&quot; + new Calculator(&quot;18 - 12&quot;).calculate());</span><br><span class="line">    System.out.println(&quot;测试结果是：&quot; + new Calculator(&quot;18 + 12&quot;).calculate());</span><br><span class="line">    System.out.println(&quot;测试结果是：&quot; + new Calculator(&quot;18 * 2 + 12 - 6&quot;).calculate());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/3/27/1711a82c4985c352?w=723&h=735&f=png&s=42721" alt=""></p>
<h1 id="二、解释器模式在源码中的体现"><a href="#二、解释器模式在源码中的体现" class="headerlink" title="二、解释器模式在源码中的体现"></a>二、解释器模式在源码中的体现</h1><h2 id="2-1-正则表达式编译和继续Pattern类"><a href="#2-1-正则表达式编译和继续Pattern类" class="headerlink" title="2.1 正则表达式编译和继续Pattern类"></a>2.1 正则表达式编译和继续Pattern类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private Pattern(String p, int f) &#123;</span><br><span class="line">    pattern &#x3D; p;</span><br><span class="line">    flags &#x3D; f;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; to use UNICODE_CASE if UNICODE_CHARACTER_CLASS present</span><br><span class="line">    if ((flags &amp; UNICODE_CHARACTER_CLASS) !&#x3D; 0)</span><br><span class="line">        flags |&#x3D; UNICODE_CASE;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Reset group index count</span><br><span class="line">    capturingGroupCount &#x3D; 1;</span><br><span class="line">    localCount &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    if (pattern.length() &gt; 0) &#123;</span><br><span class="line">        compile();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        root &#x3D; new Start(lastAccept);</span><br><span class="line">        matchRoot &#x3D; lastAccept;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Pattern compile(String regex) &#123;</span><br><span class="line">    return new Pattern(regex, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Pattern compile(String regex, int flags) &#123;</span><br><span class="line">    return new Pattern(regex, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-Spring中的ExpressionParser接口"><a href="#2-2-Spring中的ExpressionParser接口" class="headerlink" title="2.2 Spring中的ExpressionParser接口"></a>2.2 Spring中的ExpressionParser接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface ExpressionParser &#123;</span><br><span class="line">    Expression parseExpression(String expressionString) throws ParseException;</span><br><span class="line"></span><br><span class="line">    Expression parseExpression(String expressionString, ParserContext context) throws ParseException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、解释器模式的优缺点"><a href="#三、解释器模式的优缺点" class="headerlink" title="三、解释器模式的优缺点"></a>三、解释器模式的优缺点</h1><p>优点：</p>
<ul>
<li>扩展性强在解释器模式中由于语法是由很多类表示的，当语法规则更改时，只需修改相应的非终结符表达式即可；若扩展语法时，只需添加相应非终结符类即可；</li>
<li>增加了新的解释表达式的方式；</li>
<li>于实现文法解释器模式对应的文法应当是比较简单目易于实现的，过于复杂的语法并不适合使用解释器模式。</li>
</ul>
<p>缺点：</p>
<ul>
<li>语法规则较复杂时，会引起类膨胀：解释器模式每个语法都要产生一个非终结符表达式，当浯法规则比较复杂时，就会产生大量的解释类，增加系统维护困难；</li>
<li>执行效率比较低解释器模式采用递归调用方法，每个菲终结符表达式只关心与自己有关的表达式，每个表达式需要知道最终的结果，因此完整表达式的最终结果是通过从后往前递归调用的方式获取得到。当完整表达式层级较深时，解释效率下降，且出错时调试困难，因为递归迭代层级太深。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/03/27/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E8%A2%AB%E8%AA%89%E4%B8%BA%E6%91%A9%E6%96%AF%E5%AF%86%E7%A0%81%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="ckacbh0fl000iknra5qsndlbj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，不需要中间商赚差价的中介者模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/25/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E4%B8%8D%E9%9C%80%E8%A6%81%E4%B8%AD%E9%97%B4%E5%95%86%E8%B5%9A%E5%B7%AE%E4%BB%B7%E7%9A%84%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-03-25T05:21:57.000Z" itemprop="datePublished">2020-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/25/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E4%B8%8D%E9%9C%80%E8%A6%81%E4%B8%AD%E9%97%B4%E5%95%86%E8%B5%9A%E5%B7%AE%E4%BB%B7%E7%9A%84%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，不需要中间商赚差价的中介者模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>中介者模式（Mediator Pattern）又称为调解者模式或者调停者模式。用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地互相作用，从而使其松散耦合，而且可以独立的改变他们之间的交互。</p>
<p>中介者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。当某些对象之间的作用发生改变时，不会立即影响其它的一些对象之间的作用。保证这些作用可以彼此独立的变化。其核心思想是，通过中介者解耦系统各层次对象的直接耦合，层次对象的对外依赖通信统统交由中介者转发。</p>
<h1 id="一、中介者模式的应用场景"><a href="#一、中介者模式的应用场景" class="headerlink" title="一、中介者模式的应用场景"></a>一、中介者模式的应用场景</h1><p>在现实生活中，中介者的存在是不可缺少的，如果没有了中介者，我们就不能与远方的朋友进行交流了。各个对象将会互相进行引用，如果每个对象都与多个对象进行交互时，将会形成如下图所示的网状结构。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/25/1710fac9b4f6a8df?w=603&h=432&f=png&s=44219" alt=""></p>
<p>从上面的图可以发现，每个对象之间过度耦合，这样既不利于信息的复用也不利于扩展。如果引入了中介者模式，那么对象之间的关系将变为星状结构，采用中介者模式后如下图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/25/1710fac782e44b8d?w=582&h=567&f=png&s=43118" alt=""></p>
<p>引入中介者模式后，任何一个类的变化，只会影响中介者合类本身，之前的设计是任何一个类的变化都会引起其关联所有类的变化。这样的设计减少了系统的耦合度。</p>
<p>其实在我们日常生活中每天在刷的微信朋友圈，就是一个中介者。还有信息交易平台，也是中介者模式的体现。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/25/1710fb1bc3473ecf?w=500&h=400&f=png&s=149052" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/25/1710fb27716e6c1a?w=640&h=425&f=png&s=287081" alt=""></p>
<p>中介者模式是用来降低多个对象和类之间的通信复杂性。这种模式通过提供一个中介类，将系统各层次对象间的多对多关系变成一对多关系，中介者对象可以将复杂的网状结构变成以调停者为中心的星形结构，达到降低系统的复杂性，提高可扩展性的作用。</p>
<p>若系统各层次对象之间存在大量的关联关系，即层次对象呈复杂的网状结构，如果直接让它们紧耦合通信，会造成系统结构变得异常复杂，且其中某个层次对象发生改变，则与其紧耦合的相应层次对象也需进行修改，系统很难进行维护。而通过为该系统增加一个中介者层次对象让其他各层次需对外通信的行为统统交由中介者进行转发，系统呈现以中介者为中心进行通讯的星形结构，系统的复杂性大大降低。</p>
<p>简单的说如果多个类相互耦合，形成了网状结构，则需要考虑使用中介者模式进行优化处理。中介者模式适用以下几个场景：</p>
<ul>
<li>系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解；</li>
<li>交互的公共行为，如果需要改变行为则可以新增新的中介者类。</li>
</ul>
<p>中介者模式主要包含4个角色：</p>
<ul>
<li>抽象中介者（Mediator）：定义统一的接口，用户各个同事角色间的通讯；</li>
<li>具体中介者（ConcreateMediator）：从具体的同事对象接收消息，协调各同事对象间的协作；</li>
<li>抽象同事类（Colleague）：每一个同事对象均需要依赖中介者角色，与其他同事通信时，交由中介者进行转发；</li>
<li>具体同事类（ConcreteColleague）：负责实现自发行为（Self-Method），转发依赖方法（Dep-Method）交由中介者进行协调。</li>
</ul>
<h2 id="1-1-简易聊天室系统使用中介者模式"><a href="#1-1-简易聊天室系统使用中介者模式" class="headerlink" title="1.1 简易聊天室系统使用中介者模式"></a>1.1 简易聊天室系统使用中介者模式</h2><p>假设我们要构建一个聊天室系统，用户可以向聊天室发送消息，聊天室会向所有的用户显示消息。实际上就是用户发信息与聊天室显示的通信过程，不过用户无法直接将信息发给聊天室，而是需要将信息先发到服务器上，然后服务器再将该消息发给聊天室进行显示。具体代码如下。</p>
<p>创建User类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private ChatRoom chatRoom;</span><br><span class="line"></span><br><span class="line">    public User(String name, ChatRoom chatRoom) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.chatRoom &#x3D; chatRoom;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sendMsg(String msg) &#123;</span><br><span class="line">        chatRoom.showMsg(this, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建聊天室ChatRoom类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ChatRoom &#123;</span><br><span class="line"></span><br><span class="line">    public void showMsg(User user, String msg) &#123;</span><br><span class="line">        System.out.println(&quot;[&quot; + user.getName() + &quot;] ：&quot; + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    ChatRoom chatRoom &#x3D; new ChatRoom();</span><br><span class="line"></span><br><span class="line">    User kevin &#x3D; new User(&quot;Kevin&quot;, chatRoom);</span><br><span class="line">    User jhon &#x3D; new User(&quot;Jhon&quot;, chatRoom);</span><br><span class="line">    kevin.sendMsg(&quot;Hello, Jhon!&quot;);</span><br><span class="line">    jhon.sendMsg(&quot;Hi, Kevin!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/25/1710fd1ef6a080cd?w=480&h=213&f=png&s=11682" alt=""></p>
<h1 id="二、中介者模式在源码中的体现"><a href="#二、中介者模式在源码中的体现" class="headerlink" title="二、中介者模式在源码中的体现"></a>二、中介者模式在源码中的体现</h1><p><strong>JDK中的Timer类</strong><br>打开Timer类的结构图我们发现Timer类中有很多schedule()方法重载，如下图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/25/1710fd58032837db?w=609&h=612&f=png&s=56835" alt=""></p>
<p>任意点开其中的一个方法，发现所有的方法最终都是调用了私有的sched()方法，看下它们的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> private void sched(TimerTask task, long time, long period) &#123;</span><br><span class="line">    if (time &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal execution time.&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Constrain value of period sufficiently to prevent numeric</span><br><span class="line">    &#x2F;&#x2F; overflow while still being effectively infinitely large.</span><br><span class="line">    if (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; 1))</span><br><span class="line">        period &gt;&gt;&#x3D; 1;</span><br><span class="line"></span><br><span class="line">    synchronized(queue) &#123;</span><br><span class="line">        if (!thread.newTasksMayBeScheduled)</span><br><span class="line">            throw new IllegalStateException(&quot;Timer already cancelled.&quot;);</span><br><span class="line"></span><br><span class="line">        synchronized(task.lock) &#123;</span><br><span class="line">            if (task.state !&#x3D; TimerTask.VIRGIN)</span><br><span class="line">                throw new IllegalStateException(</span><br><span class="line">                    &quot;Task already scheduled or cancelled&quot;);</span><br><span class="line">            task.nextExecutionTime &#x3D; time;</span><br><span class="line">            task.period &#x3D; period;</span><br><span class="line">            task.state &#x3D; TimerTask.SCHEDULED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue.add(task);</span><br><span class="line">        if (queue.getMin() &#x3D;&#x3D; task)</span><br><span class="line">            queue.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不管什么样的任务都加入到一个队列中顺序执行。把这个队列中所有的对象称之为“同事”。同事之间通过Timer来协调完成，Timer承担了中介者的角色。</p>
<h1 id="三、中介者模式的优缺点"><a href="#三、中介者模式的优缺点" class="headerlink" title="三、中介者模式的优缺点"></a>三、中介者模式的优缺点</h1><p>优点</p>
<ul>
<li>减少类间依赖，将多对多依赖转化成了一对多，降低了类间耦合；</li>
<li>类间各司其职，符合迪米特法则。</li>
</ul>
<p>缺点</p>
<ul>
<li>中介者模式中将原本多个对象直接的相互依赖变成了中介者和多个同事类的依赖关系。当同事类越多时，中介者就会越臃肿，变得复杂且难以维护。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/03/25/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E4%B8%8D%E9%9C%80%E8%A6%81%E4%B8%AD%E9%97%B4%E5%95%86%E8%B5%9A%E5%B7%AE%E4%BB%B7%E7%9A%84%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="ckacbgzqj0002knrahw36gcqk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，参与富文本编辑器开发的备忘录模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/22/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%8F%82%E4%B8%8E%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E5%BC%80%E5%8F%91%E7%9A%84%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-03-22T05:01:35.000Z" itemprop="datePublished">2020-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/22/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%8F%82%E4%B8%8E%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E5%BC%80%E5%8F%91%E7%9A%84%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，参与富文本编辑器开发的备忘录模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>备忘录模式（Memento Pattern）又称为快照模式（Snapshot Pattern）或者令牌模式（Token Pattern），是指在不破坏封装的前提下，捕获一个内部状态，并在对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p>
<p>在软件系统中，备忘录模式为我们提供了一种“<strong>后悔药</strong>”的机制，它通过存储系统各个历史状态的快照，使得我们可以在任意时刻将系统回滚到某一个历史状态。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/22/171002812f09c741?w=500&h=375&f=png&s=24408" alt=""></p>
<h1 id="一、备忘录模式的应用场景"><a href="#一、备忘录模式的应用场景" class="headerlink" title="一、备忘录模式的应用场景"></a>一、备忘录模式的应用场景</h1><p>我们机会天天都在使用备忘录模式，比如使用Git、SVN提供一种代码版本撤回的功能。还有游戏的存档功能，通过将游戏当前进度存储到本地文件系统或数据库中，使得下次继续游戏时，玩家可以从之前的位置继续进行。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/22/1710023437ec7aba?w=862&h=640&f=png&s=587660" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/3/22/1710020e9a571dc6?w=898&h=568&f=png&s=919989" alt=""></p>
<p>备忘录模式适用于以下两个场景：</p>
<ul>
<li>需要保存历史快照的场景；</li>
<li>希望在对象之外保存状态，且除了自己其它类对象无法访问状态保存具体内容。</li>
</ul>
<p>备忘录模式主要包含三种角色：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/22/171004323610cfc2?w=667&h=616&f=png&s=35027" alt=""></p>
<ul>
<li>发起人角色（Orgainator）：负责创建一个备忘录，记录自身需要保存的状态，具备状态回滚功能；</li>
<li>备忘录角色（Memento）：用于存储发起人的内部状态，且可以防止发起人以外的对象进行访问；</li>
<li>备忘录管理员（Caretaker）：负责存储，提供管理备忘录，无法对备忘录内容进行操作和访问。</li>
</ul>
<h2 id="1-1-利用压栈管理落地备忘录模式"><a href="#1-1-利用压栈管理落地备忘录模式" class="headerlink" title="1.1 利用压栈管理落地备忘录模式"></a>1.1 利用压栈管理落地备忘录模式</h2><p>我们在网页上写文章或者博客都使用过富文本编辑器，它会附带草稿箱、撤销等这样的功能。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/22/17100457db7f8162?w=1330&h=628&f=png&s=46599" alt=""></p>
<p>下面使用代码来实现这样的功能。假设我们需要发布一篇文章，这篇文章的编辑过程需要花很长的时间，编辑的过程中会不停的撤销，保存草稿、修改。首先创建发起人角色编辑器 Editor 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class Editor &#123;</span><br><span class="line"></span><br><span class="line">    private String title;</span><br><span class="line"></span><br><span class="line">    private String content;</span><br><span class="line"></span><br><span class="line">    private String imgs;</span><br><span class="line"></span><br><span class="line">    public Editor(String title, String content, String imgs) &#123;</span><br><span class="line">        this.title &#x3D; title;</span><br><span class="line">        this.content &#x3D; content;</span><br><span class="line">        this.imgs &#x3D; imgs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ArticleMemento save2Memento() &#123;</span><br><span class="line">        ArticleMemento articleMemento &#x3D;</span><br><span class="line">                new ArticleMemento(this.title, this.content, this.imgs);</span><br><span class="line">        return articleMemento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void undoFromMemento(ArticleMemento articleMemento) &#123;</span><br><span class="line">        this.title &#x3D; articleMemento.getTitle();</span><br><span class="line">        this.content &#x3D; articleMemento.getContent();</span><br><span class="line">        this.imgs &#x3D; articleMemento.getImgs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getTitle() &#123;</span><br><span class="line">        return title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTitle(String title) &#123;</span><br><span class="line">        this.title &#x3D; title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getContent() &#123;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setContent(String content) &#123;</span><br><span class="line">        this.content &#x3D; content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getImgs() &#123;</span><br><span class="line">        return imgs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setImgs(String imgs) &#123;</span><br><span class="line">        this.imgs &#x3D; imgs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Editor&#123;&quot; +</span><br><span class="line">                &quot;title&#x3D;&#39;&quot; + title + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, content&#x3D;&#39;&quot; + content + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, imgs&#x3D;&#39;&quot; + imgs + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后创建备忘录角色 ArticleMemento 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class ArticleMemento &#123;</span><br><span class="line"></span><br><span class="line">    private String title;</span><br><span class="line"></span><br><span class="line">    private String content;</span><br><span class="line"></span><br><span class="line">    private String imgs;</span><br><span class="line"></span><br><span class="line">    public ArticleMemento(String title, String content, String imgs) &#123;</span><br><span class="line">        this.title &#x3D; title;</span><br><span class="line">        this.content &#x3D; content;</span><br><span class="line">        this.imgs &#x3D; imgs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getTitle() &#123;</span><br><span class="line">        return title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTitle(String title) &#123;</span><br><span class="line">        this.title &#x3D; title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getContent() &#123;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setContent(String content) &#123;</span><br><span class="line">        this.content &#x3D; content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getImgs() &#123;</span><br><span class="line">        return imgs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setImgs(String imgs) &#123;</span><br><span class="line">        this.imgs &#x3D; imgs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;ArticleMemento&#123;&quot; +</span><br><span class="line">                &quot;title&#x3D;&#39;&quot; + title + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, content&#x3D;&#39;&quot; + content + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, imgs&#x3D;&#39;&quot; + imgs + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建备忘录管理角色草稿箱 DraftBox 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class DraftBox &#123;</span><br><span class="line"></span><br><span class="line">    private final Stack&lt;ArticleMemento&gt; STACK &#x3D; new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public ArticleMemento getMemento() &#123;</span><br><span class="line">        ArticleMemento articleMemento &#x3D; STACK.pop();</span><br><span class="line">        return articleMemento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addMemento(ArticleMemento articleMemento) &#123;</span><br><span class="line">        STACK.push(articleMemento);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>草稿箱的Stack类是Vector的一个子类，它实现了一个标准的后进先出的栈。</p>
<h1 id="二、备忘录模式在源码中的体现"><a href="#二、备忘录模式在源码中的体现" class="headerlink" title="二、备忘录模式在源码中的体现"></a>二、备忘录模式在源码中的体现</h1><p>备忘录模式在框架源码中的应用还是比较少见的，主要还是结合具体的应用场景来使用。spring中的webfolw源码<strong>StateManageableMessageContext</strong>接口，我们来看它的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public interface StateManageableMessageContext extends MessageContext &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Create a serializable memento, or token representing a snapshot of the internal state of this message context.</span><br><span class="line">	 * @return the messages memento</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public Serializable createMessagesMemento();</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Set the state of this context from the memento provided. After this call, the messages in this context will match</span><br><span class="line">	 * what is encapsulated inside the memento. Any previous state will be overridden.</span><br><span class="line">	 * @param messagesMemento the messages memento</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void restoreMessages(Serializable messagesMemento);</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Configure the message source used to resolve messages added to this context. May be set at any time to change how</span><br><span class="line">	 * coded messages are resolved.</span><br><span class="line">	 * @param messageSource the message source</span><br><span class="line">	 * @see MessageContext#addMessage(MessageResolver)</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void setMessageSource(MessageSource messageSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createMessagesMemento()创建一个消息备忘录。可以看一下实现类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultMessageContext implements StateManageableMessageContext &#123;</span><br><span class="line"></span><br><span class="line">	private static final Log logger &#x3D; LogFactory.getLog(DefaultMessageContext.class);</span><br><span class="line"></span><br><span class="line">	private MessageSource messageSource;</span><br><span class="line"></span><br><span class="line">	@SuppressWarnings(&quot;serial&quot;)</span><br><span class="line">	private Map&lt;Object, List&lt;Message&gt;&gt; sourceMessages &#x3D; new AbstractCachingMapDecorator&lt;Object, List&lt;Message&gt;&gt;(</span><br><span class="line">			new LinkedHashMap&lt;Object, List&lt;Message&gt;&gt;()) &#123;</span><br><span class="line"></span><br><span class="line">		protected List&lt;Message&gt; create(Object source) &#123;</span><br><span class="line">			return new ArrayList&lt;Message&gt;();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Creates a new default message context. Defaults to a message source that simply resolves default text and cannot</span><br><span class="line">	 * resolve localized message codes.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public DefaultMessageContext() &#123;</span><br><span class="line">		init(null);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Creates a new default message context.</span><br><span class="line">	 * @param messageSource the message source to resolve messages added to this context</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public DefaultMessageContext(MessageSource messageSource) &#123;</span><br><span class="line">		init(messageSource);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public MessageSource getMessageSource() &#123;</span><br><span class="line">		return messageSource;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; implementing message context</span><br><span class="line"></span><br><span class="line">	public Message[] getAllMessages() &#123;</span><br><span class="line">		List&lt;Message&gt; messages &#x3D; new ArrayList&lt;Message&gt;();</span><br><span class="line">		for (List&lt;Message&gt; list : sourceMessages.values()) &#123;</span><br><span class="line">			messages.addAll(list);</span><br><span class="line">		&#125;</span><br><span class="line">		return messages.toArray(new Message[messages.size()]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Message[] getMessagesBySource(Object source) &#123;</span><br><span class="line">		List&lt;Message&gt; messages &#x3D; sourceMessages.get(source);</span><br><span class="line">		return messages.toArray(new Message[messages.size()]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Message[] getMessagesByCriteria(MessageCriteria criteria) &#123;</span><br><span class="line">		List&lt;Message&gt; messages &#x3D; new ArrayList&lt;Message&gt;();</span><br><span class="line">		for (List&lt;Message&gt; sourceMessages : this.sourceMessages.values()) &#123;</span><br><span class="line">			for (Message message : sourceMessages) &#123;</span><br><span class="line">				if (criteria.test(message)) &#123;</span><br><span class="line">					messages.add(message);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return messages.toArray(new Message[messages.size()]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public boolean hasErrorMessages() &#123;</span><br><span class="line">		for (List&lt;Message&gt; sourceMessages : this.sourceMessages.values()) &#123;</span><br><span class="line">			for (Message message : sourceMessages) &#123;</span><br><span class="line">				if (message.getSeverity() &#x3D;&#x3D; Severity.ERROR) &#123;</span><br><span class="line">					return true;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void addMessage(MessageResolver messageResolver) &#123;</span><br><span class="line">		Locale currentLocale &#x3D; LocaleContextHolder.getLocale();</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Resolving message using &quot; + messageResolver);</span><br><span class="line">		&#125;</span><br><span class="line">		Message message &#x3D; messageResolver.resolveMessage(messageSource, currentLocale);</span><br><span class="line">		List&lt;Message&gt; messages &#x3D; sourceMessages.get(message.getSource());</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Adding resolved message &quot; + message);</span><br><span class="line">		&#125;</span><br><span class="line">		messages.add(message);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void clearMessages() &#123;</span><br><span class="line">		sourceMessages.clear();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; implementing state manageable message context</span><br><span class="line"></span><br><span class="line">	public Serializable createMessagesMemento() &#123;</span><br><span class="line">		return new LinkedHashMap&lt;Object, List&lt;Message&gt;&gt;(sourceMessages);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">	public void restoreMessages(Serializable messagesMemento) &#123;</span><br><span class="line">		sourceMessages.putAll((Map&lt;Object, List&lt;Message&gt;&gt;) messagesMemento);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setMessageSource(MessageSource messageSource) &#123;</span><br><span class="line">		if (messageSource &#x3D;&#x3D; null) &#123;</span><br><span class="line">			messageSource &#x3D; new DefaultTextFallbackMessageSource();</span><br><span class="line">		&#125;</span><br><span class="line">		this.messageSource &#x3D; messageSource;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; internal helpers</span><br><span class="line"></span><br><span class="line">	private void init(MessageSource messageSource) &#123;</span><br><span class="line">		setMessageSource(messageSource);</span><br><span class="line">		&#x2F;&#x2F; create the &#39;null&#39; source message list eagerly to ensure global messages are indexed first</span><br><span class="line">		this.sourceMessages.get(null);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return new ToStringCreator(this).append(&quot;sourceMessages&quot;, sourceMessages).toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static class DefaultTextFallbackMessageSource extends AbstractMessageSource &#123;</span><br><span class="line">		protected MessageFormat resolveCode(String code, Locale locale) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要逻辑就相当于是给Message留一个备份，以备恢复之用。</p>
<h1 id="三、备忘录模式的优缺点"><a href="#三、备忘录模式的优缺点" class="headerlink" title="三、备忘录模式的优缺点"></a>三、备忘录模式的优缺点</h1><p>优点：</p>
<ul>
<li>简化发起人职责，隔离状态存储与获取，实现了信息的封装，客户端无需关心状态的保存细节；</li>
<li>提供状态回滚功能。</li>
</ul>
<p>缺点：<br>消耗资源：如果需要保存的状态过多时，每一次保存都会消耗很多内存。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/03/22/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%8F%82%E4%B8%8E%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E5%BC%80%E5%8F%91%E7%9A%84%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="ckacbh0f5000cknra3rpgcpm1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-架构师内功心法，参与电商订单业务开发的状态模式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/21/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%8F%82%E4%B8%8E%E7%94%B5%E5%95%86%E8%AE%A2%E5%8D%95%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-03-21T06:47:29.000Z" itemprop="datePublished">2020-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/21/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%8F%82%E4%B8%8E%E7%94%B5%E5%95%86%E8%AE%A2%E5%8D%95%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">架构师内功心法，参与电商订单业务开发的状态模式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>状态模式在生活场景中也是比较常见的。比如我们平时网购的订单状态变化，还有平时坐电梯，电梯状态的变化。<br><img src="https://user-gold-cdn.xitu.io/2020/3/20/170f6a106d4fecd1?w=744&h=564&f=png&s=113326" alt=""><br><img src="https://user-gold-cdn.xitu.io/2020/3/20/170f6a1e5d87254f?w=592&h=333&f=png&s=132053" alt=""></p>
<p>在软件开发过程中，对于某一项的操作，可能存在不同的情况。通常处理多情况问题最直接的办法就是使用if…else或者switch…case条件语句进行判断。这种做法对于复杂状态的判断天然存在弊端：判断条件语句过于臃肿，可读性较差，不具备扩展性，维度难度也很大。如果转换一下思维，将这些不同状态独立起来用各种不同的类进行表示，系统处理哪种情况，直接使用相应的状态类进行处理，消除条件判断语句，代码也更加具有层次感，且具备良好的扩展能力。</p>
<p>状态模式（State Pattern）也成为状态机模式（State Machine Pattern），是允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。状态模式中类的行为是由状态决定的，不同的状态下有不同的行为。其意图是让一个对象在其内部改变的时候，其行为也随之改变。状态模式的核心就是状态与行为绑定，不同的状态对应不同的行为。</p>
<h1 id="一、状态模式的应用场景"><a href="#一、状态模式的应用场景" class="headerlink" title="一、状态模式的应用场景"></a>一、状态模式的应用场景</h1><p>状态模式适用于以下几种场景：</p>
<ul>
<li>行为随状态改变而改变场景；</li>
<li>一个操作中含有庞大的多分支机构，并且这些分支取决于对象的状态。</li>
</ul>
<p>状态模式主要包含三种角色：</p>
<ul>
<li>环境类角色（Context）：定义客户端需要的接囗，内部维护一个当前状态实例，并负责具体状态的切换；</li>
<li>抽象状态角色（State）：定义该状态下的行为，可以有一个或多个行为；</li>
<li>具体状态角色（ConcreteState）：具体实现该状态对应的行为并且在需要的肩况下进行状态切换。</li>
</ul>
<h2 id="1-1-状态模式在业务场景中的应用"><a href="#1-1-状态模式在业务场景中的应用" class="headerlink" title="1.1 状态模式在业务场景中的应用"></a>1.1 状态模式在业务场景中的应用</h2><p>我们在某社区阅读文章的时候，如果觉得某篇文章写得好，就会转发、收藏并且评论。如果用户处于登录情况下，我们就可以做评论、转发、收藏这些行为。否则需要跳转到登录页面，登录之后才能执行先前的动作。那么这里涉及到的状态有两种：已登录和未登录，行为有三种：评论、转发、收藏。下面使用代码来实现这些逻辑，首先创建抽象状态角色类UserState：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public abstract class UserState &#123;</span><br><span class="line"></span><br><span class="line">    private AppContext appContext;</span><br><span class="line"></span><br><span class="line">    public void setAppContext(AppContext appContext) &#123;</span><br><span class="line">        this.appContext &#x3D; appContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void forward();</span><br><span class="line"></span><br><span class="line">    public abstract void collect();</span><br><span class="line"></span><br><span class="line">    public abstract void comment(String comment);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建登录状态LoginState类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class LoginState extends UserState &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void forward() &#123;</span><br><span class="line">        System.out.println(&quot;转发成功！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void collect() &#123;</span><br><span class="line">        System.out.println(&quot;收藏成功！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void comment(String comment) &#123;</span><br><span class="line">        System.out.println(&quot;评论成功,内容是：&quot; + comment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着创建未登录状态UnLoginState类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class UnLoginState extends UserState &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void forward() &#123;</span><br><span class="line">        forward2Login();</span><br><span class="line">        this.appContext.forward();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void collect() &#123;</span><br><span class="line">        forward2Login();</span><br><span class="line">        this.appContext.collect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void comment(String comment) &#123;</span><br><span class="line">        forward2Login();</span><br><span class="line">        this.appContext.comment(comment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void forward2Login() &#123;</span><br><span class="line">        System.out.println(&quot;跳转到登录页面！&quot;);</span><br><span class="line">        this.appContext.setState(this.appContext.LOGIN_STATE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建上下文角色AppContext类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class AppContext &#123;</span><br><span class="line"></span><br><span class="line">    public static final UserState LOGIN_STATE &#x3D; new LoginState();</span><br><span class="line"></span><br><span class="line">    public static final UserState UNLOGIN_STATE &#x3D; new UnLoginState();</span><br><span class="line"></span><br><span class="line">    private UserState currentState &#x3D; UNLOGIN_STATE;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        UNLOGIN_STATE.setAppContext(this);</span><br><span class="line">        LOGIN_STATE.setAppContext(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setState(UserState state) &#123;</span><br><span class="line">        this.currentState &#x3D; state;</span><br><span class="line">        this.currentState.setAppContext(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public UserState getState() &#123;</span><br><span class="line">        return this.currentState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void forward() &#123;</span><br><span class="line">        this.currentState.forward();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void collect() &#123;</span><br><span class="line">        this.currentState.collect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void comment(String comment) &#123;</span><br><span class="line">        this.currentState.comment(comment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">    AppContext context &#x3D; new AppContext();</span><br><span class="line">    context.forward();</span><br><span class="line">    context.collect();</span><br><span class="line">    context.comment(&quot;说的太好了，双手双脚给个赞������&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/20/170f76262cd00174?w=571&h=196&f=png&s=14631" alt=""></p>
<h2 id="1-2-利用状态机实现订单状态流转控制"><a href="#1-2-利用状态机实现订单状态流转控制" class="headerlink" title="1.2 利用状态机实现订单状态流转控制"></a>1.2 利用状态机实现订单状态流转控制</h2><p>状态机是状态模式的一种应用，相当于上下文角色的一个升级版本。在工作流或游戏等各种系统中有大量使用，比如各种工作流引擎，它几乎是状态机的子集和实现，封装状态的变化规则。Spring提供了一个很好的解决方案。Spring的组件名称就叫StateMachine（状态机）。状态机帮助开发者简化状态控制的开发过程，让状态机结构更加层次化。下面来用Spring状态机模拟一个订单状态流转的过程。</p>
<p>1、pom依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.statemachine&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-statemachine-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.1.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2、创建订单实体类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Order &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private OrderStatus status;</span><br><span class="line">    public void setStatus(OrderStatus status) &#123;</span><br><span class="line">        this.status &#x3D; status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public OrderStatus getStatus() &#123;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;订单号：&quot; + id + &quot;, 订单状态：&quot; + status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建订单状态枚举类和状态转换枚举类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 订单状态</span><br><span class="line"> *&#x2F;</span><br><span class="line">public enum OrderStatus &#123;</span><br><span class="line">    &#x2F;&#x2F; 待支付，待发货，待收货，订单结束</span><br><span class="line">    WAIT_PAYMENT, WAIT_DELIVER, WAIT_RECEIVE, FINISH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 订单状态改变事件</span><br><span class="line"> *&#x2F;</span><br><span class="line">public enum OrderStatusChangeEvent &#123;</span><br><span class="line">    &#x2F;&#x2F; 支付，发货，确认收货</span><br><span class="line">    PAYED, DELIVERY, RECEIVED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、添加状态流转配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 订单状态机配置</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">@EnableStateMachine(name &#x3D; &quot;orderStateMachine&quot;)</span><br><span class="line">public class OrderStateMachineConfig extends StateMachineConfigurerAdapter&lt;OrderStatus, OrderStatusChangeEvent&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 配置状态</span><br><span class="line">     * @param states</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void configure(StateMachineStateConfigurer&lt;OrderStatus, OrderStatusChangeEvent&gt; states) throws Exception &#123;</span><br><span class="line">        states</span><br><span class="line">                .withStates()</span><br><span class="line">                .initial(OrderStatus.WAIT_PAYMENT)</span><br><span class="line">                .states(EnumSet.allOf(OrderStatus.class));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 配置状态转换事件关系</span><br><span class="line">     * @param transitions</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void configure(StateMachineTransitionConfigurer&lt;OrderStatus, OrderStatusChangeEvent&gt; transitions) throws Exception &#123;</span><br><span class="line">        transitions</span><br><span class="line">                .withExternal().source(OrderStatus.WAIT_PAYMENT).target(OrderStatus.WAIT_DELIVER).event(OrderStatusChangeEvent.PAYED)</span><br><span class="line">                .and()</span><br><span class="line">                .withExternal().source(OrderStatus.WAIT_DELIVER).target(OrderStatus.WAIT_RECEIVE).event(OrderStatusChangeEvent.DELIVERY)</span><br><span class="line">                .and()</span><br><span class="line">                .withExternal().source(OrderStatus.WAIT_RECEIVE).target(OrderStatus.FINISH).event(OrderStatusChangeEvent.RECEIVED);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 持久化配置</span><br><span class="line">     * 实际使用中，可以配合redis等，进行持久化操作</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    public DefaultStateMachinePersister persister()&#123;</span><br><span class="line">        return new DefaultStateMachinePersister&lt;&gt;(new StateMachinePersist&lt;Object, Object, Order&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void write(StateMachineContext&lt;Object, Object&gt; context, Order order) throws Exception &#123;</span><br><span class="line">                &#x2F;&#x2F;此处并没有进行持久化操作</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            @Override</span><br><span class="line">            public StateMachineContext&lt;Object, Object&gt; read(Order order) throws Exception &#123;</span><br><span class="line">                &#x2F;&#x2F;此处直接获取order中的状态，其实并没有进行持久化读取操作</span><br><span class="line">                return new DefaultStateMachineContext(order.getStatus(), null, null, null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、添加订单状态监听器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;orderStateListener&quot;)</span><br><span class="line">@WithStateMachine(name &#x3D; &quot;orderStateMachine&quot;)</span><br><span class="line">public class OrderStateListenerImpl&#123;</span><br><span class="line"> </span><br><span class="line">    @OnTransition(source &#x3D; &quot;WAIT_PAYMENT&quot;, target &#x3D; &quot;WAIT_DELIVER&quot;)</span><br><span class="line">    public boolean payTransition(Message&lt;OrderStatusChangeEvent&gt; message) &#123;</span><br><span class="line">        Order order &#x3D; (Order) message.getHeaders().get(&quot;order&quot;);</span><br><span class="line">        order.setStatus(OrderStatus.WAIT_DELIVER);</span><br><span class="line">        System.out.println(&quot;支付，状态机反馈信息：&quot; + message.getHeaders().toString());</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @OnTransition(source &#x3D; &quot;WAIT_DELIVER&quot;, target &#x3D; &quot;WAIT_RECEIVE&quot;)</span><br><span class="line">    public boolean deliverTransition(Message&lt;OrderStatusChangeEvent&gt; message) &#123;</span><br><span class="line">        Order order &#x3D; (Order) message.getHeaders().get(&quot;order&quot;);</span><br><span class="line">        order.setStatus(OrderStatus.WAIT_RECEIVE);</span><br><span class="line">        System.out.println(&quot;发货，状态机反馈信息：&quot; + message.getHeaders().toString());</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @OnTransition(source &#x3D; &quot;WAIT_RECEIVE&quot;, target &#x3D; &quot;FINISH&quot;)</span><br><span class="line">    public boolean receiveTransition(Message&lt;OrderStatusChangeEvent&gt; message)&#123;</span><br><span class="line">        Order order &#x3D; (Order) message.getHeaders().get(&quot;order&quot;);</span><br><span class="line">        order.setStatus(OrderStatus.FINISH);</span><br><span class="line">        System.out.println(&quot;收货，状态机反馈信息：&quot; + message.getHeaders().toString());</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6、创建IOrderService接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface IOrderService &#123;</span><br><span class="line">    &#x2F;&#x2F;创建新订单</span><br><span class="line">    Order create();</span><br><span class="line">    &#x2F;&#x2F;发起支付</span><br><span class="line">    Order pay(int id);</span><br><span class="line">    &#x2F;&#x2F;订单发货</span><br><span class="line">    Order deliver(int id);</span><br><span class="line">    &#x2F;&#x2F;订单收货</span><br><span class="line">    Order receive(int id);</span><br><span class="line">    &#x2F;&#x2F;获取所有订单信息</span><br><span class="line">    Map&lt;Integer, Order&gt; getOrders();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7、在Service中添加业务逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">@Service(&quot;orderService&quot;)</span><br><span class="line">public class OrderServiceImpl implements IOrderService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StateMachine&lt;OrderStatus, OrderStatusChangeEvent&gt; orderStateMachine;</span><br><span class="line"> </span><br><span class="line">    @Autowired</span><br><span class="line">    private StateMachinePersister&lt;OrderStatus, OrderStatusChangeEvent, Order&gt; persister;</span><br><span class="line"> </span><br><span class="line">    private int id &#x3D; 1;</span><br><span class="line">    private Map&lt;Integer, Order&gt; orders &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public Order create() &#123;</span><br><span class="line">        Order order &#x3D; new Order();</span><br><span class="line">        order.setStatus(OrderStatus.WAIT_PAYMENT);</span><br><span class="line">        order.setId(id++);</span><br><span class="line">        orders.put(order.getId(), order);</span><br><span class="line">        return order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Order pay(int id) &#123;</span><br><span class="line">        Order order &#x3D; orders.get(id);</span><br><span class="line">        System.out.println(&quot;线程名称：&quot; + Thread.currentThread().getName() + &quot; 尝试支付，订单号：&quot; + id);</span><br><span class="line">        Message message &#x3D; MessageBuilder.withPayload(OrderStatusChangeEvent.PAYED).setHeader(&quot;order&quot;, order).build();</span><br><span class="line">        if (!sendEvent(message, order)) &#123;</span><br><span class="line">            System.out.println(&quot;线程名称：&quot; + Thread.currentThread().getName() + &quot; 支付失败, 状态异常，订单号：&quot; + id);</span><br><span class="line">        &#125;</span><br><span class="line">        return orders.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Order deliver(int id) &#123;</span><br><span class="line">        Order order &#x3D; orders.get(id);</span><br><span class="line">        System.out.println(&quot;线程名称：&quot; + Thread.currentThread().getName() + &quot; 尝试发货，订单号：&quot; + id);</span><br><span class="line">        if (!sendEvent(MessageBuilder.withPayload(OrderStatusChangeEvent.DELIVERY).setHeader(&quot;order&quot;, order).build(), orders.get(id))) &#123;</span><br><span class="line">            System.out.println(&quot;线程名称：&quot; + Thread.currentThread().getName() + &quot; 发货失败，状态异常，订单号：&quot; + id);</span><br><span class="line">        &#125;</span><br><span class="line">        return orders.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Order receive(int id) &#123;</span><br><span class="line">        Order order &#x3D; orders.get(id);</span><br><span class="line">        System.out.println(&quot;线程名称：&quot; + Thread.currentThread().getName() + &quot; 尝试收货，订单号：&quot; + id);</span><br><span class="line">        if (!sendEvent(MessageBuilder.withPayload(OrderStatusChangeEvent.RECEIVED).setHeader(&quot;order&quot;, order).build(), orders.get(id))) &#123;</span><br><span class="line">            System.out.println(&quot;线程名称：&quot; + Thread.currentThread().getName() + &quot; 收货失败，状态异常，订单号：&quot; + id);</span><br><span class="line">        &#125;</span><br><span class="line">        return orders.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    public Map&lt;Integer, Order&gt; getOrders() &#123;</span><br><span class="line">        return orders;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发送订单状态转换事件</span><br><span class="line">     *</span><br><span class="line">     * @param message</span><br><span class="line">     * @param order</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private synchronized boolean sendEvent(Message&lt;OrderStatusChangeEvent&gt; message, Order order) &#123;</span><br><span class="line">        boolean result &#x3D; false;</span><br><span class="line">        try &#123;</span><br><span class="line">            orderStateMachine.start();</span><br><span class="line">            &#x2F;&#x2F;尝试恢复状态机状态</span><br><span class="line">            persister.restore(orderStateMachine, order);</span><br><span class="line">            &#x2F;&#x2F;添加延迟用于线程安全测试</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            result &#x3D; orderStateMachine.sendEvent(message);</span><br><span class="line">            &#x2F;&#x2F;持久化状态机状态</span><br><span class="line">            persister.persist(orderStateMachine, order);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            orderStateMachine.stop();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    Thread.currentThread().setName(&quot;主线程&quot;);</span><br><span class="line"></span><br><span class="line">    ConfigurableApplicationContext context &#x3D; SpringApplication.run(Test.class,args);</span><br><span class="line"></span><br><span class="line">    IOrderService orderService &#x3D; (IOrderService)context.getBean(&quot;orderService&quot;);</span><br><span class="line"></span><br><span class="line">    orderService.create();</span><br><span class="line">    orderService.create();</span><br><span class="line"></span><br><span class="line">    orderService.pay(1);</span><br><span class="line"></span><br><span class="line">    new Thread(&quot;客户线程&quot;)&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            orderService.deliver(1);</span><br><span class="line">            orderService.receive(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line"></span><br><span class="line">    orderService.pay(2);</span><br><span class="line">    orderService.deliver(2);</span><br><span class="line">    orderService.receive(2);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;全部订单状态：&quot; + orderService.getOrders());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二、状态模式中的源码体现"><a href="#二、状态模式中的源码体现" class="headerlink" title="二、状态模式中的源码体现"></a>二、状态模式中的源码体现</h1><p>状态模式的具体应用在源码中非常少见，在源码中一般只是提供一种通用的解决方案。如果一定要找，当然也是能找到的。经历千辛万苦，持续烧脑，下面我们来看一个在JSF源码中的Lifecycle类。JSF也算是一个比较经典的前端框架，那么没用过的小伙伴也没关系，我们这是只是分析一下其设计思想。在JSF中它所有页面的处理分为6个阶段，被定义在了Phaseld类中用不同的常量来表示生命周期阶段，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class PhaseId implements Comparable &#123;</span><br><span class="line">    private final int ordinal;</span><br><span class="line">    private String phaseName;</span><br><span class="line">    private static int nextOrdinal &#x3D; 0;</span><br><span class="line">    private static final String ANY_PHASE_NAME &#x3D; &quot;ANY&quot;;</span><br><span class="line">    public static final PhaseId ANY_PHASE &#x3D; new PhaseId(&quot;ANY&quot;);</span><br><span class="line">    private static final String RESTORE_VIEW_NAME &#x3D; &quot;RESTORE_VIEW&quot;;</span><br><span class="line">    public static final PhaseId RESTORE_VIEW &#x3D; new PhaseId(&quot;RESTORE_VIEW&quot;);</span><br><span class="line">    private static final String APPLY_REQUEST_VALUES_NAME &#x3D; &quot;APPLY_REQUEST_VALUES&quot;;</span><br><span class="line">    public static final PhaseId APPLY_REQUEST_VALUES &#x3D; new PhaseId(&quot;APPLY_REQUEST_VALUES&quot;);</span><br><span class="line">    private static final String PROCESS_VALIDATIONS_NAME &#x3D; &quot;PROCESS_VALIDATIONS&quot;;</span><br><span class="line">    public static final PhaseId PROCESS_VALIDATIONS &#x3D; new PhaseId(&quot;PROCESS_VALIDATIONS&quot;);</span><br><span class="line">    private static final String UPDATE_MODEL_VALUES_NAME &#x3D; &quot;UPDATE_MODEL_VALUES&quot;;</span><br><span class="line">    public static final PhaseId UPDATE_MODEL_VALUES &#x3D; new PhaseId(&quot;UPDATE_MODEL_VALUES&quot;);</span><br><span class="line">    private static final String INVOKE_APPLICATION_NAME &#x3D; &quot;INVOKE_APPLICATION&quot;;</span><br><span class="line">    public static final PhaseId INVOKE_APPLICATION &#x3D; new PhaseId(&quot;INVOKE_APPLICATION&quot;);</span><br><span class="line">    private static final String RENDER_RESPONSE_NAME &#x3D; &quot;RENDER_RESPONSE&quot;;</span><br><span class="line">    public static final PhaseId RENDER_RESPONSE &#x3D; new PhaseId(&quot;RENDER_RESPONSE&quot;);</span><br><span class="line">    private static final PhaseId[] values;</span><br><span class="line">    public static final List VALUES;</span><br><span class="line"></span><br><span class="line">    private PhaseId(String newPhaseName) &#123;</span><br><span class="line">        this.ordinal &#x3D; nextOrdinal++;</span><br><span class="line">        this.phaseName &#x3D; null;</span><br><span class="line">        this.phaseName &#x3D; newPhaseName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int compareTo(Object other) &#123;</span><br><span class="line">        return this.ordinal - ((PhaseId)other).ordinal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getOrdinal() &#123;</span><br><span class="line">        return this.ordinal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return null &#x3D;&#x3D; this.phaseName ? String.valueOf(this.ordinal) : this.phaseName + &#39; &#39; + this.ordinal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        values &#x3D; new PhaseId[]&#123;ANY_PHASE, RESTORE_VIEW, APPLY_REQUEST_VALUES, PROCESS_VALIDATIONS, UPDATE_MODEL_VALUES, INVOKE_APPLICATION, RENDER_RESPONSE&#125;;</span><br><span class="line">        VALUES &#x3D; Collections.unmodifiableList(Arrays.asList(values));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这些状态的切换都在Lifecycle的execute()方、去中进行。其中会传一个参数FacesContext对象，最终所有的状态都被FacesContext保存。在此呢，我们就不做继续深入的分析。</p>
<h1 id="三、状态模式的相关模式"><a href="#三、状态模式的相关模式" class="headerlink" title="三、状态模式的相关模式"></a>三、状态模式的相关模式</h1><h2 id="3-1-状态模式与责任链模式"><a href="#3-1-状态模式与责任链模式" class="headerlink" title="3.1 状态模式与责任链模式"></a>3.1 状态模式与责任链模式</h2><p>状态模式和责任链模式都能消除if分支过多的问题。但某些情况下，状态模式中的状态可以理解为责任，那么这种情况下，两种模式都可以使用。</p>
<p>从定义来看，状态模式强调的是一个对象内在状态的改变，而责任链模式强调的是外部节点对象间的改变。</p>
<p>从其代码实现上来看，他们间最大的区别就是状态模式各个状态对象知道自己下一个要进入的状态对象而责任链模式并不清楚其下一个节点处理对象，因为链式组装由客户端负责。</p>
<h2 id="3-2-状态模式与策略模式"><a href="#3-2-状态模式与策略模式" class="headerlink" title="3.2 状态模式与策略模式"></a>3.2 状态模式与策略模式</h2><p>状态模式和策略模式的UML类图架构几乎完全一样，但他们的应用场景是不一样的。策略模式多种算法行为择其一都能满足，彼此之间是独立的用户可自行更换策略算法，而状态模式各个状态间是存在相互关系的，彼此之间在一定条件下存在自动切换状态效果，且用户无法指定状态，只能设置初始状态。</p>
<h1 id="四、状态模式的优缺点"><a href="#四、状态模式的优缺点" class="headerlink" title="四、状态模式的优缺点"></a>四、状态模式的优缺点</h1><p>优点：</p>
<ul>
<li>结构清晰：将状态独立为类，消除了冗余的if…else或switch…case语句，使代码更加简洁，提高系统可维护性；</li>
<li>将状态转换显示化通常的对象内部都是使用数值类型来定义状态，状态的切换是通过賦值进行表现，不够直观，而使用状态类，在切换状态时，是以不同的类进行表示，转换目的更加明确；</li>
<li>状态类职责明确且具备扩展性。</li>
</ul>
<p>缺点：</p>
<ul>
<li>类膨胀：如果一个事物具备很多状态，则会造成状态类太多；</li>
<li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱；</li>
<li>状态模式对开闭原则的支持并不太好，对于可以切换状态的状态模式增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/03/21/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%EF%BC%8C%E5%8F%82%E4%B8%8E%E7%94%B5%E5%95%86%E8%AE%A2%E5%8D%95%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" data-id="ckacbh0g7000oknra8d759lwq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/05/18/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%8F%AD%E5%BC%80%E7%AF%87%E7%AB%A0%EF%BC%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86%EF%BC%8C%E4%BA%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%84%8F%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/">JAVA并发编程揭开篇章，并发编程基本认识，了解多线程意义和使用</a>
          </li>
        
          <li>
            <a href="/2020/05/15/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%98%85%E8%AF%BBmybatis%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%EF%BC%8C%E6%8E%8C%E6%8F%A1%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/">手把手教你阅读mybatis核心源码，掌握底层工作原理与设计思想</a>
          </li>
        
          <li>
            <a href="/2020/05/14/%E9%9D%A2%E8%AF%95%E5%AE%98%E5%8F%A3%E4%B8%AD%E7%9A%84Mybatis%EF%BC%8C%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E3%80%81%E6%9E%B6%E6%9E%84%E5%88%86%E5%B1%82%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86%E4%BB%A5%E5%8F%8A%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/">面试官口中的Mybatis，工作流程、架构分层与模块划分以及缓存机制</a>
          </li>
        
          <li>
            <a href="/2020/05/05/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%8C%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E6%98%AF%E2%80%9C%E9%81%93%E2%80%9D%EF%BC%8C%E8%80%8C%E4%B8%8D%E5%8F%AA%E6%98%AF%E2%80%9C%E6%9C%AF%E2%80%9D/">23种设计模式的学习，我们需要掌握的是“道”，而不只是“术”</a>
          </li>
        
          <li>
            <a href="/2020/04/05/%E6%B7%B1%E5%BA%A6%E9%98%85%E8%AF%BBSpring5-x%E6%BA%90%E7%A0%81%E5%90%8E%EF%BC%8C%E4%BD%BF%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E8%BF%B7%E4%BD%A0%E7%89%88Spring%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF%E5%AE%9E%E8%B7%B5/">深度阅读Spring5.x源码后，使用Java实现迷你版Spring的基本思路实践</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Kevin Shaw<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>