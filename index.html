<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>来一杯咖啡</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="互联网Java体系平台架构，分布式系统，中间件技术等">
<meta property="og:type" content="website">
<meta property="og:title" content="来一杯咖啡">
<meta property="og:url" content="https://xkjava.github.io/index.html">
<meta property="og:site_name" content="来一杯咖啡">
<meta property="og:description" content="互联网Java体系平台架构，分布式系统，中间件技术等">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Kevin Shaw">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="Netty">
<meta property="article:tag" content="Kafka...">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="来一杯咖啡" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">来一杯咖啡</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">互联网技术无边界，学习与交流</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://xkjava.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-迈出spring5源码阅读第一步，如何编译源码并使用IDEA打开" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/14/%E8%BF%88%E5%87%BAspring5%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81%E5%B9%B6%E4%BD%BF%E7%94%A8IDEA%E6%89%93%E5%BC%80/" class="article-date">
  <time datetime="2020-12-14T11:46:51.000Z" itemprop="datePublished">2020-12-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/14/%E8%BF%88%E5%87%BAspring5%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81%E5%B9%B6%E4%BD%BF%E7%94%A8IDEA%E6%89%93%E5%BC%80/">迈出spring5源码阅读第一步，如何编译源码并使用IDEA打开</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、下载源码"><a href="#一、下载源码" class="headerlink" title="一、下载源码"></a>一、下载源码</h1><p>这里使用的是5.2.8.RELEASE版本！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --branch v5.2.8.RELEASE https:&#x2F;&#x2F;gitee.com&#x2F;Z201&#x2F;spring-framework.git</span><br></pre></td></tr></table></figure>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f516267442954b6f9de5602a36fe11d5~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<h1 id="二、安装gradle"><a href="#二、安装gradle" class="headerlink" title="二、安装gradle"></a>二、安装gradle</h1><p>这里使用的是6.0.1版本！<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46708e3ee2574abb8358843d5556b7df~tplv-k3u1fbpfcp-watermark.image" alt=""><br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a65b71d656024fa19861ad0a8691dd02~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<h1 id="三、修改源码下的文件内容"><a href="#三、修改源码下的文件内容" class="headerlink" title="三、修改源码下的文件内容"></a>三、修改源码下的文件内容</h1><h2 id="3-1-修改settings-gradle文件"><a href="#3-1-修改settings-gradle文件" class="headerlink" title="3.1 修改settings.gradle文件"></a>3.1 修改settings.gradle文件</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bd7757de786411c870482f264b27516~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<p>加入阿里云的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">   gradlePluginPortal()</span><br><span class="line">   maven &#123; url &#39;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;public&#39; &#125;</span><br><span class="line">   maven &#123; url &#39;https:&#x2F;&#x2F;repo.spring.io&#x2F;plugins-release&#39; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-修改gradle-properties文件"><a href="#3-2-修改gradle-properties文件" class="headerlink" title="3.2 修改gradle.properties文件"></a>3.2 修改gradle.properties文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">version&#x3D;5.2.8.RELEASE</span><br><span class="line">org.gradle.jvmargs&#x3D;-Xmx2048M</span><br><span class="line">org.gradle.caching&#x3D;true</span><br><span class="line">org.gradle.parallel&#x3D;true</span><br><span class="line">org.gradle.configureondemand&#x3D;true</span><br><span class="line">org.gradle.daemon&#x3D;true</span><br></pre></td></tr></table></figure>
<h2 id="3-3-修改build-gradle文件"><a href="#3-3-修改build-gradle文件" class="headerlink" title="3.3 修改build.gradle文件"></a>3.3 修改build.gradle文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">maven &#123; url &#39;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&#39; &#125;</span><br><span class="line">maven &#123; url &#39;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;repositories&#x2F;jcenter&#39;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-编译源码"><a href="#3-4-编译源码" class="headerlink" title="3.4 编译源码"></a>3.4 编译源码</h2><p>编译spring-oxm模块，编译命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradlew :spring-oxm:compileTestJava</span><br></pre></td></tr></table></figure>
<p>编译成功后的截图</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/398695239a4a4e8da1b37c187348477b~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<h1 id="四、IDEA导入源码"><a href="#四、IDEA导入源码" class="headerlink" title="四、IDEA导入源码"></a>四、IDEA导入源码</h1><h2 id="4-1-下载Idea-kotlin插件安装"><a href="#4-1-下载Idea-kotlin插件安装" class="headerlink" title="4.1 下载Idea kotlin插件安装"></a>4.1 下载Idea kotlin插件安装</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33ba2837993b48c4b897f7a3a8f38b95~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<h2 id="4-2-IDEA导入Spring源码"><a href="#4-2-IDEA导入Spring源码" class="headerlink" title="4.2 IDEA导入Spring源码"></a>4.2 IDEA导入Spring源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File -&gt; New -&gt; Project from Existing Souces...</span><br></pre></td></tr></table></figure>

<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16cdcd008f3b4812ad873af4bf8aab0e~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef75cb79d9e84efebc2f15b6f9668e6d~tplv-k3u1fbpfcp-watermark.image" alt=""><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c197ca504ce4927976b85c988eb749f~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<p>最终编译成功后的截图：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f923961818234057811f40d66126b73a~tplv-k3u1fbpfcp-watermark.image" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/12/14/%E8%BF%88%E5%87%BAspring5%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81%E5%B9%B6%E4%BD%BF%E7%94%A8IDEA%E6%89%93%E5%BC%80/" data-id="ckiohtc5s0006ryraay289bdt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Ambari大数据平台集群利器的探索与实践" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/16/Ambari%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0%E9%9B%86%E7%BE%A4%E5%88%A9%E5%99%A8%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E8%B7%B5/" class="article-date">
  <time datetime="2020-09-16T07:03:01.000Z" itemprop="datePublished">2020-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/16/Ambari%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0%E9%9B%86%E7%BE%A4%E5%88%A9%E5%99%A8%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E8%B7%B5/">Ambari大数据平台集群利器的探索与实践</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>Ambari是 Apache Software Foundation 中的一个顶级项目，它是用来创建、管理、监视Hadoop整个生态圈的工具。 Ambari是分布式架构，主要由Ambari Server和Ambari Agent组成。</p>
<p>HDP是hortonworks的软件栈，里面包含了hadoop生态系统的所有软件项目，其实就是软件包合集。</p>
<p>HDP-UTILS是工具类库。各软件版本对照表：</p>
<p><a href="https://supportmatrix.hortonworks.com/" target="_blank" rel="noopener">https://supportmatrix.hortonworks.com/</a></p>
<p><strong>hadoop生态圈示图：</strong><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9af9108183e4b27afd5d08486eec6e5~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h1 id="二、环境准备"><a href="#二、环境准备" class="headerlink" title="二、环境准备"></a>二、环境准备</h1><h2 id="2-1-资源要求"><a href="#2-1-资源要求" class="headerlink" title="2.1 资源要求"></a>2.1 资源要求</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4c39ef626164219be1568987dba237f~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="2-2-软件要求"><a href="#2-2-软件要求" class="headerlink" title="2.2 软件要求"></a>2.2 软件要求</h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5968fb8ba5704939ace3014a5a10a6bd~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="2-3-软件下载地址"><a href="#2-3-软件下载地址" class="headerlink" title="2.3 软件下载地址"></a>2.3 软件下载地址</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@ambari-server01 ~]# wget http:&#x2F;&#x2F;public-repo-1.hortonworks.com&#x2F;ambari&#x2F;centos7&#x2F;2.x&#x2F;updates&#x2F;2.7.1.0&#x2F;ambari-2.7.1.0-centos7.tar.gz</span><br><span class="line">[root@ambari-server01 ~]# wget http:&#x2F;&#x2F;public-repo-1.hortonworks.com&#x2F;HDP&#x2F;centos7&#x2F;3.x&#x2F;updates&#x2F;3.0.1.0&#x2F;HDP-3.0.1.0-centos7-rpm.tar.gz</span><br><span class="line">[root@ambari-server01 ~]# wget http:&#x2F;&#x2F;public-repo-1.hortonworks.com&#x2F;HDP-UTILS-1.1.0.22&#x2F;repos&#x2F;centos7&#x2F;HDP-UTILS-1.1.0.22-centos7.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="2-4-系统初始化，执行以下脚本（所有节点）"><a href="#2-4-系统初始化，执行以下脚本（所有节点）" class="headerlink" title="2.4 系统初始化，执行以下脚本（所有节点）"></a>2.4 系统初始化，执行以下脚本（所有节点）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#</span><br><span class="line">#服务器初始化脚本</span><br><span class="line"> </span><br><span class="line"># 关闭防火墙</span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line"> </span><br><span class="line"># 关闭 SeLinux</span><br><span class="line">setenforce 0</span><br><span class="line">sed -i &quot;s&#x2F;SELINUX&#x3D;enforcing&#x2F;SELINUX&#x3D;disabled&#x2F;g&quot; &#x2F;etc&#x2F;selinux&#x2F;config</span><br><span class="line"> </span><br><span class="line"># 关闭 swap</span><br><span class="line">swapoff -a</span><br><span class="line">sed -i &#39;s&#x2F;.*swap.*&#x2F;#&amp;&#x2F;&#39; &#x2F;etc&#x2F;fstab</span><br><span class="line"># echo &quot;1&quot; &gt;&#x2F;proc&#x2F;sys&#x2F;net&#x2F;bridge&#x2F;bridge-nf-call-iptables</span><br><span class="line"> </span><br><span class="line"># 安装必要的调试程序</span><br><span class="line">yum install -y vim lrzsz telnet net-tools tar wget</span><br><span class="line">yum install -y java-1.8.0-openjdk*</span><br><span class="line"> </span><br><span class="line"># 安装配置时间同步服务</span><br><span class="line">yum install -y ntp</span><br><span class="line">systemctl start ntpd.service</span><br><span class="line">systemctl enable ntpd.service</span><br><span class="line"> </span><br><span class="line"># 设置进程文件最大打开数量</span><br><span class="line">echo &quot;* soft nofile 65535&quot;  &gt;&gt; &#x2F;etc&#x2F;security&#x2F;limits.conf</span><br><span class="line">echo &quot;* hard nofile 65535&quot;  &gt;&gt; &#x2F;etc&#x2F;security&#x2F;limits.conf</span><br><span class="line"> </span><br><span class="line"># 设置系统总限制文件最大打开数量</span><br><span class="line">echo  6553560 &gt; &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max</span><br><span class="line">echo &quot;fs.file-max &#x3D; 6553560&quot; &gt;&gt;  &#x2F;etc&#x2F;sysctl.conf</span><br></pre></td></tr></table></figure>

<h2 id="2-5-设置主机名（所有节点）"><a href="#2-5-设置主机名（所有节点）" class="headerlink" title="2.5 设置主机名（所有节点）"></a>2.5 设置主机名（所有节点）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 三台主机分别设置hostname</span><br><span class="line">[root@ambari-server01 ~]# hostnamectl set-hostname ambari-server01.test.com</span><br><span class="line">[root@ambari-node01 ~]# hostnamectl set-hostname ambari-node01.test.com</span><br><span class="line">[root@ambari-node02 ~]# hostnamectl set-hostname ambari-node02.test.com</span><br><span class="line"> </span><br><span class="line"># 添加hosts解析（所有节点）</span><br><span class="line">[root@ambari-server01 ~]# cat &gt;&gt; &#x2F;etc&#x2F;hosts &lt;&lt; EOF</span><br><span class="line">192.168.2.111  ambari-server01.test.com</span><br><span class="line">192.168.2.112  ambari-node01.test.com</span><br><span class="line">192.168.2.113  ambari-node02.test.com</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h2 id="2-6-设置免密登陆（ambari-server01节点）"><a href="#2-6-设置免密登陆（ambari-server01节点）" class="headerlink" title="2.6 设置免密登陆（ambari-server01节点）"></a>2.6 设置免密登陆（ambari-server01节点）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 在192.168.2.111节点执行：</span><br><span class="line">[root@ambari-server01 ~]# ssh-keygen</span><br><span class="line">[root@ambari-server01 ~]# ssh-copy-id  ambari-server01.test.com</span><br><span class="line">[root@ambari-server01 ~]# ssh-copy-id  ambari-node01.test.com</span><br><span class="line">[root@ambari-server01 ~]# ssh-copy-id  ambari-node02.test.com</span><br><span class="line">[root@ambari-server01 ~]# scp -r .ssh&#x2F; ambari-node01.test.com:&#x2F;root</span><br><span class="line">[root@ambari-server01 ~]# scp -r .ssh&#x2F; ambari-node02.test.com:&#x2F;root</span><br></pre></td></tr></table></figure>

<h1 id="三、安装mysql相关（ambari-server01节点）"><a href="#三、安装mysql相关（ambari-server01节点）" class="headerlink" title="三、安装mysql相关（ambari-server01节点）"></a>三、安装mysql相关（ambari-server01节点）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 下载并安装mysql</span><br><span class="line">[root@ambari-server01 ~]# wget -i -c http:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql-community-release-el7-5.noarch.rpm</span><br><span class="line">[root@ambari-server01 ~]# yum -y install mysql-community-release-el7-5.noarch.rpm</span><br><span class="line">[root@ambari-server01 ~]# yum -y install mysql-community-server</span><br><span class="line"> </span><br><span class="line"># 启动mysql</span><br><span class="line">[root@ambari-server01 ~]# systemctl start mysqld.service    # 启动mysql</span><br><span class="line">[root@ambari-server01 ~]# systemctl status mysqld.service  # 查看mysql状态</span><br><span class="line">[root@ambari-server01 ~]# systemctl enable mysqld.service   # 开机自启</span><br><span class="line"> </span><br><span class="line"># 设置mysql密码</span><br><span class="line">&gt; set password for root@localhost &#x3D; password(&#39;root123&#39;);   # 方法一，需要登陆mysql执行</span><br><span class="line"> </span><br><span class="line"># 创建ambari数据库及用户名和密码</span><br><span class="line">mysql&gt; create database ambari character set utf8;</span><br><span class="line">mysql&gt; CREATE USER &#39;ambari&#39;@&#39;%&#39;IDENTIFIED BY &#39;Ambari123&#39;;</span><br><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON ambari.* TO &#39;ambari&#39;@&#39;%&#39;;</span><br><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON ambari.* TO &#39;ambari&#39;@&#39;ambari-server01.test.com&#39;IDENTIFIED BY &#39;Ambari123&#39;;</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br><span class="line"> </span><br><span class="line"># 创建hive数据库及用户名和密码（如果不需要安装hive服务，则不需要配置以下数据库）</span><br><span class="line">mysql&gt; create database hive character set utf8;</span><br><span class="line">mysql&gt; CREATE USER &#39;hive&#39;@&#39;%&#39;IDENTIFIED BY &#39;Hive123&#39;;</span><br><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON hive.* TO &#39;hive&#39;@&#39;%&#39;;</span><br><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON hive.* TO &#39;ambari&#39;@&#39;ambari-server01.test.com&#39;IDENTIFIED BY &#39;Hive123&#39;;</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br><span class="line"> </span><br><span class="line"># 如果需要安装oozie、ranger服务，创建数据库方法同上。</span><br><span class="line"> </span><br><span class="line"># 下载 mysql-connector-java-5.1.46-bin.jar包</span><br><span class="line"># 复制到&#x2F;var&#x2F;lib&#x2F;ambari-server&#x2F;resources&#x2F;mysql-connector-java-5.1.46-bin.jar目录；</span><br><span class="line"># 再复制到&#x2F;usr&#x2F;share&#x2F;java&#x2F;mysql-connector-java-5.1.46-bin.jar到这个目录一份。</span><br></pre></td></tr></table></figure>

<h1 id="四、利用httpd创建本地yum的repo源（ambari-server01节点）"><a href="#四、利用httpd创建本地yum的repo源（ambari-server01节点）" class="headerlink" title="四、利用httpd创建本地yum的repo源（ambari-server01节点）"></a>四、利用httpd创建本地yum的repo源（ambari-server01节点）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 安装软件</span><br><span class="line">[root@ambari-server01 ~]# yum -y install yum-utils createrepo httpd</span><br><span class="line"># 创建目录</span><br><span class="line">[root@ambari-server01 ~]# mkdir -p &#x2F;var&#x2F;www&#x2F;html&#x2F;ambari&#x2F;</span><br><span class="line">[root@ambari-server01 ~]# mkdir -p &#x2F;var&#x2F;www&#x2F;html&#x2F;hdp&#x2F;</span><br><span class="line">[root@ambari-server01 ~]# mkdir -p &#x2F;var&#x2F;www&#x2F;html&#x2F;hdp&#x2F;HDP-UTILS&#x2F;</span><br><span class="line"># 解压tar包</span><br><span class="line">[root@ambari-server01 ~]# tar -zxvf ambari-2.7.1.0-centos7.tar.gz -C &#x2F;var&#x2F;www&#x2F;html&#x2F;ambari&#x2F;</span><br><span class="line">[root@ambari-server01 ~]# tar -zxvf HDP-3.0.1.0-centos7-rpm.tar.gz -C &#x2F;var&#x2F;www&#x2F;html&#x2F;hdp&#x2F;</span><br><span class="line">[root@ambari-server01 ~]# tar -zxvf HDP-UTILS-1.1.0.22-centos7.tar.gz -C &#x2F;var&#x2F;www&#x2F;html&#x2F;hdp&#x2F;HDP-UTILS&#x2F;</span><br><span class="line"># 启动httpd</span><br><span class="line">[root@ambari-server01 ~]# systemctl start httpd</span><br><span class="line">[root@ambari-server01 ~]# systemctl enable httpd</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">**浏览器查看，如下即为正常**</span><br><span class="line"></span><br><span class="line">![](https:&#x2F;&#x2F;p1-juejin.byteimg.com&#x2F;tos-cn-i-k3u1fbpfcp&#x2F;6eda665d14c04ee9bb69a5dbbe28b23a~tplv-k3u1fbpfcp-zoom-1.image)</span><br><span class="line"></span><br><span class="line"># 配置本地repo</span><br><span class="line">[root@ambari-server01 ~]# wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;ambari.repo http:&#x2F;&#x2F;public-repo-1.hortonworks.com&#x2F;ambari&#x2F;centos7&#x2F;2.x&#x2F;updates&#x2F;2.7.1.0&#x2F;ambari.repo</span><br><span class="line"> </span><br><span class="line"># 将下载的repo修改内容为如下</span><br><span class="line">[root@ambari-server01 ~]# vim &#x2F;etc&#x2F;yum.repos.d&#x2F;ambari.repo</span><br><span class="line">#VERSION_NUMBER&#x3D;2.7.1.0-139</span><br><span class="line">[ambari-2.7.1.0]</span><br><span class="line">#json.url &#x3D; http:&#x2F;&#x2F;public-repo-1.hortonworks.com&#x2F;HDP&#x2F;hdp_urlinfo.json</span><br><span class="line">name&#x3D;ambari Version - ambari-2.7.1.0</span><br><span class="line">baseurl&#x3D;http:&#x2F;&#x2F;192.168.2.111&#x2F;ambari&#x2F;ambari&#x2F;centos7&#x2F;2.7.1.0-169</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">gpgkey&#x3D;http:&#x2F;&#x2F;192.168.2.111&#x2F;ambari&#x2F;ambari&#x2F;centos7&#x2F;2.7.1.0-169&#x2F;RPM-GPG-KEY&#x2F;RPM-GPG-KEY-Jenkins</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">priority&#x3D;1</span><br><span class="line"> </span><br><span class="line"># 配置HDP和HDP-UTILS的repo</span><br><span class="line">[root@ambari-server01 ~]# vim &#x2F;etc&#x2F;yum.repos.d&#x2F;HDP.repo</span><br><span class="line">#VERSION_NUMBER&#x3D;3.0.1.0-187</span><br><span class="line">[HDP-3.0.1.0]</span><br><span class="line">name&#x3D;HDP Version - HDP-3.0.1.0</span><br><span class="line">baseurl&#x3D;http:&#x2F;&#x2F;192.168.2.111&#x2F;hdp&#x2F;HDP&#x2F;centos7</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">gpgkey&#x3D;http:&#x2F;&#x2F;192.168.2.111&#x2F;hdp&#x2F;HDP&#x2F;centos7&#x2F;3.0.1.0-187&#x2F;RPM-GPG-KEY&#x2F;RPM-GPG-KEY-Jenkins</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">priority&#x3D;1</span><br><span class="line">[HDP-UTILS-1.1.0.22]</span><br><span class="line">name&#x3D;HDP-UTILS Version - HDP-UTILS-1.1.0.22</span><br><span class="line">baseurl&#x3D;http:&#x2F;&#x2F;192.168.2.111&#x2F;hdp&#x2F;HDP-UTILS&#x2F;centos7&#x2F;1.1.0.22</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">gpgkey&#x3D;http:&#x2F;&#x2F;192.168.2.111&#x2F;hdp&#x2F;HDP-UTILS&#x2F;centos7&#x2F;1.1.0.22&#x2F;RPM-GPG-KEY&#x2F;RPM-GPG-KEY-Jenkins</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">priority&#x3D;1</span><br><span class="line"> </span><br><span class="line"># 将repo拷贝到其他节点</span><br><span class="line">[root@ambari-server01 ~]# cd &#x2F;etc&#x2F;yum.repos.d&#x2F;</span><br><span class="line">[root@ambari-server01 ~]# scp ambari.repo HDP.repo root@192.168.2.112:&#x2F;etc&#x2F;yum.repos.d&#x2F;</span><br><span class="line">[root@ambari-server01 ~]# scp ambari.repo HDP.repo root@192.168.2.113:&#x2F;etc&#x2F;yum.repos.d&#x2F;</span><br><span class="line"> </span><br><span class="line"># 生成本地源</span><br><span class="line">[root@ambari-server01 ~]# createrepo &#x2F;var&#x2F;www&#x2F;html&#x2F;hdp&#x2F;HDP&#x2F;centos7&#x2F;</span><br><span class="line">[root@ambari-server01 ~]# createrepo  &#x2F;var&#x2F;www&#x2F;html&#x2F;hdp&#x2F;HDP-UTILS&#x2F;</span><br></pre></td></tr></table></figure>

<h1 id="五、安装ambari集群"><a href="#五、安装ambari集群" class="headerlink" title="五、安装ambari集群"></a>五、安装ambari集群</h1><h2 id="5-1-安装ambari-server（ambari-server01节点）"><a href="#5-1-安装ambari-server（ambari-server01节点）" class="headerlink" title="5.1 安装ambari-server（ambari-server01节点）"></a>5.1 安装ambari-server（ambari-server01节点）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@ambari-server01 ~]# yum -y install ambari-server</span><br><span class="line">[root@ambari-server01 ~]# ambari-server setup</span><br><span class="line">Using python  &#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line">Setup ambari-server</span><br><span class="line">Checking SELinux...</span><br><span class="line">SELinux status is &#39;disabled&#39;</span><br><span class="line">Customize user account for ambari-server daemon [y&#x2F;n] (n)? y</span><br><span class="line">Enter user account for ambari-server daemon (root):root # 用户</span><br><span class="line">Adjusting ambari-server permissions and ownership...</span><br><span class="line">Checking firewall status...</span><br><span class="line">Checking JDK...</span><br><span class="line">[1] Oracle JDK 1.8 + Java Cryptography Extension (JCE) Policy Files 8</span><br><span class="line">[2] Custom JDK</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Enter choice (1): 2 # 选择自定义jdk</span><br><span class="line">WARNING: JDK must be installed on all hosts and JAVA_HOME must be valid on all hosts.</span><br><span class="line">WARNING: JCE Policy files are required for configuring Kerberos security. If you plan to use Kerberos,please make sure JCE Unlimited Strength Jurisdiction Policy Files are valid on all hosts.</span><br><span class="line">Path to JAVA_HOME: &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.8.0-openjdk-1.8.0.262.b10-0.el7_8.x86_64&#x2F;     #jdk安装路径</span><br><span class="line">Validating JDK on Ambari Server...done.</span><br><span class="line">Check JDK version for Ambari Server...</span><br><span class="line">JDK version found: 8</span><br><span class="line">Minimum JDK version is 8 for Ambari. Skipping to setup different JDK for Ambari Server.</span><br><span class="line">Checking GPL software agreement...</span><br><span class="line">GPL License for LZO: https:&#x2F;&#x2F;www.gnu.org&#x2F;licenses&#x2F;old-licenses&#x2F;gpl-2.0.en.html</span><br><span class="line">Enable Ambari Server to download and install GPL Licensed LZO packages [y&#x2F;n] (n)? y</span><br><span class="line">Completing setup...</span><br><span class="line">Configuring database...</span><br><span class="line">Enter advanced database configuration [y&#x2F;n] (n)? y</span><br><span class="line">Configuring database...</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Choose one of the following options:</span><br><span class="line">[1] - PostgreSQL (Embedded)</span><br><span class="line">[2] - Oracle</span><br><span class="line">[3] - MySQL &#x2F; MariaDB</span><br><span class="line">[4] - PostgreSQL</span><br><span class="line">[5] - Microsoft SQL Server (Tech Preview)</span><br><span class="line">[6] - SQL Anywhere</span><br><span class="line">[7] - BDB</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Enter choice (1): 3 # 选择安装的mysql</span><br><span class="line">Hostname (localhost): ambari-server01.test.com  # 配置hostname</span><br><span class="line">Port (3306):    # 默认</span><br><span class="line">Database name (ambari):       # 默认</span><br><span class="line">Username (ambari):       # 默认</span><br><span class="line">Enter Database Password (bigdata):  # 输入密码</span><br><span class="line">Re-enter password:</span><br><span class="line">Configuring ambari database...</span><br><span class="line">Should ambari use existing default jdbc &#x2F;usr&#x2F;share&#x2F;java&#x2F;mysql-connector-java.jar [y&#x2F;n] (y)? y</span><br><span class="line">Configuring remote database connection properties...</span><br><span class="line">WARNING: Before starting Ambari Server, you must run the following DDL directly from the database shell to create the schema: &#x2F;var&#x2F;lib&#x2F;ambari-server&#x2F;resources&#x2F;Ambari-DDL-MySQL-CREATE.sql      # 此处需注意，启动ambari之前需要执行此句</span><br><span class="line">Proceed with configuring remote database connection properties [y&#x2F;n] (y)? y</span><br><span class="line">Extracting system views...</span><br><span class="line">ambari-admin-2.7.3.0.139.jar</span><br><span class="line">....</span><br><span class="line">Ambari repo file contains latest json url http:&#x2F;&#x2F;public-repo-1.hortonworks.com&#x2F;HDP&#x2F;hdp_urlinfo.json, updating stacks repoinfos with it...</span><br><span class="line">Adjusting ambari-server permissions and ownership...</span><br><span class="line">Ambari Server &#39;setup&#39; completed successfully.   # 安装成功</span><br></pre></td></tr></table></figure>

<h2 id="5-2-使用ambari用户登陆mysql"><a href="#5-2-使用ambari用户登陆mysql" class="headerlink" title="5.2 使用ambari用户登陆mysql"></a>5.2 使用ambari用户登陆mysql</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@ambari-server01 ~]# mysql -u ambari -pAmbari123 -h ambari-server01.test.com</span><br><span class="line">mysql&gt; source &#x2F;var&#x2F;lib&#x2F;ambari-server&#x2F;resources&#x2F;Ambari-DDL-MySQL-CREATE.sql;</span><br><span class="line">mysql&gt; show tables;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-启动ambari-Server"><a href="#5-3-启动ambari-Server" class="headerlink" title="5.3 启动ambari-Server"></a>5.3 启动ambari-Server</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ambari-server01 ~]# ambari-server start</span><br></pre></td></tr></table></figure>

<h2 id="5-4-安装ambari-agent（ambari-node01、ambari-node02节点）"><a href="#5-4-安装ambari-agent（ambari-node01、ambari-node02节点）" class="headerlink" title="5.4 安装ambari-agent（ambari-node01、ambari-node02节点）"></a>5.4 安装ambari-agent（ambari-node01、ambari-node02节点）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ambari-node01 ~]# yum -y install ambari-agent</span><br></pre></td></tr></table></figure>

<h1 id="六、Ambari-web页面配置"><a href="#六、Ambari-web页面配置" class="headerlink" title="六、Ambari web页面配置"></a>六、Ambari web页面配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">访问地址：http:&#x2F;&#x2F;192.168.2.111:8080&#x2F;</span><br><span class="line">默认账号：admin</span><br><span class="line">默认密码：admin</span><br></pre></td></tr></table></figure>
<p>进行web页面配置时没有截图，以下截图为网上下载，仅供参考</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e3ac6dc623544508032c29fddd3bf16~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1d992f1cc1e4fbfba2806f81b33d531~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="6-1-选择版本"><a href="#6-1-选择版本" class="headerlink" title="6.1 选择版本"></a>6.1 选择版本</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb4482e463ea40e6a13135b072fdfa07~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="6-2-配置节点、密钥"><a href="#6-2-配置节点、密钥" class="headerlink" title="6.2 配置节点、密钥"></a>6.2 配置节点、密钥</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2092ab25469c4a268be9c6b91ae4e17a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="6-3-主机确认"><a href="#6-3-主机确认" class="headerlink" title="6.3 主机确认"></a>6.3 主机确认</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe2b3e217f53481c8aaa52b87915e034~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="6-4-选择要安装的组件"><a href="#6-4-选择要安装的组件" class="headerlink" title="6.4 选择要安装的组件"></a>6.4 选择要安装的组件</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f728e5d99c4f4b6987049a03b81b2565~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="6-5-节点分配"><a href="#6-5-节点分配" class="headerlink" title="6.5 节点分配"></a>6.5 节点分配</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69a24ff077c341098b01575b8414e2a5~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="6-6-分配从属和客户端"><a href="#6-6-分配从属和客户端" class="headerlink" title="6.6 分配从属和客户端"></a>6.6 分配从属和客户端</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/224b5998f1e7423480777d9324d11334~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="6-7-定制服务"><a href="#6-7-定制服务" class="headerlink" title="6.7 定制服务"></a>6.7 定制服务</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f72d7e51bfee4bf2a5fbfd01a79998ae~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51fcc85f6a5e4627a01aef1bafe1e26e~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 执行以下命令（ambari-server01节点）</span><br><span class="line">[root@ambari-server01 ~]# ambari-server setup --jdbc-db&#x3D;mysql --jdbc-driver&#x3D;&#x2F;usr&#x2F;share&#x2F;java&#x2F;mysql-connector-java-5.1.46-bin.jar</span><br></pre></td></tr></table></figure>

<h2 id="6-8-设置存储路径等"><a href="#6-8-设置存储路径等" class="headerlink" title="6.8 设置存储路径等"></a>6.8 设置存储路径等</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71a92b78ef5c4f79ac45eca4e0c83b46~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c7454bf473941e3a3f9e403f2d96328~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/497f60f441b74fdead707516a736f6ef~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="6-9-集群情况预览并部署"><a href="#6-9-集群情况预览并部署" class="headerlink" title="6.9 集群情况预览并部署"></a>6.9 集群情况预览并部署</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bf0c5646bf145008839facd353b0f3c~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/071e17b7023142668fa8c58603eddb2c~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8121b4b855c40a6af1fa61d2a2e6941~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br><strong>等待启动完毕，不用担心警告，后期可以调整，搭建完成，可以在展示页面进行查看集群状态</strong><br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cd42dfaa6ab45bb89a3a49a4f460ac5~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd7fa948348347429a4eabcad267b613~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><strong>可以查看监控界面，可以看到大数据组件中出现错误，单个组件点开处理</strong><br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4d708f1bc2e499fb07be3297782bfc5~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="6-10-监控面板"><a href="#6-10-监控面板" class="headerlink" title="6.10 监控面板"></a>6.10 监控面板</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5de66eded065467bbd807303aadda296~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="6-10-1-监控面板-主机状态"><a href="#6-10-1-监控面板-主机状态" class="headerlink" title="6.10.1 监控面板-主机状态"></a>6.10.1 监控面板-主机状态</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28a1d7e1bf27435484a3ae0fce2daab4~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="6-10-2-监控面板-配置历史（可针对单个服务调整配置）"><a href="#6-10-2-监控面板-配置历史（可针对单个服务调整配置）" class="headerlink" title="6.10.2 监控面板-配置历史（可针对单个服务调整配置）"></a>6.10.2 监控面板-配置历史（可针对单个服务调整配置）</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d463712c7e3446c90b3439cffb0182b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="6-11-新部署其他服务"><a href="#6-11-新部署其他服务" class="headerlink" title="6.11 新部署其他服务"></a>6.11 新部署其他服务</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f81f8b396a3a4e2a87749bac4028a95a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="6-12-添加node节点"><a href="#6-12-添加node节点" class="headerlink" title="6.12 添加node节点"></a>6.12 添加node节点</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97b509c6e3c141dd87722f15f673d45a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="6-13-配置邮件报警"><a href="#6-13-配置邮件报警" class="headerlink" title="6.13 配置邮件报警"></a>6.13 配置邮件报警</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68c2faa8a3194e6986198a8eeee181d2~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="6-14-ambari会自动安装grafana作为监控面板"><a href="#6-14-ambari会自动安装grafana作为监控面板" class="headerlink" title="6.14 ambari会自动安装grafana作为监控面板"></a>6.14 ambari会自动安装grafana作为监控面板</h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fae0e6faadaf41cfb769b81f445cf245~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ac9651e60ed42b9b170be87f4533f06~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><strong>至此，搭建完成！</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/09/16/Ambari%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0%E9%9B%86%E7%BE%A4%E5%88%A9%E5%99%A8%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E8%B7%B5/" data-id="ckiohtc6g0007ryradsbg7rqe" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-时间序列数据库InfluxDB集群方案高级实践经验，请关注" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/03/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E5%BA%93InfluxDB%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88%E9%AB%98%E7%BA%A7%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C%EF%BC%8C%E8%AF%B7%E5%85%B3%E6%B3%A8/" class="article-date">
  <time datetime="2020-09-03T09:22:50.000Z" itemprop="datePublished">2020-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/03/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E5%BA%93InfluxDB%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88%E9%AB%98%E7%BA%A7%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C%EF%BC%8C%E8%AF%B7%E5%85%B3%E6%B3%A8/">时间序列数据库InfluxDB集群方案高级实践经验，请关注</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>如果监控全部接入单节点influxdb显然不能满足需求，Influxdb免费版不支持集群，商业版按照节点数收费不合理，在查询Influxdb监控数据的时候天然不会跨表（Measurement）查询。</p>
<h1 id="一、数据处理"><a href="#一、数据处理" class="headerlink" title="一、数据处理"></a>一、数据处理</h1><p>连接kafka/RocketMQ服务从其中获取数据，处理数据之后调用代理网关将数据插入数据库中。</p>
<h1 id="二、查询代理"><a href="#二、查询代理" class="headerlink" title="二、查询代理"></a>二、查询代理</h1><p>预处理查询语句，过滤危险查询代码，调用查询InfluxDB数据库。</p>
<h1 id="三、网关层"><a href="#三、网关层" class="headerlink" title="三、网关层"></a>三、网关层</h1><p>网关用proxy模式来做数据分片，它的功能包括：</p>
<ul>
<li>按 db 和 measurement 分片写入不同节点</li>
<li>聚合查询请求</li>
<li>保存节点配置、转发规则到nacos中</li>
<li>动态配置和更新网关中的配置</li>
<li>在某个节点宕机后，下线或者替换某个节点</li>
<li>基于raft分布式一致性协议实现AP<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64358de4f0194979965c4a084a507609~tplv-k3u1fbpfcp-zoom-1.image" alt=""></li>
</ul>
<h1 id="四、简易架构图"><a href="#四、简易架构图" class="headerlink" title="四、简易架构图"></a>四、简易架构图</h1><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c8da0ced9eb45738b3fcd16f951f78d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/09/03/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E5%BA%93InfluxDB%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88%E9%AB%98%E7%BA%A7%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C%EF%BC%8C%E8%AF%B7%E5%85%B3%E6%B3%A8/" data-id="ckiohtc5m0002ryra3fl2ar75" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据治理的王者Apache-Atlas如何构建自己的API" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/25/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E7%9A%84%E7%8E%8B%E8%80%85Apache-Atlas%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84API/" class="article-date">
  <time datetime="2020-08-25T02:44:06.000Z" itemprop="datePublished">2020-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/25/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E7%9A%84%E7%8E%8B%E8%80%85Apache-Atlas%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84API/">数据治理的王者Apache-Atlas如何构建自己的API</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Apache Atlas是一个优秀的服务治理组件，用于企业Hadoop集群上的数据治理和元数据管理的数据治理工具。接下来我们将讨论构建自己的Java API，这些Java API可使用Apache atlas客户端与Apache Atlas交互以在其中创建新的实体和类型。</p>
<h1 id="一、Atlas客户端Maven依赖关系"><a href="#一、Atlas客户端Maven依赖关系" class="headerlink" title="一、Atlas客户端Maven依赖关系"></a>一、Atlas客户端Maven依赖关系</h1><p>以下依赖项可用于pom.xml文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.atlas&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;atlas-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.7-incubating&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.atlas&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;atlas-typesystem&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.7-incubating&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.atlas&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;atlas-notification&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.7-incubating&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.atlas&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;atlas-repository&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.7-incubating&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h1 id="二、设置atlas-application-properties"><a href="#二、设置atlas-application-properties" class="headerlink" title="二、设置atlas-application.properties"></a>二、设置atlas-application.properties</h1><p>Apache Atlas客户端使用atlas-application属性在我们的API和Apache Atlas服务器之间建立连接。这些属性应放置在resources/atlas-application.properties中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#########  Security Properties  #########</span><br><span class="line"></span><br><span class="line"># SSL config</span><br><span class="line">atlas.enableTLS&#x3D;false</span><br><span class="line"></span><br><span class="line">#########  Server Properties  #########</span><br><span class="line">atlas.rest.address&#x3D;http:&#x2F;&#x2F;192.168.5.95:21000</span><br><span class="line"></span><br><span class="line">atlas.hook.demo.kafka.retries&#x3D;1</span><br><span class="line">atlas.kafka.zookeeper.connect&#x3D;192.168.5.93:2181,192.168.5.94:2181,192.168.5.95:2181</span><br><span class="line">atlas.kafka.bootstrap.servers&#x3D;192.168.5.93:9092,192.168.5.94:9092,192.168.5.95:9092</span><br><span class="line">atlas.kafka.zookeeper.session.timeout.ms&#x3D;4000</span><br><span class="line">atlas.kafka.zookeeper.connection.timeout.ms&#x3D;2000</span><br><span class="line">atlas.kafka.zookeeper.sync.time.ms&#x3D;20</span><br><span class="line">atlas.kafka.auto.commit.interval.ms&#x3D;1000</span><br><span class="line">atlas.kafka.hook.group.id&#x3D;atlas</span><br></pre></td></tr></table></figure>
<h1 id="三、创建与Atlas服务器的连接"><a href="#三、创建与Atlas服务器的连接" class="headerlink" title="三、创建与Atlas服务器的连接"></a>三、创建与Atlas服务器的连接</h1><p>要与Apache atlas Server，baseUrl和用户名创建连接，必须在AtlasClient构造函数中传递密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final AtlasClient atlasClient &#x3D; new AtlasClient</span><br><span class="line">            (new String[]&#123;&quot;http:&#x2F;&#x2F;192.168.5.95:21000&quot;&#125;,</span><br><span class="line">                    new String[]&#123;&quot;admin&quot;,</span><br><span class="line">                            &quot;admin&quot;&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="四、关于Type相关的测试类"><a href="#四、关于Type相关的测试类" class="headerlink" title="四、关于Type相关的测试类"></a>四、关于Type相关的测试类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">public class AtlasTypesTest &#123;</span><br><span class="line"></span><br><span class="line">    final AtlasClient atlasClient &#x3D; new AtlasClient</span><br><span class="line">            (new String[]&#123;&quot;http:&#x2F;&#x2F;192.168.5.95:21000&quot;&#125;,</span><br><span class="line">                    new String[]&#123;&quot;admin&quot;,</span><br><span class="line">                            &quot;admin&quot;&#125;);</span><br><span class="line"></span><br><span class="line">    static final String DATABASE_TYPE &#x3D; &quot;DB_Sync&quot;;</span><br><span class="line">    static final String COLUMN_TYPE &#x3D; &quot;Column_Sync&quot;;</span><br><span class="line">    static final String TABLE_TYPE &#x3D; &quot;Table_Sync&quot;;</span><br><span class="line">    static final String VIEW_TYPE &#x3D; &quot;View_Sync&quot;;</span><br><span class="line">    public static final String DB_ATTRIBUTE &#x3D; &quot;db&quot;;</span><br><span class="line">    static final String STORAGE_DESC_TYPE &#x3D; &quot;StorageDesc&quot;;</span><br><span class="line">    public static final String COLUMNS_ATTRIBUTE &#x3D; &quot;columns&quot;;</span><br><span class="line">    public static final String INPUT_TABLES_ATTRIBUTE &#x3D; &quot;inputTables&quot;;</span><br><span class="line">    private static final String[] TYPES &#x3D;</span><br><span class="line">            &#123;DATABASE_TYPE, TABLE_TYPE, STORAGE_DESC_TYPE, COLUMN_TYPE, VIEW_TYPE, &quot;JdbcAccess&quot;,</span><br><span class="line">                    &quot;ETL&quot;, &quot;Metric&quot;, &quot;PII&quot;, &quot;Fact&quot;, &quot;Dimension&quot;, &quot;Log Data&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 组织定义types</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    TypesDef createTypeDefinitions() &#123;</span><br><span class="line">        HierarchicalTypeDefinition&lt;ClassType&gt; dbClsDef &#x3D; TypesUtil</span><br><span class="line">                .createClassTypeDef(DATABASE_TYPE, DATABASE_TYPE, null,</span><br><span class="line">                        TypesUtil.createUniqueRequiredAttrDef(&quot;name&quot;, DataTypes.STRING_TYPE),</span><br><span class="line">                        attrDef(&quot;description&quot;, DataTypes.STRING_TYPE.getName()), attrDef(&quot;locationUri&quot;, DataTypes.STRING_TYPE.getName()),</span><br><span class="line">                        attrDef(&quot;owner&quot;, DataTypes.STRING_TYPE.getName()), attrDef(&quot;createTime&quot;, DataTypes.LONG_TYPE.getName()));</span><br><span class="line"></span><br><span class="line">        HierarchicalTypeDefinition&lt;ClassType&gt; columnClsDef &#x3D; TypesUtil</span><br><span class="line">                .createClassTypeDef(COLUMN_TYPE, COLUMN_TYPE, null, attrDef(&quot;name&quot;, DataTypes.STRING_TYPE.getName()),</span><br><span class="line">                        attrDef(&quot;dataType&quot;, DataTypes.STRING_TYPE.getName()), attrDef(&quot;comment&quot;, DataTypes.STRING_TYPE.getName()));</span><br><span class="line"></span><br><span class="line">        HierarchicalTypeDefinition&lt;ClassType&gt; tblClsDef &#x3D; TypesUtil</span><br><span class="line">                .createClassTypeDef(TABLE_TYPE, TABLE_TYPE, ImmutableSet.of(&quot;DataSet&quot;),</span><br><span class="line">                        new AttributeDefinition(DB_ATTRIBUTE, DATABASE_TYPE, Multiplicity.REQUIRED, false, null),</span><br><span class="line">                        new AttributeDefinition(&quot;sd&quot;, STORAGE_DESC_TYPE, Multiplicity.REQUIRED, true, null),</span><br><span class="line">                        attrDef(&quot;owner&quot;, DataTypes.STRING_TYPE.getName()), attrDef(&quot;createTime&quot;, DataTypes.LONG_TYPE.getName()),</span><br><span class="line">                        attrDef(&quot;lastAccessTime&quot;, DataTypes.LONG_TYPE.getName()), attrDef(&quot;retention&quot;, DataTypes.LONG_TYPE.getName()),</span><br><span class="line">                        attrDef(&quot;viewOriginalText&quot;, DataTypes.STRING_TYPE.getName()),</span><br><span class="line">                        attrDef(&quot;viewExpandedText&quot;, DataTypes.STRING_TYPE.getName()), attrDef(&quot;tableType&quot;, DataTypes.STRING_TYPE.getName()),</span><br><span class="line">                        attrDef(&quot;temporary&quot;, DataTypes.BOOLEAN_TYPE.getName()),</span><br><span class="line">                        new AttributeDefinition(COLUMNS_ATTRIBUTE, DataTypes.arrayTypeName(COLUMN_TYPE),</span><br><span class="line">                                Multiplicity.COLLECTION, true, null));</span><br><span class="line"></span><br><span class="line">        HierarchicalTypeDefinition&lt;ClassType&gt; viewClsDef &#x3D; TypesUtil</span><br><span class="line">                .createClassTypeDef(VIEW_TYPE, VIEW_TYPE, ImmutableSet.of(&quot;DataSet&quot;),</span><br><span class="line">                        new AttributeDefinition(&quot;db&quot;, DATABASE_TYPE, Multiplicity.REQUIRED, false, null),</span><br><span class="line">                        new AttributeDefinition(&quot;inputTables&quot;, DataTypes.arrayTypeName(TABLE_TYPE),</span><br><span class="line">                                Multiplicity.COLLECTION, false, null));</span><br><span class="line"></span><br><span class="line">        return TypesUtil.getTypesDef(ImmutableList.&lt;EnumTypeDefinition&gt;of(), ImmutableList.&lt;StructTypeDefinition&gt;of(),</span><br><span class="line">                ImmutableList.of(),</span><br><span class="line">                ImmutableList.of(dbClsDef, columnClsDef, tblClsDef, viewClsDef));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void createTypes() throws Exception &#123;</span><br><span class="line">        TypesDef typesDef &#x3D; createTypeDefinitions();</span><br><span class="line">        String typesAsJSON &#x3D;  TypesSerialization.toJson(typesDef);</span><br><span class="line">        System.out.println(&quot;typesAsJSON &#x3D; &quot; + typesAsJSON);</span><br><span class="line">        atlasClient.createType(typesAsJSON);</span><br><span class="line">        verifyTypesCreated();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void verifyTypesCreated() throws Exception &#123;</span><br><span class="line">        List&lt;String&gt; types &#x3D; atlasClient.listTypes();</span><br><span class="line">        for (String type : TYPES) &#123;</span><br><span class="line">            assert types.contains(type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AttributeDefinition attrDef(String name, String dT) &#123;</span><br><span class="line">        return attrDef(name, dT, Multiplicity.OPTIONAL, false, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AttributeDefinition attrDef(String name, String dT, Multiplicity m, boolean isComposite,</span><br><span class="line">                                String reverseAttributeName) &#123;</span><br><span class="line">        return new AttributeDefinition(name, dT, m, isComposite, reverseAttributeName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void createNewTypes() throws Exception &#123;</span><br><span class="line">        createTypes();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、关于Entities相关的测试类"><a href="#五、关于Entities相关的测试类" class="headerlink" title="五、关于Entities相关的测试类"></a>五、关于Entities相关的测试类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">public class AtlasEntitiesTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    final AtlasClient atlasClient &#x3D; new AtlasClient</span><br><span class="line">            (new String[]&#123;&quot;http:&#x2F;&#x2F;192.168.5.95:21000&quot;&#125;,</span><br><span class="line">                    new String[]&#123;&quot;admin&quot;,</span><br><span class="line">                            &quot;admin&quot;&#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 创建实例并返创建的Id对象</span><br><span class="line">     * @param referenceable</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Id createInstance(Referenceable referenceable) throws Exception &#123;</span><br><span class="line">        String typeName &#x3D; referenceable.getTypeName();</span><br><span class="line">        String entityJSON &#x3D; InstanceSerialization.toJson(referenceable, true);</span><br><span class="line">        System.out.println(&quot;Submitting new entity&#x3D; &quot; + entityJSON);</span><br><span class="line">        List&lt;String&gt; guids &#x3D; atlasClient.createEntity(entityJSON);</span><br><span class="line">        System.out.println(&quot;created instance for type &quot; + typeName + &quot;, guid: &quot; + guids);</span><br><span class="line">        return new Id(guids.get(guids.size() - 1), referenceable.getId().getVersion(),</span><br><span class="line">                referenceable.getTypeName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 创建数据库实例并返创建的数据库Id对象</span><br><span class="line">     * @param name</span><br><span class="line">     * @param description</span><br><span class="line">     * @param owner</span><br><span class="line">     * @param locationUri</span><br><span class="line">     * @param traitNames</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Id database(String name, String description, String owner, String locationUri, String... traitNames)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        Referenceable referenceable &#x3D; new Referenceable(DATABASE_TYPE, traitNames);</span><br><span class="line">        referenceable.set(&quot;name&quot;, name);</span><br><span class="line">        referenceable.set(&quot;description&quot;, description);</span><br><span class="line">        referenceable.set(&quot;owner&quot;, owner);</span><br><span class="line">        referenceable.set(&quot;locationUri&quot;, locationUri);</span><br><span class="line">        referenceable.set(&quot;createTime&quot;, System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        return createInstance(referenceable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 创建列的实例并返创建的列的实例对象</span><br><span class="line">     * @param name</span><br><span class="line">     * @param dataType</span><br><span class="line">     * @param comment</span><br><span class="line">     * @param traitNames</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Referenceable column(String name, String dataType, String comment, String... traitNames) throws Exception &#123;</span><br><span class="line">        Referenceable referenceable &#x3D; new Referenceable(COLUMN_TYPE, traitNames);</span><br><span class="line">        referenceable.set(&quot;name&quot;, name);</span><br><span class="line">        referenceable.set(&quot;dataType&quot;, dataType);</span><br><span class="line">        referenceable.set(&quot;comment&quot;, comment);</span><br><span class="line"></span><br><span class="line">        return referenceable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 创建表的实例并返创建的表的Id对象</span><br><span class="line">     * @param name</span><br><span class="line">     * @param description</span><br><span class="line">     * @param dbId</span><br><span class="line">     * @param sd</span><br><span class="line">     * @param owner</span><br><span class="line">     * @param tableType</span><br><span class="line">     * @param columns</span><br><span class="line">     * @param traitNames</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Id table(String name, String description, Id dbId, Referenceable sd, String owner, String tableType,</span><br><span class="line">             List&lt;Referenceable&gt; columns, String... traitNames) throws Exception &#123;</span><br><span class="line">        Referenceable referenceable &#x3D; new Referenceable(TABLE_TYPE, traitNames);</span><br><span class="line">        referenceable.set(&quot;name&quot;, name);</span><br><span class="line">        referenceable.set(AtlasClient.REFERENCEABLE_ATTRIBUTE_NAME, name);</span><br><span class="line">        referenceable.set(&quot;description&quot;, description);</span><br><span class="line">        referenceable.set(&quot;owner&quot;, owner);</span><br><span class="line">        referenceable.set(&quot;tableType&quot;, tableType);</span><br><span class="line">        referenceable.set(&quot;createTime&quot;, System.currentTimeMillis());</span><br><span class="line">        referenceable.set(&quot;lastAccessTime&quot;, System.currentTimeMillis());</span><br><span class="line">        referenceable.set(&quot;retention&quot;, System.currentTimeMillis());</span><br><span class="line">        referenceable.set(&quot;db&quot;, dbId);</span><br><span class="line">        referenceable.set(&quot;sd&quot;, sd);</span><br><span class="line">        referenceable.set(&quot;columns&quot;, columns);</span><br><span class="line"></span><br><span class="line">        return createInstance(referenceable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 创建视图的实例并返创建的视图的Id对象</span><br><span class="line">     * @param name</span><br><span class="line">     * @param dbId</span><br><span class="line">     * @param inputTables</span><br><span class="line">     * @param traitNames</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Id view(String name, Id dbId, List&lt;Id&gt; inputTables, String... traitNames) throws Exception &#123;</span><br><span class="line">        Referenceable referenceable &#x3D; new Referenceable(VIEW_TYPE, traitNames);</span><br><span class="line">        referenceable.set(&quot;name&quot;, name);</span><br><span class="line">        referenceable.set(AtlasClient.REFERENCEABLE_ATTRIBUTE_NAME, name);</span><br><span class="line">        referenceable.set(&quot;db&quot;, dbId);</span><br><span class="line"></span><br><span class="line">        referenceable.set(INPUT_TABLES_ATTRIBUTE, inputTables);</span><br><span class="line"></span><br><span class="line">        return createInstance(referenceable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 原始存储描述符</span><br><span class="line">     * @param location</span><br><span class="line">     * @param inputFormat</span><br><span class="line">     * @param outputFormat</span><br><span class="line">     * @param compressed</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Referenceable storageDescriptor(String location, String inputFormat, String outputFormat, boolean compressed)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        Referenceable referenceable &#x3D; new Referenceable(STORAGE_DESC_TYPE);</span><br><span class="line">        referenceable.set(&quot;location&quot;, location);</span><br><span class="line">        referenceable.set(&quot;inputFormat&quot;, inputFormat);</span><br><span class="line">        referenceable.set(&quot;outputFormat&quot;, outputFormat);</span><br><span class="line">        referenceable.set(&quot;compressed&quot;, compressed);</span><br><span class="line"></span><br><span class="line">        return referenceable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void createEntities() throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;创建数据库实例</span><br><span class="line">        Id syncDB &#x3D; database(&quot;sy_sync&quot;, &quot;Sync Database&quot;, &quot;root&quot;, &quot;&quot;);</span><br><span class="line">        &#x2F;&#x2F;存储描述符</span><br><span class="line">        Referenceable sd &#x3D;</span><br><span class="line">                storageDescriptor(&quot;&quot;, &quot;TextInputFormat&quot;, &quot;TextOutputFormat&quot;,</span><br><span class="line">                        true);</span><br><span class="line">        &#x2F;&#x2F;创建列实例</span><br><span class="line">        &#x2F;&#x2F;1、数据源</span><br><span class="line">        List&lt;Referenceable&gt; databaseColumns &#x3D; ImmutableList</span><br><span class="line">                .of(column(&quot;id&quot;, &quot;long&quot;, &quot;id&quot;),</span><br><span class="line">                        column(&quot;name&quot;, &quot;string&quot;, &quot;name&quot;),</span><br><span class="line">                        column(&quot;type&quot;, &quot;string&quot;, &quot;type&quot;),</span><br><span class="line">                        column(&quot;url&quot;, &quot;string&quot;, &quot;url&quot;),</span><br><span class="line">                        column(&quot;database_name&quot;, &quot;string&quot;, &quot;database name&quot;),</span><br><span class="line">                        column(&quot;username&quot;, &quot;string&quot;, &quot;username&quot;),</span><br><span class="line">                        column(&quot;password&quot;,&quot;string&quot;,&quot;password&quot;),</span><br><span class="line">                        column(&quot;description&quot;, &quot;string&quot;, &quot;description&quot;),</span><br><span class="line">                        column(&quot;create_time&quot;, &quot;string&quot;, &quot;create time&quot;),</span><br><span class="line">                        column(&quot;update_time&quot;, &quot;string&quot;, &quot;update time&quot;),</span><br><span class="line">                        column(&quot;create_id&quot;, &quot;long&quot;, &quot;user id&quot;),</span><br><span class="line">                        column(&quot;update_id&quot;, &quot;long&quot;, &quot;user id&quot;));</span><br><span class="line">        &#x2F;&#x2F;2、同步文件夹</span><br><span class="line">        List&lt;Referenceable&gt; syncFolderColumns &#x3D; ImmutableList</span><br><span class="line">                .of(column(&quot;id&quot;, &quot;long&quot;, &quot;id&quot;),</span><br><span class="line">                        column(&quot;name&quot;, &quot;string&quot;, &quot;name&quot;),</span><br><span class="line">                        column(&quot;description&quot;, &quot;string&quot;, &quot;description&quot;),</span><br><span class="line">                        column(&quot;create_time&quot;, &quot;string&quot;, &quot;create time&quot;),</span><br><span class="line">                        column(&quot;update_time&quot;, &quot;string&quot;, &quot;update time&quot;),</span><br><span class="line">                        column(&quot;create_id&quot;, &quot;long&quot;, &quot;user id&quot;),</span><br><span class="line">                        column(&quot;update_id&quot;, &quot;long&quot;, &quot;user id&quot;));</span><br><span class="line">        &#x2F;&#x2F;创建表实例</span><br><span class="line">        Id database &#x3D; table(&quot;datasource&quot;, &quot;database table&quot;, syncDB, sd, &quot;root&quot;, &quot;External&quot;, databaseColumns);</span><br><span class="line">        Id syncFolder &#x3D; table(&quot;folder&quot;, &quot;sync folder table&quot;, syncDB, sd, &quot;root&quot;, &quot;External&quot;, syncFolderColumns);</span><br><span class="line">        &#x2F;&#x2F;创建视图实例</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void getEntity() throws AtlasServiceException &#123;</span><br><span class="line">        Referenceable referenceable &#x3D; atlasClient.getEntity(&quot;1406ddd0-5d51-41d4-b174-859bd4f34a5b&quot;);</span><br><span class="line">        System.out.println(InstanceSerialization.toJson(referenceable, true));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/08/25/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E7%9A%84%E7%8E%8B%E8%80%85Apache-Atlas%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84API/" data-id="ckiohtc78000iryra9dyk1ham" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CountDownLatch、Semaphore、CyclicBarrier、Condition源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/26/CountDownLatch%E3%80%81Semaphore%E3%80%81CyclicBarrier%E3%80%81Condition%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2020-07-26T11:27:44.000Z" itemprop="datePublished">2020-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/26/CountDownLatch%E3%80%81Semaphore%E3%80%81CyclicBarrier%E3%80%81Condition%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">CountDownLatch、Semaphore、CyclicBarrier、Condition源码分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、CountDownLatch"><a href="#一、CountDownLatch" class="headerlink" title="一、CountDownLatch"></a>一、CountDownLatch</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>它是一个同步辅助类，允许一个或多个线程等待，直到在其他线程中执行的一组操作完成。一个倒数计算的概念。<br>初始化给定一定的整数参数值，然后通过countDown()来实现倒数功能，在这个整数倒数到 0 之前，调用了 await() 方法的程序都必须要等待，当到达0后， 释放所有等待线程。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/26/17389d7755916958?w=1843&h=607&f=png&s=70631" alt=""></p>
<h2 id="1-2-源码分析"><a href="#1-2-源码分析" class="headerlink" title="1.2 源码分析"></a>1.2 源码分析</h2><p>对于 CountDownLatch，我们仅仅需要关心两个方法，一个是 <strong>countDown</strong>() 方法，另一个是 <strong>await</strong>() 方法。</p>
<h2 id="1-2-1-countDown"><a href="#1-2-1-countDown" class="headerlink" title="1.2.1 countDown()"></a>1.2.1 countDown()</h2><p>CountDownLatch有一个同步内部类<strong>Sync</strong>：<br>它使用AQS状态表示计数，实现同步控制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Synchronization control For CountDownLatch.</span><br><span class="line">     * Uses AQS state to represent count.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static final class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        private static final long serialVersionUID &#x3D; 4982264981922014374L;</span><br><span class="line"></span><br><span class="line">        Sync(int count) &#123;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int getCount() &#123;</span><br><span class="line">            return getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">            return (getState() &#x3D;&#x3D; 0) ? 1 : -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">            &#x2F;&#x2F; Decrement count; signal when transition to zero</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                int c &#x3D; getState();</span><br><span class="line">                if (c &#x3D;&#x3D; 0)</span><br><span class="line">                    return false;</span><br><span class="line">                int nextc &#x3D; c-1;</span><br><span class="line">                if (compareAndSetState(c, nextc))</span><br><span class="line">                    return nextc &#x3D;&#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>countDown方法调用Sync中releaseShared()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void countDown() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的线程由于调用了await()方法阻塞了，只能等到countDown()使得state=0的时候才会被全部唤醒。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    &#x2F;&#x2F; Decrement count; signal when transition to zero</span><br><span class="line">    &#x2F;&#x2F;使用自旋的方式实现state-1</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; getState();</span><br><span class="line">        if (c &#x3D;&#x3D; 0)</span><br><span class="line">            return false;</span><br><span class="line">        int nextc &#x3D; c-1;</span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line">            return nextc &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当state递减为0的时候，tryReleaseShared才返回true；否则只是返回state-1的值；<br>如果state=0，调用<strong>doReleaseShared</strong>()方法，唤醒等待的线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h !&#x3D; tail) &#123;</span><br><span class="line">            int ws &#x3D; h.waitStatus;</span><br><span class="line">            if (ws &#x3D;&#x3D; Node.SIGNAL) &#123;</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            &#x2F;&#x2F; loop to recheck cases</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;PROPAGATE的节点状态，表示处于共享模式，会对线程的唤醒进行传播</span><br><span class="line">            else if (ws &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                &#x2F;&#x2F; loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果前面唤醒的线程占领了head，那么再进行循环，通过头节点检查是否改变了，如果改变了就继续循环</span><br><span class="line">        if (h &#x3D;&#x3D; head)                   &#x2F;&#x2F; loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在线程被唤醒的执行顺序中：</p>
<ul>
<li><strong>h == head</strong> 表示头节点还没有被使用；</li>
<li><strong>unparkSuccessor(h)</strong> 表示唤醒的线程；</li>
<li><strong>h != head</strong> 表示头节点被刚刚唤醒的线程占用。</li>
</ul>
<h2 id="1-2-2-await"><a href="#1-2-2-await" class="headerlink" title="1.2.2 await()"></a>1.2.2 await()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void await() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<strong>state&lt;0</strong>，那么当前线程需要加入到共享锁队列中，执行<strong>doAcquireSharedInterruptibly</strong>()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireSharedInterruptibly(int arg)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    &#x2F;&#x2F;SHARED为共享模式，创建一个共享模式的节点到队列中</span><br><span class="line">    final Node node &#x3D; addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            if (p &#x3D;&#x3D; head) &#123;</span><br><span class="line">                &#x2F;&#x2F;尝试获取锁</span><br><span class="line">                int r &#x3D; tryAcquireShared(arg);</span><br><span class="line">                &#x2F;&#x2F;获得了锁并且state!&#x3D;0，下面的代码则不会执行</span><br><span class="line">                if (r &gt;&#x3D; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F;把唤醒的节点，设置成head节点</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                    failed &#x3D; false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把唤醒的节点，设置成head节点，当第一个线程被唤醒后，并设置为head节点，依次会唤醒第二个线程……</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">    Node h &#x3D; head; &#x2F;&#x2F; Record old head for check below</span><br><span class="line">    setHead(node);</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * Try to signal next queued node if:</span><br><span class="line">     *   Propagation was indicated by caller,</span><br><span class="line">     *     or was recorded (as h.waitStatus either before</span><br><span class="line">     *     or after setHead) by a previous operation</span><br><span class="line">     *     (note: this uses sign-check of waitStatus because</span><br><span class="line">     *      PROPAGATE status may transition to SIGNAL.)</span><br><span class="line">     * and</span><br><span class="line">     *   The next node is waiting in shared mode,</span><br><span class="line">     *     or we don&#39;t know, because it appears null</span><br><span class="line">     *</span><br><span class="line">     * The conservatism in both of these checks may cause</span><br><span class="line">     * unnecessary wake-ups, but only when there are multiple</span><br><span class="line">     * racing acquires&#x2F;releases, so most need signals now or soon</span><br><span class="line">     * anyway.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    if (propagate &gt; 0 || h &#x3D;&#x3D; null || h.waitStatus &lt; 0 ||</span><br><span class="line">        (h &#x3D; head) &#x3D;&#x3D; null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">        Node s &#x3D; node.next;</span><br><span class="line">        if (s &#x3D;&#x3D; null || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="https://user-gold-cdn.xitu.io/2020/7/26/1738a21abbf083e6?w=971&h=322&f=png&s=38421" alt=""></p>
<h1 id="二、Semaphore"><a href="#二、Semaphore" class="headerlink" title="二、Semaphore"></a>二、Semaphore</h1><h2 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h2><p>从单词的意思理解为信号灯，它可以控制同时访问程序的线程个数，比如停车场总共有100个车位，那么这时一下子来了150辆车需要停放在此停车场，必须要等到停车场有空余的位置才能让停满剩下的车进入此停车场。使用场景可用于限流。<br><img src="https://user-gold-cdn.xitu.io/2020/7/26/1738a47754e9bdbb?w=1795&h=712&f=png&s=87894" alt=""></p>
<p>两个重要的方法，acquire()获取一个许可，release()释放一个许可。</p>
<h2 id="2-2-源码分析"><a href="#2-2-源码分析" class="headerlink" title="2.2 源码分析"></a>2.2 源码分析</h2><h2 id="2-2-1-FairSync-公平策略"><a href="#2-2-1-FairSync-公平策略" class="headerlink" title="2.2.1 FairSync 公平策略"></a>2.2.1 FairSync 公平策略</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 2014338818796000944L;</span><br><span class="line"></span><br><span class="line">    FairSync(int permits) &#123;</span><br><span class="line">        super(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            &#x2F;&#x2F;判断是否有线程在排队，然后再进行CAS操作</span><br><span class="line">            if (hasQueuedPredecessors())</span><br><span class="line">                return -1;</span><br><span class="line">            int available &#x3D; getState();</span><br><span class="line">            int remaining &#x3D; available - acquires;</span><br><span class="line">            if (remaining &lt; 0 ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                return remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-2-2-NonFairSync-非公平策略"><a href="#2-2-2-NonFairSync-非公平策略" class="headerlink" title="2.2.2 NonFairSync 非公平策略"></a>2.2.2 NonFairSync 非公平策略</h2><p>公平与非公平策略只是多了个<strong>hasQueuedPredecessors</strong>()判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; -2694183684443567898L;</span><br><span class="line"></span><br><span class="line">    NonfairSync(int permits) &#123;</span><br><span class="line">        super(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">        return nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>nonfairTryAcquireShared</strong>()方法源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final int nonfairTryAcquireShared(int acquires) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int available &#x3D; getState();</span><br><span class="line">        int remaining &#x3D; available - acquires;</span><br><span class="line">        if (remaining &lt; 0 ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            return remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其它源码和 <strong>CountDownLatch</strong> 的是完全一样，都是基于共享锁的实现的。</p>
<h1 id="三、CyclicBarrier"><a href="#三、CyclicBarrier" class="headerlink" title="三、CyclicBarrier"></a>三、CyclicBarrier</h1><h2 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h2><p>从单词组成的意思理解为<strong>循环屏障</strong>。所谓屏障就是一个同步点，当一组线程到达这个同步点的时候被阻塞了，只有最后一个线程到达这个同步点的时候，屏障（也就是同步点）的大门才会打开，所有被拦截在大门之外的线程才会进入大门而继续工作。可以适用的场景于所有的子线程完成任务后，再执行主线程。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/26/1738a80a234bb06d?w=715&h=799&f=png&s=118926" alt=""></p>
<h2 id="3-2-源码分析"><a href="#3-2-源码分析" class="headerlink" title="3.2 源码分析"></a>3.2 源码分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public CyclicBarrier(int parties, Runnable barrierAction) &#123;</span><br><span class="line">    if (parties &lt;&#x3D; 0) throw new IllegalArgumentException();</span><br><span class="line">    this.parties &#x3D; parties;</span><br><span class="line">    this.count &#x3D; parties;</span><br><span class="line">    this.barrierCommand &#x3D; barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造方法参数parties，表示参与线程的个数；<br>每一个线程调用await()方法后，parties递减1，穿过屏障的大门（栅栏）后重置。<br>第二个参数barrierAction为Runnable实例，由最后一个到达的线程进行执行，如果没有需要执行的，设置为null。</p>
<h1 id="四、Condition"><a href="#四、Condition" class="headerlink" title="四、Condition"></a>四、Condition</h1><h2 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h2><p>它是一个用来多线程的协调通信的工具类，当某个线程阻塞等待某个条件时，当满足条件才会被唤醒。</p>
<h2 id="4-2-源码分析"><a href="#4-2-源码分析" class="headerlink" title="4.2 源码分析"></a>4.2 源码分析</h2><p>两个重要方法，await()和signal()。</p>
<h2 id="4-2-1-await"><a href="#4-2-1-await" class="headerlink" title="4.2.1 await()"></a>4.2.1 await()</h2><p>调用此方法会使得线程进入等待队列并释放锁，线程的状态变成等待状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">    &#x2F;&#x2F;允许线程中断</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    &#x2F;&#x2F;创建一个状态为condition的节点，采用链表的形式存放数据</span><br><span class="line">    Node node &#x3D; addConditionWaiter();</span><br><span class="line">    &#x2F;&#x2F;释放当前的锁，得到锁的状态，释放等待队列中的一个线程</span><br><span class="line">    int savedState &#x3D; fullyRelease(node);</span><br><span class="line">    int interruptMode &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F;判断当前节点是或否在队列上</span><br><span class="line">    while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        &#x2F;&#x2F;挂起当前线程</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        if ((interruptMode &#x3D; checkInterruptWhileWaiting(node)) !&#x3D; 0)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;acquireQueued为false就拿到了锁</span><br><span class="line">    &#x2F;&#x2F;interruptMode !&#x3D; THROW_IE表示这个线程没有成功将 node 入队,但 signal 执行了 enq 方法让其入队了</span><br><span class="line">    if (acquireQueued(node, savedState) &amp;&amp; interruptMode !&#x3D; THROW_IE)</span><br><span class="line">        &#x2F;&#x2F;将这个变量设置成 REINTERRUPT</span><br><span class="line">        interruptMode &#x3D; REINTERRUPT;</span><br><span class="line">    &#x2F;&#x2F;如果node节点的下一个等待者不为空，则开始进行清理，清理condition节点 </span><br><span class="line">    if (node.nextWaiter !&#x3D; null) &#x2F;&#x2F; clean up if cancelled</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    &#x2F;&#x2F;如果线程中断了，需要抛出异常    </span><br><span class="line">    if (interruptMode !&#x3D; 0)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>addConditionWaiter()源码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private Node addConditionWaiter() &#123;</span><br><span class="line">    Node t &#x3D; lastWaiter;</span><br><span class="line">    &#x2F;&#x2F; If lastWaiter is cancelled, clean out.</span><br><span class="line">    &#x2F;&#x2F;如果lastWaiter不等于空并且waitStatus不为condition，把这个节点从链表中移除</span><br><span class="line">    if (t !&#x3D; null &amp;&amp; t.waitStatus !&#x3D; Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t &#x3D; lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;创建一个状态为condition的单向列表</span><br><span class="line">    Node node &#x3D; new Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    if (t &#x3D;&#x3D; null)</span><br><span class="line">        firstWaiter &#x3D; node;</span><br><span class="line">    else</span><br><span class="line">        t.nextWaiter &#x3D; node;</span><br><span class="line">    lastWaiter &#x3D; node;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>fullyRelease()方法源码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final int fullyRelease(Node node) &#123;</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;获得重入的次数</span><br><span class="line">        int savedState &#x3D; getState();</span><br><span class="line">        &#x2F;&#x2F;释放并唤醒同步队列中的线程</span><br><span class="line">        if (release(savedState)) &#123;</span><br><span class="line">            failed &#x3D; false;</span><br><span class="line">            return savedState;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            node.waitStatus &#x3D; Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>isOnSyncQueue()方法源码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final boolean isOnSyncQueue(Node node) &#123;</span><br><span class="line">    &#x2F;&#x2F;判断当前节点是否在队列中，false表示不在，true表示在</span><br><span class="line">    if (node.waitStatus &#x3D;&#x3D; Node.CONDITION || node.prev &#x3D;&#x3D; null)</span><br><span class="line">        return false;</span><br><span class="line">    if (node.next !&#x3D; null) &#x2F;&#x2F; If has successor, it must be on queue</span><br><span class="line">        return true;</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * node.prev can be non-null, but not yet on queue because</span><br><span class="line">     * the CAS to place it on queue can fail. So we have to</span><br><span class="line">     * traverse from tail to make sure it actually made it.  It</span><br><span class="line">     * will always be near the tail in calls to this method, and</span><br><span class="line">     * unless the CAS failed (which is unlikely), it will be</span><br><span class="line">     * there, so we hardly ever traverse much.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;从tail节点往前扫描AQS队列，如果发现AQS队列中的节点与当前节点相等，则说明节点一定存在与队列中</span><br><span class="line">    return findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-2-signal"><a href="#4-2-2-signal" class="headerlink" title="4.2.2 signal()"></a>4.2.2 signal()</h2><p>调用此方法，将会唤醒在AQS队列中的节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final void signal() &#123;</span><br><span class="line">    &#x2F;&#x2F;判断当前线程是否获得了锁</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    &#x2F;&#x2F;AQS队列的第一个节点</span><br><span class="line">    Node first &#x3D; firstWaiter;</span><br><span class="line">    if (first !&#x3D; null)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>doSignal()方法的源码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void doSignal(Node first) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F;从condition队列中移除first节点</span><br><span class="line">        if ( (firstWaiter &#x3D; first.nextWaiter) &#x3D;&#x3D; null)</span><br><span class="line">            lastWaiter &#x3D; null;</span><br><span class="line">        first.nextWaiter &#x3D; null;</span><br><span class="line">    &#125; while (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first &#x3D; firstWaiter) !&#x3D; null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>transferForSignal()方法的源码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">final boolean transferForSignal(Node node) &#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * If cannot change waitStatus, the node has been cancelled.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;更新节点状态为0</span><br><span class="line">    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * Splice onto queue and try to set waitStatus of predecessor to</span><br><span class="line">     * indicate that thread is (probably) waiting. If cancelled or</span><br><span class="line">     * attempt to set waitStatus fails, wake up to resync (in which</span><br><span class="line">     * case the waitStatus can be transiently and harmlessly wrong).</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;调用 enq，把当前节点添加到AQS队列。并且返回返回按当前节点的上一个节点，也就是原tail 节点</span><br><span class="line">    Node p &#x3D; enq(node);</span><br><span class="line">    int ws &#x3D; p.waitStatus;</span><br><span class="line">    &#x2F;&#x2F;如果上一个节点被取消了，尝试设置上一节点状态为SIGNAL</span><br><span class="line">    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        &#x2F;&#x2F;唤醒节点上的线程</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>阻塞：await()方法中，在线程释放锁资源之后，如果节点不在AQS等待队列，则阻塞当前线程，如果在等待队列，则自旋等待尝试获取锁；</li>
<li>释放：signal()后，节点会从condition队列移动到AQS等待队列，则进入正常锁的获取流程。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/07/26/CountDownLatch%E3%80%81Semaphore%E3%80%81CyclicBarrier%E3%80%81Condition%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" data-id="ckiohtc6h0008ryraag04adc1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-微服务核心重新认识SpringBoot，掌握核心特性及设计思想" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86SpringBoot%EF%BC%8C%E6%8E%8C%E6%8F%A1%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/" class="article-date">
  <time datetime="2020-07-05T10:14:48.000Z" itemprop="datePublished">2020-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86SpringBoot%EF%BC%8C%E6%8E%8C%E6%8F%A1%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/">微服务核心重新认识SpringBoot，掌握核心特性及设计思想</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”.</p>
<p>We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need minimal Spring configuration.</p>
<p>这是Spring官网对SpringBoot的定义和评价。</p>
<h1 id="一、SpringBoot的前世今生"><a href="#一、SpringBoot的前世今生" class="headerlink" title="一、SpringBoot的前世今生"></a>一、SpringBoot的前世今生</h1><p>对于Spring框架而言，我们接触的比较多的是Spring framework中的SpringMVC、IOC、AOP、DI等。而这些框架在使用过程中需要进行大量的配置文件的编写，或者需要进行很多繁琐的配置才能完成项目的初始化搭建工作。Spring可以说它是万能胶，这样一点没错。下面我们来使用SpringMVC去构建一个Web项目，看看其步骤有多么的繁琐吧。</p>
<ul>
<li>1、创建一个项目结构（maven/gradle）</li>
<li>2、spring的依赖，spring mvc 、servlet api的依赖</li>
<li>3、web.xml， DispatcherServlet</li>
<li>4、启动一个Spring mVC的配置，Dispatcher-servlet.xml</li>
<li>5、创建一个Controller 发布一个http请求</li>
<li>6、发布到jsp/servlet容器</li>
</ul>
<h2 id="1-1-SpringBoot的产生过程"><a href="#1-1-SpringBoot的产生过程" class="headerlink" title="1.1 SpringBoot的产生过程"></a>1.1 SpringBoot的产生过程</h2><p><strong>2012年10月份</strong>，一个叫Mike Youngstrom(扬斯特罗姆)在Spring Jira中创建了一个功能请求，要求在Spring Framework中支持无容器Web应用程序体系结构，他谈到了在主容器引导 spring 容器<br>内配置 Web 容器服务。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/173191a9a190ecac?w=1861&h=943&f=png&s=247267" alt=""></p>
<p>SpringBoot刚出生的时候，引起了很多开源社区的关注，并且也有个人和企业开始尝试使用SpringBoot。 <strong>其实直到2016年</strong>，SpringBoot才真正在国内被使用起来。</p>
<h2 id="1-2-到底什么是SpringBoot"><a href="#1-2-到底什么是SpringBoot" class="headerlink" title="1.2 到底什么是SpringBoot"></a>1.2 到底什么是SpringBoot</h2><p>SpringBoot 框架是为了能够帮助使用Spring框架的开发者快速高效的构建一个基于Spirng框架以及Spring生态体系的应用解决方案。它是对“<strong>约定优于配置</strong>”这个理念下的一个最佳实践。因此它是一个服务于框架的框架，服务的范围是简化配置文件。</p>
<p><strong>什么才是约定优于配置呢？</strong></p>
<ul>
<li><p>只要依赖的spring-boot-starter-web的jar，就会自动内置一个tomcat容器(替换)<br>项目结构</p>
</li>
<li><p>默认提供了配置文件application.properties/yml</p>
</li>
<li><p>starter启动依赖 - 如果是一个webstarter ，默认认为你是去构建一个spring mvc的应用. </p>
</li>
<li><p>EnableAutoConfiguration 默认对于依赖的 starter 进行自动装载</p>
</li>
</ul>
<h1 id="二、SpringBoot与微服务"><a href="#二、SpringBoot与微服务" class="headerlink" title="二、SpringBoot与微服务"></a>二、SpringBoot与微服务</h1><p>那为什么Spring Cloud会采用Spring Boot来作为基础框架呢？原因很简单</p>
<ol>
<li>Spring Cloud它是关注服务治理领域的解决方案，而服务治理是依托于服务架构之上，所以它仍然需要一个承载框架；</li>
<li>Spring Boot 可以简单认为它是一套快速配置Spring应用的脚手架，它可以快速开发单个微服务，所以Spring Cloud的版本和Spring Boot版本的兼容性有很大关联。</li>
</ol>
<h1 id="三、Spring注解驱动的发展过程"><a href="#三、Spring注解驱动的发展过程" class="headerlink" title="三、Spring注解驱动的发展过程"></a>三、Spring注解驱动的发展过程</h1><h2 id="3-1-Spring-1-x"><a href="#3-1-Spring-1-x" class="headerlink" title="3.1 Spring 1.x"></a>3.1 Spring 1.x</h2><p>在SpringFramework1.x时代，其中在1.2.0是这个时代的分水岭，当时Java5刚刚发布，业界正兴起了使用Annotation的技术风，SpringFramework自然也提供了支持，比如当时已经支持了@Transactional等注解，但是这个时候，XML配置方式还是唯一选择。</p>
<h2 id="3-2-Spring-2-x"><a href="#3-2-Spring-2-x" class="headerlink" title="3.2 Spring 2.x"></a>3.2 Spring 2.x</h2><p>Spring Framework2.x时代，2.0版本在Annotation中添加了@Required、@Repository以及AOP相关的@Aspect等注解，同时也提升了XML配置能力，也就是可扩展的XML，比如Dubbo这样的开源框架就是基于SpringXML的扩展来完美的集成Spring，从而降低了Dubbo使用的门槛。</p>
<p>在2.x时代，2.5版本也是这个时代的分水岭， 它引入了一些很核心的Annotation</p>
<ul>
<li>@Autowired 依赖注入</li>
<li>@Qualifier 依赖查找</li>
<li>@Component、@Service 组件声明</li>
<li>@Controller、@RequestMappring等spring mvc的注解</li>
</ul>
<p>尽管Spring 2.x时代提供了不少的注解，但是仍然没有脱离XML配置驱动，比如context:annotation-config context:componet-scan,前者的职责是注册Annotation处理器，后者是负责扫描classpath下指定包路径下被Spring模式注解标注的类，将他们注册成为Spring Bean</p>
<ul>
<li>@Required</li>
<li>@Repository（Dao）</li>
<li>@Aspect</li>
</ul>
<p>spring 2.5</p>
<ul>
<li>@Component (组件)</li>
<li>@Service service（服务接口）</li>
<li>@Controller（控制器）</li>
<li>@RequetsMapping（请求映射器）</li>
</ul>
<h2 id="3-3-Spring-3-x"><a href="#3-3-Spring-3-x" class="headerlink" title="3.3 Spring 3.x"></a>3.3 Spring 3.x</h2><p>Spring Framework3.0是一个里程碑式的时代，他的功能特性开始出现了非常大的扩展，比如全面拥抱Java5、以及Spring Annotation。更重要的是，它提供了配置类注解@Configuration，它出现的首要任务就是取代XML配置方式。</p>
<p><strong>实现无配置化的方式实现Bean的装配。</strong></p>
<ul>
<li>@Configuraion （去xml化）</li>
</ul>
<p>把Bean的对象如何以便捷的方式加载到Spring IOC容器中</p>
<ul>
<li>ComponentScan（扫描@Service、@Controller、@Repository）</li>
<li>Import（把多个容器配置合并在一个配置中）</li>
</ul>
<p><strong>Enable模块驱动</strong><br>在Spring 3.1中，提供了很多以@Enable开头的注解，比如：</p>
<ul>
<li>@EnableWebMvc（引入MVC框架在Spring应用中需要用到的所有的Bean）</li>
<li>@EnableScheduling（开启任务计划）</li>
<li>@EnableAutoConfiguration</li>
<li>@Bean（来声明一个bean）</li>
</ul>
<h2 id="3-4-Spring-4-x"><a href="#3-4-Spring-4-x" class="headerlink" title="3.4 Spring 4.x"></a>3.4 Spring 4.x</h2><p>@Conditional（选择性的对加载的bean进行条件过滤）</p>
<h2 id="3-5-Spring-5-x"><a href="#3-5-Spring-5-x" class="headerlink" title="3.5 Spring 5.x"></a>3.5 Spring 5.x</h2><h1 id="四、SpringBoot的特性"><a href="#四、SpringBoot的特性" class="headerlink" title="四、SpringBoot的特性"></a>四、SpringBoot的特性</h1><p>首先分析特性的时候，我们不妨从SrpingBootApplication的注解入手，看看它做了什么，首先打开注解的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(excludeFilters &#x3D; &#123;</span><br><span class="line">		@Filter(type &#x3D; FilterType.CUSTOM, classes &#x3D; TypeExcludeFilter.class),</span><br><span class="line">		@Filter(type &#x3D; FilterType.CUSTOM,</span><br><span class="line">				classes &#x3D; AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line">public @interface SpringBootApplication &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SpringBootApplication 本质上是由 3 个注解组成，分别是：</p>
<ul>
<li>@Configuration;</li>
<li>@EnableAutoConfiguration;</li>
<li>@ComponentScan。</li>
<li>可以直接用这三个注解也可以启动SpringBoot应用，只是每次配置三个注解比较繁琐，所以直接用一个复合注解更方便些。后面会逐一详尽分析这些注解的，这里先简单介绍一下。</li>
</ul>
<h2 id="4-1-EnableAutoConfiguration自动装配"><a href="#4-1-EnableAutoConfiguration自动装配" class="headerlink" title="4.1 EnableAutoConfiguration自动装配"></a>4.1 EnableAutoConfiguration自动装配</h2><p>打开EnableAutoConfigration注解的源码，不难发现会带有一个@Import的注解。其实所有以Enable开头的注解都会有一个@Import注解。下面来看下源码吧。</p>
<h2 id="4-1-1-Import注解"><a href="#4-1-1-Import注解" class="headerlink" title="4.1.1 @Import注解"></a>4.1.1 @Import注解</h2><ul>
<li>@EnableAutoConfiguration</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(&#123;EnableAutoConfigurationImportSelector.class&#125;)</span><br><span class="line">public @interface EnableAutoConfiguration &#123;</span><br><span class="line">    Class&lt;?&gt;[] exclude() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() default &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>@EnableScheduling</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Import(&#123;SchedulingConfiguration.class&#125;)</span><br><span class="line">@Documented</span><br><span class="line">public @interface EnableScheduling &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>@EnableWebMvc</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Documented</span><br><span class="line">@Import(&#123;DelegatingWebMvcConfiguration.class&#125;)</span><br><span class="line">public @interface EnableWebMvc &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>类似于<code>&lt;import resource/&gt;</code> 形式的注解，就是把多个容器配置合并在一个配置中。可以配置三种不同的class：</p>
<ul>
<li>普通的bean或者带有@Configuration注解的bean；</li>
<li>实现ImportSelector接口进行动态注入：</li>
<li>实现ImportBeanDefinitionRegistror接口进行动态注入。</li>
</ul>
<h2 id="4-1-2-EnableAutoConfiguration分析"><a href="#4-1-2-EnableAutoConfiguration分析" class="headerlink" title="4.1.2 EnableAutoConfiguration分析"></a>4.1.2 EnableAutoConfiguration分析</h2><p>EnableAutoConfiguration的主要作用就是把SpringBoot中所有符合条件的@Configuration配置都加载到创建并使用的IoC容器中。</p>
<p>在注解源码中我们看到@Import注解中配置了<strong>EnableAutoConfigurationImportSelector</strong>这个类。</p>
<p><strong>EnableAutoConfigurationImportSelector又是什么呢？</strong></p>
<p>从名字上看一定是实现了<strong>ImportSelector</strong>接口，所以是基于动态bean的加载功能。来看下<strong>selectImports</strong>方法的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public String[] selectImports(AnnotationMetadata metadata) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        AnnotationAttributes attributes &#x3D; this.getAttributes(metadata);</span><br><span class="line">        List&lt;String&gt; configurations &#x3D; this.getCandidateConfigurations(metadata, attributes);</span><br><span class="line">        configurations &#x3D; this.removeDuplicates(configurations);</span><br><span class="line">        Set&lt;String&gt; exclusions &#x3D; this.getExclusions(metadata, attributes);</span><br><span class="line">        configurations.removeAll(exclusions);</span><br><span class="line">        configurations &#x3D; this.sort(configurations);</span><br><span class="line">        this.recordWithConditionEvaluationReport(configurations, exclusions);</span><br><span class="line">        return (String[])configurations.toArray(new String[configurations.size()]);</span><br><span class="line">    &#125; catch (IOException var5) &#123;</span><br><span class="line">        throw new IllegalStateException(var5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处返回的String数组，是所有类的全类名，它们都会被纳入到Spring的IoC容器中。</p>
<p>其实 <strong>EnableAutoConfiguration</strong>会帮助SpringBoot应用把所有符合@Configuration 配置都加载到当前SpringBoot创建的IoC容器，而这里面借助了Spring框架提供的一个工具类 <strong>SpringFactoriesLoader</strong>的支持。以及用到了Spring提供的条件注解 <strong>@Conditional</strong>，选择性的针对需要加载的 bean 进行条件过滤。</p>
<h2 id="4-1-3-SpringFactoriesLoader"><a href="#4-1-3-SpringFactoriesLoader" class="headerlink" title="4.1.3 SpringFactoriesLoader"></a>4.1.3 SpringFactoriesLoader</h2><p>SpringFactoriesLoader其实和java中的<strong>SPI</strong>机制是一样的。但是不会像SPI一样一次性加载所有的类，而是根据key进行加载。其key是配置在<strong>META-INF/spring.factories</strong>配置文件中，根据key来加载对于的bean到Ioc容器中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public abstract class SpringFactoriesLoader &#123;</span><br><span class="line">    private static final Log logger &#x3D; LogFactory.getLog(SpringFactoriesLoader.class);</span><br><span class="line">    public static final String FACTORIES_RESOURCE_LOCATION &#x3D; &quot;META-INF&#x2F;spring.factories&quot;;</span><br><span class="line"></span><br><span class="line">    public SpringFactoriesLoader() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SPI机制</strong></p>
<p>Service provider interface<br>满足以下条件</p>
<ul>
<li><p>需要在classpath目录下创建一个 META-INF/services；</p>
</li>
<li><p>在该目录下创建一个扩展点的全路径名：</p>
<p>  1、文件中填写这个扩展点的实现 </p>
<p>  2、文件编码格式UTF-8 </p>
<p>  3、ServiceLoader去进行加载 </p>
</li>
</ul>
<h2 id="4-1-4-条件过滤Conditional的分析"><a href="#4-1-4-条件过滤Conditional的分析" class="headerlink" title="4.1.4 条件过滤Conditional的分析"></a>4.1.4 条件过滤Conditional的分析</h2><p>通过条件过滤减少带有@Configuration注解类的数量，从而减少SpringBoot的启动时间。</p>
<p>@Conditional中的其它注解</p>
<ul>
<li>@ConditionalOnBean（在存在某个bean的时候）；</li>
<li>@ConditionalOnMissingBean（不存在某个bean的时候）；</li>
<li>@ConditionalOnClass（当classpath可以找到某个类型的类时）；</li>
<li>@ConditionalOnMissingClass（当classpath不能找到某个类型的类时）；</li>
<li>@ConditionalOnResource（当前classpath是否存在某个资源文件）；</li>
<li>@ConditionalOnProperty（当前jvm是否包含某个系统属性的某个值）；</li>
<li>@ConditionalOnWebApplication（当前spring context是否是web应用程序）。</li>
</ul>
<h2 id="4-2-Starter"><a href="#4-2-Starter" class="headerlink" title="4.2 Starter"></a>4.2 Starter</h2><p>Starter相当于模块，能将模块所需要的依赖整合起来并对模块内的bean根据环境来进行自动配置。使用者只需要依赖相应功能的Starter，无需做过多的配置和依赖，SpringBoot 就能自动扫描并加载相应的模块。</p>
<ul>
<li>官方包 spring-boot-starter-xxx；</li>
<li>第三方包 xxx-spring-boot-starter</li>
</ul>
<h2 id="4-3-Actuator"><a href="#4-3-Actuator" class="headerlink" title="4.3 Actuator"></a>4.3 Actuator</h2><p>SpringBoot提供了spring-boot-start-actuator支持对SpringBoot应用的监控。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-1-endpoint"><a href="#4-3-1-endpoint" class="headerlink" title="4.3.1 endpoint"></a>4.3.1 endpoint</h2><p>通过访问地址：<a href="http://localhost:8080/actuator" target="_blank" rel="noopener">http://localhost:8080/actuator</a></p>
<p>可以看到非常多的 Endpoint。 有一些 Endpoint 是不能访问的，涉及到安全问题。</p>
<p>开启所有的endpoint：（management.endpoints.web.exposure.include=* *）</p>
<ul>
<li>health（健康检查）:<strong>management.endpoint.health.show-details= always</strong></li>
<li>Loggers（日志配置信息，针对每个package 对应的日志级别）</li>
<li>beans（IoC 容器中所有的 bean）</li>
<li>Dump（获取活动线程的快照）</li>
<li>Mappings（全部的 uri 路径，以及和控制器的映射关系）</li>
<li>conditions（当前所有的条件注解）</li>
<li>shutdown（关闭应用）：<strong>management.endpoint .shutdown.enabled= true</strong>，注意不要开启，比较危险</li>
<li>Env（获取全部的环境信息）</li>
</ul>
<h2 id="4-3-2-Health的原理分析"><a href="#4-3-2-Health的原理分析" class="headerlink" title="4.3.2 Health的原理分析"></a>4.3.2 Health的原理分析</h2><p>应用健康状态的检查应该是监控系统中最基本的需求，所以我们基于 health 来分析一下它是如何实现的。<br><strong>org.springframework.boot.actuate.autoconfigure.HealthIndicatorAutoConfiguration</strong>类自动装配载入的，打开对应包下的spring.foctories文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.AuditAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.CacheStatisticsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.CrshAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.EndpointAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.EndpointMBeanExportAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.EndpointWebMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.HealthIndicatorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.JolokiaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.ManagementServerPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.ManagementWebSecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.MetricFilterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.MetricRepositoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.MetricsDropwizardAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.MetricsChannelAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.MetricExportAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.PublicMetricsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.TraceRepositoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.TraceWebFilterAutoConfiguration</span><br><span class="line"></span><br><span class="line">org.springframework.boot.actuate.autoconfigure.ManagementContextConfiguration&#x3D;\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.EndpointWebMvcManagementContextConfiguration,\</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.EndpointWebMvcHypermediaManagementContextConfiguration</span><br></pre></td></tr></table></figure>

<p>Actuator 中提供了非常多的扩展点，默认情况下提供了一些常见的服务的监控检查的支持。</p>
<ul>
<li>DataSourceHealthIndicator</li>
<li>DiskSpaceHealthIndicator</li>
<li>RedisHealthIndicator</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/07/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86SpringBoot%EF%BC%8C%E6%8E%8C%E6%8F%A1%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/" data-id="ckiohtc77000hryra55lohxe8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JAVA并发编程关于锁的那些事，ReentantLock的底层设计深入浅出" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/26/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B3%E4%BA%8E%E9%94%81%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%8CReentantLock%E7%9A%84%E5%BA%95%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/" class="article-date">
  <time datetime="2020-06-26T08:34:17.000Z" itemprop="datePublished">2020-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/26/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B3%E4%BA%8E%E9%94%81%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%8CReentantLock%E7%9A%84%E5%BA%95%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/">JAVA并发编程关于锁的那些事，ReentantLock的底层设计深入浅出</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、介绍JUC"><a href="#一、介绍JUC" class="headerlink" title="一、介绍JUC"></a>一、介绍JUC</h1><p>java.util.concurrent是在并发编程中比较常用的工具类，里面包含很多用来在并发场景中使用的组件。比如<strong>线程池、阻塞队列、计时器、同步器、并发集合</strong>等等。</p>
<h1 id="二、介绍Lock"><a href="#二、介绍Lock" class="headerlink" title="二、介绍Lock"></a>二、介绍Lock</h1><p><strong>Lock最为重要的特性就是解决并发程序的安全性问题。</strong> 在JUC大部分组件都使用了Lock，所以了解和使用Lock显得尤为重要。Lock在JUC中本质上是以一个接口的形势表现的。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d4c105e6dc681?w=1498&h=529&f=png&s=50933" alt=""></p>
<p>我们可以从上面的图中可以看出关于锁有很多不同的实现类。下面来简单介绍一翻吧。</p>
<h2 id="2-1-ReentrantLock（重入锁）"><a href="#2-1-ReentrantLock（重入锁）" class="headerlink" title="2.1 ReentrantLock（重入锁）"></a>2.1 ReentrantLock（重入锁）</h2><p>ReentrantLock实现了Lock接口，表示重入锁。是线程在获得锁之后，再次获取锁不需要阻塞，而是直接关联一次计数器增加重入次数。<strong>后面我们重点分析ReentrantLock的原理。</strong></p>
<h2 id="2-2-ReentrantReadWriteLock（重入读写锁）"><a href="#2-2-ReentrantReadWriteLock（重入读写锁）" class="headerlink" title="2.2 ReentrantReadWriteLock（重入读写锁）"></a>2.2 ReentrantReadWriteLock（重入读写锁）</h2><p>ReentrantReadWriteLock实现了ReadWriteLock接口，其中有两把锁，一个<strong>ReadLock</strong>,一个<strong>WriteLock</strong>,它们分别实现了<strong>Lock</strong>接口。<strong>适合读多写少的场景。</strong><br>基本原则：</p>
<ul>
<li>读和读不互斥；</li>
<li>读和写互斥；</li>
<li>写和写互斥。<h2 id="2-3-StampedLock（改进版读写锁）"><a href="#2-3-StampedLock（改进版读写锁）" class="headerlink" title="2.3 StampedLock（改进版读写锁）"></a>2.3 StampedLock（改进版读写锁）</h2>StampedLock是JDK1.8引进的新的锁机制，它是读写锁的一个改进版。一种乐观的读策略，使得乐观锁完全不阻塞写线程。</li>
</ul>
<h1 id="三、ReentrantLock设计"><a href="#三、ReentrantLock设计" class="headerlink" title="三、ReentrantLock设计"></a>三、ReentrantLock设计</h1><p>说到重入锁ReentrantLock，就是再次获取锁的同时，只是对重入次数进行计数，而不需要阻塞来获取锁。先来看一个案例代码，这样容易理解重入锁的概念。</p>
<p>我们在测试代码中调用test()方法获得了当前对象的锁，然后在这个方法中去调用test1()方法，test2()中也存在一个实例锁，这个时候当前线程无法获取test1()中的对象锁而阻塞， 这样就会产生死锁。R<strong>eentrantLock重入锁的目的就是为了避免线程产生死锁。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantLockDemo &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void test() &#123;</span><br><span class="line">        System.out.println(&quot;Begin test...&quot;);</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test1() &#123;</span><br><span class="line">        System.out.println(&quot;Begin test1...&quot;);</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ReentrantLockDemo reentrantLockDemo &#x3D; new ReentrantLockDemo();</span><br><span class="line">        new Thread(reentrantLockDemo::test).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-1-ReentrantLock重入锁使用案例"><a href="#3-1-ReentrantLock重入锁使用案例" class="headerlink" title="3.1 ReentrantLock重入锁使用案例"></a>3.1 ReentrantLock重入锁使用案例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantLockDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    static Lock lock &#x3D; new ReentrantLock(true);</span><br><span class="line"></span><br><span class="line">    public static void incr() &#123;</span><br><span class="line">        &#x2F;&#x2F;线程A获取锁，计数state &#x3D; 1</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;退出线程 中断的过程往下传递.  true</span><br><span class="line">            &#x2F;&#x2F; sleep&#x2F; join&#x2F; wait</span><br><span class="line">            &#x2F;&#x2F;while()</span><br><span class="line">            &#x2F;&#x2F; ...</span><br><span class="line">            Thread.sleep(1);</span><br><span class="line">            count++;</span><br><span class="line">&#x2F;&#x2F;            decr();</span><br><span class="line">        &#125;catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            &#x2F;&#x2F;线程A释放锁，state&#x3D;1-1&#x3D;0</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void decr() &#123;</span><br><span class="line">        &#x2F;&#x2F;线程A再次获取锁，计数加1，state &#x3D; 2</span><br><span class="line">        lock.lock();</span><br><span class="line">        try&#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 &#x3D; new Thread(()-&gt;&#123;</span><br><span class="line">           ReentrantLockDemo.incr();</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t1.interrupt();&#x2F;&#x2F;线程中断</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; 0 ; i &lt; 1000; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                ReentrantLockDemo.incr();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        System.out.println(&quot;result &#x3D; &quot; + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-ReentrantReadWriteLock重入读写锁案例"><a href="#3-2-ReentrantReadWriteLock重入读写锁案例" class="headerlink" title="3.2 ReentrantReadWriteLock重入读写锁案例"></a>3.2 ReentrantReadWriteLock重入读写锁案例</h2><p>读写锁维护了一个读锁，一个写锁。一般情况下读写锁比排它锁的性能要好一些，因为大多数的场景是读多写少的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantReadWriteLockDemo &#123;</span><br><span class="line"></span><br><span class="line">    static Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    static ReentrantReadWriteLock rrwl &#x3D; new ReentrantReadWriteLock();</span><br><span class="line">    static Lock read &#x3D; rrwl.readLock();</span><br><span class="line">    static Lock write &#x3D; rrwl.writeLock();</span><br><span class="line"></span><br><span class="line">    public static Object get(String key) &#123;</span><br><span class="line">        System.out.println(&quot;Begin reading data...&quot;);</span><br><span class="line">        read.lock();</span><br><span class="line">        try&#123;</span><br><span class="line">            return map.get(key);</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            read.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object put(String key, Object obj) &#123;</span><br><span class="line">        System.out.println(&quot;Begin writing data...&quot;);</span><br><span class="line">        write.lock();</span><br><span class="line">        try&#123;</span><br><span class="line">            return map.put(key, obj);</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            write.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>读锁与读锁可以共享；</li>
<li>读锁与写锁不可以共享（排他）；</li>
<li>写锁与写锁不可以共享（排他。</li>
</ul>
<h2 id="3-3-ReentrantLock的实现原理"><a href="#3-3-ReentrantLock的实现原理" class="headerlink" title="3.3 ReentrantLock的实现原理"></a>3.3 ReentrantLock的实现原理</h2><p>我们在Synchronized中分析了<strong>偏向锁、轻量级锁、重量级锁</strong>。它们是基于<strong>乐观锁</strong>以及<strong>自旋锁</strong>来优化synchronized加锁的开销，在<strong>重量级锁阶段</strong>是通过线程的阻塞以及唤醒来达到线程竞争和同步的目的。</p>
<p>那么在ReentrantLock也一定存在这样的问题，那么它是怎么去解决的呢？这里我们需要引入AQS(AbstractQueueSynchronizer)。</p>
<h2 id="3-3-1-什么是AQS"><a href="#3-3-1-什么是AQS" class="headerlink" title="3.3.1 什么是AQS"></a>3.3.1 什么是AQS</h2><p>在Lock中，AQS是一个同步队列，它是一个同步工具，也是Lock用来实现线程同步的核心组件。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d5dcc08f66488?w=1080&h=383&f=png&s=295579" alt=""></p>
<h2 id="3-3-2-AQS的独占锁和共享锁"><a href="#3-3-2-AQS的独占锁和共享锁" class="headerlink" title="3.3.2 AQS的独占锁和共享锁"></a>3.3.2 AQS的独占锁和共享锁</h2><ul>
<li>独占锁：每次只有一个线程持有锁，<strong>ReentrantLock</strong>的独占锁方式；</li>
<li>共享锁：允许多个线程同时获得锁，并访问共享资源，<strong>ReentrantReadWriteLock</strong>的共享锁方式。</li>
</ul>
<h2 id="3-3-3-AQS的内部实现"><a href="#3-3-3-AQS的内部实现" class="headerlink" title="3.3.3 AQS的内部实现"></a>3.3.3 AQS的内部实现</h2><p>AQS内部维护的是一个FIFO的双向链表，这种数据结构的特点就是有<strong>两个指针</strong>，分别指向直接的后继节点next和直接的前驱节点prev。当线程抢占锁失败后，会封装成一个<strong>Node</strong>直接放入到AQS阻塞队列中。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d5dac220c07ab?w=1252&h=280&f=png&s=138903" alt=""></p>
<h2 id="3-3-4-AQS中的Node"><a href="#3-3-4-AQS中的Node" class="headerlink" title="3.3.4 AQS中的Node"></a>3.3.4 AQS中的Node</h2><p>先上AQS中的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line">        &#x2F;** Marker to indicate a node is waiting in shared mode *&#x2F;</span><br><span class="line">        static final Node SHARED &#x3D; new Node();</span><br><span class="line">        &#x2F;** Marker to indicate a node is waiting in exclusive mode *&#x2F;</span><br><span class="line">        static final Node EXCLUSIVE &#x3D; null;</span><br><span class="line"></span><br><span class="line">        &#x2F;** waitStatus value to indicate thread has cancelled *&#x2F;</span><br><span class="line">        static final int CANCELLED &#x3D;  1;</span><br><span class="line">        &#x2F;** waitStatus value to indicate successor&#39;s thread needs unparking *&#x2F;</span><br><span class="line">        static final int SIGNAL    &#x3D; -1;</span><br><span class="line">        &#x2F;** waitStatus value to indicate thread is waiting on condition *&#x2F;</span><br><span class="line">        static final int CONDITION &#x3D; -2;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * waitStatus value to indicate the next acquireShared should</span><br><span class="line">         * unconditionally propagate</span><br><span class="line">         *&#x2F;</span><br><span class="line">        static final int PROPAGATE &#x3D; -3;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Status field, taking on only the values:</span><br><span class="line">         *   SIGNAL:     The successor of this node is (or will soon be)</span><br><span class="line">         *               blocked (via park), so the current node must</span><br><span class="line">         *               unpark its successor when it releases or</span><br><span class="line">         *               cancels. To avoid races, acquire methods must</span><br><span class="line">         *               first indicate they need a signal,</span><br><span class="line">         *               then retry the atomic acquire, and then,</span><br><span class="line">         *               on failure, block.</span><br><span class="line">         *   CANCELLED:  This node is cancelled due to timeout or interrupt.</span><br><span class="line">         *               Nodes never leave this state. In particular,</span><br><span class="line">         *               a thread with cancelled node never again blocks.</span><br><span class="line">         *   CONDITION:  This node is currently on a condition queue.</span><br><span class="line">         *               It will not be used as a sync queue node</span><br><span class="line">         *               until transferred, at which time the status</span><br><span class="line">         *               will be set to 0. (Use of this value here has</span><br><span class="line">         *               nothing to do with the other uses of the</span><br><span class="line">         *               field, but simplifies mechanics.)</span><br><span class="line">         *   PROPAGATE:  A releaseShared should be propagated to other</span><br><span class="line">         *               nodes. This is set (for head node only) in</span><br><span class="line">         *               doReleaseShared to ensure propagation</span><br><span class="line">         *               continues, even if other operations have</span><br><span class="line">         *               since intervened.</span><br><span class="line">         *   0:          None of the above</span><br><span class="line">         *</span><br><span class="line">         * The values are arranged numerically to simplify use.</span><br><span class="line">         * Non-negative values mean that a node doesn&#39;t need to</span><br><span class="line">         * signal. So, most code doesn&#39;t need to check for particular</span><br><span class="line">         * values, just for sign.</span><br><span class="line">         *</span><br><span class="line">         * The field is initialized to 0 for normal sync nodes, and</span><br><span class="line">         * CONDITION for condition nodes.  It is modified using CAS</span><br><span class="line">         * (or when possible, unconditional volatile writes).</span><br><span class="line">         *&#x2F;</span><br><span class="line">        volatile int waitStatus;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Link to predecessor node that current node&#x2F;thread relies on</span><br><span class="line">         * for checking waitStatus. Assigned during enqueuing, and nulled</span><br><span class="line">         * out (for sake of GC) only upon dequeuing.  Also, upon</span><br><span class="line">         * cancellation of a predecessor, we short-circuit while</span><br><span class="line">         * finding a non-cancelled one, which will always exist</span><br><span class="line">         * because the head node is never cancelled: A node becomes</span><br><span class="line">         * head only as a result of successful acquire. A</span><br><span class="line">         * cancelled thread never succeeds in acquiring, and a thread only</span><br><span class="line">         * cancels itself, not any other node.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        volatile Node prev;&#x2F;&#x2F;前驱节点</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Link to the successor node that the current node&#x2F;thread</span><br><span class="line">         * unparks upon release. Assigned during enqueuing, adjusted</span><br><span class="line">         * when bypassing cancelled predecessors, and nulled out (for</span><br><span class="line">         * sake of GC) when dequeued.  The enq operation does not</span><br><span class="line">         * assign next field of a predecessor until after attachment,</span><br><span class="line">         * so seeing a null next field does not necessarily mean that</span><br><span class="line">         * node is at end of queue. However, if a next field appears</span><br><span class="line">         * to be null, we can scan prev&#39;s from the tail to</span><br><span class="line">         * double-check.  The next field of cancelled nodes is set to</span><br><span class="line">         * point to the node itself instead of null, to make life</span><br><span class="line">         * easier for isOnSyncQueue.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        volatile Node next;&#x2F;&#x2F;后继节点</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * The thread that enqueued this node.  Initialized on</span><br><span class="line">         * construction and nulled out after use.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        volatile Thread thread;&#x2F;&#x2F;当前线程</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Link to next node waiting on condition, or the special</span><br><span class="line">         * value SHARED.  Because condition queues are accessed only</span><br><span class="line">         * when holding in exclusive mode, we just need a simple</span><br><span class="line">         * linked queue to hold nodes while they are waiting on</span><br><span class="line">         * conditions. They are then transferred to the queue to</span><br><span class="line">         * re-acquire. And because conditions can only be exclusive,</span><br><span class="line">         * we save a field by using special value to indicate shared</span><br><span class="line">         * mode.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        Node nextWaiter;&#x2F;&#x2F;存储在condition队列中的后继节点</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Returns true if node is waiting in shared mode.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        &#x2F;&#x2F;是否为共享锁</span><br><span class="line">        final boolean isShared() &#123;</span><br><span class="line">            return nextWaiter &#x3D;&#x3D; SHARED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Returns previous node, or throws NullPointerException if null.</span><br><span class="line">         * Use when predecessor cannot be null.  The null check could</span><br><span class="line">         * be elided, but is present to help the VM.</span><br><span class="line">         *</span><br><span class="line">         * @return the predecessor of this node</span><br><span class="line">         *&#x2F;</span><br><span class="line">        final Node predecessor() throws NullPointerException &#123;</span><br><span class="line">            Node p &#x3D; prev;</span><br><span class="line">            if (p &#x3D;&#x3D; null)</span><br><span class="line">                throw new NullPointerException();</span><br><span class="line">            else</span><br><span class="line">                return p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node() &#123;    &#x2F;&#x2F; Used to establish initial head or SHARED marker</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;将线程组装成一个Node，添加到队列中</span><br><span class="line">        Node(Thread thread, Node mode) &#123;     &#x2F;&#x2F; Used by addWaiter</span><br><span class="line">            this.nextWaiter &#x3D; mode;</span><br><span class="line">            this.thread &#x3D; thread;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;在condition队列中进行使用</span><br><span class="line">        Node(Thread thread, int waitStatus) &#123; &#x2F;&#x2F; Used by Condition</span><br><span class="line">            this.waitStatus &#x3D; waitStatus;</span><br><span class="line">            this.thread &#x3D; thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h1 id="四、ReentrantLock的源码分析"><a href="#四、ReentrantLock的源码分析" class="headerlink" title="四、ReentrantLock的源码分析"></a>四、ReentrantLock的源码分析</h1><h2 id="4-1-画出ReentrantLock时序图"><a href="#4-1-画出ReentrantLock时序图" class="headerlink" title="4.1 画出ReentrantLock时序图"></a>4.1 画出ReentrantLock时序图</h2><p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d6465503eb58f?w=1600&h=680&f=png&s=77986" alt=""></p>
<h2 id="4-2-ReentrantLock-lock"><a href="#4-2-ReentrantLock-lock" class="headerlink" title="4.2 ReentrantLock.lock()"></a>4.2 ReentrantLock.lock()</h2><p>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void lock() &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d64a181e4952f?w=1231&h=226&f=png&s=30412" alt=""><br>根据源码可以看到具体的实现，分别是FairSync（公平）和NonFairSync（非公平）两个类。</p>
<ul>
<li>FairSync：所有线程严格按照FIFO规则获取锁；</li>
<li>NonFairSync：可以存在抢占锁的功能，不管队列上是否存在其他线程等待，新线程都有机会抢占锁。</li>
</ul>
<h2 id="4-3-NonFairSync-lock"><a href="#4-3-NonFairSync-lock" class="headerlink" title="4.3 NonFairSync.lock()"></a>4.3 NonFairSync.lock()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 7316153563782823691L;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Performs lock.  Try immediate barge, backing up to normal</span><br><span class="line">     * acquire on failure.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final void lock() &#123;</span><br><span class="line">        &#x2F;&#x2F;对于非公平锁，一开始就CAS抢占一下</span><br><span class="line">        &#x2F;&#x2F;如果CAS成功了，就表示获得了锁</span><br><span class="line">        if (compareAndSetState(0, 1))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        else&#x2F;&#x2F;如果CAS失败了，调用acquire()方法走竞争逻辑</span><br><span class="line">            acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        return nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-1-CAS的实现原理"><a href="#4-3-1-CAS的实现原理" class="headerlink" title="4.3.1 CAS的实现原理"></a>4.3.1 CAS的实现原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean compareAndSetState(int expect, int update) &#123;</span><br><span class="line">    &#x2F;&#x2F; See below for intrinsics setup to support this</span><br><span class="line">    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> CAS 就是 Unsafe 类中提供的一个原子操作。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/25/172e9942c6022b84?w=1342&h=265&f=png&s=29677" alt=""></p>
<ul>
<li>var1：需要改变的对象；</li>
<li>var2：偏移量(headOffset的值)；</li>
<li>var4：期待的值；</li>
<li>var5：更新后的值。</li>
</ul>
<p><strong>整个方法更新成功返回true，失败则返回false。</strong></p>
<p>state是AQS中的一个属性，对于重入锁（ReentrantLock）而言，它表示一个同步状态。有两层含义：</p>
<ul>
<li>当state=0时，表示无锁状态；</li>
<li><strong>当state&gt;0时，表示线程获得了锁，state+1，重入多少次数，state会递增；而当锁释放的时候，state次数递减，直到state=0其它线程才有资格抢占锁</strong></li>
</ul>
<p>接下来我们来看unsafe.cpp文件中最终执行的源码方法吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(&quot;Unsafe_CompareAndSwapInt&quot;);</span><br><span class="line">  &#x2F;&#x2F;将Java对象解析成JVM的oop</span><br><span class="line">  oop p &#x3D; JNIHandles::resolve(obj);</span><br><span class="line">  &#x2F;&#x2F;根据对象p和地址偏移量找到地址</span><br><span class="line">  jint* addr &#x3D; (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  &#x2F;&#x2F;基于 cas 比较并替换， x 表示需要更新的值，addr 表示 state 在内存中的地址，e 表示预期值</span><br><span class="line">  return (jint)(Atomic::cmpxchg(x, addr, e)) &#x3D;&#x3D; e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>

<h2 id="4-3-2-Unsafe类"><a href="#4-3-2-Unsafe类" class="headerlink" title="4.3.2 Unsafe类"></a>4.3.2 Unsafe类</h2><p>属于sun.misc包，不属于Java标准。但是很多 Java 的基础类库，包<br>括一些被广泛使用的高性能开发库都是基于 Unsafe 类开发的，比如<strong>Netty、<br>Hadoop、Kafka</strong> 等；</p>
<p>Unsafe 可认为是 Java 中留下的后门，提供了一些低层次操作，如直接内存访问、<br>线程的挂起和恢复、CAS、线程同步、内存屏障等。</p>
<h2 id="4-4-AQS-acquire"><a href="#4-4-AQS-acquire" class="headerlink" title="4.4 AQS.acquire()"></a>4.4 AQS.acquire()</h2><p>从下面源码分析来看，如果CAS未能操作成功，说明state已经不等于0了，此时需要执行acquire(1)方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    if (compareAndSetState(0, 1))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    else</span><br><span class="line">        acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看acquire(1)方法的源码吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>尝试使用tryAcquire(arg)获得独占锁，如果成功返回true，失败返回false；</li>
<li>如果tryAcquire失败，则通过addWaiter方法将当前线程封装成Node对象加入到AQS队列尾部；</li>
<li>acquireQueued，将Node作为参数，通过自旋的方式获得锁，下面是对于的源码。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted &#x3D; false;</span><br><span class="line">        for (;;) &#123;&#x2F;&#x2F;自旋方式获得锁</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                failed &#x3D; false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4-1-NonfairSync-tryAcquire"><a href="#4-4-1-NonfairSync-tryAcquire" class="headerlink" title="4.4.1 NonfairSync.tryAcquire()"></a>4.4.1 NonfairSync.tryAcquire()</h2><p>这个方法的作用是尝试获取锁，如果成功返回 true，不成功返回 false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    return nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来看此方法的具体实现：</p>
<ul>
<li>获得当前线程，判断当前锁的状态；</li>
<li>如果state=0表示无锁状态，通过CAS更新state状态的值；</li>
<li>如果当前线程属于重入，则增加重入次数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    int c &#x3D; getState();</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc &#x3D; c + acquires;</span><br><span class="line">        if (nextc &lt; 0) &#x2F;&#x2F; overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-AQS-addWaiter"><a href="#4-5-AQS-addWaiter" class="headerlink" title="4.5 AQS.addWaiter()"></a>4.5 AQS.addWaiter()</h2><p>当tryAcquire()获取锁失败时，则会调用此方法来将当前线程封装成Node对象加入到AQS队列尾部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">    &#x2F;&#x2F; Try the fast path of enq; backup to full enq on failure</span><br><span class="line">    &#x2F;&#x2F;tail表示AQS队列的尾部，默认为null</span><br><span class="line">    Node pred &#x3D; tail;</span><br><span class="line">    if (pred !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;当前线程的prev执行tail</span><br><span class="line">        node.prev &#x3D; pred;</span><br><span class="line">        &#x2F;&#x2F;通过CAS把node加入到队列中，并设置为tail</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            &#x2F;&#x2F;设置成功后，把tail节点的next指向当前node</span><br><span class="line">            pred.next &#x3D; node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;tail为null时，把node加入到同步队列</span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>enq(node)方法通过自旋的方式，把当前节点node加入到同步队列中去，下面看一下enq源码吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        &#x2F;&#x2F;将新的节点prev指向tail</span><br><span class="line">        Node t &#x3D; tail;</span><br><span class="line">        if (t &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; Must initialize</span><br><span class="line">            &#x2F;&#x2F;通过CAS将tail设置为新的节点</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail &#x3D; head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.prev &#x3D; t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                &#x2F;&#x2F;将原来的tail的next节点指向新的节点</span><br><span class="line">                t.next &#x3D; node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172eea9bb11f862b?w=996&h=529&f=png&s=66511" alt=""></p>
<h2 id="4-6-AQS-acquireQueued"><a href="#4-6-AQS-acquireQueued" class="headerlink" title="4.6 AQS.acquireQueued()"></a>4.6 AQS.acquireQueued()</h2><p>通过 addWaiter 方法把线程添加到链表后，会接着把 Node 作为参数传递给<br>acquireQueued 方法，去竞争锁。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172eed6b9d9d8b11?w=790&h=157&f=png&s=15582" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;线程中断标记</span><br><span class="line">        boolean interrupted &#x3D; false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            &#x2F;&#x2F;获得当前节点的prev节点</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            &#x2F;&#x2F;如果是head节点，说明有资格去抢占锁</span><br><span class="line">            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                &#x2F;&#x2F;获取锁成功，线程A已经释放了锁，然后设置head为线程B获得执行权限</span><br><span class="line">                setHead(node);</span><br><span class="line">                &#x2F;&#x2F;把原来的head节点从链表中移除，弱引用</span><br><span class="line">                p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                failed &#x3D; false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;线程A可能还没释放锁，使得线程B在执行tryAcquire时返回false</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                &#x2F;&#x2F;当前线程在等待过程中有没有中断</span><br><span class="line">                interrupted &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F;取消锁的操作</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-6-1-shouldParkAfterFailedAcquire"><a href="#4-6-1-shouldParkAfterFailedAcquire" class="headerlink" title="4.6.1 shouldParkAfterFailedAcquire()"></a>4.6.1 shouldParkAfterFailedAcquire()</h2><p>线程A的锁可能还没释放，那么此时线程B来抢占锁肯定失败，就会调用此方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    &#x2F;&#x2F;前置节点</span><br><span class="line">    int ws &#x3D; pred.waitStatus;</span><br><span class="line">    &#x2F;&#x2F;如果前置节点为 SIGNAL，意味着只需要等待其他前置节点的线程被释放</span><br><span class="line">    if (ws &#x3D;&#x3D; Node.SIGNAL)</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * This node has already set status asking a release</span><br><span class="line">         * to signal it, so it can safely park.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        &#x2F;&#x2F;返回true，可以放心挂起了</span><br><span class="line">        return true;</span><br><span class="line">    &#x2F;&#x2F;ws 大于 0，意味着 prev 节点取消了排队，直接移除这个节点就行</span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">         * indicate retry.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        do &#123;</span><br><span class="line">            &#x2F;&#x2F;相当于: pred&#x3D;pred.prev;node.prev&#x3D;pred;</span><br><span class="line">            node.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);&#x2F;&#x2F;这里采用循环，从双向列表中移除 CANCELLED 的节点</span><br><span class="line">        pred.next &#x3D; node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="line">         * need a signal, but don&#39;t park yet.  Caller will need to</span><br><span class="line">         * retry to make sure it cannot acquire before parking.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        &#x2F;&#x2F;利用 cas 设置 prev 节点的状态为 SIGNAL(-1)</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Node的状态有5种，默认状态是0，以下是其它四种状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该 Node 的结点, 其结点的 waitStatus为CANCELLED，即结束状态，进入该状态后的结点将不会再变化</span><br><span class="line">static final int CANCELLED &#x3D;  1;</span><br><span class="line">&#x2F;&#x2F;只要前置节点释放锁，就会通知标识为 SIGNAL 状态的后续节点的线程</span><br><span class="line">static final int SIGNAL    &#x3D; -1;</span><br><span class="line">&#x2F;&#x2F;表示该线程在condition队列中阻塞</span><br><span class="line">static final int CONDITION &#x3D; -2;</span><br><span class="line">&#x2F;&#x2F;共享模式下，PROPAGATE 状态的线程处于可运行状态</span><br><span class="line">static final int PROPAGATE &#x3D; -3;</span><br></pre></td></tr></table></figure>

<h2 id="4-6-2-parkAndCheckInterrupt"><a href="#4-6-2-parkAndCheckInterrupt" class="headerlink" title="4.6.2 parkAndCheckInterrupt()"></a>4.6.2 parkAndCheckInterrupt()</h2><p>使用LockSupport.park(this)挂起当前线程为WAITING状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    LockSupport.park(this);</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Thread.interrupted，返回当前线程是否被其他线程触发过中断请求，也就是<br>thread.interrupt(); 如果有触发过中断请求，那么这个方法会返回当前的中断标识<br>true，并且对中断标识进行复位标识已经响应过了中断请求。如果返回 true，意味<br>着在 acquire 方法中会执行 selfInterrupt()。</p>
<h2 id="4-6-3-selfInterrupt"><a href="#4-6-3-selfInterrupt" class="headerlink" title="4.6.3 selfInterrupt()"></a>4.6.3 selfInterrupt()</h2><p>当前线程在acquireQueued中被中断过，则需要产生一个中断请求，原因是线程在调用acquireQueued方法的时候不会响应中断请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void selfInterrupt() &#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-6-4-LockSupport"><a href="#4-6-4-LockSupport" class="headerlink" title="4.6.4 LockSupport"></a>4.6.4 LockSupport</h2><p>从Java6开始引用的一个提供了基本的线程同步原语的类，LockSupport本质还是调用了Unsafe中的方法：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172ef8298e418507?w=757&h=172&f=png&s=11808" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(void, Unsafe_Unpark(JNIEnv *env, jobject unsafe, jobject jthread))</span><br><span class="line">  UnsafeWrapper(&quot;Unsafe_Unpark&quot;);</span><br><span class="line">  Parker* p &#x3D; NULL;</span><br><span class="line">  if (jthread !&#x3D; NULL) &#123;</span><br><span class="line">    oop java_thread &#x3D; JNIHandles::resolve_non_null(jthread);</span><br><span class="line">    if (java_thread !&#x3D; NULL) &#123;</span><br><span class="line">      jlong lp &#x3D; java_lang_Thread::park_event(java_thread);</span><br><span class="line">      if (lp !&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; This cast is OK even though the jlong might have been read</span><br><span class="line">        &#x2F;&#x2F; non-atomically on 32bit systems, since there, one word will</span><br><span class="line">        &#x2F;&#x2F; always be zero anyway and the value set is always the same</span><br><span class="line">        p &#x3D; (Parker*)addr_from_java(lp);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; Grab lock if apparently null or using older version of library</span><br><span class="line">        MutexLocker mu(Threads_lock);</span><br><span class="line">        java_thread &#x3D; JNIHandles::resolve_non_null(jthread);</span><br><span class="line">        if (java_thread !&#x3D; NULL) &#123;</span><br><span class="line">          JavaThread* thr &#x3D; java_lang_Thread::thread(java_thread);</span><br><span class="line">          if (thr !&#x3D; NULL) &#123;</span><br><span class="line">            p &#x3D; thr-&gt;parker();</span><br><span class="line">            if (p !&#x3D; NULL) &#123; &#x2F;&#x2F; Bind to Java thread for next time.</span><br><span class="line">              java_lang_Thread::set_park_event(java_thread, addr_to_java(p));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (p !&#x3D; NULL) &#123;</span><br><span class="line">#ifndef USDT2</span><br><span class="line">    HS_DTRACE_PROBE1(hotspot, thread__unpark, p);</span><br><span class="line">#else &#x2F;* USDT2 *&#x2F;</span><br><span class="line">    HOTSPOT_THREAD_UNPARK(</span><br><span class="line">                          (uintptr_t) p);</span><br><span class="line">#endif &#x2F;* USDT2 *&#x2F;</span><br><span class="line">    p-&gt;unpark();</span><br><span class="line">  &#125;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(void, Unsafe_Park(JNIEnv *env, jobject unsafe, jboolean isAbsolute, jlong time))</span><br><span class="line">  UnsafeWrapper(&quot;Unsafe_Park&quot;);</span><br><span class="line">  EventThreadPark event;</span><br><span class="line">#ifndef USDT2</span><br><span class="line">  HS_DTRACE_PROBE3(hotspot, thread__park__begin, thread-&gt;parker(), (int) isAbsolute, time);</span><br><span class="line">#else &#x2F;* USDT2 *&#x2F;</span><br><span class="line">   HOTSPOT_THREAD_PARK_BEGIN(</span><br><span class="line">                             (uintptr_t) thread-&gt;parker(), (int) isAbsolute, time);</span><br><span class="line">#endif &#x2F;* USDT2 *&#x2F;</span><br><span class="line">  JavaThreadParkedState jtps(thread, time !&#x3D; 0);</span><br><span class="line">  thread-&gt;parker()-&gt;park(isAbsolute !&#x3D; 0, time);</span><br><span class="line">#ifndef USDT2</span><br><span class="line">  HS_DTRACE_PROBE1(hotspot, thread__park__end, thread-&gt;parker());</span><br><span class="line">#else &#x2F;* USDT2 *&#x2F;</span><br><span class="line">  HOTSPOT_THREAD_PARK_END(</span><br><span class="line">                          (uintptr_t) thread-&gt;parker());</span><br><span class="line">#endif &#x2F;* USDT2 *&#x2F;</span><br><span class="line">  if (event.should_commit()) &#123;</span><br><span class="line">    oop obj &#x3D; thread-&gt;current_park_blocker();</span><br><span class="line">    event.set_klass((obj !&#x3D; NULL) ? obj-&gt;klass() : NULL);</span><br><span class="line">    event.set_timeout(time);</span><br><span class="line">    event.set_address((obj !&#x3D; NULL) ? (TYPE_ADDRESS) cast_from_oop&lt;uintptr_t&gt;(obj) : 0);</span><br><span class="line">    event.commit();</span><br><span class="line">  &#125;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>

<h2 id="4-7-ReentrantLock-unlock"><a href="#4-7-ReentrantLock-unlock" class="headerlink" title="4.7 ReentrantLock.unlock()"></a>4.7 ReentrantLock.unlock()</h2><p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172ef99ae113acc9?w=776&h=146&f=png&s=11943" alt=""><br>在unlock()方法中，会调用release()方法来释放锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    &#x2F;&#x2F;释放锁成功</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        &#x2F;&#x2F;得到AQS队列中的head节点</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        &#x2F;&#x2F;如果head不为空并且状态不等于0，调用unpark唤醒后续节点</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-7-1-tryRelease"><a href="#4-7-1-tryRelease" class="headerlink" title="4.7.1 tryRelease()"></a>4.7.1 tryRelease()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    &#x2F;&#x2F;state状态减掉传入的参数1</span><br><span class="line">    int c &#x3D; getState() - releases;</span><br><span class="line">    if (Thread.currentThread() !&#x3D; getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    boolean free &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;如果结果为0，将排它锁的Owner设置为null</span><br><span class="line">    &#x2F;&#x2F;解锁的时候减掉 1，同一个锁，在可以重入后，可能会被叠加为 2、3、4 这些值，只有 unlock()的次数与 lock()的次数对应才会将 Owner 线程设置为空，而且也只有这种情况下才会返回 true</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        free &#x3D; true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-7-2-unparkSuccessor"><a href="#4-7-2-unparkSuccessor" class="headerlink" title="4.7.2 unparkSuccessor()"></a>4.7.2 unparkSuccessor()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">       &#x2F;*</span><br><span class="line">        * If status is negative (i.e., possibly needing signal) try</span><br><span class="line">        * to clear in anticipation of signalling.  It is OK if this</span><br><span class="line">        * fails or if status is changed by waiting thread.</span><br><span class="line">        *&#x2F;</span><br><span class="line">       &#x2F;&#x2F;获得head节点的状态</span><br><span class="line">       int ws &#x3D; node.waitStatus;</span><br><span class="line">       if (ws &lt; 0)</span><br><span class="line">           &#x2F;&#x2F;设置head节点的状态为0</span><br><span class="line">           compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">       &#x2F;*</span><br><span class="line">        * Thread to unpark is held in successor, which is normally</span><br><span class="line">        * just the next node.  But if cancelled or apparently null,</span><br><span class="line">        * traverse backwards from tail to find the actual</span><br><span class="line">        * non-cancelled successor.</span><br><span class="line">        *&#x2F;</span><br><span class="line">       &#x2F;&#x2F;得到head节点的下一个节点</span><br><span class="line">       Node s &#x3D; node.next;</span><br><span class="line">       &#x2F;&#x2F;如果下一个节点为 null 或者 status&gt;0 表示 cancelled 状态</span><br><span class="line">       if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">           s &#x3D; null;</span><br><span class="line">           &#x2F;&#x2F;通过从尾部节点开始扫描，找到距离 head 最近的一个waitStatus&lt;&#x3D;0 的节点</span><br><span class="line">           for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)</span><br><span class="line">               if (t.waitStatus &lt;&#x3D; 0)</span><br><span class="line">                   s &#x3D; t;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F;next 节点不为空，直接唤醒这个线程即可</span><br><span class="line">       if (s !&#x3D; null)</span><br><span class="line">           LockSupport.unpark(s.thread);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-7-3-为什么释放锁的时候是从tail节点开始扫描的？"><a href="#4-7-3-为什么释放锁的时候是从tail节点开始扫描的？" class="headerlink" title="4.7.3 为什么释放锁的时候是从tail节点开始扫描的？"></a>4.7.3 为什么释放锁的时候是从tail节点开始扫描的？</h2><p>我们在加锁的enq()方法中，在 cas 操作之后，t.next=node 操作之前。 存在其他线程调用 unlock 方法从 head开始往后遍历，由于 t.next=node 还没执行意味着链表的关系还没有建立完整。就会导致遍历到 t 节点的时候被中断。所以从后往前遍历，一定不会存在这个问题。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172efa6404e1343a?w=893&h=214&f=png&s=21823" alt=""></p>
<h2 id="4-8-原本挂起的线程如何执行呢？"><a href="#4-8-原本挂起的线程如何执行呢？" class="headerlink" title="4.8 原本挂起的线程如何执行呢？"></a>4.8 原本挂起的线程如何执行呢？</h2><p>通过ReentrantLock.unlock()将原本挂起的线程换唤醒后继续执行，原来被挂起的线程是在 <strong>acquireQueued</strong>() 方法中，所以被唤醒以后继续从这个方法开始执行.</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172efb16874cc2df?w=1156&h=230&f=png&s=24416" alt=""></p>
<h1 id="五、公平锁与非公平锁的区别"><a href="#五、公平锁与非公平锁的区别" class="headerlink" title="五、公平锁与非公平锁的区别"></a>五、公平锁与非公平锁的区别</h1><p>锁的公平性是相对于获取锁的顺序而言的，如果是一个公平锁，那么锁的获取顺序<br>就应该符合请求的绝对时间顺序，也就是 <strong>FIFO</strong>。 只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁则不一样，差异点<br>有两个：</p>
<p>1、FairSync.lock()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、NonfairSync.lock()方法</p>
<p>非公平锁在获取锁的时候，会先通过 CAS 进行抢占，而公平锁则不会。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    if (compareAndSetState(0, 1))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    else</span><br><span class="line">        acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/06/26/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B3%E4%BA%8E%E9%94%81%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%8CReentantLock%E7%9A%84%E5%BA%95%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/" data-id="ckiohtc9g0012ryragb7t09qd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JAVA并发编程阶段总结篇，解决死锁问题以及ThreadLocal原理分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/20/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E7%AF%87%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2020-06-20T10:08:17.000Z" itemprop="datePublished">2020-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/20/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E7%AF%87%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">JAVA并发编程阶段总结篇，解决死锁问题以及ThreadLocal原理分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、线程的死锁问题"><a href="#一、线程的死锁问题" class="headerlink" title="一、线程的死锁问题"></a>一、线程的死锁问题</h1><p>首先来看下死锁的概念吧：一组相互竞争的线程因为相互等待，造成“永久”阻塞的现象，我们称之为死锁；那么有死锁必然就有活锁了，什么是活锁呢？即任务或者执行者都没有被阻塞，由于某些条件未被满足，一直处于重试-&gt;尝试执行-&gt;执行失败的过程被成为活锁。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/14/172b0a706ee448b8?w=1273&h=744&f=png&s=163373" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/14/172b0a72988b6f3f?w=756&h=406&f=png&s=17964" alt=""></p>
<h2 id="1-1-死锁发生的条件"><a href="#1-1-死锁发生的条件" class="headerlink" title="1.1 死锁发生的条件"></a>1.1 死锁发生的条件</h2><p>只要满足以下<strong>四个条件</strong>，就必然会产生死锁：</p>
<ul>
<li><strong>线程互斥</strong>，共享资源只能被一个线程占用，要么线程A要么线程B（<strong>有一个坑位，谁抢到就是谁的</strong>）；</li>
<li><strong>占有且等待</strong>，线程T已经获得资源A，在同时等待资源B的时候，不释放资源A（<strong>占着茅坑等送纸</strong>）；</li>
<li><strong>不可抢占</strong>，其它线程不能强制抢占线程T占有的资源（<strong>有且仅有的坑位被占，不能马上赶走别人</strong>）；</li>
<li><strong>循环等待</strong>，线程T1等待线程T2占有的资源，线程T2等待线程T2占有的资源（<strong>我惦记着你的，你惦记着我的</strong>）。</li>
</ul>
<h2 id="1-2-如何解决死锁问题"><a href="#1-2-如何解决死锁问题" class="headerlink" title="1.2 如何解决死锁问题"></a>1.2 如何解决死锁问题</h2><p>针对上面的发生死锁的四个条件，只需要破坏其中的一个条件，就不会发生死锁。</p>
<ul>
<li>互斥条件无法破坏，因为使用锁（lock或synchronized）就是互斥的；</li>
<li>占有且等待，一次性申请所有的资源，就不存在等待了；</li>
<li>不可抢占，占有资源的线程如果需要申请其它资源的时候，可以主动释放占有的资源；</li>
<li>循环等待，可以有线性顺序的方式来申请资源。从序号小的开始，然后再接着申请序号大的资源。</li>
</ul>
<h2 id="1-3-Thread-join"><a href="#1-3-Thread-join" class="headerlink" title="1.3 Thread.join"></a>1.3 Thread.join</h2><p>它的作用就是让线程的执行结果对后续线程的访问可见。</p>
<h1 id="二、-ThreadLocal原理分析"><a href="#二、-ThreadLocal原理分析" class="headerlink" title="二、 ThreadLocal原理分析"></a>二、 ThreadLocal原理分析</h1><p>ThreadLocal实际上是一种线程的隔离机制，就是为了保证在多线程环境下对于共享变量的访问的安全性。</p>
<h2 id="2-1-set-方法"><a href="#2-1-set-方法" class="headerlink" title="2.1 set()方法"></a>2.1 set()方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line"> * Sets the current thread&#39;s copy of this thread-local variable</span><br><span class="line"> * to the specified value.  Most subclasses will have no need to</span><br><span class="line"> * override this method, relying solely on the &#123;@link #initialValue&#125;</span><br><span class="line"> * method to set the values of thread-locals.</span><br><span class="line"> *</span><br><span class="line"> * @param value the value to be stored in the current thread&#39;s copy of</span><br><span class="line"> *        this thread-local.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">    if (map !&#x3D; null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当map不为空时，执行map.set(this, value)方法</strong>，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; We don&#39;t use a fast path as with get() because it is at</span><br><span class="line">    &#x2F;&#x2F; least as common to use set() to create new entries as</span><br><span class="line">    &#x2F;&#x2F; it is to replace existing ones, in which case, a fast</span><br><span class="line">    &#x2F;&#x2F; path would fail more often than not.</span><br><span class="line"></span><br><span class="line">    Entry[] tab &#x3D; table;</span><br><span class="line">    int len &#x3D; tab.length;</span><br><span class="line">    &#x2F;&#x2F;根据哈希码和数组长度求得元素的放置位置，即Entry数组的下标</span><br><span class="line">    int i &#x3D; key.threadLocalHashCode &amp; (len-1);</span><br><span class="line">    &#x2F;&#x2F;从i开始遍历到数组的最后一个Entry（进行线性探索）</span><br><span class="line">    for (Entry e &#x3D; tab[i];</span><br><span class="line">         e !&#x3D; null;</span><br><span class="line">         e &#x3D; tab[i &#x3D; nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line">        &#x2F;&#x2F;如果key相等，就覆盖value</span><br><span class="line">        if (k &#x3D;&#x3D; key) &#123;</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果key为空，用新的key，value，同时清理历史key&#x3D;null（弱引用）的旧数据</span><br><span class="line">        if (k &#x3D;&#x3D; null) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] &#x3D; new Entry(key, value);</span><br><span class="line">    int sz &#x3D; ++size;</span><br><span class="line">    &#x2F;&#x2F;如果超过设置的閥值，则需要进行扩容</span><br><span class="line">    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;&#x3D; threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-线性探测"><a href="#2-2-线性探测" class="headerlink" title="2.2 线性探测"></a>2.2 线性探测</h2><p>在上面的源码中使用了<strong>线性探测</strong>的方式来解决<strong>hash冲突</strong>问题。</p>
<p>那么什么是线性探测呢？</p>
<p>线性探测是一种开放的寻址策略。hash表是直接通过key访问数据结构的，通过hash函数来把key映射到hash表中的一个位置的访问记录，从而加速查找的速度。存储记录的就叫hash表（也成为散列表）。</p>
<p>由两种方式情况解决这个冲突问题：</p>
<ul>
<li><strong>写入</strong>：找到发生冲突的最近单元</li>
<li><strong>查找</strong>：从发生冲突的位置开始，往后查找</li>
</ul>
<p>通俗的解释是这样子的：<strong>我们去蹲坑的时候发现坑位被占，就找后面的一个坑，如果后面的这个坑空着，那么就占用；如果后面的坑被占用，则一直往后面的坑位遍历，直到找到空闲的坑位为止，否则就一直憋着。</strong></p>
<h2 id="2-3-repalceStaleEntry-方法"><a href="#2-3-repalceStaleEntry-方法" class="headerlink" title="2.3 repalceStaleEntry()方法"></a>2.3 repalceStaleEntry()方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value,</span><br><span class="line">                               int staleSlot) &#123;</span><br><span class="line">    Entry[] tab &#x3D; table;</span><br><span class="line">    int len &#x3D; tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Back up to check for prior stale entry in current run.</span><br><span class="line">    &#x2F;&#x2F; We clean out whole runs at a time to avoid continual</span><br><span class="line">    &#x2F;&#x2F; incremental rehashing due to garbage collector freeing</span><br><span class="line">    &#x2F;&#x2F; up refs in bunches (i.e., whenever the collector runs).</span><br><span class="line">    &#x2F;&#x2F;向前扫描，查找最前一个无效的slot</span><br><span class="line">    int slotToExpunge &#x3D; staleSlot;</span><br><span class="line">    for (int i &#x3D; prevIndex(staleSlot, len);</span><br><span class="line">         (e &#x3D; tab[i]) !&#x3D; null;</span><br><span class="line">         i &#x3D; prevIndex(i, len))</span><br><span class="line">        if (e.get() &#x3D;&#x3D; null)</span><br><span class="line">            &#x2F;&#x2F;通过循环遍历，可以定位到最前面的一个无效的slot</span><br><span class="line">            slotToExpunge &#x3D; i;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Find either the key or trailing null slot of run, whichever</span><br><span class="line">    &#x2F;&#x2F; occurs first</span><br><span class="line">    &#x2F;&#x2F;从i开始遍历到数组的最后一个Entry（进行线性探索）</span><br><span class="line">    for (int i &#x3D; nextIndex(staleSlot, len);</span><br><span class="line">         (e &#x3D; tab[i]) !&#x3D; null;</span><br><span class="line">         i &#x3D; nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If we find key, then we need to swap it</span><br><span class="line">        &#x2F;&#x2F; with the stale entry to maintain hash table order.</span><br><span class="line">        &#x2F;&#x2F; The newly stale slot, or any other stale slot</span><br><span class="line">        &#x2F;&#x2F; encountered above it, can then be sent to expungeStaleEntry</span><br><span class="line">        &#x2F;&#x2F; to remove or rehash all of the other entries in run.</span><br><span class="line">        &#x2F;&#x2F;找到匹配的key</span><br><span class="line">        if (k &#x3D;&#x3D; key) &#123;</span><br><span class="line">            &#x2F;&#x2F;更新对应的slot对应的value</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line">            &#x2F;&#x2F;与无效的slot进行替换</span><br><span class="line">            tab[i] &#x3D; tab[staleSlot];</span><br><span class="line">            tab[staleSlot] &#x3D; e;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Start expunge at preceding stale entry if it exists</span><br><span class="line">            &#x2F;&#x2F;&#x2F;&#x2F;如果最早的一个无效的slot和当前的staleSlot相等，则从i作为清理的起点</span><br><span class="line">            if (slotToExpunge &#x3D;&#x3D; staleSlot)</span><br><span class="line">                slotToExpunge &#x3D; i;</span><br><span class="line">            &#x2F;&#x2F;从slotToExpunge开始做一次连续的清理    </span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If we didn&#39;t find stale entry on backward scan, the</span><br><span class="line">        &#x2F;&#x2F; first stale entry seen while scanning for key is the</span><br><span class="line">        &#x2F;&#x2F; first still present in the run.</span><br><span class="line">        &#x2F;&#x2F;如果当前的slot已经无效，并且向前扫描过程中没有无效slot，则更新slotToExpunge为当前位置</span><br><span class="line">        if (k &#x3D;&#x3D; null &amp;&amp; slotToExpunge &#x3D;&#x3D; staleSlot)</span><br><span class="line">            slotToExpunge &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If key not found, put new entry in stale slot</span><br><span class="line">    &#x2F;&#x2F;如果key对应的value在entry中不存在，则直接放一个新的entry</span><br><span class="line">    tab[staleSlot].value &#x3D; null;</span><br><span class="line">    tab[staleSlot] &#x3D; new Entry(key, value);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If there are any other stale entries in run, expunge them</span><br><span class="line">    &#x2F;&#x2F;如果有任何一个无效的slot，则做一次清理</span><br><span class="line">    if (slotToExpunge !&#x3D; staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-斐波那契额散列（Fibonacci散列算法）"><a href="#2-4-斐波那契额散列（Fibonacci散列算法）" class="headerlink" title="2.4 斐波那契额散列（Fibonacci散列算法）"></a>2.4 斐波那契额散列（Fibonacci散列算法）</h2><p>下面还是给一段ThreadLocal的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;HASH_INCREMENT是为了让哈希码能均匀的分布在2的N次方的数组里</span><br><span class="line">private static final int HASH_INCREMENT &#x3D; 0x61c88647;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Returns the next hash code.</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static int nextHashCode() &#123;</span><br><span class="line">    return nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中定义了一个魔法值 HASH_INCREMENT = <strong>0x61c88647</strong>，对于实例变量threadLocalHashCode，每当创建ThreadLocal实例时这个值都会<strong>getAndAdd(0x61c88647)</strong>。</p>
<p>HASH_INCREMENT 再借助一定的算法，就可以将哈希码能均匀的分布在 2 的 N 次方的数组里，<strong>保证了散列表的离散度</strong>，从而降低了冲突几率。我们不妨来写段测试代码吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class FibonacciHash &#123;</span><br><span class="line"></span><br><span class="line">    private static final int HASH_INCREMENT &#x3D; 0x61c88647;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        magicHash(16);</span><br><span class="line">        magicHash(32);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void magicHash(int size) &#123;</span><br><span class="line">        int hashCode &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">            hashCode &#x3D; i * HASH_INCREMENT + HASH_INCREMENT;</span><br><span class="line">            System.out.print((hashCode &amp; (size - 1)) + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行main()方法的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7 14 5 12 3 10 1 8 15 6 13 4 11 2 9 0 </span><br><span class="line">7 14 21 28 3 10 17 24 31 6 13 20 27 2 9 16 23 30 5 12 19 26 1 8 15 22 29 4 11 18 25 0</span><br></pre></td></tr></table></figure>

<p><strong>产生的哈希码分布确实是很均匀，而且没有任何冲突。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/06/20/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E7%AF%87%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" data-id="ckiohtc6r000bryra48qb6nve" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JAVA并发编程递进篇，探索线程安全性volatile关键字如何保证可见性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/30/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%80%92%E8%BF%9B%E7%AF%87%EF%BC%8C%E6%8E%A2%E7%B4%A2%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7/" class="article-date">
  <time datetime="2020-05-30T08:56:53.000Z" itemprop="datePublished">2020-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/30/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%80%92%E8%BF%9B%E7%AF%87%EF%BC%8C%E6%8E%A2%E7%B4%A2%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7/">JAVA并发编程递进篇，探索线程安全性volatile关键字如何保证可见性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一开始就直接上代码，直接来看一段木有使用<strong>volatile</strong>关键字的线程调用代码吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class VolatileDemo &#123;</span><br><span class="line">    public static boolean stop &#x3D; false;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t &#x3D; new Thread(()-&gt;&#123;</span><br><span class="line">            int i &#x3D; 0;</span><br><span class="line">            while(!stop) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                &#x2F;&#x2F;System.out.println(&quot;result:&quot; + i);</span><br><span class="line">                &#x2F;*</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(0);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                *&#x2F;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;myThread&quot;);</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        stop&#x3D;true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然运行<strong>main</strong>()方法后，循环并没有结束，程序一直处于运行状态。</p>
<p>如果我们要使得循环结束该怎么做呢？</p>
<h1 id="一、Volatile关键字的使用递进"><a href="#一、Volatile关键字的使用递进" class="headerlink" title="一、Volatile关键字的使用递进"></a>一、Volatile关键字的使用递进</h1><h2 id="1-1-System-out-println"><a href="#1-1-System-out-println" class="headerlink" title="1.1 System.out.println"></a>1.1 System.out.println</h2><p>使用print打印i的值，发现循环就被终止了。这是为什么呢？我们不妨来看下<strong>println</strong>()方法的源码吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void println(String x) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>底层方法使用<strong>synchronized</strong>关键字，这个同步会防止循环期间对变量stop的值缓存。</p>
<p>从IO角度来说<strong>，print本质上是一个IO的操作</strong>，我们知道磁盘IO的效率一定要比CPU的计算效率慢得多，所以IO可以使得CPU有时间去做内存刷新的事情，从而导致这个现象。比如我们可以在里面定义一个new File()。同样会达到效果。</p>
<h2 id="1-2-Thread-sleep-0"><a href="#1-2-Thread-sleep-0" class="headerlink" title="1.2 Thread.sleep(0)"></a>1.2 Thread.sleep(0)</h2><p>增加Thread.sleep(0)也能生效，是和cpu、以及jvm、操作系统等因素有关系。</p>
<p>官方文档上是说，Thread.sleep没有任何同步语义，编译器不需要在调用Thread.sleep之前把缓存在寄存器中的写刷新到给共享内存、也不需要在Thread.sleep之后重新加载缓存在寄存器中的值。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/26/172514091156910a?w=1453&h=523&f=png&s=83759" alt=""></p>
<p>编译器可以自由选择读取stop的值一次或者多次，这个是由编译器自己来决定的。<br>Thread.sleep(0)导致线程切换，线程切换会导致缓存失效从而读取到了新的值。</p>
<h2 id="1-3-Volatile关键字"><a href="#1-3-Volatile关键字" class="headerlink" title="1.3 Volatile关键字"></a>1.3 Volatile关键字</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public volatile static boolean stop &#x3D; false;</span><br></pre></td></tr></table></figure>
<p>我们在stop变量加上<strong>volatile</strong>关键字进行修饰，可以查看汇编指令，使用HSDIS工具进行查看。</p>
<ul>
<li>在IDEA中加入VM options：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-server -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:CompileCommand&#x3D;compileonly,*VolatileDemo.*</span><br></pre></td></tr></table></figure>
运行程序后，在输出的结果中，查找下 <strong>lock</strong> 指令，会发现，在修改带有<strong>volatile</strong> 修饰的成员变量时，会多一个 <strong>lock</strong> 指令。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x00000000034e49f3: lock add dword ptr [rsp],0h  ;*putstatic stop</span><br><span class="line">                                                ; - com.sy.sa.thread.VolatileDemo::&lt;clinit&gt;@1 (line 5)</span><br><span class="line">0x00000000034e4643: lock add dword ptr [rsp],0h  ;*putstatic stop</span><br><span class="line">                                                ; - com.sy.sa.thread.VolatileDemo::&lt;clinit&gt;@1 (line 5)</span><br></pre></td></tr></table></figure>
<p>运行加了<strong>volatile</strong>关键字的代码，发现中多了<strong>lock</strong>汇编指令。那么lock指令是怎么保证可见性的呢？</p>
<h2 id="1-3-1-什么是可见性？"><a href="#1-3-1-什么是可见性？" class="headerlink" title="1.3.1 什么是可见性？"></a>1.3.1 什么是可见性？</h2><p>在单线程的环境下，如果向一个变量先写入一个值，然后在没有写干涉的情况下读取这个变量的值，那这个时候读取到的这个变量的值应该是之前写入的那个值。这本来是一个很正常的事情。但是在多线程环境下，读和写发生在不同的线程中的时候，可能会出现：读线程不能及时的读取到其他线程写入的最新的值。这就是所谓的<strong>可见性</strong>。</p>
<h2 id="1-3-2-硬件方面了解可见性本质"><a href="#1-3-2-硬件方面了解可见性本质" class="headerlink" title="1.3.2 硬件方面了解可见性本质"></a>1.3.2 硬件方面了解可见性本质</h2><p>硬件方面将从<strong>CPU、内存、磁盘I/O</strong> 三方面着手。</p>
<h2 id="1-3-2-1-CPU的高速缓存"><a href="#1-3-2-1-CPU的高速缓存" class="headerlink" title="1.3.2.1 CPU的高速缓存"></a>1.3.2.1 CPU的高速缓存</h2><p>因为高速缓存的存在，会导致一个缓存一致性问题。<br><img src="https://user-gold-cdn.xitu.io/2020/5/27/1725562186444afd?w=480&h=385&f=png&s=17195" alt=""></p>
<h2 id="1-3-2-2-总线锁和缓存锁"><a href="#1-3-2-2-总线锁和缓存锁" class="headerlink" title="1.3.2.2 总线锁和缓存锁"></a>1.3.2.2 总线锁和缓存锁</h2><p>总线锁，简单来说就是，在多cpu下，当其中一个处理器要对共享内存进行操作的时候，在总线上发出一个LOCK#信号，这个信号使得其他处理器无法通过总线来访问到共享内存中的数据，总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，这种机制显然是不合适的 。</p>
<p>如何优化呢？最好的方法就是控制锁的保护粒度，我们只需要保证对于被多个CPU缓存的同一份数据是一致的就行。在P6架构的CPU后，引入了缓存锁，如果当前数据已经被CPU缓存了，并且是要协会到主内存中的，就可以采用缓存锁来解决问题。</p>
<p>所谓的缓存锁，就是指内存区域如果被缓存在处理器的缓存行中，并且在Lock期间被锁定，那么当它执行锁操作回写到内存时，不再总线上加锁，而是修改内部的内存地址，基于缓存一致性协议来保证操作的原子性。</p>
<p>总线锁和缓存锁怎么选择，取决于很多因素，比如CPU是否支持、以及存在无法缓存的数据时（比较大或者快约多个缓存行的数据），必然还是会使用总线锁。</p>
<h2 id="1-3-2-3-缓存一致性"><a href="#1-3-2-3-缓存一致性" class="headerlink" title="1.3.2.3 缓存一致性"></a>1.3.2.3 缓存一致性</h2><p>MSI ，MESI 、MOSI …<br>为了达到数据访问的一致，需要各个处理器在访问缓存时遵循一些协议，在读写时根据协议来操作，常见的协议有MSI，MESI，MOSI等。最常见的就是MESI协议。接下来给大家简单讲解一下MESIMESI表示缓存行的四种状态，分别是：</p>
<ul>
<li>M(Modify)： 表示共享数据只缓存在当前CPU缓存中，并且是被修改状态，也就是缓存的数据和主内存中的数据不一致；</li>
<li>E(Exclusive)： 表示缓存的独占状态，数据只缓存在当前CPU缓存中，并且没有被修改；</li>
<li>S(Shared)： 表示数据可能被多个CPU缓存，并且各个缓存中的数据和主内存数据一致；</li>
<li>I(Invalid)： 表示缓存已经失效。</li>
</ul>
<h2 id="1-3-2-4-MESI带来的优化"><a href="#1-3-2-4-MESI带来的优化" class="headerlink" title="1.3.2.4 MESI带来的优化"></a>1.3.2.4 MESI带来的优化</h2><p>各CPU通过消息传递来更新各个缓存行的状态。在CPU中引入了Store Bufferes。<br><img src="https://user-gold-cdn.xitu.io/2020/5/30/172644f7dcdc9647?w=443&h=372&f=png&s=19534" alt=""><br>CPU0 只需要在写入共享数据时，直接把数据写入到 <strong>store bufferes</strong> 中，同时发送 <strong>invalidate</strong> 消息，然后继续去处理其他指令。<br>当收到其他所有CPU发送了<strong>invalidate acknowledge</strong>消息时，再将 <strong>store bufferes</strong> 中的数据数据存储至 <strong>cache line</strong>中。最后再从缓存行同步到主内存。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/30/172645273b4233b8?w=322&h=284&f=png&s=11075" alt=""></p>
<p><strong>指令重排序</strong></p>
<p>来关注下面这段代码，假设分别有两个线程，分别执行executeToCPU0和executeToCPU1，分别由两个不同的CPU来执行。引入Store Bufferes之后，就可能出现 b==1返回true ，但是assert(a==1)返回false。很多肯定会表示不理解，这种情况怎么可能成立？那接下来我们去分析一下，写一段伪代码吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">executeToCPU0()&#123;</span><br><span class="line">  a&#x3D;1;</span><br><span class="line">  b&#x3D;1;</span><br><span class="line">&#125;</span><br><span class="line">executeToCPU1()&#123;</span><br><span class="line">  while(b&#x3D;&#x3D;1)&#123;</span><br><span class="line">    assert(a&#x3D;&#x3D;1);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>通过内存屏障禁止了指令重排序</strong></p>
<p>X86的memory barrier指令包括<strong>lfence(读屏障) sfence(写屏障) mfence(全屏障)</strong>。</p>
<ul>
<li>Store Memory Barrier(写屏障)：告诉处理器在写屏障之前的所有已经存储在存储缓存(store bufferes)中的数据同步到主内存，简单来说就是使得写屏障之前的指令的结果对屏障之后的读或者写是可见的</li>
<li>Load Memory Barrier(读屏障)：处理器在读屏障之后的读操作，都在读屏障之后执行。配合写屏障，使得写屏障之前的内存更新对于读屏障之后的读操作是可见的</li>
<li>Full Memory Barrier(全屏障)：确保屏障前的内存读写操作的结果提交到内存之后，再执行屏障后的读写操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">volatile int a&#x3D;0;</span><br><span class="line">executeToCpu0()&#123;</span><br><span class="line">  a&#x3D;1;</span><br><span class="line">  &#x2F;&#x2F;storeMemoryBarrier()写屏障，写入到内存</span><br><span class="line">  b&#x3D;1;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; CPU层面的重排序</span><br><span class="line">  &#x2F;&#x2F;b&#x3D;1;</span><br><span class="line">  &#x2F;&#x2F;a&#x3D;1;</span><br><span class="line">&#125;</span><br><span class="line">executeToCpu1()&#123;</span><br><span class="line">  while(b&#x3D;&#x3D;1)&#123;  &#x2F;&#x2F;true</span><br><span class="line">    loadMemoryBarrier(); &#x2F;&#x2F;读屏障</span><br><span class="line">    assert(a&#x3D;&#x3D;1) &#x2F;&#x2F;false</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="1-3-3-软件方面了解可见性本质"><a href="#1-3-3-软件方面了解可见性本质" class="headerlink" title="1.3.3 软件方面了解可见性本质"></a>1.3.3 软件方面了解可见性本质</h2><h2 id="1-3-3-1-JMM（Java内存模型）"><a href="#1-3-3-1-JMM（Java内存模型）" class="headerlink" title="1.3.3.1 JMM（Java内存模型）"></a>1.3.3.1 JMM（Java内存模型）</h2><p>简单来说，JMM定义了共享内存中多线程程序读写操作的行为规范：在虚拟机中把共享变量存储到内存以及从内存中取出共享变量的底层实现细节。通过这些规则来规范对内存的读写操作从而保证指令的正确性，<strong>解决了CPU多级缓存、处理器优化、指令重排序导致的内存访问问题，保证了并发场景下的可见性</strong>。</p>
<p>需要注意的是，JMM并没有主动限制执行引擎使用处理器的寄存器和高速缓存来提升指令执行速度，也没主动限制编译器对于指令的重排序，也就是说在JMM这个模型之上，仍然会存在缓存一致性问题和指令重排序问题。JMM是一个抽象模型，它是建立在不同的操作系统和硬件层面之上对问题进行了统一的抽象，然后再Java层面提供了一些高级指令，让用户选择在合适的时候去引入这些高级指令来解决可见性问题。</p>
<h2 id="1-3-3-2-JMM解决可见性有序性"><a href="#1-3-3-2-JMM解决可见性有序性" class="headerlink" title="1.3.3.2 JMM解决可见性有序性"></a>1.3.3.2 JMM解决可见性有序性</h2><p>其实通过前面的内容分析我们发现，导致可见性问题有两个因素，一个是高速缓存导致的可见性问题，另一个是指令重排序。那JMM是如何解决可见性和有序性问题的呢？其实前面在分析硬件层面的内容时，已经提到过了，对于缓存一致性问题，有总线锁和缓存锁，缓存锁是基于MESI协议。而对于指令重排序，硬件层面提供了内存屏障指令。</p>
<p>而JMM在这个基础上提供了<strong>volatile、final</strong>等关键字，使得开发者可以在合适的时候增加相应相应的关键字来<strong>禁止高速缓存</strong>和<strong>禁止指令重排序</strong>来解决可见性和有序性问题。</p>
<h2 id="1-3-3-3-Volatile底层的原理"><a href="#1-3-3-3-Volatile底层的原理" class="headerlink" title="1.3.3.3 Volatile底层的原理"></a>1.3.3.3 Volatile底层的原理</h2><p>通过javap -v VolatileDemo.class 分析汇编指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static volatile boolean stop;</span><br><span class="line"> descriptor: Z</span><br><span class="line"> flags: ACC_PUBLIC, ACC_STATIC, ACC_VOLATILE</span><br><span class="line">int field_offset &#x3D; cache-&gt;f2_as_index();</span><br><span class="line">     if (cache-&gt;is_volatile()) &#123;</span><br><span class="line">      if (tos_type &#x3D;&#x3D; itos) &#123;</span><br><span class="line">       obj-&gt;release_int_field_put(field_offset, STACK_INT(-1));</span><br><span class="line">     &#125; else if (tos_type &#x3D;&#x3D; atos) &#123;</span><br><span class="line">       VERIFY_OOP(STACK_OBJECT(-1));</span><br><span class="line">       obj-&gt;release_obj_field_put(field_offset, STACK_OBJECT(-1));</span><br><span class="line">       OrderAccess::release_store(&amp;BYTE_MAP_BASE[(uintptr_t)obj &gt;&gt;</span><br><span class="line">CardTableModRefBS::card_shift], 0);</span><br><span class="line">     &#125; else if (tos_type &#x3D;&#x3D; btos) &#123;</span><br><span class="line">       obj-&gt;release_byte_field_put(field_offset, STACK_INT(-1));</span><br><span class="line">     &#125; else if (tos_type &#x3D;&#x3D; ltos) &#123;</span><br><span class="line">       obj-&gt;release_long_field_put(field_offset, STACK_LONG(-1));</span><br><span class="line">     &#125; else if (tos_type &#x3D;&#x3D; ctos) &#123;</span><br><span class="line">       obj-&gt;release_char_field_put(field_offset, STACK_INT(-1));</span><br><span class="line">     &#125; else if (tos_type &#x3D;&#x3D; stos) &#123;</span><br><span class="line">       obj-&gt;release_short_field_put(field_offset, STACK_INT(-1));</span><br><span class="line">     &#125; else if (tos_type &#x3D;&#x3D; ftos) &#123;</span><br><span class="line">       obj-&gt;release_float_field_put(field_offset, STACK_FLOAT(-1));</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       obj-&gt;release_double_field_put(field_offset, STACK_DOUBLE(-1));</span><br><span class="line">     &#125;</span><br><span class="line">      OrderAccess::storeload();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-4-Happens-Before模型"><a href="#1-3-4-Happens-Before模型" class="headerlink" title="1.3.4 Happens-Before模型"></a>1.3.4 Happens-Before模型</h2><p>除了显示引用volatile关键字能够保证可见性以外，在Java中，还有很多的可见性保障的规则。</p>
<p>从JDK1.5开始，引入了一个<strong>happens-before</strong>的概念来阐述多个线程操作共享变量的可见性问题。所以我们可以认为在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作必须要存在<strong>happens-before</strong>关系。这两个操作可以是同一个线程，也可以是不同的线程。</p>
<h2 id="1-3-4-1-程序顺序规则"><a href="#1-3-4-1-程序顺序规则" class="headerlink" title="1.3.4.1 程序顺序规则"></a>1.3.4.1 程序顺序规则</h2><p>可以认为是<strong>as-if-serial</strong>语义。</p>
<ul>
<li>不能改变程序的执行结果(在单线程环境下，执行的结果不变)</li>
<li>依赖问题， 如果两个指令存在依赖关系，是不允许重排序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int a&#x3D;0;</span><br><span class="line">int b&#x3D;0;</span><br><span class="line">void test()&#123;</span><br><span class="line">  int a&#x3D;1;   a</span><br><span class="line">  int b&#x3D;1;   b</span><br><span class="line">  &#x2F;&#x2F;int b&#x3D;1;</span><br><span class="line">  &#x2F;&#x2F;int a&#x3D;1;</span><br><span class="line">  int c&#x3D;a*b;  c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>a happens -before b ; b happens before c</strong></p>
<h2 id="1-3-4-2-传递性规则"><a href="#1-3-4-2-传递性规则" class="headerlink" title="1.3.4.2 传递性规则"></a>1.3.4.2 传递性规则</h2><p><strong>a happens-before b , b happens- before c, a happens-before c</strong></p>
<h2 id="1-3-4-3-volatile变量规则"><a href="#1-3-4-3-volatile变量规则" class="headerlink" title="1.3.4.3 volatile变量规则"></a>1.3.4.3 volatile变量规则</h2><ul>
<li>volatile 修饰的变量的写操作，一定happens-before后续对于volatile变量的读操作.</li>
<li>内存屏障机制来防止指令重排.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class VolatileExample&#123;</span><br><span class="line">  int a&#x3D;0;</span><br><span class="line">  volatile boolean flag&#x3D;false;</span><br><span class="line">  public void writer()&#123;</span><br><span class="line">    a&#x3D;1;             1</span><br><span class="line">    flag&#x3D;true; &#x2F;&#x2F;修改       2</span><br><span class="line"> &#125;</span><br><span class="line">  public void reader()&#123;</span><br><span class="line">    if(flag)&#123; &#x2F;&#x2F;true       3</span><br><span class="line">      int i&#x3D;a;  &#x2F;&#x2F;1      4</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>1 happens-before 2 是否成立？ 是 -&gt; ?</li>
<li>3 happens-before 4 是否成立? 是</li>
<li>2 happens -before 3 -&gt;volatile规则</li>
<li>1 happens-before 4 ; i=1成立.</li>
</ul>
<h2 id="1-3-4-4-监视器锁规则"><a href="#1-3-4-4-监视器锁规则" class="headerlink" title="1.3.4.4 监视器锁规则"></a>1.3.4.4 监视器锁规则</h2><p>对一个锁的解锁，happens-before 于随后对这个锁的加锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int x&#x3D;10;</span><br><span class="line">synchronized(this)&#123;</span><br><span class="line">  &#x2F;&#x2F;后续线程读取到的x的值一定12</span><br><span class="line">  if(x&lt;12)&#123;</span><br><span class="line">    x&#x3D;12;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">x&#x3D;12;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-4-5-start规则"><a href="#1-3-4-5-start规则" class="headerlink" title="1.3.4.5 start规则"></a>1.3.4.5 start规则</h2><p>如果线程 A 执行操作 ThreadB.start(),那么线程 A 的 ThreadB.start()操作 happens-before 线程 B 中的任意操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class StartDemo&#123;</span><br><span class="line">  int x&#x3D;0;</span><br><span class="line">  Thread t1&#x3D;new Thread(()-&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F;读取x的值 一定是20</span><br><span class="line">    if(x&#x3D;&#x3D;20)&#123;</span><br><span class="line">     </span><br><span class="line">   &#125;</span><br><span class="line"> &#125;);</span><br><span class="line">  x&#x3D;20;</span><br><span class="line">  t1.start();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-4-6-Join规则"><a href="#1-3-4-6-Join规则" class="headerlink" title="1.3.4.6 Join规则"></a>1.3.4.6 Join规则</h2><p>如果线程 A 执行操作 ThreadB.join()并成功返回，那么线程 B 中的任意操作 happens-before 于线程A 从 ThreadB.join()操作成功返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">  int x&#x3D;0;</span><br><span class="line">  Thread t1&#x3D;new Thread(()-&gt;&#123;</span><br><span class="line">    x&#x3D;200;</span><br><span class="line"> &#125;);</span><br><span class="line">  t1.start();</span><br><span class="line">  t1.join(); &#x2F;&#x2F;保证结果的可见性。</span><br><span class="line">  &#x2F;&#x2F;在此处读取到的x的值一定是200.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/05/30/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%80%92%E8%BF%9B%E7%AF%87%EF%BC%8C%E6%8E%A2%E7%B4%A2%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7/" data-id="ckiohtc6i000aryra4cyj05wd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JAVA并发编程入门篇，思考同步锁Synchronized背后的实现哲学" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/23/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%8C%E6%80%9D%E8%80%83%E5%90%8C%E6%AD%A5%E9%94%81Synchronized%E8%83%8C%E5%90%8E%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%93%B2%E5%AD%A6/" class="article-date">
  <time datetime="2020-05-23T11:38:30.000Z" itemprop="datePublished">2020-05-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/23/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%8C%E6%80%9D%E8%80%83%E5%90%8C%E6%AD%A5%E9%94%81Synchronized%E8%83%8C%E5%90%8E%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%93%B2%E5%AD%A6/">JAVA并发编程入门篇，思考同步锁Synchronized背后的实现哲学</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>多线程在概念上类似抢占式多任务处理，线程的合理使用能够提升程序的处理能力，但是使用的同时也带来了弊端，对于共享变量访问就会产生安全性的问题。下面来看一个多线程访问共享变量的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadSafty &#123;</span><br><span class="line"></span><br><span class="line">    private static int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public static void incr() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; 1000; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                ThreadSafty.incr();</span><br><span class="line">            &#125;,&quot;threadSafty&quot; + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(3);</span><br><span class="line">        System.out.println(&quot;运行结果是：&quot; + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量count的运行结果始终是小于等于1000的随机数，因为线程的可见性和原子性。</p>
<h1 id="一、多线程访问的数据安全性"><a href="#一、多线程访问的数据安全性" class="headerlink" title="一、多线程访问的数据安全性"></a>一、多线程访问的数据安全性</h1><p>如何保证线程并行运行的数据安全性问题，这里首先能够想到的是加锁吧。关系型数据库中有乐观锁、悲观锁，那么什么是锁呢？它是处理并发的一种手段，实现互斥的特性。</p>
<p>在Java语言中实现锁的关键字是<strong>Synchronized</strong>。</p>
<h1 id="二、Synchronized的基本应用"><a href="#二、Synchronized的基本应用" class="headerlink" title="二、Synchronized的基本应用"></a>二、Synchronized的基本应用</h1><h2 id="2-1-Synchronized的三种加锁方式"><a href="#2-1-Synchronized的三种加锁方式" class="headerlink" title="2.1 Synchronized的三种加锁方式"></a>2.1 Synchronized的三种加锁方式</h2><ul>
<li>静态方法：作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">synchronized  static void method()&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>修饰代码块：指定加锁对象，进入同步代码前要获得指定对象的锁</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void method()&#123;</span><br><span class="line">    synchronized (SynchronizedDemo.class)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改实例方法：作用于当前实例加锁，进入同步代码前要获得当前实例的锁<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object lock &#x3D; new Object();</span><br><span class="line">&#x2F;&#x2F;只针对于当前对象实例有效.</span><br><span class="line">public SynchronizedDemo(Object lock)&#123;</span><br><span class="line">        this.lock &#x3D; lock;</span><br><span class="line">&#125;</span><br><span class="line"> void method()&#123;</span><br><span class="line">     synchronized(lock)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="2-2-Synchronized锁是如何存储数据的呢？"><a href="#2-2-Synchronized锁是如何存储数据的呢？" class="headerlink" title="2.2 Synchronized锁是如何存储数据的呢？"></a>2.2 Synchronized锁是如何存储数据的呢？</h2><p>以对象在<strong>jvm</strong>内存中是如何存储作为切入点，去看看对象里面有什么特性能够实现锁的</p>
<h2 id="2-2-1-对象在Heap内存中的布局"><a href="#2-2-1-对象在Heap内存中的布局" class="headerlink" title="2.2.1 对象在Heap内存中的布局"></a>2.2.1 对象在Heap内存中的布局</h2><p>在Hotspot虚拟机中，对象在堆内存中的布局，可以分为三个部分：</p>
<ul>
<li>对象头：包括对象标记、类元信息</li>
<li>实例数据</li>
<li>对齐填充</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/19/1722bcba856d89b3?w=925&h=368&f=png&s=158024" alt=""></p>
<p><strong>Hotspot</strong> 采用<strong>instanceOopDesc</strong> 和 <strong>arrayOopDesc</strong> 来描述对象头，<strong>arrayOopDesc</strong> 对象用来描述数组类型的。<br><strong>instanceOopDesc</strong>的定义在Hotspot源码中的<strong>instanceOop.hpp</strong>文件中，另外，<strong>arrayOopDesc</strong>的定义对应<strong>arrayOop.hpp</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class instanceOopDesc : public oopDesc &#123;</span><br><span class="line"> public:</span><br><span class="line">  &#x2F;&#x2F; aligned header size.</span><br><span class="line">  static int header_size() &#123; return sizeof(instanceOopDesc)&#x2F;HeapWordSize; &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; If compressed, the offset of the fields of the instance may not be aligned.</span><br><span class="line">  static int base_offset_in_bytes() &#123;</span><br><span class="line">    &#x2F;&#x2F; offset computation code breaks if UseCompressedClassPointers</span><br><span class="line">    &#x2F;&#x2F; only is true</span><br><span class="line">    return (UseCompressedOops &amp;&amp; UseCompressedClassPointers) ?</span><br><span class="line">             klass_gap_offset_in_bytes() :</span><br><span class="line">             sizeof(instanceOopDesc);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static bool contains_field_offset(int offset, int nonstatic_field_size) &#123;</span><br><span class="line">    int base_in_bytes &#x3D; base_offset_in_bytes();</span><br><span class="line">    return (offset &gt;&#x3D; base_in_bytes &amp;&amp;</span><br><span class="line">            (offset-base_in_bytes) &lt; nonstatic_field_size * heapOopSize);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F; SHARE_VM_OOPS_INSTANCEOOP_HPP</span><br></pre></td></tr></table></figure>
<p>看源码instanceOopDesc继承自oopDesc，oopDesc定义在oop.hpp文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class oopDesc &#123;</span><br><span class="line">  friend class VMStructs;</span><br><span class="line">  private:</span><br><span class="line">  volatile markOop  _mark;</span><br><span class="line">  union _metadata &#123;</span><br><span class="line">    Klass*      _klass;&#x2F;&#x2F;普通指针</span><br><span class="line">    narrowKlass _compressed_klass;&#x2F;&#x2F;压缩类指针</span><br><span class="line">  &#125; _metadata;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Fast access to barrier set.  Must be initialized.</span><br><span class="line">  static BarrierSet* _bs;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>在oopDesc类中有两个重要的成员变量，_mark：记录对象和锁有关的信息，属于markOop类型，_metadata：记录类元信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class markOopDesc: public oopDesc &#123;</span><br><span class="line"> private:</span><br><span class="line">  &#x2F;&#x2F; Conversion</span><br><span class="line">  uintptr_t value() const &#123; return (uintptr_t) this; &#125;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  &#x2F;&#x2F; Constants</span><br><span class="line">  enum &#123; </span><br><span class="line">     age_bits                 &#x3D; 4,&#x2F;&#x2F;分代年龄</span><br><span class="line">     lock_bits                &#x3D; 2,&#x2F;&#x2F;锁标识</span><br><span class="line">     biased_lock_bits         &#x3D; 1,&#x2F;&#x2F;是否为偏向锁</span><br><span class="line">     max_hash_bits            &#x3D; BitsPerWord - age_bits - lock_bits - biased_lock_bits,</span><br><span class="line">     hash_bits                &#x3D; max_hash_bits &gt; 31 ? 31 : max_hash_bits,&#x2F;&#x2F;对象的hashCode</span><br><span class="line">     cms_bits                 &#x3D; LP64_ONLY(1) NOT_LP64(0),</span><br><span class="line">     epoch_bits               &#x3D; 2&#x2F;&#x2F;偏向锁的时间戳</span><br><span class="line">  &#125;;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p><strong>markOopDesc</strong>记录了对象和锁有关的信息，也就是我们常说的<strong>Mark Word</strong>，当某个对象加上<strong>Synchronized</strong>关键字时，那么和锁有关的一系列操作都与它有关。<br><strong>32位</strong>系统<strong>Mark Word</strong>的长度是<strong>32bit</strong>，<strong>64位</strong>系统则是<strong>64bit</strong>。</p>
<p><strong>Mark Word</strong>里面的数据会随着锁的标志位的变化而变化的。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/19/1722cd90ccc7c61e?w=1024&h=329&f=png&s=291618" alt=""></p>
<h2 id="2-2-2-Java中打印对象的布局"><a href="#2-2-2-Java中打印对象的布局" class="headerlink" title="2.2.2 Java中打印对象的布局"></a>2.2.2 Java中打印对象的布局</h2><p>pom依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jol&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jol-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.10&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ClassLayout.parseInstance(synchronizedDemo).toPrintable());</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">com.sy.sa.thread.SynchronizedDemo object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           31 00 00 00 (00110001 00000000 00000000 00000000) (49)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total</span><br></pre></td></tr></table></figure>
<p><strong>大端存储和小端存储</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0     4        (object header)                           31 00 00 00 (00110001 00000000 00000000 00000000) (49)</span><br><span class="line">4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">16进制： 0x 00 00 00 00 00 00 00 01</span><br><span class="line">(64位)2进制： 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000 0</span><br></pre></td></tr></table></figure>
<p><strong>0 01 (无锁状态)</strong></p>
<ul>
<li>通过最后三位来看锁的状态和标记。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           a8 f7 76 02 (10101000 11110111 01110110 00000010) (41351080)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total</span><br></pre></td></tr></table></figure>

<p><strong>000表示为轻量级锁</strong></p>
<h2 id="2-2-3-为什么什么对象都能实现锁？"><a href="#2-2-3-为什么什么对象都能实现锁？" class="headerlink" title="2.2.3 为什么什么对象都能实现锁？"></a>2.2.3 为什么什么对象都能实现锁？</h2><p><strong>Java</strong> 中的每个对象都派生自 <strong>Object</strong> 类，而每个<strong>Java Object</strong> 在 <strong>JVM</strong> 内部都有一个 <strong>native</strong> 的 C++对象<strong>oop/oopDesc</strong> 进行对应。</p>
<p>线程在获取锁的时候，实际上就是获得一个监视器对象(<strong>monitor</strong>) ,<strong>monitor</strong> 可以认为是一个同步对象，所有的Java 对象是天生携带 <strong>monitor</strong>。在 <strong>hotspot</strong> 源码的<strong>markOop.hpp</strong> 文件中，可以看到下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor* monitor() const &#123;</span><br><span class="line">    assert(has_monitor(), &quot;check&quot;);</span><br><span class="line">    &#x2F;&#x2F; Use xor instead of &amp;~ to provide one extra tag-bit check.</span><br><span class="line">    return (ObjectMonitor*) (value() ^ monitor_value);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>多个线程访问同步代码块时，相当于去争抢对象监视器修改对象中的锁标识，上面的代码中<strong>ObjectMonitor</strong>这个对象和线程争抢锁的逻辑有密切的关系。</p>
<h1 id="2-3-Synchronized的锁升级"><a href="#2-3-Synchronized的锁升级" class="headerlink" title="2.3 Synchronized的锁升级"></a>2.3 Synchronized的锁升级</h1><p>锁的状态有：<strong>无锁、偏向锁、轻量级锁、重量级锁。</strong> 锁的状态根据竞争激烈程度从低到高不断升级。</p>
<h2 id="2-3-1-偏向锁"><a href="#2-3-1-偏向锁" class="headerlink" title="2.3.1 偏向锁"></a>2.3.1 偏向锁</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">存储（以32位为例）：线程ID（23bit）</span><br><span class="line">                   Epoch（2bit）</span><br><span class="line">                   age（4bit）</span><br><span class="line">                   是否偏向锁（1bit）</span><br><span class="line">                   锁标志位（2bit）</span><br></pre></td></tr></table></figure>
<p>当一个线程加入了Synchronized同步锁之后，会在对象头（Object Header）存储线程ID，后续这个线程进入或者退出这个同步代码块的代码时，不需要再次加入和释放锁，而是直接比较对象头里面是否存储了指向当前线程的偏向锁。如果线程ID相等，就表示偏向锁偏向于当前线程，就不需要再重新获得锁了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">com.sy.sa.thread.ClassLayoutDemo object internals:</span><br><span class="line">OFFSET SIZE  TYPE DESCRIPTION                VALUE</span><br><span class="line">  0   4    (object header)              05 e8 45 03</span><br><span class="line">(00000101 11101000 01000101 00000011) (54913029)</span><br><span class="line">  4   4    (object header)              00 00 00 00</span><br><span class="line">(00000000 00000000 00000000 00000000) (0)</span><br><span class="line">  8   4    (object header)              05 c1 00 f8</span><br><span class="line">(00000101 11000001 00000000 11111000) (-134168315)</span><br><span class="line">  12   4    (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/5/23/1723fa8d22c31cea?w=865&h=969&f=png&s=405855" alt=""></p>
<h2 id="2-3-2-轻量级锁"><a href="#2-3-2-轻量级锁" class="headerlink" title="2.3.2 轻量级锁"></a>2.3.2 轻量级锁</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">存储（以32位为例）：指向栈中锁记录的指针（30bit）</span><br><span class="line">                   锁标志位（2bit）</span><br></pre></td></tr></table></figure>
<p>如果偏向锁关闭或者当前偏向锁指向其它的线程，那么这个时候有线程去抢占锁，那么将升级为轻量级锁。</p>
<p>轻量级锁在加锁的过程中使用了自旋锁，JDK1.6之后使用了自适应的自旋锁。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/23/172402845dd99783?w=865&h=840&f=png&s=282670" alt=""></p>
<h2 id="2-3-3-重量级锁"><a href="#2-3-3-重量级锁" class="headerlink" title="2.3.3 重量级锁"></a>2.3.3 重量级锁</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">存储（以32位为例）：指向互斥量（重量级锁）的指针（30bit）</span><br><span class="line">                   锁标志位（2bit）</span><br></pre></td></tr></table></figure>
<p>当轻量级锁膨胀为重量级锁后，线程只能被挂起阻塞等待被唤醒了。先来看一个重量级锁的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class HeavyweightLock &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HeavyweightLock heavyweightLock &#x3D; new HeavyweightLock();</span><br><span class="line">        Thread t1 &#x3D; new Thread(()-&gt;&#123;</span><br><span class="line">            synchronized (heavyweightLock) &#123;</span><br><span class="line">                System.out.println(&quot;tl lock&quot;);</span><br><span class="line">                System.out.println(ClassLayout.parseInstance(heavyweightLock).toPrintable());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;heavyheightLock&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        synchronized (heavyweightLock) &#123;</span><br><span class="line">            System.out.println(&quot;main lock&quot;);</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(heavyweightLock).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">com.sy.sa.thread.HeavyweightLock object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           2a cc e9 02 (00101010 11001100 11101001 00000010) (48876586)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total</span><br><span class="line"></span><br><span class="line">tl lock</span><br><span class="line">com.sy.sa.thread.HeavyweightLock object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           2a cc e9 02 (00101010 11001100 11101001 00000010) (48876586)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total</span><br></pre></td></tr></table></figure>
<p>每一个<strong>Java</strong>对象都会与一个监视器<strong>monitor</strong>关联，可以把它理解成<strong>一把锁</strong>，当一个线程要执行用<strong>Synchronized</strong>修改的代码块或者对象时，该线程最先获取到的是<strong>Synchronized</strong>修饰对象的<strong>monitor</strong>。<br><strong>重量级加锁的基本流程：</strong><br><img src="https://user-gold-cdn.xitu.io/2020/5/23/172406dcbbcbb4b4?w=1369&h=477&f=jpeg&s=79460" alt=""><br><strong>monitorenter</strong>表示去获得一个对象监视器。<strong>monitorexit</strong>表示释放<strong>monitor</strong>监视器的所有权，使得其他被阻塞的线程可以尝试去获得这个监视器。</p>
<h2 id="2-3-4-锁升级总结"><a href="#2-3-4-锁升级总结" class="headerlink" title="2.3.4 锁升级总结"></a>2.3.4 锁升级总结</h2><ul>
<li><strong>偏向锁</strong>只有在第一次请求时采用CAS在锁对象的标记中记录当前线程的地址，在之后该线程再次进入同步代码块时，不需要抢占锁，直接判断线程ID即可，这种适用于锁会被同一个线程多次抢占的情况。</li>
<li><strong>轻量级锁</strong>才用CAS操作，把锁对象的标记字段替换为一个指针指向当前线程栈帧中的LockRecord，该工件存储锁对象原本的标记字段，它针对的是多个线程在不同时间段内申请通一把锁的情况。</li>
<li><strong>重量级锁</strong>会阻塞、和唤醒加锁的线程，它适用于多个线程同时竞争同一把锁的情况。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/23/172408d4b0ec868d?w=1527&h=349&f=jpeg&s=91081" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xkjava.github.io/2020/05/23/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%8C%E6%80%9D%E8%80%83%E5%90%8C%E6%AD%A5%E9%94%81Synchronized%E8%83%8C%E5%90%8E%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%93%B2%E5%AD%A6/" data-id="ckiohtc6h0009ryra3qp5ampa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/12/14/%E8%BF%88%E5%87%BAspring5%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81%E5%B9%B6%E4%BD%BF%E7%94%A8IDEA%E6%89%93%E5%BC%80/">迈出spring5源码阅读第一步，如何编译源码并使用IDEA打开</a>
          </li>
        
          <li>
            <a href="/2020/09/16/Ambari%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0%E9%9B%86%E7%BE%A4%E5%88%A9%E5%99%A8%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E8%B7%B5/">Ambari大数据平台集群利器的探索与实践</a>
          </li>
        
          <li>
            <a href="/2020/09/03/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E5%BA%93InfluxDB%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88%E9%AB%98%E7%BA%A7%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C%EF%BC%8C%E8%AF%B7%E5%85%B3%E6%B3%A8/">时间序列数据库InfluxDB集群方案高级实践经验，请关注</a>
          </li>
        
          <li>
            <a href="/2020/08/25/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E7%9A%84%E7%8E%8B%E8%80%85Apache-Atlas%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84API/">数据治理的王者Apache-Atlas如何构建自己的API</a>
          </li>
        
          <li>
            <a href="/2020/07/26/CountDownLatch%E3%80%81Semaphore%E3%80%81CyclicBarrier%E3%80%81Condition%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">CountDownLatch、Semaphore、CyclicBarrier、Condition源码分析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Kevin Shaw<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>